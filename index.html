<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-eval' 'unsafe-inline' https://unpkg.com https://cdn.jsdelivr.net; object-src 'none'; base-uri 'self';">
    <title>Dash v4.1</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2224%22 height=%2224%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22%23000000%22 stroke-width=%222%22 stroke-linecap=%22round%22 stroke-linejoin=%22round%22><path d=%22m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z%22/><path d=%22M5 3v4%22/><path d=%22M19 17v4%22/><path d=%22M3 5h4%22/><path d=%22M17 19h4%22/></svg>">
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- SECURITY: Remove credentials from URL immediately -->
    <script>
        // Redirect mobile devices to mobile.html immediately
        (function() {
            const isMobile = /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                           (window.innerWidth <= 768 && 'ontouchstart' in window);
            
            if (isMobile && (window.location.pathname === '/' || window.location.pathname === '/index.html')) {
                // Mobile device detected - redirecting to mobile-v2.html
                window.location.replace('/mobile-v2.html');
                return;
            }
        })();
        
        // Clear URL parameters with credentials immediately on load
        (function() {
            const url = new URL(window.location);
            if (url.searchParams.has('email') || url.searchParams.has('password')) {
                console.warn('🔒 Clearing credentials from URL for security');
                // Clear all URL parameters
                window.history.replaceState({}, document.title, url.pathname);
            }
            
            // Override console functions to prevent credential logging
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;
            
            function sanitizeMessage(msg) {
                if (typeof msg === 'string') {
                    // Remove email and password patterns from logs
                    return msg.replace(/[?&]email=[^&]*/gi, '[EMAIL_REMOVED]')
                             .replace(/[?&]password=[^&]*/gi, '[PASSWORD_REMOVED]')
                             .replace(/mail%40[^&]*/gi, '[EMAIL_REMOVED]')
                             .replace(/password=[^&]*/gi, '[PASSWORD_REMOVED]');
                }
                return msg;
            }
            
            console.log = function(msg, ...args) {
                originalLog(sanitizeMessage(msg), ...args);
            };
            
            console.error = function(msg, ...args) {
                originalError(sanitizeMessage(msg), ...args);
            };
            
            console.warn = function(msg, ...args) {
                originalWarn(sanitizeMessage(msg), ...args);
            };
            
            // Helper function to handle authentication state messages
            window.logAuthWarning = function(component, action = 'load data') {
                // Only show in development mode (localhost) or when explicitly debugging
                if (window.location.hostname === 'localhost' || window.DEBUG_AUTH) {
                    console.warn(`${component}: Authentication required to ${action}`);
                }
            };
            
            // Production-ready logging system - only log after authentication
            window.SILENT_MODE = true; // Start in silent mode for login/logout pages
            
            window.devLog = function(message, ...args) {
                if (!window.SILENT_MODE && (window.location.hostname === 'localhost' || window.DEBUG_MODE)) {
                    console.log(message, ...args);
                }
            };
            
            window.devWarn = function(message, ...args) {
                if (!window.SILENT_MODE && (window.location.hostname === 'localhost' || window.DEBUG_MODE)) {
                    console.warn(message, ...args);
                }
            };
            
            // Function to enable logging after successful authentication
            window.enableLogging = function() {
                window.SILENT_MODE = false;
            };
        })();
    </script>
    <style>
        /* === DESIGN SYSTEM === */
        :root {
            /* Colors */
            --bg-primary: #ffffff;
            --bg-secondary: #F5F5F5;
            --text-primary: #333333;
            --text-secondary: #666666;
            --text-muted: #999999;
            --border-primary: #e0e0e0;
            --border-secondary: #d1d5db;
            --accent-primary: #000000;
            
            /* Typography */
            --font-size-base: 16px;
            --line-height-base: 24px;
            --font-size-sm: 14px;
            --font-size-xs: 12px;
            --font-size-lg: 18px;
            --font-size-xl: 20px;
            
            /* Spacing */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
        }

        /* Dark mode variables - Professional, eye-friendly design */
        [data-theme="dark"] {
            --bg-primary: #0f0f23 !important;
            --bg-secondary: #1a1a2e !important;
            --text-primary: #e2e8f0 !important;
            --text-secondary: #a0aec0 !important;
            --text-muted: #718096 !important;
            --border-primary: #ffffff !important;
            --border-secondary: #e2e8f0 !important;
            --accent-primary: #ffffff !important;
        }

        /* Clean text hierarchy - no universal override */
        [data-theme="dark"] {
            color: #e2e8f0 !important;
        }

        /* Coin percentage colors in dark mode */
        [data-theme="dark"] .positive,
        [data-theme="dark"] .up {
            color: #22c55e !important;
        }

        [data-theme="dark"] .negative,
        [data-theme="dark"] .down {
            color: #ef4444 !important;
        }

        /* Professional Dark Mode Design */
        [data-theme="dark"] body {
            background: #0f0f23 !important;
            color: #e2e8f0 !important;
        }

        /* Main containers with subtle depth */
        [data-theme="dark"] .card,
        [data-theme="dark"] .todo-item,
        [data-theme="dark"] .todo-block,
        [data-theme="dark"] .resource-block,
        [data-theme="dark"] .modal-content {
            background: #1a1a2e !important;
            border-color: #2d3748 !important;
            color: #e2e8f0 !important;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3) !important;
        }

        /* Headers with slight contrast */
        [data-theme="dark"] .todo-block-header,
        [data-theme="dark"] .resource-block-header {
            background: #16213e !important;
            border-color: #2d3748 !important;
            color: #f7fafc !important;
        }

        /* Override hardcoded gray borders to white in dark mode */
        [data-theme="dark"] * {
            border-color: #ffffff !important;
        }
        
        [data-theme="dark"] *[style*="border"] {
            border-color: #ffffff !important;
        }
        
        /* Remove navbar tab borders in dark mode - make it like normal mode */
        [data-theme="dark"] .nav-tab {
            border: none !important;
        }
        
        [data-theme="dark"] .nav-tab.active,
        [data-theme="dark"] .nav-tab:hover {
            border: none !important;
            border-bottom: none !important;
        }
        
        /* Perfect text hierarchy */
        [data-theme="dark"] h1,
        [data-theme="dark"] h2,
        [data-theme="dark"] h3,
        [data-theme="dark"] h4,
        [data-theme="dark"] h5,
        [data-theme="dark"] h6 {
            color: #f7fafc !important;
            font-weight: 600 !important;
        }

        [data-theme="dark"] p,
        [data-theme="dark"] span,
        [data-theme="dark"] div,
        [data-theme="dark"] .todo-title,
        [data-theme="dark"] .resource-title,
        [data-theme="dark"] .goal-title,
        [data-theme="dark"] .journal-title,
        [data-theme="dark"] label {
            color: #e2e8f0 !important;
        }

        /* Secondary text - slightly dimmed but still readable */
        [data-theme="dark"] .text-muted,
        [data-theme="dark"] .todo-date,
        [data-theme="dark"] .resource-description {
            color: #a0aec0 !important;
        }

        /* Professional links */
        [data-theme="dark"] a,
        [data-theme="dark"] .resource-url {
            color: #63b3ed !important;
            text-decoration: none !important;
        }

        [data-theme="dark"] a:hover,
        [data-theme="dark"] .resource-url:hover {
            color: #90cdf4 !important;
        }

        /* Clean form elements */
        [data-theme="dark"] input,
        [data-theme="dark"] textarea,
        [data-theme="dark"] select {
            background: #1a1a2e !important;
            border: 1px solid #2d3748 !important;
            color: #e2e8f0 !important;
            border-radius: 6px !important;
        }

        [data-theme="dark"] input:focus,
        [data-theme="dark"] textarea:focus,
        [data-theme="dark"] select:focus {
            border-color: #4299e1 !important;
            box-shadow: 0 0 0 1px #4299e1 !important;
        }

        [data-theme="dark"] input::placeholder,
        [data-theme="dark"] textarea::placeholder {
            color: #718096 !important;
        }

        /* Modern navigation */
        [data-theme="dark"] .nav-tab {
            color: #a0aec0 !important;
            transition: color 0.2s ease !important;
        }

        [data-theme="dark"] .nav-tab.active,
        [data-theme="dark"] .nav-tab:hover {
            color: #f7fafc !important;
            border-bottom-color: #4299e1 !important;
        }

        /* Dynamic main buttons */
        .dynamic-main-button {
            animation: slideInFromRight 0.3s ease-out;
        }
        
        .pomodoro-active {
            background: #dc2626 !important;
            color: white !important;
        }
        
        .pomodoro-active:hover {
            background: #b91c1c !important;
        }
        
        .darkmode-active {
            background: #1f2937 !important;
            color: white !important;
        }
        
        .darkmode-active:hover {
            background: #111827 !important;
        }
        
        @keyframes slideInFromRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Professional QuickBar */
        [data-theme="dark"] .quickbar-sub-btn {
            background: #1a1a2e !important;
            border: 1px solid #2d3748 !important;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4) !important;
            color: #e2e8f0 !important;
        }

        [data-theme="dark"] .quickbar-sub-btn:hover {
            background: #2d3748 !important;
            border-color: #4299e1 !important;
            box-shadow: 0 4px 20px rgba(66, 153, 225, 0.3) !important;
            transform: translateY(-1px) !important;
        }

        /* Modern buttons */
        [data-theme="dark"] .btn {
            background: #1a1a2e !important;
            color: #e2e8f0 !important;
            border: 1px solid #2d3748 !important;
            border-radius: 6px !important;
            transition: all 0.2s ease !important;
        }

        [data-theme="dark"] .btn:hover {
            background: #2d3748 !important;
            border-color: #4299e1 !important;
            color: #f7fafc !important;
            transform: translateY(-1px) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
        }

        [data-theme="dark"] .btn.secondary {
            background: transparent !important;
            border-color: #4a5568 !important;
            color: #a0aec0 !important;
        }

        [data-theme="dark"] .btn.secondary:hover {
            background: #2d3748 !important;
            border-color: #63b3ed !important;
            color: #e2e8f0 !important;
        }

        /* Subtle hover effects for containers */
        [data-theme="dark"] .card:hover,
        [data-theme="dark"] .todo-item:hover,
        [data-theme="dark"] .resource-block:hover {
            border-color: #4a5568 !important;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        /* Fix white "IN X TAGEN" containers in dark mode */
        [data-theme="dark"] .termin-days-until,
        [data-theme="dark"] .ziel-days-until {
            background: #2d3748 !important;
            color: #63b3ed !important;
            border: 1px solid #4a5568 !important;
            font-weight: 600 !important;
        }

        /* Enhanced edit/delete buttons for dark mode */
        [data-theme="dark"] .termin-edit-icon {
            background: rgba(99, 179, 237, 0.2) !important;
            color: #63b3ed !important;
            border: 1px solid rgba(99, 179, 237, 0.3) !important;
        }

        [data-theme="dark"] .termin-edit-icon:hover {
            background: #63b3ed !important;
            color: #0f0f23 !important;
            border-color: #63b3ed !important;
            box-shadow: 0 4px 12px rgba(99, 179, 237, 0.4) !important;
        }

        [data-theme="dark"] .termin-delete-icon {
            background: rgba(248, 113, 113, 0.2) !important;
            color: #f87171 !important;
            border: 1px solid rgba(248, 113, 113, 0.3) !important;
        }

        [data-theme="dark"] .termin-delete-icon:hover {
            background: #f87171 !important;
            color: #0f0f23 !important;
            border-color: #f87171 !important;
            box-shadow: 0 4px 12px rgba(248, 113, 113, 0.4) !important;
        }

        /* Enhanced plus button for dark mode */
        [data-theme="dark"] .add-btn {
            color: #63b3ed !important;
            background: rgba(99, 179, 237, 0.1) !important;
            border: 1px solid rgba(99, 179, 237, 0.2) !important;
            border-radius: 50% !important;
        }

        [data-theme="dark"] .add-btn:hover {
            color: #0f0f23 !important;
            background: #63b3ed !important;
            border-color: #63b3ed !important;
            box-shadow: 0 4px 16px rgba(99, 179, 237, 0.4) !important;
            transform: rotate(90deg) scale(1.1) !important;
        }

        /* Journal entry buttons */
        [data-theme="dark"] .journal-entry-actions {
            background: transparent !important;
        }

        [data-theme="dark"] .delete-entry-btn {
            background: rgba(248, 113, 113, 0.2) !important;
            border: 1px solid rgba(248, 113, 113, 0.3) !important;
            color: #f87171 !important;
            border-radius: 6px !important;
            padding: 0.5rem !important;
        }

        [data-theme="dark"] .delete-entry-btn:hover {
            background: #f87171 !important;
            color: #0f0f23 !important;
            border-color: #f87171 !important;
            box-shadow: 0 4px 12px rgba(248, 113, 113, 0.4) !important;
        }

        /* Trade action buttons */
        [data-theme="dark"] .trade-action-btn {
            background: #1a1a2e !important;
            border: 1px solid #2d3748 !important;
            color: #e2e8f0 !important;
            border-radius: 6px !important;
        }

        [data-theme="dark"] .trade-action-btn:hover {
            background: #2d3748 !important;
            border-color: #63b3ed !important;
            color: #f7fafc !important;
            box-shadow: 0 4px 12px rgba(99, 179, 237, 0.3) !important;
        }

        /* Icon selection buttons */
        [data-theme="dark"] .icon-btn {
            background: #1a1a2e !important;
            border: 1px solid #2d3748 !important;
            color: #e2e8f0 !important;
            border-radius: 6px !important;
        }

        [data-theme="dark"] .icon-btn:hover,
        [data-theme="dark"] .icon-btn.selected {
            background: #2d3748 !important;
            border-color: #63b3ed !important;
            color: #63b3ed !important;
        }

        /* JavaScript-generated elements fix */
        [data-theme="dark"] div[style*="background: #fafafa"],
        [data-theme="dark"] div[style*="background:#fafafa"],
        [data-theme="dark"] span[style*="background: white"],
        [data-theme="dark"] span[style*="background: #ffffff"] {
            background: #2d3748 !important;
            color: #63b3ed !important;
            border: 1px solid #4a5568 !important;
        }

        /* Journal and Wiki tags */
        [data-theme="dark"] .journal-tag,
        [data-theme="dark"] .wiki-tag,
        [data-theme="dark"] .todo-tag {
            background: #2d3748 !important;
            color: #63b3ed !important;
            border: 1px solid #4a5568 !important;
            border-radius: 4px !important;
        }

        [data-theme="dark"] .journal-entry-tags,
        [data-theme="dark"] .wiki-entry-tags {
            background: transparent !important;
        }

        /* Analytics Charts and Heatmaps */
        [data-theme="dark"] .chart-container,
        [data-theme="dark"] .chart-section {
            background: #1a1a2e !important;
            border-color: #2d3748 !important;
        }

        /* Fix heatmap white squares */
        [data-theme="dark"] .heatmap-square.level-0 {
            background-color: #2d3748 !important;
            border: 1px solid #4a5568 !important;
        }

        [data-theme="dark"] .heatmap-square.level-1 {
            background-color: #3d5a5b !important;
        }

        [data-theme="dark"] .heatmap-square.level-2 {
            background-color: #2d6748 !important;
        }

        [data-theme="dark"] .heatmap-square.level-3 {
            background-color: #22543d !important;
        }

        [data-theme="dark"] .heatmap-square.level-4 {
            background-color: #1a4338 !important;
        }

        /* Performance heatmap colors adjusted for dark mode */
        [data-theme="dark"] .heatmap-square.performance-loss {
            background-color: #c53030 !important;
        }

        [data-theme="dark"] .heatmap-square.performance-neutral {
            background-color: #dd6b20 !important;
        }

        [data-theme="dark"] .heatmap-square.performance-gain {
            background-color: #38a169 !important;
        }

        /* Legend squares for dark mode */
        [data-theme="dark"] .legend-square.level-0 {
            background-color: #2d3748 !important;
        }

        [data-theme="dark"] .legend-square.level-1 {
            background-color: #3d5a5b !important;
        }

        [data-theme="dark"] .legend-square.level-2 {
            background-color: #2d6748 !important;
        }

        [data-theme="dark"] .legend-square.level-3 {
            background-color: #22543d !important;
        }

        [data-theme="dark"] .legend-square.level-4 {
            background-color: #1a4338 !important;
        }

        /* Period buttons for chart controls */
        [data-theme="dark"] .period-btn {
            background: #2d3748 !important;
            color: #e2e8f0 !important;
            border: 1px solid #4a5568 !important;
        }

        [data-theme="dark"] .period-btn.active,
        [data-theme="dark"] .period-btn:hover {
            background: #4a5568 !important;
            color: #f7fafc !important;
            border-color: #63b3ed !important;
        }

        /* Home todos - keine extra dark mode styles nötig */

        /* === TRADING RULES STYLES - Minimalist Dashboard Design === */
        .trading-rule {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            margin-bottom: 1rem;
            transition: all 0.1s ease;
            gap: 12px;
        }
        
        .trading-rule:hover {
            border-color: var(--accent-primary);
        }
        
        .trading-rule.completed {
            opacity: 0.6;
            background: var(--bg-secondary);
        }
        
        .trading-rule-checkbox {
            width: 16px;
            height: 16px;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            margin: 0;
            accent-color: var(--accent-primary);
        }
        
        .trading-rule-content {
            flex: 1;
        }
        
        .trading-rule label {
            cursor: pointer;
            user-select: none;
            font-size: var(--font-size-base);
            line-height: 1.4;
            color: var(--text-primary);
            font-weight: 400;
            margin: 0;
            display: block;
        }
        
        .trading-rule input[type="checkbox"]:checked + .trading-rule-content label {
            color: var(--text-secondary);
            text-decoration: line-through;
        }
        
        .trading-rule-category {
            margin-bottom: 1.5rem;
        }
        
        .trading-rule-category h3 {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 1rem;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-primary);
            padding-bottom: 0.5rem;
        }

        /* === INTELLIGENT GLOBAL SEARCH STYLES === */
        .search-shortcuts {
            display: flex;
            gap: 0.5rem;
        }
        
        .search-shortcut {
            font-size: 0.75rem;
            padding: 0.2rem 0.4rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 3px;
            color: var(--text-secondary);
            font-family: monospace;
        }
        
        .search-input-container {
            position: relative;
        }
        
        .search-icon {
            position: absolute;
            left: 0.75rem;
            top: 0.75rem;
            width: 16px;
            height: 16px;
            color: var(--text-muted);
            pointer-events: none;
        }
        
        #global-search-input {
            width: 100%;
            padding: 0.75rem 0.75rem 0.75rem 2.5rem;
            font-size: 1rem;
            border: 2px solid var(--border-primary);
            border-radius: 6px;
            background: var(--bg-primary);
            color: var(--text-primary);
            box-sizing: border-box;
            transition: border-color 0.2s ease;
        }
        
        #global-search-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        
        .search-filters {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.75rem;
        }
        
        .filter-btn {
            padding: 0.25rem 0.75rem;
            font-size: 0.85rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .filter-btn:hover, .filter-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }
        
        .search-results-container {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .search-suggestions {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .suggestion-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .suggestion-header {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.25rem;
        }
        
        .suggestion-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .suggestion-item:hover {
            background: var(--bg-secondary);
        }
        
        .suggestion-item i {
            width: 16px;
            height: 16px;
            color: var(--accent-primary);
        }
        
        .suggestion-item span {
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .search-results-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .search-result-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border: 1px solid transparent;
        }

        .search-result-item:hover {
            background: var(--bg-secondary);
            border-color: var(--border-primary);
        }
        
        .search-result-item.selected {
            background: var(--bg-secondary);
            border-color: var(--accent-primary);
        }
        
        .search-result-icon {
            width: 20px;
            height: 20px;
            color: var(--accent-primary);
            flex-shrink: 0;
            margin-top: 0.1rem;
        }
        
        .search-result-content {
            flex: 1;
            min-width: 0;
        }

        .search-result-title {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
            font-size: 0.95rem;
        }

        .search-result-subtitle {
            font-size: 0.8rem;
            color: var(--text-muted);
            line-height: 1.3;
        }
        
        .search-result-meta {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.25rem;
        }
        
        .search-result-category {
            font-size: 0.7rem;
            padding: 0.1rem 0.4rem;
            background: var(--accent-primary);
            color: white;
            border-radius: 3px;
            font-weight: 500;
        }
        
        .search-result-date {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        
        .search-no-results {
            text-align: center;
            padding: 2rem;
            color: var(--text-muted);
        }
        
        .search-no-results i {
            width: 48px;
            height: 48px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Dark mode support */
        
        [data-theme="dark"] .search-result-title {
            color: #e2e8f0 !important;
        }

        [data-theme="dark"] .search-result-subtitle {
            color: #a0aec0 !important;
        }

        /* QuickBar buttons dark mode visibility */
        [data-theme="dark"] .quickbar-sub-btn {
            background: #2d3748 !important;
            color: #e2e8f0 !important;
            border-color: #4a5568 !important;
        }

        [data-theme="dark"] .quickbar-sub-btn:hover {
            background: #4a5568 !important;
            color: #ffffff !important;
            border-color: #63b3ed !important;
        }

        [data-theme="dark"] .quickbar-main-btn {
            background: #2d3748 !important;
            color: #e2e8f0 !important;
            border-color: #4a5568 !important;
        }

        [data-theme="dark"] .quickbar-main-btn:hover,
        [data-theme="dark"] .quickbar-main-btn.active {
            background: #4a5568 !important;
            color: #ffffff !important;
            border-color: #63b3ed !important;
        }

        /* === LOGIN BLACK EFFECTS - VISIBLE ELEMENTS === */
        .login-effects {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99999;
        }

        /* Simple data points */
        .login-effects .data-point {
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            animation: dataFlow 15s linear infinite;
        }
        
        .login-effects .data-point:nth-child(1) {
            left: 10%;
            animation-delay: 0s;
        }
        
        .login-effects .data-point:nth-child(2) {
            left: 20%;
            animation-delay: 2s;
        }
        
        .login-effects .data-point:nth-child(3) {
            left: 30%;
            animation-delay: 4s;
        }
        
        .login-effects .data-point:nth-child(4) {
            left: 40%;
            animation-delay: 6s;
        }
        
        .login-effects .data-point:nth-child(5) {
            left: 50%;
            animation-delay: 8s;
        }
        
        .login-effects .data-point:nth-child(6) {
            left: 60%;
            animation-delay: 10s;
        }
        
        .login-effects .data-point:nth-child(7) {
            left: 70%;
            animation-delay: 12s;
        }
        
        .login-effects .data-point:nth-child(8) {
            left: 80%;
            animation-delay: 14s;
        }
        
        .login-effects .data-point:nth-child(9) {
            left: 90%;
            animation-delay: 16s;
        }
        
        .login-effects .data-point:nth-child(10) {
            left: 15%;
            animation-delay: 1s;
        }
        
        @keyframes dataFlow {
            0% {
                bottom: -10px;
                opacity: 0;
                transform: translateX(0px);
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 0.8;
            }
            100% {
                bottom: 100vh;
                opacity: 0;
                transform: translateX(30px);
            }
        }

        /* Login effects - hide by default */
        .login-effects {
            display: none;
        }
        
        /* Show ONLY when auth-screen is visible (not hidden) */
        #auth-screen:not(.hide) ~ .login-effects {
            display: block !important;
        }

        @keyframes floatPatterns {
            0%, 100% {
                transform: translateY(0) scale(1);
                opacity: 0.8;
            }
            50% {
                transform: translateY(-20px) scale(1.02);
                opacity: 1;
            }
        }

        @keyframes slideLines {
            0% {
                transform: translateX(-50px) translateY(-50px);
            }
            100% {
                transform: translateX(50px) translateY(50px);
            }
        }

        /* Login form styling */
        .login-form,
        .auth-form,
        .login-container {
            position: relative;
            z-index: 10;
            background: rgba(255, 255, 255, 0.95) !important;
            backdrop-filter: blur(5px);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        /* Login page dark mode styling */
        [data-theme="dark"] .login-container,
        [data-theme="dark"] .auth-container {
            background: #1a1a2e !important;
            color: #e2e8f0 !important;
            border-color: #2d3748 !important;
        }

        [data-theme="dark"] .login-form,
        [data-theme="dark"] .auth-form {
            background: #1a1a2e !important;
            border-color: #2d3748 !important;
        }

        [data-theme="dark"] .login-form input,
        [data-theme="dark"] .auth-form input {
            background: #2d3748 !important;
            color: #e2e8f0 !important;
            border-color: #4a5568 !important;
        }

        [data-theme="dark"] .login-form input::placeholder,
        [data-theme="dark"] .auth-form input::placeholder {
            color: #a0aec0 !important;
        }

        [data-theme="dark"] .login-form button,
        [data-theme="dark"] .auth-form button {
            background: #4a5568 !important;
            color: #ffffff !important;
            border-color: #63b3ed !important;
        }

        [data-theme="dark"] .login-form button:hover,
        [data-theme="dark"] .auth-form button:hover {
            background: #63b3ed !important;
        }

        /* Aggressive login page dark mode fixes */
        [data-theme="dark"] body {
            background: #0f0f23 !important;
        }

        [data-theme="dark"] * {
            border-color: #2d3748 !important;
        }

        [data-theme="dark"] div,
        [data-theme="dark"] form,
        [data-theme="dark"] section,
        [data-theme="dark"] main {
            background: #1a1a2e !important;
            color: #e2e8f0 !important;
        }

        /* Target specific white elements on login */
        [data-theme="dark"] [style*="background: white"],
        [data-theme="dark"] [style*="background:#fff"],
        [data-theme="dark"] [style*="background: #fff"],
        [data-theme="dark"] [style*="background-color: white"],
        [data-theme="dark"] [style*="background-color:#fff"],
        [data-theme="dark"] [style*="background-color: #fff"] {
            background: #1a1a2e !important;
        }

        /* === RESET & BASE === */
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        html { scroll-behavior: smooth; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: var(--font-size-base);
            line-height: var(--line-height-base);
            max-width: 1400px;
            margin: 0 auto;
        }

        /* === HIDE SCROLLBARS EVERYWHERE === */
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        *::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        /* === SMART LOADING STATES & SKELETON SCREENS === */
        .skeleton {
            background: linear-gradient(90deg, 
                var(--bg-secondary) 25%, 
                rgba(255,255,255,0.8) 50%, 
                var(--bg-secondary) 75%
            );
            background-size: 200% 100%;
            animation: loading-shimmer 2s infinite;
            border-radius: 4px;
        }
        
        @keyframes loading-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .skeleton-text {
            height: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .skeleton-text.large {
            height: 1.5rem;
        }
        
        .skeleton-text.small {
            height: 0.75rem;
        }
        
        .skeleton-text:last-child {
            margin-bottom: 0;
        }
        
        .skeleton-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }
        
        .skeleton-todo {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border-primary);
        }
        
        .skeleton-checkbox {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        
        .skeleton-watchlist-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border-primary);
        }
        
        .skeleton-watchlist-left {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }
        
        .skeleton-chart {
            width: 40px;
            height: 20px;
        }
        
        .skeleton-symbol {
            width: 35px;
            height: 0.75rem;
        }
        
        .skeleton-price {
            width: 60px;
            height: 0.75rem;
        }

        /* === STICKY NAVIGATION === */
        .sticky-nav {
            position: fixed;
            top: 40px; /* Below crypto ticker */
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-primary);
            z-index: 1000;
            padding: var(--spacing-md) 0;
        }
        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            position: relative;
        }
        .nav-tab {
            text-decoration: none;
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            padding: var(--spacing-sm) var(--spacing-md);
            border: 1px solid transparent;
            transition: all 0.2s ease;
            cursor: pointer;
            background: none;
            font-family: inherit;
        }
        .nav-tab:hover { 
            color: var(--accent-primary); 
            transform: translateY(-2px);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.02), rgba(0, 0, 0, 0.05));
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        .nav-tab.active {
            color: var(--accent-primary);
            font-weight: 700;
            border: 1px solid transparent;
            background: transparent;
        }
        
        /* === LOGOUT & SETTINGS BUTTONS === */
        .nav-actions {
            position: absolute;
            right: 0;
            display: flex;
            gap: 0.25rem;
            align-items: center;
        }
        
        .logout-btn, .settings-btn {
            color: var(--text-secondary) !important;
            font-weight: 400 !important;
            background: transparent !important;
            border: none !important;
            border-color: transparent !important;
            outline: none !important;
            cursor: pointer !important;
            pointer-events: auto !important;
            position: relative !important;
            z-index: 1000 !important;
            box-shadow: none !important;
            text-transform: none !important;
            letter-spacing: normal !important;
            padding: var(--spacing-sm) var(--spacing-md) !important;
        }
        
        /* Mobile-safe hover states - override nav-tab hover */
        .logout-btn:hover, .settings-btn:hover,
        .logout-btn:active, .settings-btn:active,
        .logout-btn:focus, .settings-btn:focus {
            background: transparent !important;
            border: none !important;
            border-color: transparent !important;
        }
        
        /* Specific override for nav-tab hover border */
        .nav-tab.logout-btn:hover, .nav-tab.settings-btn:hover {
            border: none !important;
            border-color: transparent !important;
            background: transparent !important;
        }

        .logout-btn:hover span, .logout-btn:active span, .logout-btn:focus span,
        .logout-btn:hover svg, .logout-btn:active svg, .logout-btn:focus svg {
            color: #dc2626 !important;
            stroke: #dc2626 !important;
        }

        .settings-btn:hover span, .settings-btn:active span, .settings-btn:focus span,
        .settings-btn:hover i, .settings-btn:active i, .settings-btn:focus i {
            color: #059669 !important;
            stroke: #059669 !important;
        }

        /* Force reset any stuck hover states on mobile */
        @media (max-width: 768px) {
            .logout-btn span {
                color: #666666 !important;
            }
            .logout-btn:hover span {
                color: #dc2626 !important;
            }
        }
        
        .logout-btn span, .settings-btn span {
            font-size: 1.2rem;
            pointer-events: none !important;
        }

        /* === SETTINGS PAGE === */
        .settings-container {
            max-width: 600px;
            margin: 0 auto;
        }
        
        .setting-group {
            background: #f8f9fa;
            padding: 2rem;
            margin-bottom: 2rem;
            border-radius: 12px;
            border: 1px solid var(--border-primary);
        }
        
        .setting-group h3 {
            margin: 0 0 1.5rem 0;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .setting-item:last-child {
            margin-bottom: 0;
        }
        
        .setting-item label {
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .setting-item input[type="time"] {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            max-width: 200px;
        }
        
        .pomodoro-duration-input {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            max-width: 200px;
        }
        
        .pomodoro-duration-input input[type="number"] {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            flex: 1;
            text-align: center;
            font-weight: 500;
        }
        
        .pomodoro-duration-input .duration-unit {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 500;
            min-width: 30px;
        }
        
        .setting-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }
        
        .btn-secondary {
            background: #6b7280 !important;
        }
        
        .btn-secondary:hover {
            background: #4b5563 !important;
        }
        
        /* === VISION BOARD === */
        .vision-board {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
            padding: 0;
        }
        
        .vision-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 0;
            padding: 2rem;
            text-align: center;
            transition: all 0.2s ease;
            cursor: grab;
            min-height: 140px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            user-select: none;
        }
        
        .vision-card:hover {
            border-color: var(--accent-primary);
        }

        .vision-card.dragging {
            opacity: 0.5;
            cursor: grabbing;
            transform: rotate(2deg);
            z-index: 1000;
        }

        .vision-card.drag-over {
            border-color: var(--accent-primary);
            border-width: 2px;
            border-style: dashed;
        }
        
        .vision-card-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: var(--accent-primary);
        }
        
        .vision-card-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }
        
        .vision-card-description {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Trading Rules Context Menu */
        .trading-rules-context-menu {
            position: fixed;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            padding: 0.5rem 0;
            min-width: 140px;
            display: none;
        }

        .trading-rules-context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-primary);
            transition: background-color 0.1s ease;
        }

        .trading-rules-context-menu-item:hover {
            background: var(--bg-secondary);
        }

        .trading-rules-context-menu-item.delete {
            color: #dc2626;
        }

        .trading-rules-context-menu-item.delete:hover {
            background: rgba(220, 38, 38, 0.1);
        }

        /* Dark mode support for trading rules context menu */
        [data-theme="dark"] .trading-rules-context-menu {
            background: var(--bg-secondary) !important;
            border-color: var(--border-primary) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        [data-theme="dark"] .trading-rules-context-menu-item:hover {
            background: rgba(255, 255, 255, 0.1) !important;
        }

        /* Vision Card Context Menu */
        .vision-context-menu {
            position: fixed;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            padding: 0.5rem 0;
            min-width: 140px;
            display: none;
        }

        .vision-context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-primary);
            transition: background-color 0.1s ease;
        }

        .vision-context-menu-item:hover {
            background: var(--bg-secondary);
        }

        .vision-context-menu-item.delete {
            color: #dc2626;
        }

        .vision-context-menu-item.delete:hover {
            background: rgba(220, 38, 38, 0.1);
        }

        /* Dark mode support for vision cards and context menu */
        [data-theme="dark"] .vision-card {
            background: var(--bg-secondary) !important;
            border-color: var(--border-primary) !important;
            color: var(--text-primary) !important;
        }

        [data-theme="dark"] .vision-context-menu {
            background: var(--bg-secondary) !important;
            border-color: var(--border-primary) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        [data-theme="dark"] .vision-context-menu-item:hover {
            background: rgba(255, 255, 255, 0.1) !important;
        }

        /* === MAIN CONTENT === */
        .main-content { padding: 0 20px 40px 20px; }
        .tab-section { display: none; }
        .tab-section.active { display: block; }

        /* === TODO BLOCKS (same as resources) === */
        .todos-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2rem;
        }
        
        .todo-block {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 0;
            overflow: hidden;
            transition: all 0.2s ease;
            height: 400px;
            max-height: 400px;
            display: flex;
            flex-direction: column;
        }

        /* Home todos: dynamic height based on content */
        .todo-block.home-todos {
            height: auto;
            max-height: none;
            min-height: auto;
        }

        .todo-block.home-todos .todo-links {
            padding: 0.75rem;
            min-height: auto;
            overflow: visible;
        }
        
        .todo-block:hover {
            border-color: #000000;
        }
        
        .todo-block-header {
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-primary);
            padding: 1.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .todo-block-header h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .todo-links {
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-height: 200px;
            flex: 1;
            overflow-y: auto;
        }
        
        .todo-empty-state {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-secondary);
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .todo-empty-state p {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: #333333;
        }
        
        .todo-empty-state small {
            font-size: 0.9rem;
            color: #888888;
            font-style: italic;
            line-height: 1.4;
        }

        /* === SHARED COMPONENTS === */
        .section-title {
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 3rem;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 1rem;
        }
        .card {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 2rem;
            transition: border-color 0.2s ease;
        }
        .card:hover { border-color: var(--accent-primary); }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 3rem; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2rem; }
        .btn {
            padding: 0.75rem 1.5rem;
            border: 1px solid var(--accent-primary);
            background: var(--bg-primary);
            color: var(--accent-primary);
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-block;
        }
        .btn:hover { background: var(--accent-primary); color: var(--bg-primary); }
        .btn.secondary { border-color: var(--border-primary); color: var(--text-secondary); }
        .btn.secondary:hover { border-color: var(--accent-primary); background: var(--bg-secondary); color: var(--accent-primary); }

        /* === CHECKBOX COMPONENT === */
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        /* Home todos - EXAKT wie Privat Container */

        /* Empty state for home todos */
        #home-todos:empty::after {
            content: "Keine Todos für heute";
            display: block;
            text-align: center;
            color: var(--text-muted);
            font-style: italic;
            padding: 1.25rem;
            font-size: 0.9rem;
        }
        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            border: 2px solid #000000;
            appearance: none;
            cursor: pointer;
            flex-shrink: 0;
        }
        .checkbox-item input[type="checkbox"]:checked {
            background-color: var(--accent-primary);
            position: relative;
        }
        .checkbox-item input[type="checkbox"]:checked::after {
            content: '✓';
            color: white;
            position: absolute;
            top: -2px;
            left: 2px;
            font-size: 12px;
        }
        .checkbox-item label {
            font-size: 0.95rem;
            cursor: pointer;
            line-height: 1.4;
        }

        /* Todo structure classes für home todos */
        .todo-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
        }

        .todo-right {
            font-size: 0.8rem;
            color: var(--text-muted);
            font-weight: 500;
        }

        /* === PROGRESS BAR === */
        .progress-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .progress-bar {
            flex: 1;
            height: 8px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: var(--accent-primary);
            transition: width 0.3s ease;
        }

        /* === STREAK TILES === */
        .streak-overview {
            margin-bottom: 3rem;
        }
        .streak-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2rem;
        }
        .streak-tile {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 2rem;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .streak-tile:hover {
            border-color: #000000;
        }
        
        /* Confetti Animation - Cool celebration effect */
        .streak-tile.success-animation {
            position: relative;
            animation: confettiPulse 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .streak-tile.updating {
            animation: updating-pulse 1s ease-in-out;
        }
        
        @keyframes updating-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.02); opacity: 0.8; border-color: #3b82f6; }
        }
        
        /* === DAILY SPORT SECTION === */
        .daily-sport-section {
            margin: 2rem 0;
        }
        
        .sport-question-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            transition: all 0.2s ease;
        }
        
        .sport-question-card:hover {
            border-color: #000000;
        }
        
        .sport-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .sport-icon {
            font-size: 1.25rem;
        }
        
        .sport-text {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .sport-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .sport-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .sport-btn:hover {
            border-color: #000000;
            color: #000000;
        }
        
        .sport-btn.sport-yes:hover {
            background: #000000;
            color: #ffffff;
        }
        
        .daily-sport-section.hidden {
            opacity: 0;
            max-height: 0;
            margin: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        @keyframes confettiPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Confetti particles */
        .confetti-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff6b6b;
            pointer-events: none;
            z-index: 1000;
        }
        
        .confetti-particle:nth-child(1) { background: #4ecdc4; }
        .confetti-particle:nth-child(2) { background: #45b7d1; }
        .confetti-particle:nth-child(3) { background: #96ceb4; }
        .confetti-particle:nth-child(4) { background: #feca57; }
        .confetti-particle:nth-child(5) { background: #ff9ff3; }
        .confetti-particle:nth-child(6) { background: #54a0ff; }
        .confetti-particle:nth-child(7) { background: #5f27cd; }
        .confetti-particle:nth-child(8) { background: #00d2d3; }
        
        @keyframes confettiFall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(60px) rotate(720deg);
                opacity: 0;
            }
        }
        
        .streak-number {
            font-size: 3rem;
            font-weight: 300;
            color: #000000;
            margin-bottom: 0.5rem;
            line-height: 1;
            transition: all 0.3s ease;
        }
        
        .streak-tile.success-animation .streak-number {
            animation: confettiNumberBounce 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes confettiNumberBounce {
            0% { 
                transform: scale(1); 
                color: #000000;
            }
            50% { 
                transform: scale(1.2); 
                color: #ff6b6b;
            }
            100% { 
                transform: scale(1); 
                color: #000000;
            }
        }
        .streak-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }
        .streak-date {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* === ROUTINE SPECIFIC === */
        .routine-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
            margin-bottom: 4rem;
            height: auto;
            min-height: 300px;
        }
        .routine-section {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            min-height: 250px;
        }
        .routine-section h2 {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .routine-section .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex: 1;
            margin-bottom: 1rem;
        }

        /* === TODO SPECIFIC === */
        .category-tabs {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 3rem;
        }
        .category-tab {
            padding: 0.75rem 2rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .category-tab:hover { border-color: #000000; color: #000000; }
        .category-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        
        .badge {
            background: #dc2626;
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 4px;
            min-width: 16px;
            text-align: center;
        }
        .category-content { display: none; }
        .category-content.active { display: block; }
        
        /* === ZIELE SPECIFIC TABS === */
        .ziel-tab {
            padding: 0.75rem 2rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .ziel-tab:hover { border-color: #000000; color: #000000; }
        .ziel-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .ziel-content { display: none; }
        
        /* === RESOURCE TABS === */
        .resource-tab {
            padding: 0.75rem 2rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .resource-tab:hover { border-color: #000000; color: #000000; }
        .resource-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .resource-content { display: none; }
        .resource-content.active { display: block; }
        .ziel-content.active { display: block; }
        
        /* === JOURNAL SPECIFIC TABS === */
        .journal-tab {
            padding: 0.75rem 2rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .journal-tab:hover { border-color: #000000; color: #000000; }
        .journal-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .journal-content { display: none; }
        .journal-content.active { display: block; }
        
        /* === TAG SELECTION === */
        .tag-option {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .tag-option:hover { border-color: #000000; color: #000000; }
        .tag-option.selected {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .tag-option .remove-tag {
            cursor: pointer;
            font-size: 1rem;
            opacity: 0.8;
            display: none;
        }
        .tag-option.selected .remove-tag {
            display: inline;
        }
        .tag-option .remove-tag:hover {
            opacity: 1;
        }
        .todo-section {
            margin-bottom: 2rem;
        }
        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .section-header h3 {
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #444444;
        }
        .section-divider {
            flex: 1;
            height: 1px;
            background: var(--border-primary);
        }
        .section-count {
            font-size: 0.8rem;
            color: var(--text-secondary);
            background: #f0f0f0;
            padding: 0.25rem 0.75rem;
            border: 1px solid var(--border-primary);
        }
        .todo-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: border-color 0.2s ease;
        }
        .todo-item:hover { border-color: var(--accent-primary); }
        .todo-item.completed { opacity: 0.6; background: var(--bg-secondary); }
        .todo-item.completed .todo-title { text-decoration: line-through; }
        .todo-header {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }
        .todo-content { flex: 1; }
        .todo-title {
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }
        .todo-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .todo-deadline {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .todo-deadline.today { color: #000000; font-weight: 500; }
        .todo-deadline.overdue { color: #cc0000; font-weight: 500; }
        .todo-deadline.soon { color: #ff6600; font-weight: 500; }
        
        /* Days until badge (similar to termine) */
        .days-until-badge {
            display: inline-block;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-left: 0.5rem;
        }
        .days-until-badge.heute {
            background: #000000;
            color: #ffffff;
        }
        .days-until-badge.morgen {
            background: #ff6600;
            color: #ffffff;
        }
        .days-until-badge.future {
            background: #3b82f6;
            color: #ffffff;
        }
        .days-until-badge.overdue {
            background: #cc0000;
            color: #ffffff;
        }
        
        /* === BRAIN DUMP CONTAINER (MINIMALIST LIKE ZIELE) === */
        .brain-dump-container {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            margin-bottom: 2rem;
            /* Removed border-radius for eckig design */
        }
        
        .brain-dump-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            cursor: pointer;
            user-select: none;
        }
        
        .brain-dump-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 500;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-primary);
        }
        
        .brain-dump-badge {
            background: var(--accent-primary);
            color: var(--bg-primary);
            font-size: 0.7rem;
            font-weight: 600;
            padding: 0.2rem 0.5rem;
            /* Removed border-radius for eckig design */
            min-width: 20px;
            text-align: center;
        }
        
        .brain-dump-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .brain-dump-expand {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary);
            padding: 0.5rem;
            /* Removed border-radius for eckig design */
            cursor: pointer;
            transition: border-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .brain-dump-expand:hover {
            border-color: var(--accent-primary);
        }
        
        .brain-dump-expand.expanded {
            transform: rotate(180deg);
        }
        
        .brain-dump-content {
            display: none;
            padding: 2rem;
            background: var(--bg-primary);
        }
        
        .brain-dump-content.expanded {
            display: block;
        }
        
        .brain-dump-alert {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            /* Removed border-radius for eckig design */
            margin-bottom: 1.5rem;
            color: var(--text-secondary);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .brain-dump-list {
            margin-bottom: 2rem;
        }
        
        .brain-dump-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            /* Removed border-radius for eckig design */
            margin-bottom: 1rem;
            transition: border-color 0.2s ease;
        }
        
        .brain-dump-item:hover {
            border-color: var(--accent-primary);
        }
        
        .brain-dump-item.selected {
            background: var(--bg-secondary);
            border-color: var(--accent-primary);
        }
        
        .brain-dump-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .brain-dump-content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .brain-dump-text {
            font-size: 1rem;
            line-height: 1.4;
            color: var(--text-primary);
        }
        
        .brain-dump-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .brain-dump-chips {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .brain-dump-chip {
            padding: 0.25rem 0.75rem;
            background: #f0f0f0;
            border: 1px solid var(--border-primary);
            /* Removed border-radius for eckig design */
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            white-space: nowrap;
        }
        
        .brain-dump-actions-area {
            display: flex;
            gap: 0.5rem;
        }
        
        .brain-dump-quick-action {
            padding: 0.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            /* Removed border-radius for eckig design */
            cursor: pointer;
            transition: border-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
        }
        
        .brain-dump-quick-action:hover {
            border-color: var(--accent-primary);
        }
        
        .brain-dump-bulk-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-primary);
        }
        
        /* Dezente aber lesbare Buttons */
        .brain-dump-bulk-actions button {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-primary);
            background: #fafafa;
            /* Removed border-radius for eckig design */
            font-size: 0.8rem;
            font-weight: normal;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        
        .brain-dump-bulk-actions button:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
            color: var(--text-primary);
        }
        
        /* Alle Buttons gleich dezent - auch Verteilen */
        .btn-primary, .btn-secondary, .btn-danger {
            background: #fafafa !important;
            color: var(--text-secondary) !important;
            border-color: var(--border-primary) !important;
        }
        
        .btn-primary:hover, .btn-secondary:hover {
            background: var(--bg-primary) !important;
            border-color: var(--accent-primary) !important;
            color: var(--text-primary) !important;
        }
        
        .btn-danger:hover {
            background: var(--bg-primary) !important;
            border-color: #cc0000 !important;
            color: #cc0000 !important;
        }
        
        .brain-dump-empty {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border: 1px solid var(--border-primary);
            background: var(--bg-secondary);
        }

        /* === ZIELE SPECIFIC === */
        .ziel-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 2rem;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 200px;
        }
        .ziel-kategorie {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            border: 1px solid var(--border-primary);
            padding: 0.2rem 0.5rem;
            background: #fafafa;
            white-space: nowrap;
        }
        .ziel-header {
            margin-bottom: 1rem;
            margin-right: 6rem;
        }
        .ziel-name {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }
        .ziel-beschreibung {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 2rem;
        }
        .ziel-progress-section { margin-top: auto; }
        .ziel-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .ziel-progress-label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #444444;
        }
        .ziel-percentage {
            font-size: 1rem;
            font-weight: 500;
        }

        /* === JOURNAL SPECIFIC === */
        .quick-journal {
            background: #f8f8f8;
            border: 1px solid var(--border-primary);
            padding: 2rem;
            margin-bottom: 3rem;
        }
        .quick-journal h2 {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .journal-form {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        .journal-input {
            flex: 1;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: var(--bg-primary);
            font-family: inherit;
            font-size: 0.95rem;
        }
        .journal-input:focus { outline: none; border-color: #000000; }
        .journal-entries, .wiki-content {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
        }
        
        @media (max-width: 1200px) {
            .journal-entries, .wiki-content {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .journal-entries, .wiki-content {
                grid-template-columns: 1fr;
            }
        }
        
        .journal-entry {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 2rem;
            margin-bottom: 0;
        }
        .journal-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1.5rem;
            gap: 1rem;
        }
        .journal-entry-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #000000;
            margin: 0;
        }
        .journal-entry-content {
            color: #374151;
            line-height: 1.6;
            margin-bottom: 1.5rem;
            white-space: pre-wrap;
        }
        
        /* Internal link styles - subtle and dashboard-native */
        .internal-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-weight: 500;
            padding: 2px 6px;
            border-radius: 4px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            transition: all 0.2s ease;
            font-size: 0.9em;
        }
        
        .internal-link:hover {
            color: var(--accent-primary);
            background-color: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: translateY(-1px);
        }
        
        /* Dark mode internal links */
        [data-theme="dark"] .internal-link {
            color: var(--text-secondary);
            background-color: var(--bg-secondary);
            border-color: var(--border-primary);
        }
        
        [data-theme="dark"] .internal-link:hover {
            color: var(--accent-primary);
            background-color: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        /* Autocomplete dropdown styles */
        .autocomplete-dropdown {
            position: fixed;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 9999;
            display: none;
        }

        .autocomplete-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.15s ease;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background-color: #f8f9fa;
        }

        .autocomplete-command {
            font-weight: 600;
            color: #3b82f6;
            display: block;
            font-size: 14px;
        }

        .autocomplete-description {
            font-size: 12px;
            color: #6b7280;
            margin-top: 2px;
            display: block;
        }

        /* Dark mode autocomplete */
        [data-theme="dark"] .autocomplete-dropdown {
            background: #1a1a2e;
            border-color: #374151;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        [data-theme="dark"] .autocomplete-item {
            border-bottom-color: #374151;
        }

        [data-theme="dark"] .autocomplete-item:hover,
        [data-theme="dark"] .autocomplete-item.selected {
            background-color: #374151;
        }

        [data-theme="dark"] .autocomplete-command {
            color: #60a5fa;
        }

        [data-theme="dark"] .autocomplete-description {
            color: #9ca3af;
        }

        /* === MOBILE OPTIMIZATIONS === */
        @media (max-width: 768px), (max-width: 834px) and (orientation: portrait), (max-width: 1024px) and (max-width: 1366px) and (pointer: coarse) {
            /* Better mobile viewport */
            body {
                font-size: 16px; /* Prevents zoom on iOS */
                -webkit-text-size-adjust: 100%;
            }
            
            /* Mobile-friendly modal */
            .modal-content {
                margin: 1rem;
                padding: 1.5rem;
                min-height: auto;
                max-height: 90vh;
                overflow-y: auto;
            }
            
            /* Larger touch targets for mobile */
            .form-group input,
            .form-group select,
            .form-group textarea {
                min-height: 44px; /* iOS recommended touch target */
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 12px;
                border-radius: 8px;
            }
            
            /* Mobile-friendly buttons */
            .btn {
                min-height: 44px;
                padding: 12px 24px;
                font-size: 16px;
                border-radius: 8px;
            }
            
            /* Hide complex elements on mobile */
            .crypto-ticker,
            .quickbar {
                display: none !important;
            }
            
            /* Simplify navigation for mobile */
            .nav-container {
                padding: 0.5rem;
            }
            
            .nav-tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                display: flex;
                gap: 0.5rem;
                padding: 0.5rem 0;
            }
            
            .nav-tab {
                min-width: auto;
                white-space: nowrap;
                font-size: 14px;
                padding: 8px 16px;
            }
        }

        /* === HIDE MOBILE ELEMENTS ON DESKTOP === */
        @media (min-width: 769px) {
            .mobile-quick-todo,
            .mobile-todo-modal {
                display: none !important;
            }
        }

        /* === MOBILE QUICK TODO === */
        @media (max-width: 768px) {
            /* Quick todo button that's always visible on mobile */
            .mobile-quick-todo {
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 56px;
                height: 56px;
                background: var(--accent-primary);
                color: var(--bg-primary);
                border: none;
                border-radius: 50%;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                z-index: 1000;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .mobile-quick-todo:hover {
                transform: scale(1.1);
                box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
            }
            
            /* Simplified mobile modal */
            .mobile-todo-modal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.7);
                z-index: 1100;
                display: none;
                align-items: flex-end;
            }
            
            .mobile-todo-modal.show {
                display: flex;
            }
            
            .mobile-todo-form {
                background: var(--bg-primary);
                width: 100%;
                border-radius: 20px 20px 0 0;
                padding: 1.5rem;
                max-height: 80vh;
                overflow-y: auto;
                animation: slideUp 0.3s ease-out;
            }
            
            @keyframes slideUp {
                from {
                    transform: translateY(100%);
                }
                to {
                    transform: translateY(0);
                }
            }
            
            .mobile-todo-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1.5rem;
                padding-bottom: 1rem;
                border-bottom: 1px solid var(--border-primary);
            }
            
            .mobile-todo-title {
                font-size: 1.2rem;
                font-weight: 600;
                margin: 0;
            }
            
            .mobile-close-btn {
                background: none;
                border: none;
                font-size: 1.5rem;
                color: var(--text-secondary);
                cursor: pointer;
                padding: 4px;
            }
        }
        .journal-entry-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }
        .journal-entry-tags {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .journal-tag {
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 0.25rem 0.5rem;
            border-radius: 0;
            font-size: 0.75rem;
            font-weight: 500;
        }
        .journal-entry-date {
            color: #9ca3af;
            font-size: 0.875rem;
        }
        .journal-entry-actions {
            display: flex;
            gap: 0.5rem;
        }
        .delete-entry-btn {
            background: none;
            border: none;
            color: #ef4444;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0;
            display: none;
        }
        .delete-entry-btn:hover {
            background: #fee2e2;
        }
        .journal-entry.show-delete .delete-entry-btn {
            display: block;
        }
        .wiki-entry-source {
            background: #e0f2fe;
            color: #0369a1;
            padding: 0.25rem 0.5rem;
            border-radius: 0;
            font-size: 0.75rem;
            font-weight: 500;
            margin-left: 0.5rem;
        }
        .journal-date {
            font-size: 1rem;
            font-weight: 500;
            color: #000000;
        }
        .journal-kategorie {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            border: 1px solid var(--border-primary);
            padding: 0.4rem 1rem;
            background: #fafafa;
        }
        .journal-content {
            font-size: 0.95rem;
            line-height: 1.7;
            color: #333333;
        }

        /* === TERMINE SPECIFIC === */
        .termin-card {
            position: relative;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 0;
            padding: 1.5rem;
            box-shadow: none;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .termin-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        }
        
        /* Base styling for days badges - dezent und rechteckig wie Kategorien */
        .termin-days-until, .ziel-days-until {
            position: absolute !important;
            top: 0.5rem !important;
            background: #fafafa !important;
            color: #666666 !important;
            padding: 0.2rem 0.5rem !important;
            border: 1px solid #e0e0e0 !important;
            font-size: 0.65rem !important;
            font-weight: 500 !important;
            text-transform: uppercase !important;
            letter-spacing: 0.1em !important;
            white-space: nowrap !important;
        }
        
        /* Termine: Rechtsbündig */
        .termin-days-until {
            right: 0.5rem !important;
        }
        
        /* Ziele: Mittig */
        .ziel-days-until {
            left: 50% !important;
            transform: translateX(-50%) !important;
        }
        
        /* === RESSOURCEN GRID === */
        .resource-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 200px));
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: start;
        }
        
        .resource-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 0.75rem;
            position: relative;
            transition: all 0.2s ease;
            height: 50px;
            display: flex;
            align-items: center;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .resource-card:hover {
            border-color: #000000;
            background: #f8f8f8;
        }
        
        .resource-icon {
            margin-right: 0.5rem;
            flex-shrink: 0;
            display: flex;
            align-items: center;
        }
        
        .resource-title {
            font-size: 0.85rem;
            font-weight: 500;
            color: #000000;
            margin: 0;
            flex: 1;
            line-height: 1.2;
        }

        /* === EMOJI PALETTE === */
        .emoji-palette {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 0.25rem;
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: #f8f8f8;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            position: relative;
            z-index: 1;
        }
        
        .emoji-btn {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 0.25rem;
            cursor: pointer;
            font-size: 1rem;
            border-radius: 2px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 28px;
            width: 28px;
        }
        
        .emoji-btn:hover {
            background: #000000;
            border-color: #000000;
            transform: scale(1.1);
        }
        
        .btn-link {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            text-decoration: underline;
            font-family: inherit;
        }
        
        .btn-link:hover {
            color: #000000;
        }
        
        .resource-footer {
            margin-top: auto;
            padding-top: 1rem;
            border-top: 1px solid #f0f0f0;
        }
        
        .resource-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #000000;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-primary);
            transition: all 0.2s ease;
        }
        
        .resource-link:hover {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
        }
        
        .resource-actions {
            position: absolute;
            top: 0.4rem;
            right: 0.4rem;
            display: flex;
            gap: 0.2rem;
            opacity: 1;
            transition: opacity 0.2s ease;
            z-index: 10;
        }

        .resource-edit-btn,
        .resource-delete-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #333333;
            cursor: pointer;
            padding: 0.25rem;
            transition: all 0.2s ease;
            border-radius: 4px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .resource-delete-btn:hover {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }
        
        .resource-edit-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.3);
            color: #3b82f6;
        }
        
        .resource-edit-btn:hover i,
        .resource-delete-btn:hover i {
            stroke: currentColor;
        }
        
        /* === RESOURCE CATEGORIES (bsp1.jpg style) === */
        .resource-category-section {
            margin-bottom: 3rem;
        }
        
        .resource-category-title {
            font-size: 1.8rem;
            font-weight: 300;
            color: #000000;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .resource-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
        }
        
        .resource-button {
            background: #333333;
            border: 1px solid #555555;
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            text-decoration: none;
            min-width: 140px;
            justify-content: flex-start;
        }
        
        .resource-button:hover {
            background: #444444;
            border-color: #666666;
            transform: translateY(-1px);
        }
        
        .resource-icon {
            font-size: 1rem;
            margin-right: 0.25rem;
        }
        
        .resource-name {
            flex: 1;
            text-align: left;
        }
        
        .resource-button .resource-actions {
            position: absolute;
            top: -0.25rem;
            right: -0.25rem;
            display: flex;
            gap: 0.125rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .resource-button .resource-edit-btn,
        .resource-button .resource-delete-btn {
            background: rgba(0, 0, 0, 0.8);
            border: none;
            color: #ffffff;
            padding: 0.25rem;
            font-size: 0.7rem;
            border-radius: 2px;
            cursor: pointer;
            opacity: 1;
        }
        
        .resource-button .resource-delete-btn:hover {
            background: #cc0000;
        }
        
        .resource-button .resource-edit-btn:hover {
            background: #007acc;
        }
        
        .termin-date {
            font-size: 0.8rem;
            color: #64748b;
            font-weight: 500;
            margin-bottom: 0.75rem;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .termin-date::before {
            content: '📅';
            font-size: 0.9rem;
        }
        
        .termin-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #1e293b;
            line-height: 1.3;
        }
        
        .termin-description {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #64748b;
            margin-bottom: 1rem;
        }
        
        .termin-edit-icon, .termin-delete-icon {
            position: absolute !important;
            bottom: 1rem !important;
            width: 32px !important;
            height: 32px !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 0.85rem !important;
            transition: all 0.2s ease !important;
            cursor: pointer !important;
        }
        
        .termin-edit-icon {
            right: 3.5rem !important;
            background: rgba(59, 130, 246, 0.1) !important;
            color: #3b82f6 !important;
            top: auto !important;
        }
        
        .termin-edit-icon:hover {
            background: #3b82f6 !important;
            color: white !important;
            transform: scale(1.1) !important;
        }
        
        .termin-delete-icon {
            right: 1rem !important;
            background: rgba(239, 68, 68, 0.1) !important;
            color: #ef4444 !important;
            top: auto !important;
        }
        
        .termin-delete-icon:hover {
            background: #ef4444 !important;
            color: white !important;
            transform: scale(1.1) !important;
        }

        /* === UNIFIED MINIMAL MODAL DESIGN === */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            padding: 1rem;
        }
        .modal.hide { display: none; }
        .modal-content {
            background: var(--bg-primary);
            border: 2px solid var(--accent-primary);
            width: 100%;
            max-width: 420px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            z-index: 4001;
            box-shadow: 0 0 0 rgba(0, 0, 0, 0);
        }
        .modal-content .close {
            position: absolute;
            top: 0;
            right: 0;
            width: 32px;
            height: 32px;
            background: #000000;
            color: #ffffff;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.1s ease;
        }
        .modal-content .close:hover {
            background: #333333;
        }
        .modal-content h2 {
            background: #000000;
            color: #ffffff;
            margin: 0;
            padding: 16px 24px;
            font-size: 14px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: none;
        }
        /* === MINIMAL FORM STYLES === */
        .modal-body {
            padding: 24px;
        }
        .form-row {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }
        .form-row .form-group {
            flex: 1;
        }
        .form-group {
            margin-bottom: 16px;
        }
        .form-group:last-child {
            margin-bottom: 0;
        }
        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #000000;
        }
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #000000;
            background: var(--bg-primary);
            font-family: inherit;
            font-size: 14px;
            color: #000000;
            box-sizing: border-box;
        }
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #000000;
            border-width: 2px;
        }
        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }
        .form-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #000000;
        }
        .btn {
            padding: 12px 24px;
            border: 1px solid var(--accent-primary);
            background: var(--bg-primary);
            color: var(--accent-primary);
            font-family: inherit;
            font-size: 12px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.1s ease;
        }
        .btn:hover {
            background: #000000;
            color: #ffffff;
        }
        .btn.secondary {
            background: var(--bg-primary);
            color: var(--text-secondary);
            border-color: #666666;
        }
        .btn.secondary:hover {
            background: #666666;
            color: #ffffff;
        }
        
        /* === COMPACT TODO STYLES === */
        .todo-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .todo-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            transition: all 0.1s ease;
            gap: 12px;
        }
        .todo-item:hover {
            border-color: #000000;
        }
        .todo-item.completed {
            opacity: 0.6;
            text-decoration: line-through;
        }
        .todo-content {
            flex: 1;
        }
        .todo-item input[type="checkbox"] {
            margin-left: auto;
        }
        .todo-title {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
            color: #000000;
        }
        .todo-meta {
            display: flex;
            gap: 12px;
            font-size: 12px;
        }
        .todo-priority {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 12px;
            flex-shrink: 0;
        }
        .priority-dringend {
            background: #dc2626;
        }
        .priority-wichtig {
            background: #d97706;
        }
        .priority-mittel {
            background: #3b82f6;
        }

        .priority-niedrig {
            background: #22c55e;
        }
        .todo-date {
            color: var(--text-secondary);
        }
        .todo-delete-btn {
            width: 24px;
            height: 24px;
            border: 1px solid #dc2626;
            background: var(--bg-primary);
            color: #dc2626;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease;
            margin-left: auto;
        }
        .todo-delete-btn:hover {
            background: #dc2626;
            color: #ffffff;
        }
        
        /* === UNIFIED PLUS BUTTON === */
        .add-btn {
            background: none;
            border: none;
            font-size: 24px;
            font-weight: 300;
            color: #333333;
            cursor: pointer;
            padding: 8px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
        }
        .add-btn:hover {
            color: #22c55e;
            transform: rotate(90deg);
        }
        
        /* === CHART EASTER EGG === */
        #chart-easter-egg-btn {
            border: none !important;
        }
        #chart-easter-egg-btn:hover {
            color: #3b82f6;
            transform: scale(1.2) rotate(360deg);
        }

        /* === ENHANCED QUICKBAR === */
        .quickbar {
            position: fixed;
            right: 24px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 3000;
            display: none; /* Hidden by default until authentication */
            flex-direction: column;
            gap: 4px;
        }

        /* Category container */
        .quickbar-category {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0px;
            opacity: 1;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Hide non-active categories when any is expanded */
        .quickbar.has-active .quickbar-category:not(.active) {
            opacity: 0;
            transform: scale(0.7);
            pointer-events: none;
        }

        .quickbar-category.active {
            opacity: 1;
            transform: scale(1);
        }

        /* Main category buttons */
        .quickbar-main-btn {
            width: 48px;
            height: 48px;
            background: none;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 3001;
            border-radius: 50%;
            color: #333333;
        }

        .quickbar-main-btn i {
            width: 24px;
            height: 24px;
            stroke-width: 2;
        }

        .quickbar-main-btn:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #000000;
            transform: scale(1.15);
        }

        .quickbar-main-btn:active {
            transform: scale(0.9);
        }

        .quickbar-main-btn.active {
            background: rgba(34, 197, 94, 0.15);
            color: #22c55e;
            transform: scale(1.1);
        }

        /* Sub-buttons - spawn directly under main icon */
        .quickbar-sub-buttons {
            position: absolute;
            top: 48px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px) scale(0.8);
            display: flex;
            flex-direction: column;
            gap: 6px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: top center;
            z-index: 3000;
        }

        .quickbar-sub-buttons.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
            pointer-events: auto;
        }

        /* Individual sub-buttons - clean icon style */
        .quickbar-sub-btn {
            width: 40px;
            height: 40px;
            background: var(--bg-primary);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transform: translateY(-10px) scale(0.8);
            color: #333333;
        }

        .quickbar-sub-btn i {
            width: 18px;
            height: 18px;
            stroke-width: 2;
        }

        .quickbar-sub-buttons.show .quickbar-sub-btn {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .quickbar-sub-btn:hover {
            background: var(--bg-primary);
            color: var(--accent-primary);
            transform: translateY(0) scale(1.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .quickbar-sub-btn:active {
            transform: scale(0.9);
        }

        /* Hide labels - only show icons */
        .quickbar-sub-label {
            display: none;
        }

        /* Tooltip for sub-buttons */
        .quickbar-sub-btn::before {
            content: attr(data-tooltip);
            position: absolute;
            right: 55px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 3002;
        }

        .quickbar-sub-btn:hover::before {
            opacity: 1;
        }

        /* Staggered animation for sub-buttons */
        .quickbar-sub-buttons.show .quickbar-sub-btn:nth-child(1) { 
            transition-delay: 0.05s; 
        }
        .quickbar-sub-buttons.show .quickbar-sub-btn:nth-child(2) { 
            transition-delay: 0.1s; 
        }
        .quickbar-sub-buttons.show .quickbar-sub-btn:nth-child(3) { 
            transition-delay: 0.15s; 
        }
        .quickbar-sub-buttons.show .quickbar-sub-btn:nth-child(4) { 
            transition-delay: 0.2s; 
        }
        .quickbar-sub-buttons.show .quickbar-sub-btn:nth-child(5) { 
            transition-delay: 0.25s; 
        }
        .quickbar-sub-buttons.show .quickbar-sub-btn:nth-child(6) { 
            transition-delay: 0.3s; 
        }

        /* Badge for quickbar buttons */
        .quickbar-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            z-index: 3001;
            pointer-events: none; /* Allow clicks to pass through */
        }

        /* Responsive - hide on mobile */
        @media (max-width: 768px) {
            .quickbar {
                display: none;
            }
        }
        
        /* === PAGE HEADERS === */
        .page-header {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin-bottom: 32px;
            padding-bottom: 16px;
            border-bottom: 1px solid #000000;
        }

        /* === AUTH SCREEN === */
        .auth-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 1rem;
        }
        .auth-screen.hide { display: none; }
        
        /* Hide all dashboard content by default until authenticated */
        body:not(.authenticated) #crypto-overlay,
        body:not(.authenticated) #quickbar,
        body:not(.authenticated) .home-section,
        body:not(.authenticated) .tabs-container,
        body:not(.authenticated) .tab-content {
            display: none !important;
        }
        
        /* Show login screen by default until JS loads */
        .auth-screen {
            display: flex !important;
        }
        
        /* Only hide login screen when explicitly authenticated */
        body.authenticated .auth-screen {
            display: none !important;
        }
        .auth-container {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 3rem;
            width: 100%;
            max-width: 400px;
        }
        .auth-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .auth-header h2 {
            font-size: 1.5rem;
            font-weight: 500;
            color: #000000;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-group {
            margin-bottom: 1.5rem;
        }
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #000000;
            font-weight: 500;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-group input {
            width: 100%;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: var(--bg-primary);
            font-family: inherit;
            font-size: 0.95rem;
        }
        .form-group input:focus { outline: none; border-color: #000000; }
        .auth-btn {
            width: 100%;
            padding: 1rem;
            border: 1px solid #000000;
            background: var(--bg-primary);
            color: #000000;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .auth-btn:hover {
            background: #000000;
            color: #ffffff;
        }
        .auth-error {
            color: #cc0000;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            display: none;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .auth-error.show { display: block; }

        /* === RESPONSIVE === */
        /* === CRYPTO WIKI STYLES === */
        .wiki-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .search-container {
            display: flex;
            flex: 1;
            min-width: 350px;
            align-items: stretch;
        }
        
        .search-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-right: none;
            border-radius: 0;
            font-size: 0.95rem;
        }
        
        .search-btn {
            padding: 0.75rem 1rem;
            border: 1px solid #d1d5db;
            border-left: none;
            border-radius: 0;
            background: #f8f9fa;
            cursor: pointer;
        }
        
        .filter-container {
            display: flex;
            gap: 1rem;
            align-items: stretch;
            flex: 1;
            min-width: 350px;
        }
        
        .filter-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0;
            font-size: 0.95rem;
            background: var(--bg-primary);
        }
        
        .filter-input:focus {
            outline: none;
            border-color: #000000;
            box-shadow: 0 0 0 1px #000000;
        }
        
        .filter-container select {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0;
            font-size: 0.95rem;
            background: var(--bg-primary);
        }

        .wiki-entry {
            background: #f8f9fa;
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 1.5rem;
        }
        
        .wiki-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }
        
        .wiki-entry-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #000000;
            margin: 0;
        }
        
        .wiki-entry-content {
            color: #333333;
            line-height: 1.6;
            margin-bottom: 1rem;
            white-space: pre-wrap;
        }
        
        .wiki-entry-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 1rem;
            border-top: 1px solid #e0e0e0;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .wiki-entry-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .wiki-tag {
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 0.25rem 0.5rem;
            border-radius: 0;
            font-size: 0.75rem;
        }
        
        .wiki-entry-source {
            font-style: italic;
        }
        
        .wiki-entry-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .wiki-entry-actions button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
        }
        
        .empty-wiki {
            text-align: center;
            color: var(--text-secondary);
            padding: 3rem;
        }

        /* === QUICK NOTES STYLES === */
        .quicknotes-section {
            margin-top: 2rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
        }

        .quicknotes-header {
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            padding: 1rem 1.5rem;
        }

        .quicknotes-header h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .quicknotes-content {
            padding: 1.5rem;
        }

        #quicknotes-textarea {
            width: 100%;
            min-height: 200px;
            padding: 1rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            font-family: inherit;
            font-size: 0.9rem;
            line-height: 1.6;
            resize: none;
            box-sizing: border-box;
            overflow: hidden;
        }

        #quicknotes-textarea:focus {
            outline: none;
            border-color: #000000;
        }

        #quicknotes-textarea::placeholder {
            color: #999999;
        }

        /* === TRADING TAB STYLES === DISABLED */
        /*
        .add-trade-section {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .add-trade-section h3 {
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .trade-form .form-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .trade-form .form-group {
            display: flex;
            flex-direction: column;
        }

        .trade-form .form-group label {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #333333;
        }

        .trade-form .form-group input {
            padding: 0.75rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            font-size: 0.9rem;
            width: 100%;
            box-sizing: border-box;
        }

        .trade-form .form-group input:focus {
            outline: none;
            border-color: #000000;
        }

        .trade-form .form-actions {
            display: flex;
            gap: 0.5rem;
        }

        .sol-input-group, .mcap-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .sol-input-group input, .mcap-input-group input {
            width: 100%;
        }

        .mcap-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .mcap-container input {
            flex: 1;
        }

        .mcap-select {
            min-width: 60px;
            padding: 0.75rem 0.5rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            font-size: 0.9rem;
            border-radius: 6px;
        }

        .mcap-select:focus {
            outline: none;
            border-color: #000000;
        }

        .sol-buttons, .mcap-buttons, .sol-sell-buttons {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
        }

        .sol-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.25rem;
        }

        .sol-btn, .mcap-btn, .sol-percent-btn {
            padding: 0.4rem 0.6rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 35px;
            text-align: center;
        }

        .sol-btn:hover, .mcap-btn:hover, .sol-percent-btn:hover {
            border-color: #000000;
            background: #f5f5f5;
        }

        .mcap-btn.active {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
        }

        */
        
        /* === MODAL STYLES === */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--bg-primary);
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.2rem;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: #000000;
        }

        .modal-body {
            padding: 1.5rem;
        }

        .trade-info {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .info-row:last-child {
            margin-bottom: 0;
        }

        .info-label {
            font-weight: 500;
            color: var(--text-secondary);
        }

        .info-value {
            font-weight: 600;
            color: #000000;
        }
        
        /* === TRADE DETAILS MODAL === DISABLED */
        /*
        .trade-details-info {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .details-section {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 1rem;
        }

        .details-section h4 {
            margin: 0 0 1rem 0;
            font-size: 0.9rem;
            font-weight: 600;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 0.5rem;
        }

        .info-grid {
            display: grid;
            gap: 0.75rem;
        }

        .notes-content, .learnings-content {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            padding: 1rem;
            min-height: 80px;
            white-space: pre-wrap;
            font-family: inherit;
            line-height: 1.5;
            color: #000000;
        }

        .learnings-content {
            border-left: 4px solid #059669;
        }

        .notes-content:empty::before {
            content: 'Keine Entry Notes verfügbar';
            color: #999999;
            font-style: italic;
        }

        .learnings-content:empty::before {
            content: 'Keine Learnings verfügbar';
            color: #999999;
            font-style: italic;
        }

        */
        
        /* === MOTIVATIONAL QUOTE WIDGET === */
        .quote-widget {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 0;
            margin-bottom: 4rem;
            transition: all 0.2s ease;
        }

        .quote-widget:hover {
            border-color: #000000;
        }

        .quote-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            padding: 1.5rem;
            color: #000000;
        }

        .quote-icon {
            font-size: 1.5rem;
            color: var(--text-secondary);
            min-width: 24px;
        }

        .quote-content {
            flex: 1;
        }

        .quote-text {
            font-size: 1rem;
            font-weight: 500;
            line-height: 1.6;
            margin-bottom: 0.5rem;
            color: #000000;
        }

        .quote-author {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .quote-refresh-btn {
            background: none;
            border: 1px solid var(--border-primary);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .quote-refresh-btn:hover {
            border-color: #000000;
            color: #000000;
        }

        @media (max-width: 768px) {
            .quote-container {
                flex-direction: column;
                text-align: center;
                gap: 1rem;
                padding: 1.25rem;
            }
            
            .quote-text {
                font-size: 0.9rem;
            }
        }

        /* === RESOURCES BLOCKS DESIGN === */
        .resources-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .resources-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2rem;
        }

        .resource-block {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 0;
            transition: all 0.2s ease;
            min-height: 300px;
        }

        .resource-block:hover {
            border-color: var(--accent-primary);
        }

        .resource-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.25rem;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-primary);
        }

        .resource-block-header h3 {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 0;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #000000;
        }

        .resource-block-header i {
            color: var(--text-secondary);
        }

        .add-to-category-btn {
            background: none;
            border: 1px solid var(--border-primary);
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .add-to-category-btn:hover {
            border-color: #000000;
            color: #000000;
        }
        
        /* === RESOURCES SEPARATOR === */
        .resources-separator {
            border: none;
            border-top: 1px solid var(--border-primary);
            margin: 2rem 0;
        }
        
        /* === TEXT SNIPPETS === */
        .textsnippet-item {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #000000;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-primary);
            transition: all 0.2s ease;
            cursor: pointer;
            background: var(--bg-primary);
            margin: 0.25rem;
            position: relative;
            overflow: visible;
        }
        
        
        .textsnippet-item:hover {
            border-color: #000000;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .textsnippet-text {
            flex: 1;
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .textsnippet-copy-feedback {
            position: absolute;
            top: 50%;
            right: 1rem;
            transform: translateY(-50%);
            color: #22c55e;
            opacity: 0;
            transition: all 0.3s ease;
            background: var(--bg-primary);
            padding: 0.25rem;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .textsnippet-copy-feedback.show {
            opacity: 1;
        }

        .resource-links {
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-height: 200px;
        }

        .resource-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border: 1px solid #f0f0f0;
            transition: all 0.2s ease;
            text-decoration: none;
            color: inherit;
            position: relative;
        }

        .resource-item:hover {
            border-color: #e0e0e0;
            background: #fafafa;
        }

        .delete-overlay {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            animation: fadeIn 0.2s ease;
            z-index: 10;
        }

        .delete-icon {
            background: #dc2626;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 4px rgba(220, 38, 38, 0.3);
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            opacity: 0;
            z-index: 10;
        }
        
        .delete-icon.show {
            opacity: 1;
            animation: fadeIn 0.2s ease;
        }

        .delete-icon:hover {
            background: #b91c1c;
            transform: scale(1.05);
            box-shadow: 0 2px 6px rgba(220, 38, 38, 0.4);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .resource-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
        }

        .resource-icon {
            color: var(--text-secondary);
            min-width: 16px;
        }

        .resource-details {
            flex: 1;
        }

        .resource-title {
            font-weight: 500;
            font-size: 0.9rem;
            color: #000000;
            margin-bottom: 0.25rem;
        }

        .resource-description {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .resource-actions {
            display: flex;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .resource-action-btn {
            background: none;
            border: none;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .resource-action-btn:hover {
            color: #dc2626;
        }

        .empty-resources {
            text-align: center;
            padding: 2rem 1rem;
            color: #999999;
            font-style: italic;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .resources-grid {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
            
            .resources-header {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
                text-align: center;
            }
        }

        .close-trade-form .form-group {
            margin-bottom: 1.5rem;
        }

        .close-trade-form .form-group:last-child {
            margin-bottom: 0;
        }

        .close-trade-form label {
            display: block;
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #333333;
        }

        .modal-footer {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            padding: 1.5rem;
            border-top: 1px solid #e0e0e0;
        }

        .portfolio-overview {
            margin-bottom: 2rem;
        }

        .portfolio-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
        }

        .portfolio-stat {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: 1.5rem;
            text-align: center;
        }

        .stat-number {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .stat-number.positive { color: #059669; }
        .stat-number.negative { color: #dc2626; }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* SIMPLE TRADE TABLE - NO CONFLICTS */
        .simple-trade-container {
            border: 1px solid #ddd;
            margin: 20px 0;
        }

        .simple-trade-table {
            width: 100%;
            border-collapse: collapse;
            font-family: -apple-system, sans-serif;
        }

        .simple-trade-table th {
            background: #f5f5f5;
            padding: 12px;
            border-bottom: 2px solid #ddd;
            font-weight: 600;
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        .simple-trade-table td {
            padding: 12px;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }

        .simple-trade-table tr:hover {
            background: #f9f9f9;
        }

        .simple-trade-table td[contenteditable] {
            cursor: text;
        }

        .simple-trade-table td[contenteditable]:focus {
            outline: 2px solid #007cba;
            background: #fff;
        }

        .simple-trade-table td[contenteditable]:empty:before {
            content: "-";
            color: #999;
        }

        .trade-amount.positive { color: #059669; }
        .trade-amount.negative { color: #dc2626; }

        /* Delete Button */
        .delete-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 18px;
            height: 18px;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 2px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: none;
            line-height: 1;
            z-index: 10;
        }

        .delete-btn:hover {
            background: #b91c1c;
        }

        .trades-view {
            /* Ensure only one view is visible at a time */
            width: 100%;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .section-header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .section-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .section-actions .btn {
            padding: 0.25rem 0.75rem;
            font-size: 0.85rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        /* === ANALYTICS STYLES === */
        .analytics-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .analytics-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
        }

        .analytics-card h3 {
            margin: 0 0 0.5rem 0;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #000000;
            margin: 0.5rem 0;
        }

        .metric-value.positive { color: #22c55e; }
        .metric-value.negative { color: #ef4444; }

        .metric-subtitle {
            font-size: 0.8rem;
            color: #888888;
        }

        .charts-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .chart-container {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1.5rem;
        }

        .chart-container h3 {
            margin: 0 0 1rem 0;
            font-size: 1rem;
            font-weight: 600;
        }

        .chart-placeholder {
            height: 200px;
            background: #f8f9fa;
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 1rem;
        }

        .analytics-charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-bottom: 1rem;
        }

        .chart-section {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1.5rem;
            height: 480px;
            max-height: 480px;
            display: flex;
            flex-direction: column;
            overflow: visible;
        }

        .chart-container {
            height: 300px;
            position: relative;
            flex: none;
            padding: 10px;
        }

        .chart-container canvas {
            max-height: 100%;
            width: 100% !important;
            height: 100% !important;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin: 0 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #f0f0f0;
        }

        .chart-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-end;
        }

        .time-period-buttons {
            display: flex;
            gap: 0.25rem;
        }

        .period-btn, .category-btn {
            padding: 0.4rem 0.8rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            color: var(--text-secondary);
            font-size: 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .period-btn:hover, .category-btn:hover {
            background: #f5f5f5;
        }

        .period-btn.active, .category-btn.active {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
        }
        
        .category-filter-buttons {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }

        .chart-header h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            color: #000000;
        }

        .chart-info {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Heatmap Styles */
        .heatmap-container {
            padding: 1rem 0;
            height: 280px;
            display: flex;
            flex-direction: column;
            flex: none;
        }

        .heatmap-months {
            display: flex;
            margin-bottom: 0.5rem;
            padding-left: 15px;
            font-size: 0.7rem;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .heatmap-month {
            flex: 1;
            text-align: left;
            min-width: 0;
        }

        .heatmap-grid {
            display: grid;
            grid-template-columns: repeat(53, 1fr);
            grid-template-rows: repeat(7, 1fr);
            gap: 1px;
            padding: 0;
            margin: 0;
            flex: 1;
            max-width: 100%;
            overflow: hidden;
        }

        .heatmap-square {
            width: 100%;
            height: 100%;
            min-width: 8px;
            min-height: 8px;
            border-radius: 1px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        @media (max-width: 768px) {
            .analytics-charts-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-container {
                height: 230px;
            }
            
            .heatmap-container {
                height: 230px;
            }
        }

        .heatmap-square:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .heatmap-square.level-0 {
            background-color: #ebedf0;
        }

        .heatmap-square.level-1 {
            background-color: #9be9a8;
        }

        .heatmap-square.level-2 {
            background-color: #40c463;
        }

        .heatmap-square.level-3 {
            background-color: #30a14e;
        }

        .heatmap-square.level-4 {
            background-color: #216e39;
        }

        /* Performance Heatmap Colors */
        .heatmap-square.performance-loss {
            background-color: #ef4444; /* Red for loss */
        }
        
        /* Tag Correlations List */
        .correlations-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 300px;
            overflow-y: auto;
            padding: 0.5rem 0;
        }
        
        .correlation-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 4px;
            font-size: var(--font-size-sm);
        }
        
        .correlation-tags {
            display: flex;
            gap: 0.5rem;
        }
        
        .correlation-tag {
            padding: 0.2rem 0.4rem;
            background: var(--accent-primary);
            color: white;
            border-radius: 12px;
            font-size: var(--font-size-xs);
            font-weight: 500;
        }
        
        .correlation-count {
            font-weight: 600;
            color: var(--text-secondary);
        }

        .heatmap-square.performance-neutral {
            background-color: #f97316; /* Orange for same */
        }

        .heatmap-square.performance-gain {
            background-color: #22c55e; /* Green for gain */
        }

        /* Performance Legend Colors */
        .legend-square.performance-loss {
            background-color: #ef4444;
        }

        .legend-square.performance-neutral {
            background-color: #f97316;
        }

        .legend-square.performance-gain {
            background-color: #22c55e;
        }

        .heatmap-legend {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-top: 1rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
            gap: 0.5rem;
        }

        .legend-colors {
            display: flex;
            gap: 2px;
        }

        .legend-square {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .legend-square.level-0 {
            background-color: #ebedf0;
        }

        /* === TRADING STICKY NOTE === DISABLED */
        /*
        .trading-rules-sticky {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            margin-bottom: 2rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .trading-rules-sticky:hover {
            border-color: #000000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .trading-rules-sticky::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, #000000, transparent);
            animation: slideRule 4s ease-in-out infinite;
        }
        
        @keyframes slideRule {
            0%, 100% { left: -100%; opacity: 0; }
            50% { left: 100%; opacity: 1; }
        }
        
        .sticky-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid #f0f0f0;
            background: #fafafa;
        }
        
        .sticky-title {
            font-weight: 500;
            font-size: 0.9rem;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .sticky-minimize {
            background: none;
            border: none;
            font-size: 1rem;
            font-weight: 300;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            transition: all 0.3s ease;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .sticky-minimize:hover {
            color: #000000;
            transform: rotate(180deg) scale(1.1);
        }
        
        .sticky-content {
            padding: 1.5rem;
        }
        
        .rules-list {
            list-style: none;
            margin: 0;
            padding: 0;
            display: grid;
            gap: 1rem;
        }
        
        .rules-list li {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #000000;
            padding: 0.75rem;
            border: 1px solid transparent;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .rules-list li:hover {
            border-color: #e0e0e0;
            background: #fafafa;
            transform: translateX(2px);
        }
        
        .rules-list li::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #000000;
            transform: scaleY(0);
            transition: transform 0.2s ease;
            transform-origin: bottom;
        }
        
        .rules-list li:hover::before {
            transform: scaleY(1);
        }
        
        .rules-list strong {
            color: #000000;
            font-weight: 500;
        }
        
        .trading-rules-sticky.minimized .sticky-content {
            display: none;
        }

        .trading-rules-sticky.minimized .sticky-header {
            border-bottom: none;
        }
        */
        
        @media (max-width: 768px) {
            .rules-list {
                gap: 0.75rem;
            }
            
            .rules-list li {
                font-size: 0.85rem;
                padding: 0.6rem;
                gap: 0.75rem;
            }
            
            .sticky-content {
                padding: 1rem;
            }
            
            .sticky-header {
                padding: 1rem 1.25rem;
            }
        }

        .legend-square.level-1 {
            background-color: #9be9a8;
        }

        .legend-square.level-2 {
            background-color: #40c463;
        }

        .legend-square.level-3 {
            background-color: #30a14e;
        }

        .legend-square.level-4 {
            background-color: #216e39;
        }

        .heatmap-info {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .performers-section {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1.5rem;
        }

        .performers-section h3 {
            margin: 0 0 1rem 0;
            font-size: 1rem;
            font-weight: 600;
        }

        .performer-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .performer-item:last-child {
            border-bottom: none;
        }

        .token-name {
            font-weight: 500;
        }

        .token-pnl.positive { color: #22c55e; }
        .token-pnl.negative { color: #ef4444; }

        @media (max-width: 768px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
            
            .analytics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* === ENHANCED TRADE FORM STYLES === */
        .form-section {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #f0f0f0;
        }

        .form-section-title {
            margin: 0 0 1rem 0;
            font-size: 0.9rem;
            font-weight: 600;
            color: #444444;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .form-group textarea {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.9rem;
            resize: vertical;
            min-height: 80px;
        }

        .form-group textarea:focus {
            outline: none;
            border-color: #000000;
        }

        .form-group textarea::placeholder {
            color: #999999;
            font-style: italic;
        }

        .stoploss-btn.active {
            background: #fecaca !important;
            color: #dc2626 !important;
            border-color: #dc2626 !important;
        }

        .takeprofit-btn.active {
            background: #bbf7d0 !important;
            color: #059669 !important;
            border-color: #059669 !important;
        }

        /* === TRADE ACTION BUTTONS === */
        .trade-action-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .trade-action-btn:hover {
            background: transparent;
            color: #16a34a;
        }

        .trade-action-btn:hover i {
            stroke: #16a34a;
        }

        /* === TRADE BADGE ICONS === */
        .trade-badge-icon {
            width: 16px;
            height: 16px;
            margin-left: 0.5rem;
            vertical-align: middle;
        }

        .initials-icon {
            stroke: #16a34a;
            stroke-width: 2;
        }

        .free-ride-icon {
            stroke: #2563eb;
            stroke-width: 2;
        }

        .trades-table {
            overflow-x: auto;
        }

        .trade-row {
            display: grid;
            grid-template-columns: 1fr 0.8fr 1fr 1fr 0.8fr 1fr 0.8fr auto;
            gap: 0.5rem;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f0f0f0;
            align-items: center;
        }

        #open-trades-view .trade-row {
            grid-template-columns: 1fr 0.8fr 1fr 1fr 0.8fr 0.8fr 0.8fr 1fr auto;
        }

        .trade-row:last-child {
            border-bottom: none;
        }

        .trade-header {
            display: grid;
            grid-template-columns: 1fr 0.8fr 1fr 1fr 0.8fr 1fr 0.8fr auto;
            gap: 0.5rem;
            padding: 0.5rem 0;
            border-bottom: 2px solid #e0e0e0;
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        #open-trades-view .trade-header {
            grid-template-columns: 1fr 0.8fr 1fr 1fr 0.8fr 0.8fr 0.8fr 1fr auto;
        }

        .trade-token {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .trade-amount {
            font-size: 0.9rem;
        }

        .trade-risk {
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .trade-notes {
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .trade-entry-price {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .trade-current-price {
            font-size: 0.9rem;
        }

        .trade-pnl {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .trade-pnl.positive { color: #059669; }
        .trade-pnl.negative { color: #dc2626; }

        .trade-actions {
            display: flex;
            gap: 0.5rem;
        }

        .trade-actions button {
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
        }

        .empty-trades {
            text-align: center;
            color: var(--text-secondary);
            padding: 2rem;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .trade-form .form-row {
                grid-template-columns: 1fr;
            }
            
            .portfolio-stats {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .trade-row, .trade-header {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }

            .trade-row > div::before {
                content: attr(data-label) ": ";
                font-weight: 600;
                display: inline-block;
                width: 80px;
            }
        }

        /* === LUCIDE ICON STYLES === */
        .icon-palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .icon-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            background: var(--bg-primary);
            border-radius: 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .icon-btn:hover {
            background: #f3f4f6;
            border-color: #000000;
        }
        
        .icon-btn:active {
            background: #e5e7eb;
        }

        /* === CRYPTO TICKER BAR === */
        .crypto-ticker-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            z-index: 999; /* Below navbar but above content */
            display: none; /* Hidden by default, shown only after authentication */
        }
        
        .ticker-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
        }
        
        .ticker-content {
            display: flex;
            align-items: center;
            gap: 20px;
            white-space: nowrap;
            animation: scroll-ticker 40s linear infinite;
        }
        
        @keyframes scroll-ticker {
            0% { transform: translateX(100%); }
            100% { transform: translateX(-100%); }
        }
        
        /* Pause animation on hover */
        .ticker-content:hover {
            animation-play-state: paused;
        }
        
        /* When few coins, center without animation */
        .ticker-content.center-static {
            animation: none;
            transform: none;
            justify-content: center;
            width: 100%;
        }
        
        .ticker-actions {
            display: none;
        }
        
        .ticker-btn {
            display: none;
        }
        
        .ticker-btn:hover {
            display: none;
        }
        
        .ticker-btn i {
            display: none;
        }
        
        /* Ticker Item Styles */
        .crypto-overlay-item {
            display: flex;
            align-items: center;
            gap: 2px;
            white-space: nowrap;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }
        
        .crypto-overlay-item:hover {
            background: var(--bg-primary);
        }
        
        .crypto-overlay-symbol {
            font-weight: 700;
            color: var(--text-primary);
            min-width: 45px;
            font-size: 14px;
            flex-shrink: 0;
        }
        
        .crypto-overlay-price {
            font-weight: 500;
            color: var(--text-primary);
            min-width: 60px;
            font-size: 11px;
            flex-shrink: 0;
        }
        
        .crypto-overlay-change {
            font-size: 10px;
            font-weight: 500;
            min-width: 40px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .crypto-overlay-change.positive {
            color: #15803d;
        }
        
        .crypto-overlay-change.negative {
            color: #dc2626;
        }
        
        /* Adjust body padding for ticker */
        body {
            padding-top: 120px; /* 40px ticker + 80px navbar */
        }

        .crypto-overlay-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm);
            border-bottom: 1px solid var(--border-primary);
            background: var(--bg-secondary);
        }

        .crypto-header-buttons {
            display: flex;
            gap: var(--spacing-xs);
        }

        .crypto-settings-btn, .crypto-toggle-btn {
            background: none;
            border: 1px solid transparent;
            cursor: pointer;
            padding: var(--spacing-xs);
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .crypto-overlay-title {
            font-weight: 600;
            font-size: var(--font-size-xs);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-primary);
        }

        .crypto-settings-btn:hover, .crypto-toggle-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .crypto-overlay-content {
            padding: var(--spacing-sm);
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .crypto-overlay.collapsed .crypto-overlay-content {
            max-height: 0;
            padding: 0 var(--spacing-sm);
        }

        .crypto-overlay.collapsed .crypto-toggle-btn i {
            transform: rotate(-90deg);
        }

        .crypto-overlay-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border-primary);
            position: relative;
        }

        .crypto-overlay-item:last-child {
            border-bottom: none;
        }

        .crypto-overlay-left {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .crypto-mini-chart {
            width: 40px;
            height: 20px;
            cursor: pointer;
        }

        .crypto-overlay-symbol {
            font-weight: 600;
            font-size: var(--font-size-xs);
            color: var(--text-primary);
            min-width: 35px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .crypto-overlay-data {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: var(--spacing-xs);
        }

        .crypto-overlay-price {
            font-weight: 600;
            font-size: var(--font-size-sm);
            color: var(--text-primary);
            font-family: inherit;
        }

        .crypto-overlay-change {
            font-size: var(--font-size-xs);
            font-weight: 500;
            font-family: inherit;
        }

        .crypto-overlay-change.positive {
            color: #22c55e;
        }

        .crypto-overlay-change.negative {
            color: #ef4444;
        }

        .crypto-overlay-change.neutral {
            color: var(--text-secondary);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .crypto-overlay {
                top: 80px;
                right: 10px;
                min-width: 160px;
                font-size: 0.7rem;
            }

            .crypto-overlay-header {
                padding: 0.4rem 0.6rem;
            }

            .crypto-overlay-content {
                padding: 0.4rem;
            }

            .crypto-overlay-item {
                padding: 0.3rem 0;
            }
        }

        @media (max-width: 480px) {
            .crypto-overlay {
                min-width: 140px;
                font-size: 0.65rem;
            }
        }

        /* Chart Styles */
        .crypto-chart-container {
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            margin-bottom: 0.5rem;
        }

        .crypto-chart-controls {
            display: flex;
            justify-content: center;
            margin-top: 0.5rem;
        }

        .crypto-chart-select {
            background: rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            padding: 0.2rem 0.4rem;
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        /* Settings Panel */
        .crypto-settings-panel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            z-index: 20; /* Higher than overlay content */
        }

        .crypto-settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm);
            border-bottom: 1px solid var(--border-primary);
            background: var(--bg-secondary);
            font-weight: 600;
            font-size: var(--font-size-xs);
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .crypto-settings-close {
            background: none;
            border: 1px solid transparent;
            cursor: pointer;
            padding: var(--spacing-xs);
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .crypto-settings-close:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .crypto-search {
            padding: var(--spacing-sm);
            border-bottom: 1px solid var(--border-primary);
        }

        .crypto-search input {
            width: 100%;
            padding: var(--spacing-sm);
            border: 1px solid var(--border-secondary);
            font-size: var(--font-size-xs);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: inherit;
        }

        .crypto-search input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .crypto-search input::placeholder {
            color: var(--text-muted);
        }

        .crypto-available-coins {
            padding: var(--spacing-sm);
            max-height: 200px;
            overflow-y: auto;
        }

        .crypto-coin-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-sm);
            gap: var(--spacing-sm);
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .crypto-coin-option:hover {
            border-color: var(--border-secondary);
            background: var(--bg-secondary);
        }

        .crypto-coin-option.added {
            border-color: #22c55e;
            background: var(--bg-secondary);
        }
        
        /* === SETTINGS CRYPTO MANAGEMENT === */
        .crypto-management {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .crypto-search-container input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            font-size: var(--font-size-sm);
            border-radius: 4px;
        }
        
        .crypto-search-container input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        
        .crypto-coins-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 0.75rem;
            max-height: 400px;
            overflow-y: auto;
            padding: 0.5rem 0;
        }
        
        .settings-crypto-coin {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-secondary);
            transition: all 0.2s ease;
        }
        
        .settings-crypto-coin:hover {
            border-color: var(--accent-primary);
        }
        
        .settings-crypto-coin.active {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.05);
        }
        
        .settings-crypto-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
        }
        
        .settings-crypto-symbol {
            font-weight: 600;
            font-size: var(--font-size-sm);
            color: var(--text-primary);
            min-width: 60px;
            text-transform: uppercase;
        }
        
        .settings-crypto-price {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
            flex: 1;
        }
        
        .settings-crypto-toggle {
            background: transparent;
            border: 1px solid var(--border-primary);
            padding: 0.4rem 0.8rem;
            font-size: var(--font-size-xs);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .settings-crypto-toggle:hover {
            border-color: var(--accent-primary);
            background: var(--bg-primary);
        }
        
        .settings-crypto-toggle.active {
            background: #22c55e;
            border-color: #22c55e;
            color: white;
        }

        .crypto-coin-info {
            flex: 1;
        }

        .crypto-coin-name {
            font-size: var(--font-size-xs);
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .crypto-coin-price {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
            margin-top: 0.1rem;
        }

        .crypto-add-btn {
            background: none;
            color: var(--text-primary);
            border: 1px solid var(--border-secondary);
            padding: var(--spacing-xs) var(--spacing-sm);
            font-size: var(--font-size-xs);
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .crypto-add-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .crypto-add-btn.added {
            border-color: #ef4444;
            color: #ef4444;
        }

        .crypto-add-btn.added:hover {
            border-color: #dc2626;
            color: #dc2626;
        }
    </style>
</head>
<body>
    <!-- === CRYPTO TICKER BAR === -->
    <div id="crypto-overlay" class="crypto-ticker-bar">
        <div class="ticker-container">
            <div class="ticker-content" id="crypto-overlay-items">
                <!-- Coins will be dynamically inserted here by JavaScript -->
            </div>
        </div>
    </div>

    <!-- === ADD TODO MODAL === -->
    <div id="add-todo-modal" class="modal hide">
        <div class="modal-content">
            <button class="close" onclick="document.getElementById('add-todo-modal').style.display='none'">×</button>
            <h2>Todo hinzufügen</h2>
            
            <div class="modal-body">
                <form id="add-todo-form" autocomplete="off">
                <div class="form-group">
                    <label for="todo-title">Aufgabe</label>
                    <input type="text" id="todo-title" name="todo-title" placeholder="Was möchtest du erledigen?" required autocomplete="off">
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="todo-category">Kategorie</label>
                        <select id="todo-category" name="todo-category" required autocomplete="off">
                            <option value="">Kategorie wählen</option>
                            <option value="privat">Privat</option>
                            <option value="uni">Uni</option>
                            <option value="arbeit">Arbeit</option>
                            <option value="projekte">Projekte</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="todo-priority">Priorität</label>
                        <select id="todo-priority" name="todo-priority" required autocomplete="off">
                            <option value="mittel" selected>Normal</option>
                            <option value="wichtig">Wichtig</option>
                            <option value="dringend">Dringend</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="todo-deadline">Deadline</label>
                        <input type="date" id="todo-deadline" name="todo-deadline" autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="todo-time">Uhrzeit</label>
                        <input type="time" id="todo-time" name="todo-time" value="21:00" autocomplete="off">
                    </div>
                </div>
                
                    <div class="form-actions">
                        <button type="button" id="cancel-todo-btn" class="btn secondary">Abbrechen</button>
                        <button type="submit" class="btn">Erstellen</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- === MOBILE QUICK TODO === -->
    <button class="mobile-quick-todo" id="mobile-quick-todo-btn" style="display: none;">
        <i data-lucide="plus"></i>
    </button>

    <!-- === MOBILE TODO MODAL === -->
    <div class="mobile-todo-modal" id="mobile-todo-modal">
        <div class="mobile-todo-form">
            <div class="mobile-todo-header">
                <h3 class="mobile-todo-title">Todo hinzufügen</h3>
                <button class="mobile-close-btn" id="mobile-todo-close">&times;</button>
            </div>
            
            <form id="mobile-todo-form">
                <div class="form-group">
                    <label for="mobile-todo-title">Aufgabe</label>
                    <input type="text" id="mobile-todo-title" placeholder="Was möchtest du erledigen?" required>
                </div>
                
                <div class="form-group">
                    <label for="mobile-todo-category">Kategorie</label>
                    <select id="mobile-todo-category" required>
                        <option value="">Kategorie wählen</option>
                        <option value="privat">Privat</option>
                        <option value="uni">Uni</option>
                        <option value="arbeit">Arbeit</option>
                        <option value="projekte">Projekte</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="mobile-todo-priority">Priorität</label>
                    <select id="mobile-todo-priority" required>
                        <option value="mittel" selected>Normal</option>
                        <option value="wichtig">Wichtig</option>
                        <option value="dringend">Dringend</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="mobile-todo-deadline">Deadline</label>
                    <input type="date" id="mobile-todo-deadline">
                </div>
                
                <div class="form-group">
                    <label for="mobile-todo-time">Uhrzeit</label>
                    <input type="time" id="mobile-todo-time" value="21:00">
                </div>
                
                <div class="form-actions" style="display: flex; gap: 1rem; margin-top: 2rem;">
                    <button type="button" id="mobile-todo-cancel" class="btn secondary" style="flex: 1;">Abbrechen</button>
                    <button type="submit" class="btn" style="flex: 1;">Erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD GOAL MODAL === -->
    <div id="add-goal-modal" class="modal hide">
        <div class="modal-content">
            <button class="close" onclick="document.getElementById('add-goal-modal').style.display='none'">×</button>
            <h2>Ziel hinzufügen</h2>
            
            <div class="modal-body">
                <form id="add-goal-form" autocomplete="off">
                <div class="form-group">
                    <label for="goal-name">Ziel-Name</label>
                    <input type="text" id="goal-name" name="goal-name" placeholder="Was möchtest du erreichen?" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="goal-description">Beschreibung</label>
                    <textarea id="goal-description" placeholder="Detaillierte Beschreibung des Ziels..." required autocomplete="off"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-category">Kategorie</label>
                        <input type="text" id="goal-category" placeholder="z.B. Fitness, Karriere, Finanzen..." required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-deadline">Deadline</label>
                        <input type="date" id="goal-deadline" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-start-value">Startwert mit Einheit</label>
                        <input type="text" id="goal-start-value" placeholder="z.B. 80kg, 1000€, 0 Bücher..." autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-target-value">Zielwert mit Einheit</label>
                        <input type="text" id="goal-target-value" placeholder="z.B. 70kg, 5000€, 12 Bücher..." required autocomplete="off">
                    </div>
                </div>
                
                    <div class="form-actions">
                        <button type="button" id="cancel-goal-btn" class="btn secondary">Abbrechen</button>
                        <button type="submit" class="btn">Erstellen</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- === ADD JOURNAL MODAL === -->
    <div id="add-journal-modal" class="modal hide">
        <div class="modal-content">
            <button class="close" onclick="document.getElementById('add-journal-modal').style.display='none'">×</button>
            <h2>Journal Eintrag</h2>
            
            <div class="modal-body">
                <form id="add-journal-form" autocomplete="off">
                <div class="form-group">
                    <label for="journal-title">Titel</label>
                    <input type="text" id="journal-title" placeholder="Titel für den Eintrag..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="journal-content">Inhalt</label>
                    <textarea id="journal-content" placeholder="Was beschäftigt dich heute...?" required autocomplete="off"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="journal-category">Kategorie</label>
                    <input type="text" id="journal-category" placeholder="z.B. trading, crypto, privat, arbeit..." autocomplete="off">
                    <small style="color: var(--text-muted); font-size: 0.8rem;">Wird automatisch als Filter-Option in Analytics verfügbar</small>
                </div>
                
                    <div class="form-actions">
                        <button type="button" id="cancel-journal-btn" class="btn secondary">Abbrechen</button>
                        <button type="submit" class="btn">Erstellen</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- === INTELLIGENT GLOBAL SEARCH === -->
    <div id="global-search-modal" class="modal hide">
        <div class="modal-content" style="max-width: 700px; width: 95vw;">
            <button class="close" onclick="GlobalSearch.hide()">×</button>
            <h2 style="margin: 0; padding: var(--spacing-lg); padding-right: 3rem; border-bottom: 1px solid var(--border-primary); display: flex; align-items: center; justify-content: space-between;">
                <div style="display: flex; align-items: center;">
                    <i data-lucide="command" style="width: 18px; height: 18px; margin-right: 0.5rem;"></i>
                    <span>Command Center</span>
                </div>
                <div class="search-shortcuts" style="margin-right: 0.5rem;">
                    <span class="search-shortcut">Ctrl+K</span>
                    <span class="search-shortcut">Ctrl+Space</span>
                    <span class="search-shortcut">F3</span>
                    <span class="search-shortcut">Esc</span>
                </div>
            </h2>
            <div class="modal-body" style="padding: var(--spacing-lg);">
                <div class="search-input-container" style="margin-bottom: var(--spacing-lg);">
                    <i data-lucide="search" class="search-icon"></i>
                    <input type="text" id="global-search-input" 
                           placeholder="Search everything or try /add, /new, @todos, #today..." 
                           spellcheck="false"
                           autocomplete="off">
                    <div class="search-filters">
                        <button class="filter-btn active" data-filter="all">All</button>
                        <button class="filter-btn" data-filter="todos">Todos</button>
                        <button class="filter-btn" data-filter="goals">Goals</button>
                        <button class="filter-btn" data-filter="visions">Visions</button>
                        <button class="filter-btn" data-filter="recent">Recent</button>
                    </div>
                </div>
                
                <div id="search-results" class="search-results-container">
                    <div id="search-suggestions" class="search-suggestions">
                        <div class="suggestion-group">
                            <div class="suggestion-header">Quick Actions</div>
                            <div class="suggestion-item" data-command="/add">
                                <i data-lucide="plus"></i>
                                <span><strong>/add</strong> Create new todo</span>
                            </div>
                            <div class="suggestion-item" data-command="/new">
                                <i data-lucide="target"></i>
                                <span><strong>/new</strong> Create new goal</span>
                            </div>
                            <div class="suggestion-item" data-command="/timer">
                                <i data-lucide="timer"></i>
                                <span><strong>/timer</strong> Start pomodoro</span>
                            </div>
                        </div>
                        <div class="suggestion-group">
                            <div class="suggestion-header">Smart Filters</div>
                            <div class="suggestion-item" data-command="@todos">
                                <i data-lucide="check-circle"></i>
                                <span><strong>@todos</strong> Search only todos</span>
                            </div>
                            <div class="suggestion-item" data-command="#today">
                                <i data-lucide="calendar"></i>
                                <span><strong>#today</strong> Today's items</span>
                            </div>
                            <div class="suggestion-item" data-command="#overdue">
                                <i data-lucide="alert-circle"></i>
                                <span><strong>#overdue</strong> Overdue items</span>
                            </div>
                        </div>
                    </div>
                    <div id="search-results-list" class="search-results-list" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- === ADD TERMIN MODAL === -->
    <div id="add-termin-modal" class="modal hide">
        <div class="modal-content">
            <button class="close" onclick="document.getElementById('add-termin-modal').style.display='none'">×</button>
            <h2>Termin</h2>
            
            <div class="modal-body">
                <form id="add-termin-form" autocomplete="off">
                <div class="form-group">
                    <label for="termin-title">Titel</label>
                    <input type="text" id="termin-title" placeholder="z.B. Zahnarzt Termin..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="termin-description">Beschreibung</label>
                    <textarea id="termin-description" placeholder="Weitere Details zum Termin..." required autocomplete="off"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="termin-date">Datum</label>
                        <input type="date" id="termin-date" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="termin-time">Uhrzeit (optional)</label>
                        <input type="time" id="termin-time" autocomplete="off">
                    </div>
                </div>
                
                    <div class="form-actions">
                        <button type="button" id="cancel-termin-btn" class="btn secondary">Abbrechen</button>
                        <button type="submit" class="btn">Erstellen</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- === EDIT GOAL VALUE MODAL === -->
    <div id="edit-goal-value-modal" class="modal hide">
        <div class="modal-content">
            <button class="close" onclick="document.getElementById('edit-goal-value-modal').style.display='none'">×</button>
            <h2 id="edit-goal-modal-title">Fortschritt</h2>
            
            <div class="modal-body">
            
            <div id="edit-goal-current-status" style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; font-size: 0.9rem; color: #666;">
                <!-- Current goal status will be inserted here -->
            </div>
            
            <form id="edit-goal-value-form" autocomplete="off">
                <div class="form-group">
                    <label for="new-goal-value">Neuer aktueller Wert</label>
                    <input type="number" id="new-goal-value" name="new-goal-value" step="0.01" required autocomplete="off">
                </div>
                
                    <div class="form-actions">
                        <button type="button" id="cancel-edit-goal-value-btn" class="btn secondary">Abbrechen</button>
                        <button type="submit" class="btn">Aktualisieren</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- === AUTH SCREEN === -->
    <div id="auth-screen" class="auth-screen">
        <div class="auth-container">
            <div class="auth-header">
                <h2>DASHBOARD</h2>
            </div>
            
            <form id="login-form" autocomplete="on">
                <div class="form-group">
                    <label for="login-email">Email</label>
                    <input type="email" id="login-email" name="email" placeholder="your@email.com" required autocomplete="email">
                </div>
                <div class="form-group">
                    <label for="login-password">Password</label>
                    <input type="password" id="login-password" name="password" placeholder="Your password" required autocomplete="current-password">
                </div>
                <button id="login-btn" type="submit" class="auth-btn">Login</button>
                <div id="login-error" class="auth-error"></div>
            </form>
        </div>
    </div>

    <!-- === STICKY NAVIGATION === -->
    <nav class="sticky-nav">
        <div class="nav-container">
            <button class="nav-tab active" data-tab="tab-home">Home</button>
            <button class="nav-tab" data-tab="tab-todos">ToDos</button>
            <button class="nav-tab" data-tab="tab-ziele">Ziele</button>
            <button class="nav-tab" data-tab="tab-journal">Journal</button>
            <button class="nav-tab" data-tab="tab-trading">Trading</button>
            <button class="nav-tab" data-tab="tab-analytics">Analytics</button>
            <button class="nav-tab" data-tab="tab-ressourcen">Ressourcen</button>
            <button class="nav-tab" data-tab="tab-vision">Vision</button>
            <button class="nav-tab" data-tab="tab-wiki">Wiki</button>
            <div class="nav-actions">
                <!-- Settings and Logout moved to Quick Actions Bar -->
            </div>
        </div>
    </nav>

    <div class="main-content">
        <!-- === HOME TAB === -->
        <section id="tab-home" class="tab-section active">
            <!-- Streak Kacheln -->
            <section class="streak-overview" style="margin-bottom: 4rem;">
                <div class="streak-grid">
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Morgenroutine</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Abendroutine</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Todos Erledigt</div>
                    </div>
                    <div class="streak-tile" onclick="window.SimpleCounters.updateAllCounters(); this.classList.add('updating'); setTimeout(() => this.classList.remove('updating'), 1000)">
                        <div class="streak-number">0.00</div>
                        <div class="streak-label">SOL Balance</div>
                        <div class="streak-date">Live</div>
                    </div>
                </div>
            </section>

            <!-- Daily Sport Question (dynamically loaded) -->
            <section id="daily-sport-container" class="daily-sport-section hidden">
                <!-- Content loaded dynamically by SportManager -->
            </section>

            <!-- Routinen Section -->
            <div class="routine-grid" style="margin-bottom: 4rem;">
                <div id="morning-routine" class="routine-section">
                    <h2>Morgenroutine</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="wasser-kreatin">
                            <label for="wasser-kreatin">Wasser und Kreatin</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="bbue-sport">
                            <label for="bbue-sport">BBÜ und Sport</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="tag-planen">
                            <label for="tag-planen">Tag planen</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="todos-checken">
                            <label for="todos-checken">Todos checken</label>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <div id="evening-routine" class="routine-section">
                    <h2>Abendroutine</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="journal-reflexion">
                            <label for="journal-reflexion">Tag reflektieren per Journal</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="lesen-lessons">
                            <label for="lesen-lessons">Lesen und Lessons nachhalten</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="trades-evaluieren">
                            <label for="trades-evaluieren">Trades evaluieren und Lessons nachhalten</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="naechsten-tag-planen">
                            <label for="naechsten-tag-planen">Nächsten Tag planen</label>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Heutige Aufgaben -->
            <section style="margin-bottom: 4rem;">
                <div class="todo-block home-todos">
                    <div class="todo-block-header">
                        <h3>
                            <i data-lucide="calendar-check" style="width: 18px; height: 18px;"></i>
                            Heute
                        </h3>
                    </div>
                    <div class="todo-links" id="home-todos">
                        <!-- Todos will be loaded from database -->
                    </div>
                </div>
            </section>

            <!-- Anstehende Termine -->
            <section style="margin-bottom: 4rem;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 2rem; margin-bottom: 1.5rem;">
                    <h2 style="font-size: 1.2rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.1em; margin: 0;">Anstehende Termine</h2>
                    <button id="add-termin-btn" class="add-btn">
                        <i data-lucide="plus"></i>
                    </button>
                </div>
                <div class="grid-3" id="termine-container">
                    <!-- Termine will be loaded from TerminManager -->
                </div>
            </section>

            <!-- Motivational Quote Widget -->
            <section class="quote-widget">
                <div class="quote-container">
                    <div class="quote-icon">
                        <i data-lucide="quote" style="width: 20px; height: 20px;"></i>
                    </div>
                    <div class="quote-content">
                        <div class="quote-text" id="daily-quote">
                            "The way to get started is to quit talking and begin doing."
                        </div>
                        <div class="quote-author" id="quote-author">Walt Disney</div>
                    </div>
                    <button class="quote-refresh-btn" id="refresh-quote-btn" title="New Quote">
                        <i data-lucide="refresh-cw" style="width: 14px; height: 14px;"></i>
                    </button>
                </div>
            </section>
        </section>

        <!-- === TODOS TAB === -->
        <section id="tab-todos" class="tab-section">
            
            <div class="page-header">
                <button id="add-todo-btn" class="add-btn">
                    <i data-lucide="plus"></i>
                </button>
            </div>

            <!-- === BRAIN DUMP CONTAINER === -->
            <div id="brain-dump-container" class="brain-dump-container">
                <div class="brain-dump-header">
                    <div class="brain-dump-title">
                        <i data-lucide="inbox" style="width: 20px; height: 20px;"></i>
                        <span>Brain Dumps</span>
                        <div class="brain-dump-badge" id="brain-dump-badge">0</div>
                    </div>
                    <div class="brain-dump-actions">
                        <button class="brain-dump-expand" id="brain-dump-expand" title="Expand/Collapse">
                            <i data-lucide="chevron-down" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                </div>
                
                <div class="brain-dump-content" id="brain-dump-content">
                    
                    <div class="brain-dump-list" id="brain-dump-list">
                        <!-- Brain dumps will be loaded here -->
                    </div>
                    
                    <div class="brain-dump-bulk-actions">
                        <button class="btn-secondary" id="brain-dump-select-all">Alle auswählen</button>
                        <button class="btn-primary" id="brain-dump-distribute">Verteilen</button>
                        <button class="btn-danger" id="brain-dump-clear-all">Alle löschen</button>
                    </div>
                </div>
            </div>

            <div class="todos-grid">
                <!-- PRIVAT BLOCK -->
                <div class="todo-block">
                    <div class="todo-block-header">
                        <h3>
                            <i data-lucide="home" style="width: 18px; height: 18px;"></i>
                            Privat
                        </h3>
                    </div>
                    <div class="todo-links" id="todo-privat">
                        <div class="todo-empty-state">
                            <p>Personal</p>
                            <small>Focus on what matters most</small>
                        </div>
                        <!-- Private todos will be loaded here -->
                    </div>
                </div>

                <!-- UNI BLOCK -->
                <div class="todo-block">
                    <div class="todo-block-header">
                        <h3>
                            <i data-lucide="graduation-cap" style="width: 18px; height: 18px;"></i>
                            Uni
                        </h3>
                    </div>
                    <div class="todo-links" id="todo-uni">
                        <div class="todo-empty-state">
                            <p>Education</p>
                            <small>Build your future</small>
                        </div>
                        <!-- Uni todos will be loaded here -->
                    </div>
                </div>

                <!-- ARBEIT BLOCK -->
                <div class="todo-block">
                    <div class="todo-block-header">
                        <h3>
                            <i data-lucide="briefcase" style="width: 18px; height: 18px;"></i>
                            Arbeit
                        </h3>
                    </div>
                    <div class="todo-links" id="todo-arbeit">
                        <div class="todo-empty-state">
                            <p>Professional</p>
                            <small>Execute with precision</small>
                        </div>
                        <!-- Work todos will be loaded here -->
                    </div>
                </div>

                <!-- PROJEKTE BLOCK -->
                <div class="todo-block">
                    <div class="todo-block-header">
                        <h3>
                            <i data-lucide="trending-up" style="width: 18px; height: 18px;"></i>
                            Projekte
                        </h3>
                    </div>
                    <div class="todo-links" id="todo-projekte">
                        <div class="todo-empty-state">
                            <p>Projects</p>
                            <small>Transform ideas into reality</small>
                        </div>
                        <!-- Project todos will be loaded here -->
                    </div>
                </div>
            </div>
        </section>

        <!-- === ZIELE TAB === -->
        <section id="tab-ziele" class="tab-section">
            
            <div class="page-header">
                <button id="add-goal-btn" class="add-btn">
                    <i data-lucide="plus"></i>
                </button>
            </div>

            <!-- ZIELE CONTENT -->
            <div class="ziele-content" id="goals-list">
                <!-- Ziele will be loaded from database -->
            </div>

        </section>

        <!-- === JOURNAL TAB === -->
        <section id="tab-journal" class="tab-section">
            
            <div class="page-header">
                <button id="add-journal-btn" class="add-btn">
                    <i data-lucide="plus"></i>
                </button>
            </div>

            <!-- Journal Content -->
            <div class="wiki-content" id="journal-entries">
                <!-- Journal entries will be loaded here --></div>

        </section>

        <!-- === TRADING TAB === -->
        <section id="tab-trading" class="tab-section">
            <div class="page-header">
                <button id="add-trade-btn" class="add-btn" onclick="addNewTrade()">
                    <i data-lucide="plus"></i>
                </button>
            </div>

            <!-- === STICKY CHEATSHEET === -->
            <div id="trading-cheatsheet" style="position: sticky; top: 10px; z-index: 100; margin-bottom: 20px;">
                <div style="background: #ffffff; border: 1px solid #e0e0e0; padding: 15px; color: #000000; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div style="font-weight: bold; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">TRADING CHECKLISTE</div>
                        <button id="toggle-cheatsheet" style="background: #f5f5f5; border: 1px solid #ddd; color: #666; width: 24px; height: 24px; cursor: pointer; font-size: 12px; font-weight: bold;">−</button>
                    </div>
                    
                    <div id="cheatsheet-content" contenteditable="true" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-size: 13px; line-height: 1.6; border: 1px solid #e8e8e8; padding: 15px; background: #fafafa; min-height: 120px;">
<strong>🔍 RESEARCH CHECKLIST</strong>
□ Developer Team überprüfen (Doxxed/Anonym?)
□ Webseite & Roadmap analysieren
□ Community Aktivität & Sentiment
□ Volume auf Echtheit prüfen (Fake Bot Volume?)
□ Social Media Aktivität der Devs
□ GitHub Activity & Code Quality

<strong>📈 ENTRY REGELN</strong>
□ NIEMALS auf grünen Kerzen kaufen
□ Nach Dump/Korrektur einsteigen (-20%+)
□ Nichts forcieren - auf Setup warten
□ Max 2-3% Portfolio pro Position
□ Patience bei Überzeugung zeigen
□ Nur bei klarem Support Level

<strong>💰 EXIT & RISK MANAGEMENT</strong>
□ Sell Orders direkt nach Kauf setzen
□ Bei 2x → Initials komplett raus
□ Bei 5x → 50% Gewinnmitnahme
□ Übertriebene Einsätze vermeiden
□ Stop Loss bei -50% konsequent
□ Emotions-Trading vermeiden
                    </div>
                </div>
            </div>
            
            <!-- KOMPLETT NEUE TRADING TABLE -->
            <div style="border: 1px solid #ddd; margin: 20px 0;">
                <!-- Header -->
                <div style="display: grid; grid-template-columns: 25% 20% 20% 35%; background: #f5f5f5; border-bottom: 2px solid #ddd;">
                    <div style="padding: 12px; font-weight: bold; border-right: 1px solid #ddd;">Trade Name</div>
                    <div style="padding: 12px; font-weight: bold; border-right: 1px solid #ddd; text-align: center;">Einsatz</div>
                    <div style="padding: 12px; font-weight: bold; border-right: 1px solid #ddd; text-align: center;">Ertrag</div>
                    <div style="padding: 12px; font-weight: bold;">Notizen/Learning</div>
                </div>
                <!-- Body -->
                <div id="trades-container">
                    <div style="padding: 2rem; text-align: center; color: #666; border-bottom: 1px solid #eee;">
                        Noch keine Trades erfasst. Klicke auf + um deinen ersten Trade hinzuzufügen.
                    </div>
                </div>
            </div>

        </section>

        <!-- === CLOSE TRADE MODAL === -->
        <div id="close-trade-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Close Trade</h3>
                    <button class="modal-close" id="close-trade-modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="trade-info">
                        <div class="info-row">
                            <span class="info-label">Token:</span>
                            <span class="info-value" id="close-trade-token">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Entry Amount:</span>
                            <span class="info-value" id="close-trade-entry-amount">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Entry McAP:</span>
                            <span class="info-value" id="close-trade-entry-mcap">-</span>
                        </div>
                    </div>
                    
                    <div class="close-trade-form">
                        <div class="form-group">
                            <label for="close-exit-mcap">Exit Market Cap</label>
                            <div class="mcap-input-group">
                                <input type="number" id="close-exit-mcap" placeholder="2.5" step="0.1" autocomplete="off">
                                <div class="mcap-buttons">
                                    <button type="button" class="mcap-btn" data-multiplier="K">K</button>
                                    <button type="button" class="mcap-btn" data-multiplier="M">M</button>
                                    <button type="button" class="mcap-btn active" data-multiplier="B">B</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="close-take-profit">SOL zu verkaufen</label>
                            <div class="sol-input-group">
                                <input type="number" id="close-take-profit" placeholder="2.0" step="0.001" autocomplete="off">
                                <div class="sol-sell-buttons">
                                    <button type="button" class="sol-percent-btn" data-percent="initials">Initials</button>
                                    <button type="button" class="sol-percent-btn" data-percent="25">25%</button>
                                    <button type="button" class="sol-percent-btn" data-percent="50">50%</button>
                                    <button type="button" class="sol-percent-btn" data-percent="75">75%</button>
                                    <button type="button" class="sol-percent-btn" data-percent="100">100%</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="close-keep-position">SOL verbleibend</label>
                            <input type="number" id="close-keep-position" placeholder="2.0" step="0.001" autocomplete="off" readonly style="background: #f8f9fa;">
                        </div>
                        
                        <div class="form-group">
                            <label for="close-trade-learnings">Learnings & Notes</label>
                            <textarea id="close-trade-learnings" placeholder="Was hast du gelernt? Warum hast du geschlossen? Fehler, Erfolge, Strategien..." rows="4" autocomplete="off" style="width: 100%; padding: 0.75rem; border: 1px solid #e0e0e0; border-radius: 4px; font-family: inherit; resize: vertical; min-height: 100px;"></textarea>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn secondary" id="close-trade-cancel">Cancel</button>
                    <button class="btn" id="close-trade-confirm">Close Trade</button>
                </div>
            </div>
        </div>


        <!-- === VIEW TRADE DETAILS MODAL === -->
        <div id="view-trade-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Trade Details</h3>
                    <button class="modal-close" id="view-trade-modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="trade-details-info">
                        <div class="details-section">
                            <h4>Trade Information</h4>
                            <div class="info-grid">
                                <div class="info-row">
                                    <span class="info-label">Token:</span>
                                    <span class="info-value" id="detail-token">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">SOL Amount:</span>
                                    <span class="info-value" id="detail-sol-amount">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Entry McAP:</span>
                                    <span class="info-value" id="detail-entry-mcap">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Exit McAP:</span>
                                    <span class="info-value" id="detail-exit-mcap">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Final P&L:</span>
                                    <span class="info-value" id="detail-pnl">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Entry Date:</span>
                                    <span class="info-value" id="detail-entry-date">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Exit Date:</span>
                                    <span class="info-value" id="detail-exit-date">-</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="details-section">
                            <h4>Entry Notes</h4>
                            <div class="notes-content" id="detail-entry-notes">-</div>
                        </div>
                        
                        <div class="details-section">
                            <h4>Close Learnings</h4>
                            <div class="learnings-content" id="detail-close-learnings">-</div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn secondary" id="close-details-modal">Close</button>
                </div>
            </div>
        </div>
        </section>

        <!-- === ANALYTICS TAB === -->
        <section id="tab-analytics" class="tab-section">
            
            <div class="page-header">
                <button id="chart-easter-egg-btn" class="add-btn">📊</button>
            </div>
            
            <div class="analytics-container">
                
                <!-- Analytics Charts Grid -->
                <div class="analytics-charts-grid">
                    <!-- SOL Balance Chart -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>SOL Balance History</h3>
                            <div class="chart-controls">
                                <div class="time-period-buttons">
                                    <button class="period-btn active" data-period="week">Woche</button>
                                    <button class="period-btn" data-period="month">Monat</button>
                                    <button class="period-btn" data-period="quarter">Quartal</button>
                                    <button class="period-btn" data-period="year">Jahr</button>
                                </div>
                                <div class="chart-info">
                                    <span id="current-sol-balance">Loading...</span>
                                </div>
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="solBalanceChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Todo Heatmap -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>Todo Activity</h3>
                            <div class="heatmap-info">
                                <span id="heatmap-stats">Loading...</span>
                            </div>
                        </div>
                        <div class="heatmap-container">
                            <div class="heatmap-months" id="heatmap-months"></div>
                            <div class="heatmap-grid" id="heatmap-grid"></div>
                            <div class="heatmap-legend">
                                <span>Less</span>
                                <div class="legend-colors">
                                    <div class="legend-square level-0" title="0 todos"></div>
                                    <div class="legend-square level-1" title="1-2 todos"></div>
                                    <div class="legend-square level-2" title="3-5 todos"></div>
                                    <div class="legend-square level-3" title="6-10 todos"></div>
                                    <div class="legend-square level-4" title="11+ todos"></div>
                                </div>
                                <span>More</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Performance Heatmap -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>Daily Performance</h3>
                            <div class="heatmap-info">
                                <span id="performance-heatmap-stats">Loading...</span>
                            </div>
                        </div>
                        <div class="heatmap-container">
                            <div class="heatmap-months" id="performance-heatmap-months"></div>
                            <div class="heatmap-grid" id="performance-heatmap-grid"></div>
                            <div class="heatmap-legend">
                                <span>Loss</span>
                                <div class="legend-colors">
                                    <div class="legend-square performance-loss" title="Loss vs previous day"></div>
                                    <div class="legend-square performance-neutral" title="Same as previous day"></div>
                                    <div class="legend-square performance-gain" title="Gain vs previous day"></div>
                                </div>
                                <span>Gain</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Morning Routine Heatmap -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>Morning Routine</h3>
                            <div class="heatmap-info">
                                <span id="morning-routine-heatmap-stats">Loading...</span>
                            </div>
                        </div>
                        <div class="heatmap-container">
                            <div class="heatmap-months" id="morning-routine-heatmap-months"></div>
                            <div class="heatmap-grid" id="morning-routine-heatmap-grid"></div>
                            <div class="heatmap-legend">
                                <span>Incomplete</span>
                                <div class="legend-colors">
                                    <div class="legend-square level-0" title="Not completed"></div>
                                    <div class="legend-square level-4" title="Completed"></div>
                                </div>
                                <span>Complete</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Evening Routine Heatmap -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>Evening Routine</h3>
                            <div class="heatmap-info">
                                <span id="evening-routine-heatmap-stats">Loading...</span>
                            </div>
                        </div>
                        <div class="heatmap-container">
                            <div class="heatmap-months" id="evening-routine-heatmap-months"></div>
                            <div class="heatmap-grid" id="evening-routine-heatmap-grid"></div>
                            <div class="heatmap-legend">
                                <span>Incomplete</span>
                                <div class="legend-colors">
                                    <div class="legend-square level-0" title="Not completed"></div>
                                    <div class="legend-square level-4" title="Completed"></div>
                                </div>
                                <span>Complete</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Sport Heatmap -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>Sport Activity</h3>
                            <div class="heatmap-info">
                                <span id="sport-heatmap-stats">Loading...</span>
                            </div>
                        </div>
                        <div class="heatmap-container">
                            <div class="heatmap-months" id="sport-heatmap-months"></div>
                            <div class="heatmap-grid" id="sport-heatmap-grid"></div>
                            <div class="heatmap-legend">
                                <span>No Sport</span>
                                <div class="legend-colors">
                                    <div class="legend-square level-0" title="No sport"></div>
                                    <div class="legend-square level-4" title="Sport completed"></div>
                                </div>
                                <span>Sport Done</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Journal Tag Analytics Section -->
                <div class="analytics-charts-grid">
                    <!-- Tag Frequency Chart -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>Journal Tag Häufigkeit</h3>
                            <div class="chart-controls">
                                <div class="time-period-buttons">
                                    <button class="period-btn active" data-period="week" onclick="window.JournalTagAnalytics?.updatePeriod('week')">Woche</button>
                                    <button class="period-btn" data-period="month" onclick="window.JournalTagAnalytics?.updatePeriod('month')">Monat</button>
                                    <button class="period-btn" data-period="quarter" onclick="window.JournalTagAnalytics?.updatePeriod('quarter')">Quartal</button>
                                </div>
                                <div class="category-filter-buttons">
                                    <!-- Dynamic buttons will be loaded here -->
                                </div>
                                <div class="chart-info">
                                    <span id="tag-stats">Loading...</span>
                                </div>
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="tagFrequencyChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Tag Correlations -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>Tag Korrelationen</h3>
                            <div class="chart-info">
                                <span id="correlation-stats">Welche Tags treten zusammen auf</span>
                            </div>
                        </div>
                        <div class="chart-container">
                            <div id="tag-correlations-list" class="correlations-list">
                                <!-- Tag correlations will be loaded here -->
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </section>

        <!-- === RESSOURCEN TAB === -->
        <section id="tab-ressourcen" class="tab-section">
            
            <div class="page-header">
                <button id="add-resource-btn" class="add-btn">
                    <i data-lucide="plus"></i>
                </button>
            </div>

            <div class="resources-grid">
                <!-- PRIVAT BLOCK -->
                <div class="resource-block">
                    <div class="resource-block-header">
                        <h3>
                            <i data-lucide="home" style="width: 18px; height: 18px;"></i>
                            Privat
                        </h3>
                    </div>
                    <div class="resource-links" id="resource-privat">
                        <!-- Private resources will be loaded here -->
                    </div>
                </div>

                <!-- CRYPTO BLOCK -->
                <div class="resource-block">
                    <div class="resource-block-header">
                        <h3>
                            <i data-lucide="trending-up" style="width: 18px; height: 18px;"></i>
                            Crypto
                        </h3>
                    </div>
                    <div class="resource-links" id="resource-crypto">
                        <!-- Crypto resources will be loaded here -->
                    </div>
                </div>

                <!-- ARBEIT BLOCK -->
                <div class="resource-block">
                    <div class="resource-block-header">
                        <h3>
                            <i data-lucide="briefcase" style="width: 18px; height: 18px;"></i>
                            Arbeit
                        </h3>
                    </div>
                    <div class="resource-links" id="resource-arbeit">
                        <!-- Work resources will be loaded here -->
                    </div>
                </div>

                <!-- STUDIUM BLOCK -->
                <div class="resource-block">
                    <div class="resource-block-header">
                        <h3>
                            <i data-lucide="book-open" style="width: 18px; height: 18px;"></i>
                            Studium
                        </h3>
                    </div>
                    <div class="resource-links" id="resource-uni">
                        <!-- University resources will be loaded here -->
                    </div>
                </div>
            </div> <!-- end resources-grid -->

            <!-- SEPARATOR LINE -->
            <hr class="resources-separator">
            
            <!-- TEXT SNIPPETS SECTION -->
            <div class="page-header">
                <button id="add-textsnippet-btn" class="add-btn">
                    <i data-lucide="plus"></i>
                </button>
            </div>
            
            <div class="resource-block">
                <div class="resource-links" id="resource-textsnippets">
                    <!-- Text snippets will be loaded here -->
                </div>
            </div>

        </section>

        <!-- === SETTINGS TAB === -->
        <section id="tab-settings" class="tab-section">
            
            <div class="settings-container">
                <div class="setting-group">
                    <h3>Routinen</h3>
                    <div class="setting-item">
                        <label for="routine-reset-time">Routine Reset Zeit:</label>
                        <input type="time" id="routine-reset-time" value="06:00">
                        <span class="setting-description">Zeit, zu der die Routinen täglich zurückgesetzt werden</span>
                    </div>
                    <button id="save-routine-settings" class="btn">Speichern</button>
                </div>
                
                <div class="setting-group">
                    <h3>Analytics</h3>
                    <div class="setting-item">
                        <label for="balance-tracking-time">SOL Balance Tracking Zeit:</label>
                        <input type="time" id="balance-tracking-time" value="06:00">
                        <span class="setting-description">Zeit, zu der täglich die SOL Balance für den Chart aufgezeichnet wird</span>
                    </div>
                    <button id="save-analytics-settings" class="btn">Speichern</button>
                </div>
                
                <div class="setting-group">
                    <h3>Pomodoro Timer</h3>
                    <div class="setting-item">
                        <label for="pomodoro-duration">Timer Dauer (Minuten):</label>
                        <div class="pomodoro-duration-input">
                            <input type="number" id="pomodoro-duration" min="5" max="60" value="25" step="1">
                            <span class="duration-unit">min</span>
                        </div>
                        <span class="setting-description">Dauer eines Pomodoro-Intervalls in Minuten</span>
                    </div>
                    <button id="save-pomodoro-settings" class="btn">Speichern</button>
                </div>
                
                <div class="setting-group">
                    <h3>Sport Container</h3>
                    <div class="setting-item">
                        <label for="sport-reset-time">Sport Reset Zeit:</label>
                        <input type="time" id="sport-reset-time" value="06:00">
                        <span class="setting-description">Zeit, zu der die Sport-Frage täglich zurückgesetzt wird</span>
                    </div>
                    <div class="setting-item">
                        <label for="sport-visibility">Container Sichtbarkeit:</label>
                        <div class="checkbox-item">
                            <input type="checkbox" id="sport-visibility" checked>
                            <label for="sport-visibility">Sport Container anzeigen</label>
                        </div>
                        <span class="setting-description">Sport Container auf dem Dashboard anzeigen/verstecken</span>
                    </div>
                    <button id="save-sport-settings" class="btn">Speichern</button>
                </div>
                
                <div class="setting-group">
                    <h3>Kryptowährung Ticker</h3>
                    <div class="setting-item">
                        <div class="crypto-management">
                            <div class="crypto-search-container">
                                <input type="text" id="settings-crypto-search" placeholder="Coin suchen..." autocomplete="off">
                            </div>
                            <div class="crypto-coins-grid" id="settings-crypto-coins">
                                <!-- Will be populated with coins -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="setting-group">
                    <h3>Backup & Export</h3>
                    <div class="setting-item">
                        <label>Daten exportieren:</label>
                        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                            <button id="export-all-data" class="btn">Alle Daten exportieren</button>
                            <span id="backup-stats" style="color: var(--text-secondary); font-size: 0.85rem;"></span>
                        </div>
                        <span class="setting-description">Exportiere alle deine Daten (Journal, Routinen, Trading Rules, etc.) als JSON-Datei</span>
                    </div>
                    <div class="setting-item">
                        <label>Daten importieren:</label>
                        <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                            <input type="file" id="import-file" accept=".json" style="display: none;">
                            <button id="select-import-file" class="btn">Datei auswählen</button>
                            <button id="import-data" class="btn" disabled>Importieren</button>
                        </div>
                        <span class="setting-description">⚠️ Vorsicht: Import überschreibt bestehende Daten. Erst Backup erstellen!</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- === TRADING RULES TAB === -->
        <section id="tab-trading-rules" class="tab-section">
            <div class="page-header">
                <button id="add-trading-rule-btn" class="add-btn">
                    <i data-lucide="plus"></i>
                </button>
            </div>

            <div class="resources-grid">
                
                <!-- Risk Management Block -->
                <div class="resource-block" data-category="Risk Management">
                    <div class="resource-block-header">
                        <h3><i data-lucide="shield" style="width: 16px; height: 16px;"></i> Risk Management</h3>
                    </div>
                    <div class="resource-links">
                        <!-- Trading rules will be loaded here -->
                    </div>
                </div>
                
                <!-- Entry Rules Block -->
                <div class="resource-block" data-category="Entry Rules">
                    <div class="resource-block-header">
                        <h3><i data-lucide="trending-up" style="width: 16px; height: 16px;"></i> Entry Rules</h3>
                    </div>
                    <div class="resource-links">
                        <!-- Trading rules will be loaded here -->
                    </div>
                </div>
                
                <!-- Exit Rules Block -->
                <div class="resource-block" data-category="Exit Rules">
                    <div class="resource-block-header">
                        <h3><i data-lucide="trending-down" style="width: 16px; height: 16px;"></i> Exit Rules</h3>
                    </div>
                    <div class="resource-links">
                        <!-- Trading rules will be loaded here -->
                    </div>
                </div>
                
                <!-- Psychology & Discipline Block -->
                <div class="resource-block" data-category="Psychology & Discipline">
                    <div class="resource-block-header">
                        <h3><i data-lucide="brain" style="width: 16px; height: 16px;"></i> Psychology & Discipline</h3>
                    </div>
                    <div class="resource-links">
                        <!-- Trading rules will be loaded here -->
                    </div>
                </div>
                
                <!-- Time Management Block -->
                <div class="resource-block" data-category="Time Management">
                    <div class="resource-block-header">
                        <h3><i data-lucide="clock" style="width: 16px; height: 16px;"></i> Time Management</h3>
                    </div>
                    <div class="resource-links">
                        <!-- Trading rules will be loaded here -->
                    </div>
                </div>
                
            </div>
        </section>

        <!-- Trading Rules Context Menu -->
        <div id="trading-rules-context-menu" class="trading-rules-context-menu">
            <div class="trading-rules-context-menu-item delete" onclick="TradingRulesManager.deleteRuleFromMenu()">
                <i data-lucide="trash-2" style="width: 16px; height: 16px;"></i>
                Löschen
            </div>
        </div>

        <!-- Vision Context Menu -->
        <div id="vision-context-menu" class="vision-context-menu">
            <div class="vision-context-menu-item delete" onclick="VisionManager.deleteVisionFromMenu()">
                <i data-lucide="trash-2" style="width: 16px; height: 16px;"></i>
                Löschen
            </div>
        </div>

        <!-- === WIKI TAB === -->
        <section id="tab-wiki" class="tab-section">
            
            <div class="page-header">
                <button id="add-wiki-btn" class="add-btn">
                    <i data-lucide="plus"></i>
                </button>
            </div>

            <!-- Wiki Content -->
            <div class="wiki-content" id="wiki-entries">
                <!-- Wiki entries will be loaded here -->
            </div>
        </section>

        <!-- === VISION TAB === -->
        <section id="tab-vision" class="tab-section">
            
            <div class="page-header">
                <button id="add-vision-btn" class="add-btn">
                    <i data-lucide="plus"></i>
                </button>
            </div>

            <!-- Vision Content -->
            <div class="vision-board" id="vision-entries">
                <!-- Vision cards will be loaded here -->
            </div>
        </section>

    </div>

    <!-- Add Resource Modal -->
    <div id="add-resource-modal" class="modal hide">
        <div class="modal-content">
            <button class="close" onclick="ResourceManager.hideAddResourceModal()">×</button>
            <h2>Resource</h2>
            
            <div class="modal-body">
                <form id="add-resource-form">
                <div class="form-group">
                    <label for="resource-title">Title *</label>
                    <input type="text" id="resource-title" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="resource-category">Category *</label>
                    <select id="resource-category" required autocomplete="off">
                        <option value="">Choose category...</option>
                        <option value="Privat">Privat</option>
                        <option value="Arbeit">Arbeit</option>
                        <option value="Uni">Uni</option>
                        <option value="Crypto">Crypto</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="resource-url">URL *</label>
                    <input type="url" id="resource-url" placeholder="https://example.com" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="resource-icon">Icon (optional)</label>
                    <input type="text" id="resource-icon" placeholder="Click icon below or type lucide icon name" readonly>
                    <div class="icon-palette">
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('mail')"><i data-lucide="mail" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('briefcase')"><i data-lucide="briefcase" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('book')"><i data-lucide="book" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('home')"><i data-lucide="home" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('message-circle')"><i data-lucide="message-circle" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('building')"><i data-lucide="building" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('wrench')"><i data-lucide="wrench" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('bar-chart-3')"><i data-lucide="bar-chart-3" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('file-text')"><i data-lucide="file-text" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('users')"><i data-lucide="users" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('globe')"><i data-lucide="globe" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('dollar-sign')"><i data-lucide="dollar-sign" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('target')"><i data-lucide="target" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('zap')"><i data-lucide="zap" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('lock')"><i data-lucide="lock" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('link')"><i data-lucide="link" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('rocket')"><i data-lucide="rocket" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('palette')"><i data-lucide="palette" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('activity')"><i data-lucide="activity" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('bot')"><i data-lucide="bot" style="width: 16px; height: 16px;"></i></button>
                    </div>
                    <small style="margin-top: 0.5rem; display: block;">Click an icon above or make input editable to type manually</small>
                    <button type="button" class="btn-link" onclick="ResourceManager.toggleIconInput()" style="font-size: 0.8rem; margin-top: 0.25rem;">Enable manual typing</button>
                </div>
                
                    <div class="form-actions">
                        <button type="button" class="btn secondary" onclick="ResourceManager.hideAddResourceModal()">Abbrechen</button>
                        <button type="submit" class="btn">Erstellen</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Add Trading Rule Modal -->
    <div id="add-trading-rule-modal" class="modal hide">
        <div class="modal-content">
            <button class="close" onclick="TradingRulesManager.hideAddRuleModal()">×</button>
            <h2>Trading Rule</h2>
            
            <div class="modal-body">
                <form id="add-trading-rule-form">
                    <div class="form-group">
                        <label for="trading-rule-title">Rule *</label>
                        <input type="text" id="trading-rule-title" required autocomplete="off" placeholder="z.B. Immer Stop-Loss setzen">
                    </div>
                    
                    <div class="form-group">
                        <label for="trading-rule-category">Category *</label>
                        <select id="trading-rule-category" required autocomplete="off">
                            <option value="">Choose category...</option>
                            <option value="Risk Management">Risk Management</option>
                            <option value="Entry Rules">Entry Rules</option>
                            <option value="Exit Rules">Exit Rules</option>
                            <option value="Psychology & Discipline">Psychology & Discipline</option>
                            <option value="Time Management">Time Management</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="trading-rule-description">Description (optional)</label>
                        <textarea id="trading-rule-description" autocomplete="off" placeholder="Weitere Details zur Regel..." rows="3"></textarea>
                    </div>
                    
                    <div class="form-actions">
                        <button type="button" class="btn secondary" onclick="TradingRulesManager.hideAddRuleModal()">Abbrechen</button>
                        <button type="submit" class="btn">Regel erstellen</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Add Vision Modal -->
    <div id="add-vision-modal" class="modal hide">
        <div class="modal-content">
            <button class="close" onclick="VisionManager.hideAddVisionModal()">×</button>
            <h2>Vision Card</h2>
            
            <div class="modal-body">
                <form id="add-vision-form">
                    <div class="form-group">
                        <label for="vision-title">Titel *</label>
                        <input type="text" id="vision-title" required autocomplete="off" placeholder="z.B. Traumhaus, Weltreise, Fitness Ziel">
                    </div>
                    
                    <div class="form-group">
                        <label for="vision-description">Beschreibung</label>
                        <input type="text" id="vision-description" autocomplete="off" placeholder="z.B. 2026, 70kg erreicht, Eigenes Business">
                    </div>

                    <div class="form-group">
                        <label for="vision-icon">Icon *</label>
                        <input type="text" id="vision-icon" required autocomplete="off" value="star" readonly>
                        <div class="icon-palette">
                            <!-- Lifestyle & Home -->
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('home')"><i data-lucide="home" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('building')"><i data-lucide="building" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('car')"><i data-lucide="car" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('key')"><i data-lucide="key" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('bed')"><i data-lucide="bed" style="width: 16px; height: 16px;"></i></button>
                            
                            <!-- Travel & Adventure -->
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('globe')"><i data-lucide="globe" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('plane')"><i data-lucide="plane" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('map')"><i data-lucide="map" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('camera')"><i data-lucide="camera" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('mountain')"><i data-lucide="mountain" style="width: 16px; height: 16px;"></i></button>
                            
                            <!-- Fitness & Health -->
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('dumbbell')"><i data-lucide="dumbbell" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('activity')"><i data-lucide="activity" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('bike')"><i data-lucide="bike" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('apple')"><i data-lucide="apple" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('zap')"><i data-lucide="zap" style="width: 16px; height: 16px;"></i></button>
                            
                            <!-- Career & Business -->
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('briefcase')"><i data-lucide="briefcase" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('trending-up')"><i data-lucide="trending-up" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('users')"><i data-lucide="users" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('laptop')"><i data-lucide="laptop" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('lightbulb')"><i data-lucide="lightbulb" style="width: 16px; height: 16px;"></i></button>
                            
                            <!-- Money & Finance -->
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('dollar-sign')"><i data-lucide="dollar-sign" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('banknote')"><i data-lucide="banknote" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('credit-card')"><i data-lucide="credit-card" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('piggy-bank')"><i data-lucide="piggy-bank" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('coins')"><i data-lucide="coins" style="width: 16px; height: 16px;"></i></button>
                            
                            <!-- Goals & Achievement -->
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('target')"><i data-lucide="target" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('trophy')"><i data-lucide="trophy" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('medal')"><i data-lucide="medal" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('crown')"><i data-lucide="crown" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('award')"><i data-lucide="award" style="width: 16px; height: 16px;"></i></button>
                            
                            <!-- Personal & Emotions -->
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('heart')"><i data-lucide="heart" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('star')"><i data-lucide="star" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('smile')"><i data-lucide="smile" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('sun')"><i data-lucide="sun" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('moon')"><i data-lucide="moon" style="width: 16px; height: 16px;"></i></button>
                            
                            <!-- Learning & Growth -->
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('book')"><i data-lucide="book" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('graduation-cap')"><i data-lucide="graduation-cap" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('brain')"><i data-lucide="brain" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('rocket')"><i data-lucide="rocket" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('compass')"><i data-lucide="compass" style="width: 16px; height: 16px;"></i></button>
                            
                            <!-- Technology & Innovation -->
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('smartphone')"><i data-lucide="smartphone" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('monitor')"><i data-lucide="monitor" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('cpu')"><i data-lucide="cpu" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('wifi')"><i data-lucide="wifi" style="width: 16px; height: 16px;"></i></button>
                            <button type="button" class="icon-btn" onclick="VisionManager.selectIcon('settings')"><i data-lucide="settings" style="width: 16px; height: 16px;"></i></button>
                        </div>
                    </div>
                    
                    <div class="form-actions">
                        <button type="button" class="btn secondary" onclick="VisionManager.hideAddVisionModal()">Abbrechen</button>
                        <button type="submit" class="btn">Erstellen</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Add Wiki Entry Modal -->
    <div id="add-wiki-modal" class="modal hide">
        <div class="modal-content">
            <button class="close" onclick="document.getElementById('add-wiki-modal').style.display='none'">×</button>
            <h2>Wiki Entry</h2>
            
            <div class="modal-body">
                <form id="add-wiki-form" autocomplete="off">
                <div class="form-group">
                    <label for="wiki-title">Titel</label>
                    <input type="text" id="wiki-title" placeholder="Titel für den Eintrag..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="wiki-content">Inhalt</label>
                    <textarea id="wiki-content" placeholder="Beschreibung, Regeln oder Learnings..." required autocomplete="off"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="wiki-tags">Tags (kommagetrennt):</label>
                    <input type="text" id="wiki-tags" placeholder="z.B. crypto, trading, analyse">
                </div>

                    <div class="form-actions">
                        <button type="button" id="cancel-wiki-btn" class="btn secondary">Abbrechen</button>
                        <button type="submit" class="btn">Erstellen</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Add Text Snippet Modal -->
    <div id="add-textsnippet-modal" class="modal hide">
        <div class="modal-content">
            <button class="close" onclick="ResourceManager.hideAddTextSnippetModal()">×</button>
            <h2>Text Snippet</h2>
            
            <div class="modal-body">
                <form id="add-textsnippet-form">
                    <div class="form-group">
                        <label for="textsnippet-text">Text *</label>
                        <textarea id="textsnippet-text" placeholder="Text Snippet eingeben..." required autocomplete="off" rows="4"></textarea>
                    </div>
                    
                    <div class="form-actions">
                        <button type="button" onclick="ResourceManager.hideAddTextSnippetModal()" class="btn secondary">Abbrechen</button>
                        <button type="submit" class="btn">Hinzufügen</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="supabase-config.js"></script>
    <script src="cloud-storage.js"></script>
    <script src="backup-system.js"></script>
    <script src="simple-counters.js"></script>
    <script src="simple-routine-system.js"></script>
    <script>
        // === SECURITY: PREVENT CREDENTIAL EXPOSURE ===
        (function() {
            // Override console functions to sanitize any URLs that might contain credentials
            const originalConsoleLog = console.log;
            const originalConsoleError = console.error;
            const originalConsoleWarn = console.warn;
            
            function sanitizeMessage(message) {
                if (typeof message === 'string') {
                    // Remove any URLs with email/password parameters (multiple patterns)
                    message = message.replace(/\?[^?\s]*email=[^&\s]*[^?\s]*/gi, '?[CREDENTIALS REMOVED]');
                    message = message.replace(/&email=[^&\s]*/gi, '&[EMAIL REMOVED]');
                    message = message.replace(/\?[^?\s]*password=[^&\s]*[^?\s]*/gi, '?[CREDENTIALS REMOVED]');
                    message = message.replace(/&password=[^&\s]*/gi, '&[PASSWORD REMOVED]');
                    // Remove any URL-encoded credentials
                    message = message.replace(/%40[^&\s]*[^?\s]*/gi, '[EMAIL REMOVED]');
                    message = message.replace(/email=%[^&\s]*/gi, '[EMAIL REMOVED]');
                    message = message.replace(/password=[^&\s]*/gi, '[PASSWORD REMOVED]');
                }
                return message;
            }
            
            console.log = function(...args) {
                const sanitizedArgs = args.map(arg => sanitizeMessage(arg));
                originalConsoleLog.apply(console, sanitizedArgs);
            };
            
            console.error = function(...args) {
                const sanitizedArgs = args.map(arg => sanitizeMessage(arg));
                originalConsoleError.apply(console, sanitizedArgs);
            };
            
            console.warn = function(...args) {
                const sanitizedArgs = args.map(arg => sanitizeMessage(arg));
                originalConsoleWarn.apply(console, sanitizedArgs);
            };
            
            // Clear URL parameters immediately if they contain credentials
            if (window.location.search && (window.location.search.includes('email=') || window.location.search.includes('password='))) {
                console.log('🔒 SECURITY: URL parameters detected and cleared to prevent credential exposure');
                const url = new URL(window.location.href);
                url.search = '';
                window.history.replaceState({}, document.title, url.toString());
            }
            
        })();
        
        // Debug: Check if basic JavaScript works
        
        window.addEventListener('error', function(e) {
            console.error('❌ JavaScript Error:', e.error);
            alert('JavaScript Error: ' + e.message + ' at line ' + e.lineno);
        });
        
        // === AUTHENTICATION ===
        const Auth = {
            isAuthenticated: false,
            currentUser: null,
            
            async init() {
                window.Auth = this;

                if (!supabase) {
                    console.log('⚠️ Demo mode - showing login screen with effects');
                    this.showAuthScreen();
                    return;
                }
                
                this.currentUser = supabase.getCurrentUser();
                
                if (supabase.isAuthenticated()) {
                    this.isAuthenticated = true;
                    await this.showDashboard();
                } else {
                    this.showAuthScreen();
                }
                
                this.setupEventListeners();
            },
            
            setupEventListeners() {
                const loginForm = document.getElementById('login-form');
                const logoutBtn = document.getElementById('logout-btn');
                
                // Only use form submit event to avoid double firing on mobile
                if (loginForm) {
                    loginForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        if (!this.isLoggingIn) { // Prevent multiple simultaneous logins
                            this.handleLogin();
                        }
                    });
                }
                
                if (logoutBtn) {
                    logoutBtn.addEventListener('click', () => this.handleLogout());
                }
            },
            
            async handleLogin() {
                // Prevent multiple simultaneous login attempts
                if (this.isLoggingIn) {
                    console.log('🔐 Login already in progress, ignoring...');
                    return;
                }
                
                this.isLoggingIn = true;
                
                const email = document.getElementById('login-email').value;
                const password = document.getElementById('login-password').value;
                const errorEl = document.getElementById('login-error');
                const loginBtn = document.getElementById('login-btn');
                
                console.log('📱 Mobile login attempt starting...', { email: email ? 'provided' : 'missing', password: password ? 'provided' : 'missing' });
                
                if (!email || !password) {
                    this.showError('Please enter email and password');
                    this.isLoggingIn = false;
                    return;
                }
                
                // Show loading state
                if (loginBtn) {
                    loginBtn.textContent = 'Logging in...';
                    loginBtn.disabled = true;
                }
                
                try {
                    console.log('📱 Attempting Supabase login...');
                    const { user, error } = await supabase.signIn(email, password);
                    
                    if (error) {
                        console.error('❌ Login error:', error);
                        this.showError(error);
                        this.isLoggingIn = false;
                        
                        // Reset button
                        if (loginBtn) {
                            loginBtn.textContent = 'Login';
                            loginBtn.disabled = false;
                        }
                        return;
                    }
                    
                    if (user) {
                        this.currentUser = user;
                        this.isAuthenticated = true;
                        await this.showDashboard();
                    }
                } catch (error) {
                    console.error('❌ Login exception:', error);
                    this.showError(error.message);
                    this.isLoggingIn = false;
                    
                    // Reset button
                    if (loginBtn) {
                        loginBtn.textContent = 'Login';
                        loginBtn.disabled = false;
                    }
                }
            },
            
            async handleLogout() {
                console.log('🚪 Logout clicked');
                try {
                    if (supabase && typeof supabase.signOut === 'function') {
                        await supabase.signOut();
                    }
                    // Only clear auth-related data, preserve routine/todo data
                    localStorage.removeItem('supabase.auth.token');
                    sessionStorage.clear();
                    // Remove authenticated class from body
                    document.body.classList.remove('authenticated');
                    
                    // Clear URL hash and redirect to clean login page
                    window.history.replaceState(null, null, window.location.pathname);
                    window.location.reload();
                } catch (error) {
                    console.error('❌ Logout error:', error);
                    // Only clear auth-related data, preserve user data
                    localStorage.removeItem('supabase.auth.token');
                    sessionStorage.clear();
                    // Remove authenticated class from body even on error
                    document.body.classList.remove('authenticated');
                    window.location.reload();
                }
            },
            
            showError(message) {
                const errorEl = document.getElementById('login-error');
                if (errorEl) {
                    errorEl.textContent = message;
                    errorEl.classList.add('show');
                    setTimeout(() => errorEl.classList.remove('show'), 5000);
                }
            },
            
            showAuthScreen() {
                // Showing login effects
                // Call stack for showAuthScreen()
                document.body.classList.remove('authenticated');
                document.getElementById('auth-screen').classList.remove('hide');
                const loginEffects = document.querySelector('.login-effects');
                if (loginEffects) {
                    loginEffects.style.display = 'block';
                    // Set display to block for login effects
                    
                    // Debug: Check if it stays visible
                    setTimeout(() => {
                        const currentDisplay = loginEffects.style.display;
                        // After 2 seconds, display set
                        if (currentDisplay === 'none') {
                            console.log('❌ LOGIN: Effects were hidden after showAuthScreen!');
                            console.trace('❌ LOGIN: Something hid the effects!');
                        }
                    }, 2000);
                }
                document.getElementById('crypto-overlay').style.display = 'none';
                // Hide QuickBar on login screen
                document.getElementById('quickbar').style.display = 'none';
            },
            
            async refreshRoutineUI() {
                // Simple refresh for routine UI without retries
                
                try {
                    // Note: Counter updates now handled by SimpleCounters
                    
                    // Dispatch update event for routine elements
                    const routineSections = document.querySelectorAll('.routine-item, .habit-item');
                    if (routineSections.length > 0) {
                        routineSections.forEach(section => {
                            const event = new Event('routineUpdate', { bubbles: true });
                            section.dispatchEvent(event);
                        });
                    }
                    
                } catch (error) {
                    console.error('❌ Error refreshing routine UI:', error);
                }
            },
            
            async showDashboard() {
                // Enable logging after successful authentication
                window.enableLogging();
                window.devLog('🔹 DASHBOARD: Hiding login effects');
                
                // Reset login state first
                this.isLoggingIn = false;
                const loginBtn = document.getElementById('login-btn');
                if (loginBtn) {
                    loginBtn.textContent = 'Login';
                    loginBtn.disabled = false;
                }
                
                document.body.classList.add('authenticated');
                
                // NUCLEAR OPTION: Completely remove auth screen from DOM on mobile
                const authScreen = document.getElementById('auth-screen');
                if (authScreen) {
                    window.devLog('📱 DASHBOARD: Removing auth screen from DOM completely');
                    authScreen.remove(); // Complete DOM removal - no CSS can override this
                }
                
                const loginEffects = document.querySelector('.login-effects');
                if (loginEffects) {
                    loginEffects.style.display = 'none';
                    console.log('🔹 DASHBOARD: Set display to none for login effects');
                }
                
                // Show main dashboard elements
                const cryptoOverlay = document.getElementById('crypto-overlay');
                if (cryptoOverlay) {
                    cryptoOverlay.style.display = 'block';
                }
                
                // Show main content areas  
                const homeSection = document.querySelector('.home-section');
                const tabsContainer = document.querySelector('.tabs-container');
                const tabContent = document.querySelectorAll('.tab-content');
                
                if (homeSection) {
                    homeSection.style.display = 'block';
                    console.log('📱 DASHBOARD: Showing home section');
                }
                
                if (tabsContainer) {
                    tabsContainer.style.display = 'block';
                    console.log('📱 DASHBOARD: Showing tabs container');
                }
                
                tabContent.forEach(content => {
                    content.style.display = 'block';
                });
                
                console.log('🎯 DASHBOARD: All elements should now be visible - auth screen completely removed from DOM');
                
                // Mobile-specific: Hide QuickBar on mobile, show on desktop
                const quickbar = document.getElementById('quickbar');
                if (quickbar) {
                    // Check if mobile
                    const isMobile = window.innerWidth <= 768 || 
                                   /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                                   ('ontouchstart' in window);
                                   
                    if (isMobile) {
                        console.log('📱 DASHBOARD: Mobile detected - hiding QuickBar');
                        quickbar.style.display = 'none';
                    } else {
                        quickbar.style.display = 'flex';
                    }
                }
                
                // Load all data after successful login
                if (supabase?.isAuthenticated()) {
                    // Debug: Check which managers are available
                    // Load all data in parallel for better performance
                    await Promise.all([
                        TodoManager.loadTodos(),
                        GoalManager.loadGoals(),
                        JournalManager.loadEntries(),
                        TerminManager.loadTermine(),
                        // Load Wiki data if available
                        window.Wiki ? window.Wiki.loadEntries() : Promise.resolve(),
                        // Load ResourceManager data if it exists (after login)
                        window.ResourceManager ? window.ResourceManager.loadResources() : Promise.resolve(),
                        // Load TradingRulesManager data if it exists (after login)
                        window.TradingRulesManager ? window.TradingRulesManager.loadTradingRules() : Promise.resolve()
                    ]);
                    
                    // Initialize crypto widget after authentication
                    try {
                        if (!window.cryptoPriceWidget) {
                            window.cryptoPriceWidget = new CryptoPriceWidget();
                            }
                    } catch (error) {
                        console.error('❌ Error initializing Crypto Widget:', error);
                    }
                    
                    // Initialize routine system FIRST, then counters to avoid race condition
                    if (window.simpleRoutineManager) {
                        await window.simpleRoutineManager.loadTodaysData();
                        window.simpleRoutineManager.restoreCheckboxes();
                        window.simpleRoutineManager.updateProgressBarsOnly();
                    }
                    
                    // Initialize counters AFTER routine system is ready
                    if (window.SimpleCounters) {
                        await window.SimpleCounters.init();
                    }
                    
                    // Render Wiki after data is loaded
                    if (window.Wiki) {
                        window.Wiki.render();
                    }
                    
                    // After login, always go to home tab for clean UX
                    console.log('🏠 After login, redirecting to home tab');
                    switchTab('tab-home', true); // Update URL to #home
                } else {
                    // Initialize displays for local storage mode
                    TodoManager.updateHomeTodos();
                    TerminManager.displayTermine();
                }
            }
        };

        // === TAB SYSTEM ===
        // Mapping between tab IDs and URL hashes
        const tabHashMapping = {
            'tab-home': 'home',
            'tab-todos': 'todos',
            'tab-ziele': 'goals', 
            'tab-journal': 'journal',
            'tab-trading': 'trading',
            'tab-ressourcen': 'resources',
            'tab-vision': 'vision',
            'tab-wiki': 'wiki',
            'tab-settings': 'settings',
            'tab-trading-rules': 'trading-rules'
        };

        // Reverse mapping for hash to tab ID
        const hashTabMapping = Object.fromEntries(
            Object.entries(tabHashMapping).map(([key, value]) => [value, key])
        );

        function switchTab(tabId, updateHash = true) {
            document.querySelectorAll('.tab-section').forEach(section => {
                section.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            const targetSection = document.getElementById(tabId);
            const targetTab = document.querySelector(`[data-tab="${tabId}"]`);
            
            if (targetSection) {
                targetSection.classList.add('active');
                
                // Add nav tab activation only if it exists (for regular tabs)
                if (targetTab) {
                    targetTab.classList.add('active');
                }
                
                // Update URL hash
                if (updateHash && tabHashMapping[tabId]) {
                    const hash = tabHashMapping[tabId];
                    
                    window.history.replaceState(null, null, `#${hash}`);
                    window.devLog(`🔗 Tab switched to ${tabId}, URL updated to #${hash}`);
                } else if (updateHash) {
                    // Fallback: if no hash mapping, clear hash
                    window.history.replaceState(null, null, window.location.pathname);
                }
            } else {
                console.error(`❌ Tab section not found: ${tabId}`);
            }
            
            // If switching to todos tab, load the active category
            if (tabId === 'tab-todos') {
                // Load all categories for new todo structure
                if (window.TodoManager && typeof window.TodoManager.loadAllCategories === 'function') {
                    TodoManager.loadAllCategories();
                } else {
                    // Fallback: load individual categories
                    ['privat', 'uni', 'arbeit', 'projekte'].forEach(category => {
                        if (window.TodoManager && typeof window.TodoManager.displayTodosForCategory === 'function') {
                            TodoManager.displayTodosForCategory(category);
                        }
                    });
                }
            }
            
            // If switching to trading rules tab, load and render rules
            if (tabId === 'tab-trading-rules') {
                if (window.TradingRulesManager) {
                    if (typeof window.TradingRulesManager.loadTradingRules === 'function') {
                        TradingRulesManager.loadTradingRules();
                    } else {
                        if (typeof window.TradingRulesManager.renderTradingRules === 'function') {
                            TradingRulesManager.renderTradingRules();
                        }
                    }
                }
            }
            
            // If switching to home tab, update home todos
            if (tabId === 'tab-home') {
                TodoManager.updateHomeTodos();
            }
            
            // If switching to ziele tab, load the active category
            if (tabId === 'tab-ziele') {
                const activeTab = document.querySelector('.ziel-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-ziel-category') : 'alle';
                GoalManager.displayGoalsForCategory(activeCategory);
            }
            
            // If switching to journal tab, load the active category
            if (tabId === 'tab-journal') {
                const activeTab = document.querySelector('.journal-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-journal-category') : 'alle';
                JournalManager.renderEntries();
            }
            
            // If switching to resources tab, load the active category
            if (tabId === 'tab-ressourcen') {
                if (window.ResourceManager) {
                    const activeTab = document.querySelector('.resource-tab.active');
                    const activeCategory = activeTab ? activeTab.getAttribute('data-resource-category') : 'alle';
                    ResourceManager.displayResourcesForCategory(activeCategory);
                }
            }
            
            // If switching to vision tab, load visions
            if (tabId === 'tab-vision') {
                if (window.VisionManager && typeof window.VisionManager.loadVisions === 'function') {
                    // Always reload visions when switching to ensure they're up to date
                    VisionManager.loadVisions();
                    
                    // Additional check: if container exists but appears empty, force reload
                    setTimeout(() => {
                        const container = document.getElementById('vision-entries');
                        if (container && container.children.length === 0) {
                            VisionManager.loadVisions();
                        }
                    }, 100);
                }
            }
            
            // Trading tab functionality
            if (tabId === 'tab-trading') {
                if (window.TradingManager) {
                    window.TradingManager.updatePortfolioStats();
                }
            }
        }

        // Handle hash changes for direct URL navigation
        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove the '#'
            if (hash && hashTabMapping[hash]) {
                window.devLog(`🔗 Hash changed to #${hash}, switching to ${hashTabMapping[hash]}`);
                switchTab(hashTabMapping[hash], false); // Don't update hash again
            } else if (!hash && supabase?.isAuthenticated()) {
                // Only default to home if authenticated (not on login screen)
                window.devLog('🔗 No hash found, defaulting to home (authenticated user)');
                switchTab('tab-home', false);
            }
            // If not authenticated and no hash, do nothing (stay on login screen)
        }

        // Initialize tab from URL hash on page load
        function initializeFromHash() {
            const hash = window.location.hash.slice(1);
            if (hash && hashTabMapping[hash]) {
                switchTab(hashTabMapping[hash], false);
            } else if (!hash && supabase?.isAuthenticated()) {
                // Only default to home if authenticated
                switchTab('tab-home', false);
            }
            // If not authenticated and no hash, do nothing (stay on login screen)
        }

        // === ROUTINE PROGRESS ===
        // Load saved checkbox states from cloud only (pure cloud mode)
        async function loadRoutineStates() {
            const today = new Date().toISOString().split('T')[0];
            let savedStates = {};
            
            // Pure cloud mode - no localStorage fallback needed
            // If authenticated, load from database
            if (supabase?.isAuthenticated()) {
                try {
                    const routineCompletions = getRoutineCompletions();
                    if (routineCompletions && routineCompletions.length > 0) {
                        // Filter for today's completions
                        const todayCompletions = routineCompletions.filter(c => c.date === today);
                        console.log(`📅 Found ${todayCompletions.length} routine completions for today`);
                        
                        // Convert database completions to checkbox states
                        todayCompletions.forEach(completion => {
                            if (completion.checkbox_id) {
                                savedStates[completion.checkbox_id] = completion.completed;
                                // Database restoration logged silently
                            }
                        });
                        
                        // Pure cloud mode - no localStorage updates needed
                        }
                } catch (error) {
                    console.error('Error loading routine states from database:', error);
                    // Continue with localStorage-only states
                }
            }
            
            // Apply states to checkboxes
            Object.keys(savedStates).forEach(checkboxId => {
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.checked = savedStates[checkboxId];
                    // Apply visual styling
                    const label = checkbox.nextElementSibling;
                    if (label) {
                        if (checkbox.checked) {
                            label.style.textDecoration = 'line-through';
                            label.style.color = '#999';
                        } else {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    }
                }
            });}
        
        // Save checkbox state to both localStorage and database
        async function saveCheckboxState(checkboxId, isChecked) {
            const today = new Date().toISOString().split('T')[0];
            
            // Pure cloud mode - no localStorage saving needed
            
            // Skip database save for routine checkboxes - handled by routine completion system
            const checkbox = document.getElementById(checkboxId);
            const routineSection = checkbox?.closest('.routine-section');
            
            if (routineSection) {
                return;
            }
            
            // Save non-routine checkboxes to database if authenticated
            if (supabase?.isAuthenticated()) {
                // Only save non-routine checkboxes to database
                // Routine checkboxes are handled by the routine completion system
            }
        }

        function updateRoutineProgress() {
            // DISABLED - conflicts with SimpleRoutineManager
            return;
            const routineTab = document.getElementById('tab-home');
            if (!routineTab) return;
            
            const routineSections = routineTab.querySelectorAll('.routine-section');
            
            routineSections.forEach(section => {
                const checkboxes = section.querySelectorAll('input[type="checkbox"]');
                const checkedBoxes = section.querySelectorAll('input[type="checkbox"]:checked');
                
                if (checkboxes.length === 0) return;
                
                const percentage = Math.round((checkedBoxes.length / checkboxes.length) * 100);
                
                const progressFill = section.querySelector('.progress-fill');
                if (progressFill) {
                    progressFill.style.width = percentage + '%';
                }

                // Update monthly streaks based on completion status (pure cloud mode)
                const today = new Date().toISOString().split('T')[0];
                const routineType = section.querySelector('h2').textContent.includes('Morgen') ? 'morning' : 'evening';
                
                let completionStatus;
                if (percentage === 100) {
                    completionStatus = true;
                } else {
                    completionStatus = false;
                }
                
                // Save to cloud if authenticated (async without blocking)
                if (supabase?.isAuthenticated()) {
                    (async () => {
                        try {
                            await cloudStorage.saveRoutineCompletion(`${routineType}_routine`, today, completionStatus);
                            
                            // Note: Counter updates now handled by SimpleCounters
                        } catch (error) {
                            console.warn('⚠️ Could not save routine completion to cloud:', error);
                        }
                    })();
                }
                
                // Note: Counter updates now handled by SimpleCounters
            });
        }

        // === CATEGORY SYSTEM (for todos) ===
        function switchCategory(categoryId) {
            const parentTab = document.querySelector('#tab-todos');
            // Hide all category contents within todos
            parentTab.querySelectorAll('.category-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all category tabs
            parentTab.querySelectorAll('.category-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-category="${categoryId}"]`).classList.add('active');
            
            // Show/hide clear archive button
            const clearArchiveBtn = document.getElementById('clear-archive-btn');
            if (clearArchiveBtn) {
                if (categoryId === 'archiv') {
                    clearArchiveBtn.style.display = 'inline-block';
                } else {
                    clearArchiveBtn.style.display = 'none';
                }
            }
            
            // Load todos for this category
            TodoManager.displayTodosForCategory(categoryId);
        }

        // === ZIELE CATEGORY SYSTEM ===
        function switchZielCategory(categoryId) {
            const parentTab = document.querySelector('#tab-ziele');
            // Hide all ziel contents
            parentTab.querySelectorAll('.ziel-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all ziel tabs
            parentTab.querySelectorAll('.ziel-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#ziel-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-ziel-category="${categoryId}"]`).classList.add('active');
            
            // Show/hide clear goal archive button
            const clearGoalArchiveBtn = document.getElementById('clear-goal-archive-btn');
            if (clearGoalArchiveBtn) {
                if (categoryId === 'archiv') {
                    clearGoalArchiveBtn.style.display = 'inline-block';
                } else {
                    clearGoalArchiveBtn.style.display = 'none';
                }
            }
            
            // Load goals for this category
            GoalManager.displayGoalsForCategory(categoryId);
        }

        // === RESOURCE CATEGORY SYSTEM ===
        function switchResourceCategory(categoryId) {
            const parentTab = document.querySelector('#tab-ressourcen');
            // Hide all resource contents
            parentTab.querySelectorAll('.resource-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all resource tabs
            parentTab.querySelectorAll('.resource-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#resource-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-resource-category="${categoryId}"]`).classList.add('active');
            
            // Load resources for this category
            ResourceManager.displayResourcesForCategory(categoryId);
        }

        // === JOURNAL CATEGORY SYSTEM ===
        function switchJournalCategory(categoryId) {
            const parentTab = document.querySelector('#tab-journal');
            // Hide all journal contents
            parentTab.querySelectorAll('.journal-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all journal tabs
            parentTab.querySelectorAll('.journal-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#journal-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-journal-category="${categoryId}"]`).classList.add('active');
            
            // Load journal entries for this category
            JournalManager.displayEntriesForCategory(categoryId);
        }

        // === SETTINGS FUNCTIONALITY ===
        function initializeSettings() {
            // Pure cloud mode - use default reset time (settings could be moved to cloud later)
            const savedResetTime = '06:00'; // Default time, no localStorage needed
            const timeInput = document.getElementById('routine-reset-time');
            if (timeInput) {
                timeInput.value = savedResetTime;
            }
            
            // Save routine settings button
            const saveBtn = document.getElementById('save-routine-settings');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    const resetTime = timeInput.value;
                    alert(`Routine Reset Zeit auf ${resetTime} temporär gesetzt! (Pure Cloud Mode - nicht dauerhaft gespeichert)`);
                    console.log(`Routine reset time noted: ${resetTime} (not persisted in pure cloud mode)`);
                });
            }
            
            // Reset routines today button
            const resetBtn = document.getElementById('reset-routines-today');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    if (confirm('Möchtest du wirklich alle Routinen für heute zurücksetzen?')) {
                        resetRoutinesToday();
                    }
                });
            }
            
            // Reset monthly todos button
            const resetTodosBtn = document.getElementById('reset-monthly-todos');
            if (resetTodosBtn) {
                resetTodosBtn.addEventListener('click', () => {
                    const now = new Date();
                    const monthName = ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni',
                                     'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
                    if (confirm(`Möchtest du wirklich den Todo-Zähler für ${monthName} ${now.getFullYear()} zurücksetzen?`)) {
                        resetMonthlyTodos();
                    }
                });
            }
            
            // Backup & Export System Event Listeners
            const exportAllBtn = document.getElementById('export-all-data');
            if (exportAllBtn) {
                exportAllBtn.addEventListener('click', async () => {
                    exportAllBtn.disabled = true;
                    exportAllBtn.textContent = 'Exportiere...';
                    
                    try {
                        const success = await window.backupManager.downloadBackup();
                        if (success) {
                            updateBackupStats();
                        }
                    } catch (error) {
                        console.error('Export failed:', error);
                    } finally {
                        exportAllBtn.disabled = false;
                        exportAllBtn.textContent = 'Alle Daten exportieren';
                    }
                });
            }
            
            const selectImportBtn = document.getElementById('select-import-file');
            const importFileInput = document.getElementById('import-file');
            const importDataBtn = document.getElementById('import-data');
            
            if (selectImportBtn && importFileInput) {
                selectImportBtn.addEventListener('click', () => {
                    importFileInput.click();
                });
                
                importFileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file && file.type === 'application/json') {
                        importDataBtn.disabled = false;
                        selectImportBtn.textContent = `${file.name} ausgewählt`;
                    } else {
                        importDataBtn.disabled = true;
                        selectImportBtn.textContent = 'Datei auswählen';
                        if (file) {
                            alert('Bitte wähle eine JSON-Datei aus.');
                        }
                    }
                });
            }
            
            if (importDataBtn) {
                importDataBtn.addEventListener('click', async () => {
                    const file = importFileInput.files[0];
                    if (!file) return;
                    
                    if (!confirm('⚠️ WARNUNG: Der Import überschreibt deine bestehenden Daten!\n\nHast du bereits ein Backup erstellt?\n\nFortfahren?')) {
                        return;
                    }
                    
                    importDataBtn.disabled = true;
                    importDataBtn.textContent = 'Importiere...';
                    
                    try {
                        await window.backupManager.importFromBackup(file);
                        updateBackupStats();
                        
                        // Reset file input
                        importFileInput.value = '';
                        selectImportBtn.textContent = 'Datei auswählen';
                        
                        // Suggest page reload
                        if (confirm('Import abgeschlossen! Seite neu laden um alle Änderungen zu sehen?')) {
                            window.location.reload();
                        }
                    } catch (error) {
                        console.error('Import failed:', error);
                    } finally {
                        importDataBtn.disabled = true;
                        importDataBtn.textContent = 'Importieren';
                    }
                });
            }
            
            // Initialize backup stats display
            updateBackupStats();
        }
        
        // Update backup statistics display
        async function updateBackupStats() {
            const statsElement = document.getElementById('backup-stats');
            if (!statsElement || !window.backupManager) return;
            
            try {
                const stats = await window.backupManager.getBackupStats();
                if (stats) {
                    statsElement.textContent = `(${stats.totalRecords} Einträge verfügbar zum Backup)`;
                } else {
                    statsElement.textContent = '';
                }
            } catch (error) {
                statsElement.textContent = '';
                console.warn('Could not get backup stats:', error);
            }
        }
        
        function resetRoutinesToday() {
            const today = new Date().toISOString().split('T')[0];
            
            // Pure cloud mode - no localStorage operations needed
            console.log(`☁️ Resetting routines for ${today} (UI only)`);
            
            // Note: In pure cloud mode, this only resets the UI
            // The actual cloud data would need to be reset via cloud operations
            
            // Uncheck all routine checkboxes
            document.querySelectorAll('.routine-section input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
                const label = checkbox.nextElementSibling;
                if (label) {
                    label.style.textDecoration = 'none';
                    label.style.color = 'inherit';
                }
            });
            
            // Update progress displays
            updateRoutineProgress();
            // Note: Counter updates now handled by SimpleCounters
            
            alert('Routinen für heute wurden zurückgesetzt!');
            console.log('Routines reset for today');
        }
        
        function resetMonthlyTodos() {
            const now = new Date();
            const monthKey = `${now.getFullYear()}-${now.getMonth()}`;
            
            // Reset monthly todo completions
            const monthlyData = JSON.parse(localStorage.getItem('monthlyTodoCompletions') || '{}');
            monthlyData[monthKey] = 0;
            localStorage.setItem('monthlyTodoCompletions', JSON.stringify(monthlyData));
            
            // Note: Counter updates now handled by SimpleCounters
            
            const monthName = ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni',
                             'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
            alert(`Todo-Zähler für ${monthName} ${now.getFullYear()} wurde auf 0 zurückgesetzt!`);
            console.log(`Monthly todos reset for ${monthKey}`);
        }
        
        // === TODO COUNTER SYSTEMS REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        // === MOBILE-FIRST ROUTINE COMPLETIONS ===
        let globalRoutineCompletions = []; // Always keep in memory for mobile
        
        async function loadRoutineCompletions() {
            try {
                // STEP 1: If not authenticated, use local data only
                if (!supabase?.isAuthenticated()) {
                    // Using local data when not authenticated
                    try {
                        const localData = localStorage.getItem('routine_completions_cache');
                        if (localData) {
                            globalRoutineCompletions = JSON.parse(localData);
                            // Note: Counter updates now handled by SimpleCounters
                        }
                    } catch (e) {
                        console.warn('⚠️ Could not read local data:', e);
                        globalRoutineCompletions = [];
                    }
                    return;
                }
                
                // STEP 2: Load cloud data
                const cloudCompletions = await supabase.query('routine_completions?select=*');
                console.log(`☁️ Loaded ${cloudCompletions?.length || 0} routine completions from cloud`);
                
                // STEP 3: Cloud-first with improved migration
                if (cloudCompletions && cloudCompletions.length > 0) {
                    // Use cloud data if available
                    globalRoutineCompletions = cloudCompletions;
                    console.log(`☁️ Using ${cloudCompletions.length} completions from cloud`);
                } else {
                    // Cloud is empty - try migration with new improved approach
                    const migrationSuccess = await migrateLocalDataToCloudV2();
                    
                    if (migrationSuccess) {
                        // Reload after successful migration
                        const newCloudCompletions = await supabase.query('routine_completions?select=*');
                        globalRoutineCompletions = newCloudCompletions || [];
                    } else {
                        // Migration failed - use local data as fallback
                        console.log('⚠️ Migration failed, using local data as fallback');
                        globalRoutineCompletions = [];
                        
                        // Load from all local sources
                        const localSources = ['routine_completions_cache', 'routineCompletionData'];
                        for (const source of localSources) {
                            try {
                                const localData = localStorage.getItem(source);
                                if (localData) {
                                    const parsed = JSON.parse(localData);
                                    
                                    if (source === 'routineCompletionData') {
                                        // Convert old format
                                        Object.keys(parsed).forEach(date => {
                                            const dayData = parsed[date];
                                            if (dayData.morning !== undefined) {
                                                globalRoutineCompletions.push({
                                                    template_id: 'morning_routine',
                                                    date: date,
                                                    completed: dayData.morning
                                                });
                                            }
                                            if (dayData.evening !== undefined) {
                                                globalRoutineCompletions.push({
                                                    template_id: 'evening_routine',
                                                    date: date,
                                                    completed: dayData.evening
                                                });
                                            }
                                        });
                                    } else if (Array.isArray(parsed)) {
                                        globalRoutineCompletions.push(...parsed);
                                    }
                                }
                            } catch (e) {
                                console.warn(`⚠️ Could not load fallback from ${source}:`, e);
                            }
                        }
                        console.log(`📱 Using ${globalRoutineCompletions.length} local completions as fallback`);
                    }
                }
                
                // STEP 4: Pure cloud mode - no local caching needed
                // STEP 5: Counter updates now handled by SimpleCounters
                
            } catch (error) {
                console.error('❌ Error loading routine completions:', error);
                // Fallback to local data on error
                try {
                    const localData = localStorage.getItem('routine_completions_cache');
                    if (localData) {
                        globalRoutineCompletions = JSON.parse(localData);
                        } else {
                        globalRoutineCompletions = [];
                    }
                } catch (e) {
                    globalRoutineCompletions = [];
                }
            }
        }
        
        // === IMPROVED MIGRATION FUNCTION V2 ===
        async function migrateLocalDataToCloudV2() {
            try {
                console.log('🚀 Starting IMPROVED migration (V2) of local routine data to cloud...');
                
                // Get current user
                const currentUser = supabase.getCurrentUser();
                if (!currentUser || !currentUser.id) {
                    console.error('❌ No authenticated user found for migration');
                    return false;
                }
                
                console.log('👤 Starting data migration...');
                
                // Collect all local data
                const localCompletions = [];
                
                // Source 1: routineCompletionData (legacy format)
                try {
                    const legacyData = localStorage.getItem('routineCompletionData');
                    if (legacyData) {
                        const parsed = JSON.parse(legacyData);
                        console.log(`📁 Found legacy data for ${Object.keys(parsed).length} dates`);
                        
                        Object.keys(parsed).forEach(date => {
                            const dayData = parsed[date];
                            if (dayData.morning !== undefined) {
                                localCompletions.push({
                                    template_id: 'morning_routine',
                                    date: date,
                                    completed: Boolean(dayData.morning),
                                    user_id: currentUser.id
                                });
                            }
                            if (dayData.evening !== undefined) {
                                localCompletions.push({
                                    template_id: 'evening_routine',
                                    date: date,
                                    completed: Boolean(dayData.evening),
                                    user_id: currentUser.id
                                });
                            }
                        });
                    }
                } catch (e) {
                    console.warn('⚠️ Could not parse legacy routine data:', e);
                }
                
                if (localCompletions.length === 0) {
                    console.log('📭 No local data found to migrate');
                    return true;
                }
                
                // Remove duplicates based on user_id + template_id + date
                const uniqueCompletions = [];
                const seen = new Set();
                
                localCompletions.forEach(completion => {
                    const key = `${completion.user_id}_${completion.template_id}_${completion.date}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueCompletions.push(completion);
                    }
                });
                
                // Upload to cloud
                let uploadedCount = 0;
                
                for (const completion of uniqueCompletions) {
                    try {
                        console.log(`⬆️ Uploading: ${completion.template_id} for ${completion.date} (${completion.completed})`);
                        
                        const result = await supabase.insert('routine_completions', [completion]);
                        if (result && result.length > 0) {
                            uploadedCount++;} else {
                            console.warn(`⚠️ Upload returned no result`);
                        }
                    } catch (uploadError) {
                        console.error(`❌ Failed to upload completion:`, uploadError);
                        
                        // Check if it's a duplicate key error (which is OK)
                        if (uploadError.message && uploadError.message.includes('unique constraint')) {
                            console.log(`ℹ️ Duplicate entry (already exists) - skipping`);
                            uploadedCount++; // Count as success since data exists
                        } else {
                            console.error(`❌ Real upload error:`, uploadError.message);
                        }
                    }
                }
                
                console.log(`🎉 Migration V2 complete! Successfully processed ${uploadedCount}/${uniqueCompletions.length} completions`);
                return uploadedCount > 0;
                
            } catch (error) {
                console.error('❌ Migration V2 failed:', error);
                return false;
            }
        }
        
        // === OLD MIGRATION FUNCTION (DEPRECATED) ===
        async function migrateLocalDataToCloud() {
            try {
                console.log('🚀 Starting migration of local routine data to cloud...');
                
                // Get all local routine data sources
                const sources = [
                    'routine_completions_cache',
                    'routineCompletionData',
                    'monthlyRoutineCompletions'
                ];
                
                let allLocalCompletions = [];
                
                for (const source of sources) {
                    try {
                        const data = localStorage.getItem(source);
                        if (data) {
                            let parsed = JSON.parse(data);
                            console.log(`📁 Found data in ${source}:`, parsed);
                            
                            if (source === 'routineCompletionData') {
                                // Convert old format to new format
                                Object.keys(parsed).forEach(date => {
                                    const dayData = parsed[date];
                                    if (dayData.morning !== undefined) {
                                        allLocalCompletions.push({
                                            template_id: 'morning_routine',
                                            date: date,
                                            completed: dayData.morning,
                                            user_id: supabase.getCurrentUser()?.id
                                            // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                        });
                                    }
                                    if (dayData.evening !== undefined) {
                                        allLocalCompletions.push({
                                            template_id: 'evening_routine', 
                                            date: date,
                                            completed: dayData.evening,
                                            user_id: supabase.getCurrentUser()?.id
                                            // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                        });
                                    }
                                });
                            } else if (Array.isArray(parsed)) {
                                // Add user_id to existing completions and remove any existing id
                                parsed.forEach(completion => {
                                    const cleanCompletion = {
                                        template_id: completion.template_id,
                                        date: completion.date,
                                        completed: completion.completed,
                                        user_id: supabase.getCurrentUser()?.id
                                        // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                    };
                                    allLocalCompletions.push(cleanCompletion);
                                });
                            }
                        }
                    } catch (e) {
                        console.warn(`⚠️ Could not parse ${source}:`, e);
                    }
                }
                
                if (allLocalCompletions.length === 0) {
                    console.log('📭 No local data found to migrate');
                    return true; // No data to migrate is considered success
                }
                
                // Clean all completions: remove any existing IDs and ensure clean data
                const cleanedCompletions = allLocalCompletions.map(completion => ({
                    template_id: completion.template_id,
                    date: completion.date,
                    completed: completion.completed,
                    user_id: completion.user_id || supabase.getCurrentUser()?.id
                    // Explicitly exclude: id, created_at, updated_at - these will be auto-generated
                }));
                
                console.log(`🧹 Cleaned data, removing ${allLocalCompletions.length - cleanedCompletions.length} invalid entries`);
                
                // Upload to cloud in batches
                const batchSize = 50;
                let uploaded = 0;
                let hasErrors = false;
                
                for (let i = 0; i < cleanedCompletions.length; i += batchSize) {
                    const batch = cleanedCompletions.slice(i, i + batchSize);
                    try {
                        const result = await supabase.insert('routine_completions', batch);
                        if (result) {
                            uploaded += batch.length;} else {
                            console.error('❌ Batch upload returned no result');
                            hasErrors = true;
                        }
                    } catch (batchError) {
                        console.error('❌ Batch upload failed:', batchError);
                        hasErrors = true;
                        
                        // Check if it's an RLS error
                        if (batchError.message && batchError.message.includes('row-level security')) {
                            console.error('🔒 RLS Error: Please run the fix-routine-completions-rls.sql file in Supabase');
                            return false; // Stop migration on RLS error
                        }
                    }
                }
                
                if (hasErrors && uploaded === 0) {
                    console.log('❌ Migration failed completely');
                    return false;
                } else if (hasErrors) {
                    console.log(`⚠️ Migration partially successful: ${uploaded}/${cleanedCompletions.length} uploaded`);
                    return uploaded > 0; // Partial success
                } else {
                    console.log(`🎉 Migration complete! Uploaded ${uploaded} routine completions to cloud`);
                    return true;
                }
                
            } catch (error) {
                console.error('❌ Migration failed:', error);
                return false;
            }
        }
        
        // Mobile-safe function that uses memory first, localStorage as fallback
        function getRoutineCompletions() {
            if (globalRoutineCompletions && globalRoutineCompletions.length > 0) {
                console.log('📱 Using routine completions from memory (Mobile-safe)');
                return globalRoutineCompletions;
            }
            
            // Fallback to localStorage if available
            try {
                const cached = localStorage.getItem('routine_completions_cache');
                if (cached) {
                    const parsed = JSON.parse(cached);
                    return parsed;
                }
            } catch (e) {
                console.warn('⚠️ localStorage read failed, using empty array');
            }
            
            return [];
        }
        
        // === CLOUD-BASED ROUTINE STREAK UPDATER REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        // === LOCAL FALLBACK FOR ROUTINE STREAKS REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        // === MONTHLY STREAK DISPLAY FUNCTIONS REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        function getRoutineCompletions() {
            // Return empty array for now
            return [];
        }
        
        // === MAKE FUNCTIONS GLOBALLY AVAILABLE ===
        window.getRoutineCompletions = getRoutineCompletions;
        window.loadRoutineCompletions = loadRoutineCompletions;
        window.loadRoutineStates = loadRoutineStates;
        window.updateRoutineProgress = updateRoutineProgress;

        // === EVENT LISTENERS ===
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Skip action buttons - they have their own handlers
                if (tab.id === 'logout-btn' || tab.id === 'settings-btn') return;
                
                const tabId = tab.getAttribute('data-tab');
                if (tabId) switchTab(tabId);
            });
        });
        
        // Settings button event listener
        const settingsBtn = document.getElementById('settings-btn');
        if (settingsBtn) {
            settingsBtn.addEventListener('click', () => {
                console.log('Settings clicked');
                switchTab('tab-settings');
            });
        }

        // Setup Settings hover animations
        function setupActionButtonHovers() {
            const settingsBtn = document.getElementById('settings-btn');
            
            if (settingsBtn?.querySelector('svg')) {
                settingsBtn.onmouseenter = function() {
                    const svg = settingsBtn.querySelector('svg');
                    if (svg) {
                        svg.style.stroke = '#059669';
                        svg.style.color = '#059669';
                    }
                };
                settingsBtn.onmouseleave = function() {
                    const svg = settingsBtn.querySelector('svg');
                    if (svg) {
                        svg.style.stroke = '';
                        svg.style.color = '';
                    }
                };
            }
        }
        
        // Setup action button hovers after Lucide
        setTimeout(setupActionButtonHovers, 1000);

        // Todo category tabs
        document.querySelectorAll('.category-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-category');
                switchCategory(categoryId);
            });
        });

        // Ziele category tabs
        document.querySelectorAll('.ziel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-ziel-category');
                switchZielCategory(categoryId);
            });
        });

        // Resource category tabs
        document.querySelectorAll('.resource-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-resource-category');
                switchResourceCategory(categoryId);
            });
        });

        // Journal category tabs
        document.querySelectorAll('.journal-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-journal-category');
                switchJournalCategory(categoryId);
            });
        });

        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', async function() {
                // ToDo-Items als completed markieren
                const todoItem = this.closest('.todo-item');
                if (todoItem) {
                    todoItem.classList.toggle('completed', this.checked);
                }
                
                // Routine-Progress aktualisieren (nur bei Routine-Checkboxen)
                const routineSection = this.closest('.routine-section');
                if (routineSection) {
                    // Apply visual styling immediately
                    const label = this.nextElementSibling;
                    if (label) {
                        if (this.checked) {
                            label.style.textDecoration = 'line-through';
                            label.style.color = '#999';
                        } else {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    }
                    
                    // DISABLED - SimpleRoutineManager handles this
                    // await saveCheckboxState(this.id, this.checked);
                    // updateRoutineProgress();
                }
            });
        });

        // === TODO MANAGEMENT ===
        const TodoManager = {
            todos: [], // In-memory storage for demo
            
            priorityIntToString(priorityInt) {
                switch(priorityInt) {
                    case 1: return 'mittel'; // Map old niedrig to mittel
                    case 2: return 'mittel';
                    case 3: return 'wichtig';
                    case 4: return 'dringend';
                    default: return 'mittel';
                }
            },
            
            getPriorityString(priority) {
                if (typeof priority === 'string') {
                    return priority;
                }
                return this.priorityIntToString(priority);
            },
            
            getPriorityDisplay(priority) {
                const priorityStr = this.getPriorityString(priority);
                return priorityStr.charAt(0).toUpperCase() + priorityStr.slice(1);
            },
            
            async loadTodos() {
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('TodoManager');
                    this.todos = [];
                    return;
                }
                
                try {
                    const user = supabase.getCurrentUser();
                    const data = await supabase.query(`todos?user_id=eq.${user.id}&select=*`);
                    if (data && Array.isArray(data)) {
                        // Transform database data to match UI expectations
                        this.todos = data.map(todo => {
                            // Convert priority integer back to string
                            let priorityString = 'mittel';
                            switch(todo.priority) {
                                case 1: priorityString = 'mittel'; break; // Map old niedrig to mittel
                                case 2: priorityString = 'mittel'; break;
                                case 3: priorityString = 'wichtig'; break;
                                case 4: priorityString = 'dringend'; break;
                                default: priorityString = 'mittel';
                            }
                            
                            return {
                                ...todo,
                                title: todo.text, // Map text to title for UI
                                deadline: todo.date, // Use date field only (no due_date)
                                priority: priorityString // Convert integer to string
                            };
                        });
                        this.refreshCurrentView();
                        this.updateHomeTodos();
                    } else {
                        this.todos = [];
                    }
                } catch (error) {
                    console.error('❌ TodoManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            showAddTodoModal(preselectedCategory = null) {
                const modal = document.getElementById('add-todo-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('todo-deadline').value = today;
                
                // Preselect category if provided
                if (preselectedCategory) {
                    const categorySelect = document.getElementById('todo-category');
                    if (categorySelect) {
                        categorySelect.value = preselectedCategory;
                    }
                }
            },
            
            hideAddTodoModal() {
                const modal = document.getElementById('add-todo-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-todo-form').reset();
                // Reset to default values
                document.getElementById('todo-time').value = '21:00';
                document.getElementById('todo-priority').value = 'mittel';
            },
            
            async addTodo(todoData) {
                // DON'T create due_date with timezone - it causes issues
                // Just store date and time separately
                
                // Convert priority string to integer
                let priorityInt = 2; // Default to mittel
                switch(todoData.priority) {
                    case 'niedrig': priorityInt = 1; break; // Keep for backwards compatibility
                    case 'mittel': priorityInt = 2; break;
                    case 'wichtig': priorityInt = 3; break;
                    case 'dringend': priorityInt = 4; break;
                    default: priorityInt = 2;
                }
                
                const todo = {
                    text: todoData.title,
                    category: todoData.category,
                    priority: priorityInt,
                    date: todoData.deadline || null,
                    time: todoData.time || null,
                    // Remove due_date field to avoid timezone issues
                    completed: false,
                    user_id: supabase?.user?.id || 'anonymous'
                };
                
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TodoManager: Not authenticated - cannot add todo in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Todo kann nicht gespeichert werden.');
                    return;
                }
                
                try {
                    const result = await supabase.insert('todos', todo);
                    if (result && Array.isArray(result) && result.length > 0) {
                        // Transform the database result to match UI expectations
                        const dbTodo = result[0];
                        const uiTodo = {
                            ...dbTodo,
                            title: dbTodo.text,
                            deadline: dbTodo.date, // Use date field only
                            priority: this.priorityIntToString(dbTodo.priority || 1)
                        };
                        this.todos.push(uiTodo);
                        } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ TodoManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Todos: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                // Refresh current view immediately
                this.refreshCurrentView();
                
                // Don't trigger counter animation when creating todos
            },
            
            refreshCurrentView() {
                
                // Update all todo categories since there's no active tab system in todos
                const categories = ['privat', 'uni', 'arbeit', 'projekte'];
                categories.forEach(category => {
                    this.displayTodosForCategory(category);
                });
                
                // Also update home todos
                this.updateHomeTodos();
                
                // Update overdue badge
                this.updateOverdueBadge();
            },
            
            updateOverdueBadge() {
                // Count overdue todos
                const today = new Date();
                const todayStr = today.getFullYear() + '-' + 
                               String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(today.getDate()).padStart(2, '0');
                
                const overdueCount = this.todos.filter(todo => 
                    todo.date && todo.date < todayStr && !todo.completed
                ).length;
                
                const badge = document.getElementById('overdue-count');
                if (badge) {
                    if (overdueCount > 0) {
                        badge.textContent = overdueCount;
                        badge.style.display = 'inline';
                    } else {
                        badge.style.display = 'none';
                    }
                }
            },
            
            displayTodosForCategory(category) {
                const container = document.getElementById(`todo-${category}`);
                if (!container) {
                    console.error('❌ Container not found for category:', category);
                    return;
                }
                
                let filteredTodos = [];
                
                switch(category) {
                    case 'heute':
                        // Get today without timezone conversion
                        const today = new Date();
                        const todayStr = today.getFullYear() + '-' + 
                                       String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                                       String(today.getDate()).padStart(2, '0');
                        
                        // Include both today's todos AND overdue todos
                        filteredTodos = this.todos.filter(todo => 
                            todo.date && todo.date <= todayStr && !todo.completed
                        );
                        break;
                    case 'alle':
                        filteredTodos = this.todos.filter(todo => !todo.completed);
                        break;
                    case 'archiv':
                        filteredTodos = this.todos.filter(todo => todo.completed);
                        break;
                    default:
                        filteredTodos = this.todos.filter(todo => 
                            todo.category === category && !todo.completed
                        );
                }
                // Sort by date first, then by time
                filteredTodos.sort((a, b) => {
                    // First by date
                    const dateA = a.date || '9999-12-31';
                    const dateB = b.date || '9999-12-31';
                    const dateComparison = dateA.localeCompare(dateB);
                    
                    if (dateComparison !== 0) {
                        return dateComparison;
                    }
                    
                    // Then by time (earliest first, no time goes to end)
                    const timeA = a.time || '23:59';
                    const timeB = b.time || '23:59';
                    return timeA.localeCompare(timeB);
                });
                
                // Clear container
                container.innerHTML = '';
                console.log('🧹 Container cleared');
                
                if (filteredTodos.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Todos vorhanden</p>';
                    return;
                }
                
                // Create compact todo list
                const todoList = document.createElement('div');
                todoList.className = 'todo-list';
                
                // Display todos
                filteredTodos.forEach((todo, index) => {
                    const todoElement = this.createTodoElement(todo);
                    todoList.appendChild(todoElement);
                });
                
                container.appendChild(todoList);
            },
            
            createTodoElement(todo) {
                const todoItem = document.createElement('div');
                todoItem.className = `todo-item${todo.completed ? ' completed' : ''}`;
                todoItem.dataset.todoId = todo.id;
                
                // Format date and time for display
                let dateTimeDisplay = '';
                if (todo.date) {
                    // Convert YYYY-MM-DD to DD.MM.YYYY format
                    const [year, month, day] = todo.date.split('-');
                    const germanDate = `${day}.${month}.${year}`;
                    dateTimeDisplay = germanDate;
                    
                    // Add time if available
                    if (todo.time) {
                        dateTimeDisplay += ` ${todo.time}`;
                    }
                }
                
                // Create simple compact HTML with priority dot and right-aligned checkbox
                todoItem.innerHTML = `
                    <div class="todo-priority priority-${todo.priority || 'mittel'}"></div>
                    <div class="todo-content">
                        <div class="todo-title">${todo.title}</div>
                        <div class="todo-meta">
                            ${dateTimeDisplay ? `<span class="todo-date">${dateTimeDisplay}</span>` : ''}
                        </div>
                    </div>
                    <input type="checkbox" id="todo-${todo.id}" ${todo.completed ? 'checked' : ''} onchange="TodoManager.toggleTodo('${todo.id}')">
                    <button class="todo-delete-btn" onclick="TodoManager.deleteTodo('${todo.id}')" title="Löschen" style="display: none;">
                        ×
                    </button>
                `;
                
                // Add right-click functionality to show delete button
                todoItem.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const deleteBtn = todoItem.querySelector('.todo-delete-btn');
                    if (deleteBtn.style.display === 'none') {
                        deleteBtn.style.display = 'inline-flex';
                        // Hide after 3 seconds or when clicking elsewhere
                        setTimeout(() => {
                            deleteBtn.style.display = 'none';
                        }, 3000);
                    } else {
                        deleteBtn.style.display = 'none';
                    }
                });
                
                // Hide delete button when clicking elsewhere
                document.addEventListener('click', (e) => {
                    if (!todoItem.contains(e.target)) {
                        const deleteBtn = todoItem.querySelector('.todo-delete-btn');
                        if (deleteBtn) {
                            deleteBtn.style.display = 'none';
                        }
                    }
                });
                
                return todoItem;
            },
            
            async toggleTodo(todoId) {
                
                const todo = this.todos.find(t => String(t.id) === String(todoId));
                if (todo) {
                    const wasCompleted = todo.completed;
                    todo.completed = !todo.completed;
                    
                    // Update counter display when todo status changes (now cloud-based)
                    if (todo.completed !== wasCompleted) {
                        }
                    
                    if (supabase?.isAuthenticated()) {
                        try {
                            // Make sure we use the right ID type
                            const updateId = Number.isInteger(Number(todo.id)) ? Number(todo.id) : todo.id;
                            const result = await supabase.update('todos', { completed: todo.completed }, updateId);
                            
                            // Trigger counter animation ONLY when todo is completed (not when uncompleted)
                            if (!wasCompleted && todo.completed) {
                                console.log('🎉 Todo completed! Triggering counter animation...');
                                if (window.SimpleCounters) {
                                    window.SimpleCounters.onTodoChanged();
                                }
                            } else if (wasCompleted && !todo.completed) {
                                if (window.SimpleCounters) {
                                    window.SimpleCounters.updateAllCounters(); // Update without animation
                                }
                            }
                            
                        } catch (error) {
                            console.error('❌ Database update failed:', error);
                            alert('Fehler: ' + error.message + '\nTodo wird nicht gespeichert!');
                            // Revert on error
                            todo.completed = wasCompleted;
                            return; // Don't refresh if update failed
                        }
                    }
                    
                    this.refreshCurrentView();
                    this.updateHomeTodos();
                } else {
                    console.error('❌ Todo not found for ID:', todoId);
                    alert('Todo nicht gefunden! ID: ' + todoId);
                }
            },
            
            async deleteTodo(todoId) {
                if (!confirm('Todo wirklich löschen?')) {
                    return;
                }
                
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TodoManager: Not authenticated - cannot delete todo in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Todo kann nicht gelöscht werden.');
                    return;
                }
                
                try {// Delete from cloud database
                    await supabase.delete('todos', String(todoId));
                    // Remove from local array
                    this.todos = this.todos.filter(todo => String(todo.id) !== String(todoId));
                    
                    // Immediately remove the deleted todo from DOM
                    const todoElement = document.querySelector(`[data-todo-id="${todoId}"]`);
                    if (todoElement) {
                        todoElement.remove();
                        }
                    
                    // Refresh current view
                    this.refreshCurrentView();
                    this.updateHomeTodos();
                    
                    // Don't trigger counter animation when deleting todos
                    
                } catch (error) {
                    console.error('❌ TodoManager: Error deleting todo:', error);
                    alert('Fehler beim Löschen: ' + error.message);
                }
            },
            
            async clearArchive() {
                if (!confirm('Wirklich alle erledigten Todos dauerhaft löschen?\n\nDiese Aktion kann nicht rückgängig gemacht werden!')) {
                    return;
                }
                
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TodoManager: Not authenticated - cannot clear archive in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Archive kann nicht geleert werden.');
                    return;
                }
                
                const completedTodos = this.todos.filter(todo => todo.completed);
                try {
                    // Delete from cloud database
                    for (const todo of completedTodos) {
                        console.log(`☁️ Deleting todo from cloud: ID ${todo.id}, Title: "${todo.title}"`);
                        if (!todo.id) {
                            console.warn(`⚠️ Skipping todo without ID: "${todo.title}"`);
                            continue;
                        }
                        const result = await supabase.delete('todos', String(todo.id));}
                    // Remove from local array
                    this.todos = this.todos.filter(todo => !todo.completed);
                    
                    // Refresh current view
                    this.refreshCurrentView();
                    
                    alert(`✅ ${completedTodos.length} erledigte Todos wurden gelöscht!`);
                } catch (error) {
                    console.error('❌ TodoManager: Error deleting from cloud:', error);
                    alert('Fehler beim Löschen aus der Cloud: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            updateHomeTodos() {
                const homeContainer = document.getElementById('home-todos');
                if (!homeContainer) return;
                
                // Show today's and overdue uncompleted todos on home
                const today = new Date();
                const todayStr = today.getFullYear() + '-' + 
                               String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(today.getDate()).padStart(2, '0');
                
                const todayTodos = this.todos.filter(todo => 
                    todo.date && todo.date <= todayStr && !todo.completed
                ).sort((a, b) => {
                    // First sort by date (overdue first)
                    const dateA = a.date || '9999-12-31';
                    const dateB = b.date || '9999-12-31';
                    const dateComparison = dateA.localeCompare(dateB);
                    
                    if (dateComparison !== 0) {
                        return dateComparison;
                    }
                    
                    // Then by time (earliest first, no time goes to end)
                    const timeA = a.time || '23:59';
                    const timeB = b.time || '23:59';
                    return timeA.localeCompare(timeB);
                });
                
                homeContainer.innerHTML = '';
                
                if (todayTodos.length === 0) {
                    homeContainer.innerHTML = '<p style="text-align: center; color: #666; padding: 1rem;">Keine Todos für heute</p>';
                    return;
                }
                
                // EXAKT wie Privat-Todos mit todo-item Klasse
                todayTodos.forEach(todo => {
                    const todoItem = document.createElement('div');
                    todoItem.className = 'todo-item';
                    todoItem.innerHTML = `
                        <div class="todo-priority priority-${this.getPriorityString(todo.priority)}"></div>
                        <div class="todo-content">
                            <div class="todo-title">${todo.title || todo.text}</div>
                            <div class="todo-meta">
                                <span class="todo-time">${todo.time || '21:00'}</span>
                            </div>
                        </div>
                        <input type="checkbox" ${todo.completed ? 'checked' : ''} onchange="TodoManager.toggleTodo('${todo.id}')">
                    `;
                    homeContainer.appendChild(todoItem);
                });
                
                // Also update overdue badge when updating home
                this.updateOverdueBadge();
            }
        };

        // Make TodoManager globally available
        window.TodoManager = TodoManager;

        // === MOBILE TODO MANAGER ===
        const MobileTodoManager = {
            showModal() {
                console.log('📱 Opening mobile todo modal');
                const modal = document.getElementById('mobile-todo-modal');
                if (modal) {
                    modal.classList.add('show');
                    
                    // Set today's date as default
                    const today = new Date().toISOString().split('T')[0];
                    document.getElementById('mobile-todo-deadline').value = today;
                    
                    // Focus the title input
                    setTimeout(() => {
                        const titleInput = document.getElementById('mobile-todo-title');
                        if (titleInput) titleInput.focus();
                    }, 100);
                }
            },
            
            hideModal() {
                console.log('📱 Closing mobile todo modal');
                const modal = document.getElementById('mobile-todo-modal');
                if (modal) {
                    modal.classList.remove('show');
                    this.resetForm();
                }
            },
            
            resetForm() {
                const form = document.getElementById('mobile-todo-form');
                if (form) {
                    form.reset();
                    document.getElementById('mobile-todo-priority').value = 'mittel';
                    document.getElementById('mobile-todo-time').value = '21:00';
                }
            },
            
            async submitTodo() {
                try {
                    const todoData = {
                        title: document.getElementById('mobile-todo-title').value,
                        category: document.getElementById('mobile-todo-category').value,
                        priority: document.getElementById('mobile-todo-priority').value,
                        deadline: document.getElementById('mobile-todo-deadline').value,
                        time: document.getElementById('mobile-todo-time').value
                    };
                    
                    console.log('📱 Mobile todo data:', todoData);
                    
                    if (!todoData.title.trim()) {
                        alert('Bitte gib eine Aufgabe ein!');
                        return;
                    }
                    
                    if (!todoData.category) {
                        alert('Bitte wähle eine Kategorie!');
                        return;
                    }
                    
                    // Use the existing TodoManager to add the todo
                    await TodoManager.addTodo(todoData);
                    
                    // Close modal and show success
                    this.hideModal();
                    this.showSuccessMessage();
                    
                    } catch (error) {
                    console.error('❌ Error adding mobile todo:', error);
                    alert('Fehler beim Hinzufügen des Todos: ' + error.message);
                }
            },
            
            showSuccessMessage() {
                // Simple success feedback
                const btn = document.getElementById('mobile-quick-todo-btn');
                if (btn) {
                    const originalHTML = btn.innerHTML;
                    btn.innerHTML = '<i data-lucide="check"></i>';
                    btn.style.background = '#22c55e';
                    
                    // Reinitialize Lucide icons for the check icon
                    if (window.lucide) lucide.createIcons();
                    
                    setTimeout(() => {
                        btn.innerHTML = originalHTML;
                        btn.style.background = 'var(--accent-primary)';
                        if (window.lucide) lucide.createIcons();
                    }, 2000);
                }
            },
            
            // Show/hide mobile button based on screen size
            initMobileDetection() {
                const mobileBtn = document.getElementById('mobile-quick-todo-btn');
                if (!mobileBtn) return;
                
                const checkMobile = () => {
                    // More conservative mobile detection - only show on actual mobile devices
                    const screenWidth = window.innerWidth;
                    const isUserAgentMobile = /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    const hasTouch = ('ontouchstart' in window);
                    
                    // Only show if screen is small AND (mobile user agent OR touch capable)
                    const isMobile = screenWidth <= 768 && (isUserAgentMobile || hasTouch);
                                   
                    if (isMobile) {
                        mobileBtn.style.display = 'flex';
                        console.log('📱 Mobile mode active - showing FAB button');
                    } else {
                        mobileBtn.style.display = 'none';
                        }
                };
                
                // Check on load
                checkMobile();
                
                // Check on resize
                window.addEventListener('resize', checkMobile);
            }
        };
        
        // Make MobileTodoManager globally available
        window.MobileTodoManager = MobileTodoManager;

        // === INTELLIGENT GLOBAL SEARCH COMMAND CENTER ===
        const GlobalSearch = {
            isOpen: false,
            selectedIndex: -1,
            suggestions: [],
            
            toggle() {
                if (this.isOpen) {
                    this.hide();
                } else {
                    this.show();
                }
            },
            
            show() {
                const modal = document.getElementById('global-search-modal');
                const input = document.getElementById('global-search-input');
                
                modal.classList.remove('hide');
                input.focus();
                input.value = '';
                
                this.isOpen = true;
                this.selectedIndex = -1;
                this.showSuggestions();
                
                // Add event listeners
                input.oninput = (e) => this.handleInput(e.target.value);
                document.addEventListener('keydown', this.handleKeydown);
            },
            
            hide() {
                const modal = document.getElementById('global-search-modal');
                modal.classList.add('hide');
                this.isOpen = false;
                this.selectedIndex = -1;
                
                // Remove event listener
                document.removeEventListener('keydown', this.handleKeydown);
            },
            
            handleKeydown(e) {
                if (e.key === 'Escape') {
                    GlobalSearch.hide();
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    GlobalSearch.navigateDown();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    GlobalSearch.navigateUp();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    GlobalSearch.executeSelected();
                }
            },
            
            handleInput(query) {
                if (!query.trim()) {
                    this.showSuggestions();
                    return;
                }
                
                // Handle commands
                if (query.startsWith('/')) {
                    this.handleCommand(query);
                } else if (query.startsWith('@') || query.startsWith('#')) {
                    this.handleSmartFilter(query);
                } else {
                    this.search(query);
                }
            },
            
            async search(query) {
                if (!query || query.length < 2) {
                    this.showSuggestions();
                    return;
                }
                
                const results = [];
                const searchTerm = query.toLowerCase();
                
                // Search Todos (enhanced)
                if (window.TodoManager?.todos) {
                    window.TodoManager.todos
                        .filter(todo => 
                            !todo.completed && 
                            !todo.archived && 
                            (todo.title?.toLowerCase().includes(searchTerm) ||
                            todo.text?.toLowerCase().includes(searchTerm))
                        )
                        .forEach(todo => results.push({
                            type: 'todo',
                            title: todo.title || todo.text,
                            subtitle: `📋 Todo • ${todo.category || 'Uncategorized'}`,
                            icon: '✅',
                            action: () => {
                                GlobalSearch.hide();
                                switchTab('tab-todos');
                                // Scroll to todo if possible
                                setTimeout(() => {
                                    const todoElement = document.querySelector(`[data-todo-id="${todo.id}"]`);
                                    if (todoElement) {
                                        todoElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                        todoElement.style.backgroundColor = 'rgba(255, 235, 59, 0.2)';
                                        setTimeout(() => todoElement.style.backgroundColor = '', 2000);
                                    }
                                }, 100);
                            }
                        }));
                }
                
                // Search Goals (enhanced)
                if (window.GoalManager?.goals) {
                    window.GoalManager.goals
                        .filter(goal => 
                            goal.title?.toLowerCase().includes(searchTerm) ||
                            goal.description?.toLowerCase().includes(searchTerm)
                        )
                        .forEach(goal => results.push({
                            type: 'goal',
                            title: goal.title,
                            subtitle: `🎯 Goal • ${goal.category || 'Uncategorized'}`,
                            icon: '🎯',
                            action: () => {
                                GlobalSearch.hide();
                                switchTab('tab-ziele');
                            }
                        }));
                }
                
                // Search Visions (if VisionCards exists)
                if (window.VisionCards?.visions) {
                    window.VisionCards.visions
                        .filter(vision => 
                            vision.title?.toLowerCase().includes(searchTerm) ||
                            vision.description?.toLowerCase().includes(searchTerm)
                        )
                        .forEach(vision => results.push({
                            type: 'vision',
                            title: vision.title,
                            subtitle: `✨ Vision • ${vision.category || 'Uncategorized'}`,
                            icon: '✨',
                            action: () => {
                                GlobalSearch.hide();
                                switchTab('tab-visions');
                            }
                        }));
                }
                
                // Search Journal entries (enhanced with tags, wiki, weather)
                if (window.JournalManager?.entries) {
                    window.JournalManager.entries
                        .filter(entry => {
                            const titleMatch = entry.title?.toLowerCase().includes(searchTerm);
                            const contentMatch = entry.content?.toLowerCase().includes(searchTerm);
                            
                            // Search in tags
                            let tagsMatch = false;
                            if (entry.tags && Array.isArray(entry.tags)) {
                                tagsMatch = entry.tags.some(tag => 
                                    tag?.toLowerCase().includes(searchTerm)
                                );
                            }
                            
                            // Search in wiki field
                            const wikiMatch = entry.wiki?.toLowerCase().includes(searchTerm);
                            
                            // Search in weather field (if exists)
                            const weatherMatch = entry.weather?.toLowerCase().includes(searchTerm);
                            
                            // Search in mood, reflection, lessons fields
                            const moodMatch = entry.mood?.toLowerCase().includes(searchTerm);
                            const reflectionMatch = entry.reflection?.toLowerCase().includes(searchTerm);
                            const lessonsMatch = entry.lessons?.toLowerCase().includes(searchTerm);
                            
                            const match = titleMatch || contentMatch || tagsMatch || wikiMatch || weatherMatch || moodMatch || reflectionMatch || lessonsMatch;
                            
                            if (match) {
                                console.log('  - Title:', titleMatch ? '✓' : '✗');
                                console.log('  - Content:', contentMatch ? '✓' : '✗');
                                console.log('  - Tags:', tagsMatch ? '✓' : '✗', entry.tags);
                                console.log('  - Wiki:', wikiMatch ? '✓' : '✗');
                                console.log('  - Weather:', weatherMatch ? '✓' : '✗');
                                console.log('  - Mood:', moodMatch ? '✓' : '✗');
                            }
                            return match;
                        })
                        .forEach(entry => results.push({
                            type: 'journal',
                            title: entry.title || 'Untitled Entry',
                            subtitle: `📝 Journal • ${entry.date || entry.created_at?.split('T')[0] || 'No date'}`,
                            icon: '📝',
                            action: () => {
                                GlobalSearch.hide();
                                switchTab('tab-journal');
                                // Try to highlight the specific entry
                                setTimeout(() => {
                                    const entryElement = document.querySelector(`[data-entry-id="${entry.id}"]`);
                                    if (entryElement) {
                                        entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                        entryElement.style.backgroundColor = 'rgba(255, 235, 59, 0.2)';
                                        setTimeout(() => entryElement.style.backgroundColor = '', 2000);
                                    }
                                }, 100);
                            }
                        }));
                }
                
                // Search Termine
                if (window.TerminManager?.termine) {
                    window.TerminManager.termine
                        .filter(termin => 
                            termin.title?.toLowerCase().includes(searchTerm) ||
                            termin.description?.toLowerCase().includes(searchTerm)
                        )
                        .forEach(termin => results.push({
                            type: 'termin',
                            title: termin.title,
                            subtitle: `📅 Termin • ${termin.date || 'No date'}`,
                            icon: '📅',
                            action: () => {
                                GlobalSearch.hide();
                                switchTab('tab-home');
                            }
                        }));
                }
                
                this.displayResults(results.slice(0, 15)); // Limit to 15 results
            },
            
            handleCommand(query) {
                const commands = [];
                const cmd = query.toLowerCase().slice(1); // Remove '/' prefix
                
                // Show command suggestions (no immediate execution)
                if (cmd.startsWith('add') || cmd.startsWith('new') || cmd === 'add' || cmd === 'new') {
                    commands.push({
                        title: '/add Todo - Schnell neuen Todo erstellen',
                        subtitle: 'Command • Todo hinzufügen',
                        icon: '➕',
                        action: () => {
                            GlobalSearch.hide();
                            switchTab('tab-todos');
                            setTimeout(() => {
                                const addBtn = document.querySelector('[onclick="TodoManager.createTodo()"]');
                                if (addBtn) addBtn.click();
                            }, 100);
                        }
                    });
                    
                    commands.push({
                        title: '/new Goal - Neues Ziel erstellen',
                        subtitle: 'Command • Ziel hinzufügen',
                        icon: '🎯',
                        action: () => {
                            GlobalSearch.hide();
                            switchTab('tab-ziele');
                            setTimeout(() => {
                                const addBtn = document.querySelector('#goals-section [onclick*="createGoal"]');
                                if (addBtn) addBtn.click();
                            }, 100);
                        }
                    });
                }
                
                if (cmd.startsWith('timer') || cmd.startsWith('pomodoro') || cmd === 'timer' || cmd === 'pomodoro') {
                    commands.push({
                        title: '/timer - Pomodoro Timer starten',
                        subtitle: 'Command • Timer öffnen',
                        icon: '⏰',
                        action: () => {
                            GlobalSearch.hide();
                            if (window.PomodoroTimer) {
                                window.PomodoroTimer.toggle();
                                // Update dynamic buttons to show/hide the red timer button
                                if (window.QuickBar) {
                                    window.QuickBar.updateDynamicButtons();
                                }
                            }
                        }
                    });
                }
                
                if (cmd.startsWith('dark') || cmd.startsWith('theme') || cmd === 'dark' || cmd === 'theme') {
                    commands.push({
                        title: '/dark - Dark Mode umschalten',
                        subtitle: 'Command • Theme wechseln',
                        icon: '🌙',
                        action: () => {
                            GlobalSearch.hide();
                            if (window.toggleTheme) {
                                window.toggleTheme();
                            }
                        }
                    });
                }
                
                if (cmd.startsWith('help') || cmd.startsWith('commands') || cmd === 'help' || cmd === 'commands' || cmd === '?') {
                    commands.push({
                        title: '/help - Alle verfügbaren Kommandos anzeigen',
                        subtitle: 'Command • Hilfe & Übersicht',
                        icon: '❓',
                        action: () => {
                            GlobalSearch.showHelp();
                        }
                    });
                }
                
                if (cmd.startsWith('rules') || cmd.startsWith('trading') || cmd === 'rules' || cmd === 'trading') {
                    commands.push({
                        title: '/rules - Trading Rules öffnen',
                        subtitle: 'Command • Trading Regeln & Disziplin',
                        icon: '📊',
                        action: () => {
                            GlobalSearch.hide();
                            switchTab('tab-trading-rules');
                        }
                    });
                }
                
                this.displayResults(commands);
            },
            
            handleSmartFilter(query) {
                const results = [];
                const filter = query.toLowerCase();
                
                if (filter.startsWith('@')) {
                    // Smart filters: @todos, @goals, @today, etc.
                    if (filter.includes('todo')) {
                        if (window.TodoManager?.todos) {
                            const activeTodos = window.TodoManager.todos.filter(t => !t.completed && !t.archived);
                            results.push({
                                title: `@todos - ${activeTodos.length} aktive Todos`,
                                subtitle: 'Smart Filter • Alle offenen Todos anzeigen',
                                icon: '📋',
                                action: () => {
                                    GlobalSearch.hide();
                                    switchTab('tab-todos');
                                }
                            });
                        }
                    }
                    
                    if (filter.includes('today') || filter.includes('heute')) {
                        const today = new Date().toISOString().split('T')[0];
                        results.push({
                            title: '@today - Heutige Aufgaben',
                            subtitle: 'Smart Filter • Nur heutige Items',
                            icon: '📅',
                            action: () => {
                                GlobalSearch.hide();
                                switchTab('tab-home');
                            }
                        });
                    }
                } else if (filter.startsWith('#')) {
                    // Context filters: #overdue, #urgent, #today
                    if (filter.includes('overdue') || filter.includes('überfällig')) {
                        results.push({
                            title: '#overdue - Überfällige Aufgaben',
                            subtitle: 'Context Filter • Überfällige Deadlines',
                            icon: '🚨',
                            action: () => {
                                GlobalSearch.hide();
                                switchTab('tab-home');
                            }
                        });
                    }
                    
                    if (filter.includes('today') || filter.includes('heute')) {
                        results.push({
                            title: '#today - Heutiger Fokus',
                            subtitle: 'Context Filter • Für heute geplant',
                            icon: '🎯',
                            action: () => {
                                GlobalSearch.hide();
                                switchTab('tab-home');
                            }
                        });
                    }
                }
                
                this.displayResults(results);
            },
            
            showSuggestions() {
                const suggestions = [
                    {
                        title: 'Typ "/add" für schnellen Todo',
                        subtitle: 'Quick Commands • Schnelle Aktionen',
                        icon: '💡',
                        action: () => {
                            document.getElementById('global-search-input').value = '/add ';
                            document.getElementById('global-search-input').focus();
                        }
                    },
                    {
                        title: 'Typ "@todos" für alle Todos',
                        subtitle: 'Smart Filters • Intelligente Filter',
                        icon: '📋',
                        action: () => {
                            document.getElementById('global-search-input').value = '@todos';
                            this.handleSmartFilter('@todos');
                        }
                    },
                    {
                        title: 'Typ "/timer" für Pomodoro',
                        subtitle: 'Quick Commands • Timer starten',
                        icon: '⏰',
                        action: () => {
                            document.getElementById('global-search-input').value = '/timer';
                            this.handleCommand('/timer');
                        }
                    },
                    {
                        title: 'Typ "/help" für alle Kommandos',
                        subtitle: 'Help • Vollständige Übersicht',
                        icon: '❓',
                        action: () => {
                            document.getElementById('global-search-input').value = '/help';
                            this.handleCommand('/help');
                        }
                    },
                    {
                        title: 'Einfach tippen zum Suchen',
                        subtitle: 'Global Search • Alle Bereiche durchsuchen',
                        icon: '🔍',
                        action: () => {}
                    }
                ];
                
                this.displayResults(suggestions);
            },
            
            navigateDown() {
                const items = document.querySelectorAll('.search-result-item');
                if (items.length === 0) return;
                
                this.selectedIndex = Math.min(this.selectedIndex + 1, items.length - 1);
                this.updateSelection(items);
            },
            
            navigateUp() {
                const items = document.querySelectorAll('.search-result-item');
                if (items.length === 0) return;
                
                this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
                this.updateSelection(items);
            },
            
            updateSelection(items) {
                items.forEach((item, index) => {
                    if (index === this.selectedIndex) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });
            },
            
            executeSelected() {
                const items = document.querySelectorAll('.search-result-item');
                
                // If no item is selected, select the first one
                if (this.selectedIndex === -1 && items.length > 0) {
                    this.selectedIndex = 0;
                    this.updateSelection(items);
                }
                
                // Execute the selected (or first) item
                if (items[this.selectedIndex]) {
                    items[this.selectedIndex].click();
                }
            },
            
            displayResults(results) {
                const container = document.getElementById('search-results');
                
                if (!container) {
                    console.error('Search results container not found');
                    return;
                }
                
                if (results.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">No results found</div>';
                    return;
                }
                
                this.selectedIndex = -1; // Reset selection
                container.innerHTML = '';
                
                results.forEach((result, index) => {
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'search-result-item';
                    resultDiv.innerHTML = `
                        <div class="search-result-content">
                            <div class="search-result-icon">${result.icon || '📄'}</div>
                            <div class="search-result-text">
                                <div class="search-result-title">${result.title}</div>
                                <div class="search-result-subtitle">${result.subtitle}</div>
                            </div>
                        </div>
                    `;
                    resultDiv.onclick = result.action;
                    container.appendChild(resultDiv);
                });
            },
            
            showHelp() {
                const helpItems = [
                    {
                        title: '🚀 Quick Commands',
                        subtitle: 'Schnelle Aktionen für produktives Arbeiten',
                        icon: '⚡',
                        action: () => {}
                    },
                    {
                        title: '/add - Neuen Todo erstellen',
                        subtitle: 'Öffnet Todo-Dialog für schnelle Aufgabe',
                        icon: '➕',
                        action: () => {
                            GlobalSearch.hide();
                            switchTab('tab-todos');
                            setTimeout(() => {
                                const addBtn = document.querySelector('[onclick="TodoManager.createTodo()"]');
                                if (addBtn) addBtn.click();
                            }, 100);
                        }
                    },
                    {
                        title: '/new - Neues Ziel erstellen',
                        subtitle: 'Öffnet Goal-Dialog für neues Ziel',
                        icon: '🎯',
                        action: () => {
                            GlobalSearch.hide();
                            switchTab('tab-ziele');
                            setTimeout(() => {
                                const addBtn = document.querySelector('#goals-section [onclick*="createGoal"]');
                                if (addBtn) addBtn.click();
                            }, 100);
                        }
                    },
                    {
                        title: '/timer - Pomodoro Timer starten',
                        subtitle: 'Startet/stoppt den Fokus-Timer',
                        icon: '⏰',
                        action: () => {
                            GlobalSearch.hide();
                            if (window.PomodoroTimer) {
                                window.PomodoroTimer.toggle();
                                if (window.QuickBar) {
                                    window.QuickBar.updateDynamicButtons();
                                }
                            }
                        }
                    },
                    {
                        title: '/dark - Theme umschalten',
                        subtitle: 'Wechselt zwischen Hell- und Dunkelmodus',
                        icon: '🌙',
                        action: () => {
                            GlobalSearch.hide();
                            if (window.toggleTheme) {
                                window.toggleTheme();
                            }
                        }
                    },
                    {
                        title: '',
                        subtitle: '',
                        icon: '',
                        action: () => {}
                    },
                    {
                        title: '🔍 Smart Filters',
                        subtitle: 'Intelligente Filter für schnelle Navigation',
                        icon: '🎯',
                        action: () => {}
                    },
                    {
                        title: '@todos - Alle aktiven Todos',
                        subtitle: 'Zeigt Übersicht aller offenen Aufgaben',
                        icon: '📋',
                        action: () => {
                            GlobalSearch.hide();
                            switchTab('tab-todos');
                        }
                    },
                    {
                        title: '@today - Heutige Aufgaben',
                        subtitle: 'Filtert nach heutigen Terminen und Tasks',
                        icon: '📅',
                        action: () => {
                            GlobalSearch.hide();
                            switchTab('tab-home');
                        }
                    },
                    {
                        title: '#overdue - Überfällige Items',
                        subtitle: 'Zeigt alle überfälligen Deadlines',
                        icon: '🚨',
                        action: () => {
                            GlobalSearch.hide();
                            switchTab('tab-home');
                        }
                    },
                    {
                        title: '#today - Heutiger Fokus',
                        subtitle: 'Kontext-Filter für heutige Prioritäten',
                        icon: '⭐',
                        action: () => {
                            GlobalSearch.hide();
                            switchTab('tab-home');
                        }
                    },
                    {
                        title: '',
                        subtitle: '',
                        icon: '',
                        action: () => {}
                    },
                    {
                        title: '⌨️ Keyboard Shortcuts',
                        subtitle: 'Tastenkombinationen für schnellen Zugriff',
                        icon: '⚡',
                        action: () => {}
                    },
                    {
                        title: 'Ctrl+K / Ctrl+Space / F3 - Search öffnen',
                        subtitle: 'Öffnet Command Center von überall',
                        icon: '🔍',
                        action: () => {}
                    },
                    {
                        title: 'Pfeiltasten + Enter - Navigation',
                        subtitle: 'Navigiere durch Ergebnisse und bestätige',
                        icon: '⬆️',
                        action: () => {}
                    },
                    {
                        title: 'Escape - Schließen',
                        subtitle: 'Schließt das Command Center',
                        icon: '❌',
                        action: () => {}
                    },
                    {
                        title: '',
                        subtitle: '',
                        icon: '',
                        action: () => {}
                    },
                    {
                        title: '🔎 Global Search',
                        subtitle: 'Durchsuche alle Bereiche gleichzeitig',
                        icon: '🌐',
                        action: () => {}
                    },
                    {
                        title: 'Einfach tippen - Universelle Suche',
                        subtitle: 'Durchsucht Todos, Goals, Visions, Journal, Termine',
                        icon: '🔍',
                        action: () => {}
                    },
                    {
                        title: 'Journal-Suche - Alle Felder',
                        subtitle: 'Sucht in Title, Content, Tags, Wiki, Weather, Mood',
                        icon: '📝',
                        action: () => {}
                    }
                ];
                
                this.displayResults(helpItems);
            },
            
            clearResults() {
                this.showSuggestions();
            }
        };
        
        // Make GlobalSearch globally available
        window.GlobalSearch = GlobalSearch;
        
        // === GLOBAL KEYBOARD SHORTCUTS ===
        // Add global keyboard shortcuts for search
        document.addEventListener('keydown', function(e) {
            // Ctrl+K or Cmd+K to open global search from anywhere
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                
                // Don't open if search is already open or if we're in an input field
                if (!GlobalSearch.isOpen && !['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                    GlobalSearch.show();
                }
                return false;
            }
            
            // Alternative: Ctrl+Space as backup shortcut
            if (e.ctrlKey && e.code === 'Space') {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                
                if (!GlobalSearch.isOpen && !['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                    GlobalSearch.show();
                }
                return false;
            }
            
            // Alternative: F3 as another backup
            if (e.key === 'F3') {
                e.preventDefault();
                e.stopPropagation();
                
                if (!GlobalSearch.isOpen) {
                    GlobalSearch.show();
                }
                return false;
            }
        }, true); // Use capture phase to intercept before browser

        // === GOAL MANAGEMENT ===
        const GoalManager = {
            goals: [], // In-memory storage for demo
            
            async loadGoals() {
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('GoalManager');
                    this.goals = [];
                    return;
                }
                
                try {
                    const user = supabase.getCurrentUser();
                    const data = await supabase.query(`goals?user_id=eq.${user.id}&select=*`);
                    if (data && Array.isArray(data)) {
                        // Transform database data to match UI expectations
                        this.goals = data.map(goal => {
                            return {
                                ...goal,
                                name: goal.title, // Map title to name for UI
                                deadline: goal.target_date, // Map target_date to deadline for UI
                                progress: goal.progress || 0, // Use DB progress field
                                timeframe: goal.timeframe || 'monat', // Use DB timeframe field
                                completed: goal.completed, // Use DB completed field
                                // Map new progress fields
                                startValue: goal.start_value,
                                targetValue: goal.target_value, 
                                currentValue: goal.current_value,
                                unit: goal.unit
                            };
                        });
                        this.refreshCurrentView();
                    } else {
                        this.goals = [];
                    }
                } catch (error) {
                    console.error('❌ GoalManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            // Calculate automatic deadlines based on timeframe
            calculateDeadline(timeframe) {
                const now = new Date();
                
                switch(timeframe) {
                    case 'monat': {
                        // Last day of current month - use day 0 of next month
                        const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                        // Format manually to avoid timezone issues
                        const year = endOfMonth.getFullYear();
                        const month = String(endOfMonth.getMonth() + 1).padStart(2, '0');
                        const day = String(endOfMonth.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    case 'quartal': {
                        // Last day of current quarter
                        const currentQuarter = Math.floor(now.getMonth() / 3);
                        const quarterEndMonth = (currentQuarter + 1) * 3; // 3, 6, 9, 12
                        const endOfQuarter = new Date(now.getFullYear(), quarterEndMonth, 0);
                        // Format manually to avoid timezone issues
                        const year = endOfQuarter.getFullYear();
                        const month = String(endOfQuarter.getMonth() + 1).padStart(2, '0');
                        const day = String(endOfQuarter.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    case 'jahr': {
                        // December 31st of current year
                        const year = now.getFullYear();
                        return `${year}-12-31`;
                    }
                    default:
                        return now.toISOString().split('T')[0];
                }
            },
            
            showAddGoalModal() {
                const modal = document.getElementById('add-goal-modal');
                modal.classList.remove('hide');
                
                // Set default deadline based on current timeframe selection
                const timeframeSelect = document.getElementById('goal-timeframe');
                const deadlineInput = document.getElementById('goal-deadline');
                if (timeframeSelect && deadlineInput) {
                    deadlineInput.value = this.calculateDeadline(timeframeSelect.value);
                }
            },
            
            hideAddGoalModal() {
                const modal = document.getElementById('add-goal-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-goal-form').reset();
            },
            
            calculateProgress(startValue, targetValue, currentValue) {
                if (startValue === targetValue) return 100; // Edge case
                const progress = ((currentValue - startValue) / (targetValue - startValue)) * 100;
                return Math.max(0, Math.min(100, Math.round(progress))); // Clamp between 0-100
            },
            
            async addGoal(goalData) {
                const goal = {
                    id: Date.now().toString(),
                    name: goalData.name,
                    description: goalData.description,
                    category: goalData.category,
                    timeframe: goalData.timeframe, // WICHTIG: timeframe für Filterung
                    deadline: goalData.deadline,
                    unit: goalData.unit || '',
                    startValue: goalData.startValue || 0,
                    targetValue: goalData.targetValue,
                    currentValue: goalData.startValue || 0, // Start with start value
                    progress: 0, // Will be calculated
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                // Calculate initial progress
                goal.progress = this.calculateProgress(goal.startValue, goal.targetValue, goal.currentValue);
                
                console.log('🎯 Created goal with progress data:', {
                    name: goal.name,
                    startValue: goal.startValue,
                    targetValue: goal.targetValue,
                    currentValue: goal.currentValue,
                    unit: goal.unit,
                    progress: goal.progress
                });
                
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('GoalManager', 'add goals');
                    alert('Fehler: Nicht authentifiziert. Ziel kann nicht gespeichert werden.');
                    return;
                }
                
                try {
                    // Parse numeric values from text inputs like "5 SOL" -> 5
                    const parseValue = (value) => {
                        if (!value) return 0;
                        const match = value.toString().match(/[\d.]+/);
                        return match ? parseFloat(match[0]) : 0;
                    };
                    
                    // Extract unit from text inputs like "5 SOL" -> "SOL"
                    const extractUnit = (value) => {
                        if (!value) return '';
                        const match = value.toString().match(/[^\d\s.]+/);
                        return match ? match[0].trim() : '';
                    };
                    
                    // Map UI fields to database schema - all progress fields now supported
                    const dbGoal = {
                        title: goal.name,
                        description: goal.description,
                        category: goal.category,
                        target_date: goal.deadline,
                        progress: goal.progress || 0,
                        timeframe: goal.timeframe || '',
                        completed: goal.completed || false,
                        start_value: parseValue(goal.startValue),
                        target_value: parseValue(goal.targetValue), 
                        current_value: parseValue(goal.currentValue || goal.startValue),
                        unit: extractUnit(goal.targetValue) || extractUnit(goal.startValue) || '',
                        user_id: supabase?.user?.id
                    };
                    
                    const result = await supabase.insert('goals', dbGoal);
                    if (result && Array.isArray(result) && result.length > 0) {
                        // Use database result and transform back to UI format
                        const savedGoal = {
                            ...result[0],
                            name: result[0].title,
                            deadline: result[0].target_date,
                            timeframe: result[0].timeframe,
                            progress: result[0].progress,
                            completed: result[0].completed,
                            startValue: result[0].start_value,
                            targetValue: result[0].target_value,
                            currentValue: result[0].current_value,
                            unit: result[0].unit,
                            database_id: result[0].id // Store real DB ID for updates
                        };
                        this.goals.push(savedGoal);
                        } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ GoalManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Ziels: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('Goal added:', goal);
                console.log('All goals after adding:', this.goals);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.ziel-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-ziel-category') : 'alle';
                
                console.log('🎯 Goals refresh - active category:', activeCategory);
                console.log('🎯 All goals:', this.goals.map(g => ({name: g.name, category: g.category, timeframe: g.timeframe})));
                
                this.displayGoalsForCategory(activeCategory);
            },
            
            displayGoalsForCategory(category = 'alle') {
                const container = document.getElementById('goals-list');
                if (!container) return;
                
                // Show all active goals (no category filtering)
                const filteredGoals = this.goals.filter(goal => !goal.completed);
                
                // Sort by deadline
                filteredGoals.sort((a, b) => new Date(a.deadline) - new Date(b.deadline));
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredGoals.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Ziele vorhanden</p>';
                    return;
                }
                
                // Create grid for goals
                const grid = document.createElement('div');
                grid.className = 'grid-2';
                
                // Display goals
                filteredGoals.forEach(goal => {
                    const goalElement = this.createGoalElement(goal);
                    grid.appendChild(goalElement);
                });
                
                container.appendChild(grid);
            },
            
            createGoalElement(goal) {
                const goalCard = document.createElement('div');
                goalCard.className = `termin-card${goal.completed ? ' completed' : ''}`;
                goalCard.dataset.goalId = goal.id;
                
                // Calculate days until deadline (exactly like termine)
                let daysUntilText = '';
                let badgeColor1 = '';
                let badgeColor2 = '';
                let formattedDeadline = '';
                
                if (goal.deadline) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const goalDate = new Date(goal.deadline);
                    goalDate.setHours(0, 0, 0, 0);
                    const daysDifference = Math.ceil((goalDate - today) / (1000 * 60 * 60 * 24));
                    
                    // Format deadline like termine
                    formattedDeadline = goalDate.toLocaleDateString('de-DE', {
                        weekday: 'long',
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric'
                    });
                    
                    // Badge styling (exactly like termine)
                    if (daysDifference === 0) {
                        daysUntilText = 'Heute';
                        badgeColor1 = '#ef4444';
                        badgeColor2 = '#dc2626';
                    } else if (daysDifference === 1) {
                        daysUntilText = 'Morgen';
                        badgeColor1 = '#f97316';
                        badgeColor2 = '#ea580c';
                    } else if (daysDifference === -1) {
                        daysUntilText = 'Gestern';
                        badgeColor1 = '#6b7280';
                        badgeColor2 = '#4b5563';
                    } else if (daysDifference > 1) {
                        daysUntilText = `in ${daysDifference} Tagen`;
                        badgeColor1 = '#3b82f6';
                        badgeColor2 = '#2563eb';
                    } else if (daysDifference < -1) {
                        daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                        badgeColor1 = '#6b7280';
                        badgeColor2 = '#4b5563';
                    }
                }
                
                // Set CSS custom properties for badge colors (like terme)
                const badgeColorVars = `--badge-color-1: ${badgeColor1}; --badge-color-2: ${badgeColor2};`;
                goalCard.style.cssText += badgeColorVars;
                
                // Prepare progress display  
                const hasProgressData = goal.hasOwnProperty('startValue') && goal.hasOwnProperty('targetValue');
                const progressSection = hasProgressData ? `
                    <div class="goal-progress-section" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0;">
                        <div class="goal-values" style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem; color: #666;">
                            <span>${goal.startValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                            <span style="font-weight: 600; color: #000;">${goal.currentValue || goal.startValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                            <span>${goal.targetValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                        </div>
                        <div class="progress-container" style="background: #f0f0f0; height: 6px; border-radius: 3px; overflow: hidden;">
                            <div class="progress-fill" style="background: linear-gradient(90deg, #3b82f6, #1d4ed8); height: 100%; width: ${goal.progress || 0}%; transition: width 0.3s ease;"></div>
                        </div>
                        <div style="text-align: center; margin-top: 0.5rem; font-size: 0.9rem; font-weight: 600; color: #1d4ed8;">
                            ${goal.progress || 0}%
                        </div>
                    </div>
                ` : '';
                
                goalCard.innerHTML = `
                    ${daysUntilText ? `<div class="ziel-days-until">${daysUntilText}</div>` : ''}
                    <div class="ziel-kategorie">${goal.category}</div>
                    ${formattedDeadline ? `<div class="termin-date">🎯 ${formattedDeadline}</div>` : ''}
                    <div class="termin-title">${goal.name}</div>
                    <div class="termin-description">${InternalLinkParser.parseInternalLinks(goal.description)}</div>
                    ${progressSection}
                    <div class="termin-edit-icon" onclick="GoalManager.showEditGoalValueModal('${goal.id}')">✎</div>
                    <div class="termin-delete-icon" onclick="GoalManager.deleteGoal('${goal.id}')">🗑</div>
                `;
                
                return goalCard;
            },
            
            async updateGoalProgress(goalId, newProgress) {
                const goal = this.goals.find(g => g.id == goalId); // Use == for flexible ID matching
                if (goal) {
                    const oldProgress = goal.progress;
                    goal.progress = parseInt(newProgress);
                    goal.completed = goal.progress >= 100;
                    
                    console.log('🎯 Updating goal:', goal.name, 'to progress:', goal.progress);
                    
                    // Check if goal has real database ID or use database_id field
                    const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                    
                    if (supabase?.isAuthenticated() && dbId) {
                        try {
                            const result = await supabase.update('goals', { 
                                progress: goal.progress,
                                completed: goal.completed
                            }, dbId);
                            } catch (error) {
                            console.error('❌ Error updating goal progress:', error);
                            // Don't revert - keep local change even if DB fails
                            console.warn('⚠️ Goal updated locally only (database update failed)');
                        }
                    } else {
                        console.warn('⚠️ Goal updated locally only (no database ID or not authenticated)');
                    }
                    
                    this.refreshCurrentView();
                } else {
                    console.error('❌ Goal not found for ID:', goalId);
                }
            },
            
            showEditGoalValueModal(goalId) {
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                const currentValue = goal.currentValue || goal.startValue || 0;
                const unit = goal.unit ? ` ${goal.unit}` : '';
                
                // Set modal title and current status
                document.getElementById('edit-goal-modal-title').textContent = `Fortschritt für "${goal.name}"`;
                document.getElementById('edit-goal-current-status').innerHTML = `
                    <strong>Aktueller Status:</strong><br>
                    Start: <strong>${goal.startValue}${unit}</strong> → 
                    Ziel: <strong>${goal.targetValue}${unit}</strong><br>
                    Aktuell: <strong>${currentValue}${unit}</strong> 
                    (${goal.progress || 0}% erreicht)
                `;
                
                // Pre-fill current value
                document.getElementById('new-goal-value').value = currentValue;
                
                // Store goal ID for form submission
                document.getElementById('edit-goal-value-form').dataset.goalId = goalId;
                
                // Show modal
                document.getElementById('edit-goal-value-modal').classList.remove('hide');
                
                // Ensure event listeners are set up when modal opens
                console.log('🎯 Modal opened, reinitializing event listeners...');
                if (window.initGoalEditModalEventListeners) {
                    window.initGoalEditModalEventListeners();
                }
                
                // Focus input
                setTimeout(() => {
                    document.getElementById('new-goal-value').focus();
                    document.getElementById('new-goal-value').select();
                }, 100);
            },
            
            hideEditGoalValueModal() {
                document.getElementById('edit-goal-value-modal').classList.add('hide');
                document.getElementById('edit-goal-value-form').reset();
                delete document.getElementById('edit-goal-value-form').dataset.goalId;
            },
            
            async editGoalValue(goalId) {
                console.log('🎯 editGoalValue called with goalId:', goalId);
                
                // This method is now called by the modal form submission
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    console.error('❌ Goal not found for ID:', goalId);
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                console.log('🎯 Found goal:', goal.name, 'Current value:', goal.currentValue);
                
                const newValueInput = document.getElementById('new-goal-value').value;
                console.log('🎯 Input value:', newValueInput);
                
                const newValue = parseFloat(newValueInput);
                if (isNaN(newValue)) {
                    console.error('❌ Invalid number:', newValueInput);
                    alert('Bitte eine gültige Zahl eingeben!');
                    return;
                }
                
                console.log('🎯 Parsed new value:', newValue);
                
                // Pure cloud mode - require authentication
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('GoalManager', 'update goals');
                    alert('Fehler: Nicht authentifiziert. Ziel-Wert kann nicht aktualisiert werden.');
                    return;
                }
                
                const unit = goal.unit ? ` ${goal.unit}` : '';
                
                // Update values
                const oldCurrentValue = goal.currentValue;
                const oldProgress = goal.progress;
                
                goal.currentValue = newValue;
                goal.progress = this.calculateProgress(goal.startValue, goal.targetValue, goal.currentValue);
                goal.completed = goal.progress >= 100;
                
                console.log('🎯 Updated values:', {
                    oldCurrentValue,
                    newCurrentValue: goal.currentValue,
                    oldProgress,
                    newProgress: goal.progress,
                    startValue: goal.startValue,
                    targetValue: goal.targetValue
                });
                
                // Update in database - use database ID
                const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                console.log('🎯 Database ID for update:', dbId);
                
                if (dbId) {
                    try {
                        const updateData = { 
                            current_value: goal.currentValue, // Use DB field name
                            progress: goal.progress,
                            completed: goal.completed
                        };
                        await supabase.update('goals', updateData, dbId);
                        } catch (error) {
                        console.error('❌ Error updating goal value:', error);
                        alert('Fehler beim Speichern: ' + error.message);
                        return;
                    }
                } else {
                    console.error('❌ No valid database ID found for goal:', goal);
                    alert('Fehler: Kann Ziel nicht in der Datenbank aktualisieren (keine gültige ID).');
                    return;
                }
                
                // Hide modal and refresh view
                console.log('🎯 Hiding modal and refreshing view...');
                this.hideEditGoalValueModal();
                this.refreshCurrentView();
                
                },
            
            async deleteGoal(goalId) {
                if (!confirm('Dieses Ziel ins Archiv verschieben?\n\n(Es wird als abgeschlossen markiert und ins Archiv verschoben)')) {
                    return;
                }
                
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    console.error('❌ Goal not found for archiving:', goalId);
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                console.log('📦 Archiving goal:', goal.name);
                
                // Mark as completed (move to archive)
                const oldCompleted = goal.completed;
                goal.completed = true;
                goal.progress = 100; // Set to 100% when archived
                
                // Update in database if authenticated and has real DB ID
                const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                
                if (supabase?.isAuthenticated() && dbId) {
                    try {
                        await supabase.update('goals', { 
                            completed: true,
                            progress: 100
                        }, dbId);
                        } catch (error) {
                        console.error('❌ Error archiving goal in database:', error);
                        alert('Fehler beim Archivieren: ' + error.message);
                        // Revert on error
                        goal.completed = oldCompleted;
                        return;
                    }
                }
                
                // Refresh current view
                this.refreshCurrentView();
                
                },
            
            async clearGoalArchive() {
                if (!confirm('Wirklich alle erledigten Ziele dauerhaft löschen?\n\nDiese Aktion kann nicht rückgängig gemacht werden!')) {
                    return;
                }
                
                const completedGoals = this.goals.filter(goal => goal.completed);if (supabase?.isAuthenticated()) {
                    try {
                        // Delete from database (only goals with database IDs)
                        for (const goal of completedGoals) {
                            const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                            if (hasDbId) {
                                await supabase.delete('goals', goal.id);
                                } else {
                                }
                        }
                        } catch (error) {
                        console.error('❌ Error deleting goals from database:', error);
                        alert('Fehler beim Löschen aus der Datenbank: ' + error.message);
                        return;
                    }
                }
                
                // Remove from local array
                this.goals = this.goals.filter(goal => !goal.completed);
                
                // Refresh current view
                this.refreshCurrentView();
                
                alert(`✅ ${completedGoals.length} erledigte Ziele wurden gelöscht!`);
            },
            
            clearLocalGoals() {
                if (confirm('Alle lokalen Ziele löschen? (Nur Ziele die nicht in der Datenbank sind)\n\nDas kann alte/kaputte Ziele entfernen.')) {
                    const before = this.goals.length;
                    // Keep only goals that look like they have database IDs
                    this.goals = this.goals.filter(goal => {
                        const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                        return hasDbId;
                    });
                    const after = this.goals.length;this.refreshCurrentView();
                    alert(`${before - after} lokale Ziele gelöscht!`);
                }
            },
            
            editGoalProgress(goalId) {
                console.log('✏️ Edit goal progress - ID:', goalId, 'Type:', typeof goalId);
                const goal = this.goals.find(g => g.id == goalId); // Flexible matching
                if (!goal) {
                    console.error('❌ Goal not found for edit. ID:', goalId);
                    console.log('❌ Available goals:', this.goals.map(g => ({id: g.id, name: g.name})));
                    return;
                }
                console.log('✏️ Editing goal:', goal.name, 'Current progress:', goal.progress);
                
                // Find the goal card and progress percentage element
                const goalCard = document.querySelector(`[data-goal-id="${goalId}"]`);
                const percentageElement = goalCard.querySelector('.ziel-percentage');
                const progressFill = goalCard.querySelector('.progress-fill');
                
                // Create inline edit container
                const editContainer = document.createElement('div');
                editContainer.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; background: #f9f9f9; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px;';
                
                // Create progress input
                const input = document.createElement('input');
                input.type = 'number';
                input.min = '0';
                input.max = '100';
                input.value = goal.progress;
                input.style.cssText = 'width: 50px; padding: 2px 4px; border: 1px solid #ccc; font-size: 0.9rem; text-align: center;';
                
                // Create complete button
                const completeBtn = document.createElement('button');
                completeBtn.textContent = '✓ Erledigt';
                completeBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; border: 1px solid #28a745; background: #28a745; color: white; border-radius: 3px; cursor: pointer;';
                
                // Create cancel button
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = '×';
                cancelBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; border: 1px solid #ccc; background: #f8f9fa; border-radius: 3px; cursor: pointer;';
                
                editContainer.appendChild(input);
                editContainer.appendChild(completeBtn);
                editContainer.appendChild(cancelBtn);
                
                // Replace percentage display with edit container
                const originalText = percentageElement.textContent;
                percentageElement.replaceWith(editContainer);
                input.focus();
                input.select();
                
                // Prevent double execution
                let isHandled = false;
                
                // Handle save/cancel
                const saveProgress = async () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    const newValue = parseInt(input.value);
                    if (!isNaN(newValue) && newValue >= 0 && newValue <= 100) {
                        await this.updateGoalProgress(goalId, newValue);
                        
                        // Update UI
                        const newPercentageElement = document.createElement('span');
                        newPercentageElement.className = 'ziel-percentage';
                        newPercentageElement.textContent = `${newValue}%`;
                        editContainer.replaceWith(newPercentageElement);
                        
                        // Update progress bar
                        progressFill.style.width = `${newValue}%`;
                        
                        // Refresh view if goal completed
                        if (newValue >= 100) {
                            this.refreshCurrentView();
                        }
                    } else {
                        cancelEdit();
                    }
                };
                
                const markComplete = async () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    await this.updateGoalProgress(goalId, 100);
                    
                    // Update UI
                    const newPercentageElement = document.createElement('span');
                    newPercentageElement.className = 'ziel-percentage';
                    newPercentageElement.textContent = '100%';
                    editContainer.replaceWith(newPercentageElement);
                    
                    // Update progress bar
                    progressFill.style.width = '100%';
                    
                    // Refresh view to move to archive
                    this.refreshCurrentView();
                };
                
                const cancelEdit = () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    const newPercentageElement = document.createElement('span');
                    newPercentageElement.className = 'ziel-percentage';
                    newPercentageElement.textContent = originalText;
                    editContainer.replaceWith(newPercentageElement);
                };
                
                // Event listeners
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveProgress();
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
                
                completeBtn.addEventListener('click', markComplete);
                cancelBtn.addEventListener('click', cancelEdit);
                
                // Auto-save on blur for input
                input.addEventListener('blur', (e) => {
                    // Only if user didn't click on buttons
                    setTimeout(() => {
                        if (!isHandled && document.contains(editContainer)) {
                            saveProgress();
                        }
                    }, 100);
                });
            }
        };

        // Make GoalManager globally available
        window.GoalManager = GoalManager;

        // === INTERNAL LINK PARSER ===
        const InternalLinkParser = {
            // Map of @-links to tab IDs with descriptions
            linkMapping: {
                'trading-rules': { tab: 'tab-trading-rules', description: 'Trading Rules & Disziplin' },
                'goals': { tab: 'tab-ziele', description: 'Ziele & Fortschritt' }, 
                'todos': { tab: 'tab-home', description: 'Todos & Aufgaben' },
                'journal': { tab: 'tab-journal', description: 'Journal & Reflexion' },
                'resources': { tab: 'tab-ressourcen', description: 'Ressourcen & Links' },
                'wiki': { tab: 'tab-wiki', description: 'Wiki & Notizen' },
                'vision': { tab: 'tab-vision', description: 'Vision Board' },
                'termine': { tab: 'tab-home', description: 'Termine & Deadlines' },
                'settings': { tab: 'tab-settings', description: 'Einstellungen' }
            },
            
            // Current autocomplete state
            autocompleteState: {
                isActive: false,
                currentTextarea: null,
                dropdown: null,
                selectedIndex: -1,
                suggestions: [],
                currentAtPosition: -1
            },
            
            parseInternalLinks(text) {
                if (!text) return text;
                
                // Replace @link-name with clickable links
                return text.replace(/@([a-zA-Z-]+)/g, (match, linkName) => {
                    const linkData = this.linkMapping[linkName.toLowerCase()];
                    if (linkData) {
                        return `<a href="#" class="internal-link" data-tab="${linkData.tab}" onclick="InternalLinkParser.navigateToTab('${linkData.tab}'); return false;">@${linkName}</a>`;
                    }
                    return match; // Return original if no mapping found
                });
            },
            
            navigateToTab(tabId) {
                window.devLog('🔗 Internal link navigation to:', tabId);
                if (typeof switchTab === 'function') {
                    switchTab(tabId);
                } else {
                    console.error('❌ switchTab function not available');
                }
            },
            
            // Setup autocomplete for a textarea
            setupAutocomplete(textarea) {
                if (!textarea) return;// Remove existing listeners to prevent duplicates
                textarea.removeEventListener('input', this.handleInput.bind(this));
                textarea.removeEventListener('keydown', this.handleKeydown.bind(this));
                
                // Add event listeners
                textarea.addEventListener('input', this.handleInput.bind(this));
                textarea.addEventListener('keydown', this.handleKeydown.bind(this));
            },
            
            handleInput(event) {
                const textarea = event.target;
                const cursorPos = textarea.selectionStart;
                const text = textarea.value;
                
                // Find @ symbol before cursor
                const textBeforeCursor = text.substring(0, cursorPos);
                const atMatch = textBeforeCursor.match(/@([a-zA-Z-]*)$/);
                
                if (atMatch) {
                    const query = atMatch[1].toLowerCase();
                    const atPosition = textBeforeCursor.lastIndexOf('@');
                    
                    this.autocompleteState.currentAtPosition = atPosition;
                    this.autocompleteState.currentTextarea = textarea;
                    
                    // Filter suggestions based on query
                    const suggestions = Object.keys(this.linkMapping).filter(key => 
                        key.startsWith(query)
                    );
                    
                    if (suggestions.length > 0) {
                        this.showAutocomplete(textarea, suggestions, atPosition, cursorPos);
                    } else {
                        this.hideAutocomplete();
                    }
                } else {
                    this.hideAutocomplete();
                }
            },
            
            handleKeydown(event) {
                if (!this.autocompleteState.isActive) return;
                
                const { suggestions, selectedIndex } = this.autocompleteState;
                
                switch (event.key) {
                    case 'ArrowDown':
                        event.preventDefault();
                        this.autocompleteState.selectedIndex = Math.min(selectedIndex + 1, suggestions.length - 1);
                        this.updateSelection();
                        break;
                        
                    case 'ArrowUp':
                        event.preventDefault();
                        this.autocompleteState.selectedIndex = Math.max(selectedIndex - 1, -1);
                        this.updateSelection();
                        break;
                        
                    case 'Enter':
                    case 'Tab':
                        event.preventDefault();
                        if (selectedIndex >= 0 && selectedIndex < suggestions.length) {
                            this.selectSuggestion(suggestions[selectedIndex]);
                        }
                        break;
                        
                    case 'Escape':
                        this.hideAutocomplete();
                        break;
                }
            },
            
            showAutocomplete(textarea, suggestions, atPosition, cursorPos) {
                this.autocompleteState.isActive = true;
                this.autocompleteState.suggestions = suggestions;
                this.autocompleteState.selectedIndex = 0;
                
                if (!this.autocompleteState.dropdown) {
                    this.createDropdown();
                }
                
                const dropdown = this.autocompleteState.dropdown;
                
                // Clear and populate dropdown
                dropdown.innerHTML = '';
                suggestions.forEach((suggestion, index) => {
                    const linkData = this.linkMapping[suggestion];
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.innerHTML = `
                        <span class="autocomplete-command">@${suggestion}</span>
                        <span class="autocomplete-description">${linkData.description}</span>
                    `;
                    
                    item.addEventListener('click', () => {
                        this.selectSuggestion(suggestion);
                    });
                    
                    dropdown.appendChild(item);
                });
                
                // Position dropdown near cursor
                this.positionDropdown(textarea, atPosition);
                this.updateSelection();
            },
            
            createDropdown() {
                const dropdown = document.createElement('div');
                dropdown.className = 'autocomplete-dropdown';
                dropdown.id = 'internal-link-autocomplete';
                document.body.appendChild(dropdown);
                this.autocompleteState.dropdown = dropdown;
            },
            
            positionDropdown(textarea, atPosition) {
                const dropdown = this.autocompleteState.dropdown;
                
                // Get textarea position
                const textareaRect = textarea.getBoundingClientRect();
                
                // Rough estimate of cursor position (not perfect but good enough)
                const lineHeight = 20;
                const charWidth = 8;
                
                // Calculate approximate cursor position
                const textBeforeAt = textarea.value.substring(0, atPosition);
                const lines = textBeforeAt.split('\n');
                const currentLine = lines.length - 1;
                const currentColumn = lines[lines.length - 1].length;
                
                const left = textareaRect.left + (currentColumn * charWidth);
                const top = textareaRect.top + ((currentLine + 1) * lineHeight);
                
                dropdown.style.left = Math.min(left, window.innerWidth - 300) + 'px';
                dropdown.style.top = Math.min(top, window.innerHeight - 200) + 'px';
                dropdown.style.display = 'block';
            },
            
            updateSelection() {
                const items = this.autocompleteState.dropdown.querySelectorAll('.autocomplete-item');
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === this.autocompleteState.selectedIndex);
                });
            },
            
            selectSuggestion(suggestion) {
                const textarea = this.autocompleteState.currentTextarea;
                const atPosition = this.autocompleteState.currentAtPosition;
                
                if (textarea && atPosition >= 0) {
                    const value = textarea.value;
                    const cursorPos = textarea.selectionStart;
                    
                    // Replace from @ to cursor position
                    const beforeAt = value.substring(0, atPosition);
                    const afterCursor = value.substring(cursorPos);
                    
                    const newValue = beforeAt + '@' + suggestion + ' ' + afterCursor;
                    textarea.value = newValue;
                    
                    // Set cursor after the inserted text
                    const newCursorPos = atPosition + suggestion.length + 2; // +2 for @ and space
                    textarea.setSelectionRange(newCursorPos, newCursorPos);
                    
                    this.hideAutocomplete();
                    textarea.focus();
                }
            },
            
            hideAutocomplete() {
                this.autocompleteState.isActive = false;
                this.autocompleteState.selectedIndex = -1;
                
                if (this.autocompleteState.dropdown) {
                    this.autocompleteState.dropdown.style.display = 'none';
                }
            }
        };
        
        // Make InternalLinkParser global
        window.InternalLinkParser = InternalLinkParser;

        // === JOURNAL MANAGEMENT ===
        const JournalManager = {
            entries: [], // In-memory storage for demo
            filteredEntries: [], // Filtered entries for display
            searchTimeout: null,
            
            async loadEntries() {
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('JournalManager');
                    this.entries = [];
                    return;
                }
                
                try {
                    const data = await supabase.select('journal_entries', '*');
                    if (data && Array.isArray(data)) {
                        // Transform database data to ensure tags is always an array
                        this.entries = data.map(entry => {
                            let tags = [];
                            if (Array.isArray(entry.tags)) {
                                tags = entry.tags;
                            } else if (entry.tags) {
                                if (typeof entry.tags === 'string') {
                                    try {
                                        // Try to parse as JSON first
                                        tags = JSON.parse(entry.tags);
                                        if (!Array.isArray(tags)) {
                                            // If it's not an array, treat as single tag
                                            tags = [entry.tags];
                                        }
                                    } catch (e) {
                                        // If JSON.parse fails, treat as single tag
                                        tags = [entry.tags];
                                    }
                                } else {
                                    tags = [entry.tags];
                                }
                            }
                            return {
                                ...entry,
                                tags: tags
                            };
                        });
                        this.filteredEntries = [...this.entries]; // Initialize filtered entries
                        this.renderEntries();
                    } else {
                        this.entries = [];
                        this.filteredEntries = [];
                    }
                } catch (error) {
                    console.error('❌ JournalManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            showAddJournalModal() {
                const modal = document.getElementById('add-journal-modal');
                modal.classList.remove('hide');
            },
            
            hideAddJournalModal() {
                const modal = document.getElementById('add-journal-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-journal-form').reset();
            },
            
            async addEntry(entryData) {
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('JournalManager', 'add entries');
                    alert('Fehler: Nicht authentifiziert. Journal-Eintrag kann nicht gespeichert werden.');
                    return;
                }
                
                const entry = {
                    title: entryData.title,
                    content: entryData.content,
                    category: entryData.category || 'general',
                    date: entryData.date, // Keep date for local use
                    entry_date: entryData.date, // Use entry_date for database
                    user_id: supabase?.user?.id,
                    created_at: new Date().toISOString()
                };
                
                try {
                    // Create database entry without 'date' and 'created_at' fields (auto-generated)
                    const dbEntry = { ...entry };
                    delete dbEntry.date;
                    delete dbEntry.created_at;
                    const result = await supabase.insert('journal_entries', dbEntry);
                    if (result && result.length > 0) {
                        this.entries.push(result[0]);
                        // AUTOMATICALLY EXTRACT AND SAVE TAGS
                        if (window.cloudStorage && result[0].id) {
                            const fullContent = `${entryData.title} ${entryData.content}`;
                            await window.cloudStorage.saveJournalTags(
                                result[0].id, 
                                entryData.date, 
                                fullContent, 
                                entryData.category || 'general'
                            );
                            }
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ JournalManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Journal-Eintrags: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                // Refresh analytics if initialized
                if (window.JournalTagAnalytics && window.JournalTagAnalytics.isInitialized) {
                    setTimeout(async () => {
                        await window.JournalTagAnalytics.updateCategoryButtons();
                        await window.JournalTagAnalytics.loadAndDisplayAnalytics();
                    }, 200);
                }
                
                // Update filtered entries and refresh view
                this.filteredEntries = [...this.entries];
                this.renderEntries();
            },
            
            renderEntries() {
                const container = document.getElementById('journal-entries');
                if (!container) return;
                
                // Use filteredEntries if available, otherwise use all entries
                const entriesToShow = this.filteredEntries.length > 0 
                    ? this.filteredEntries 
                    : this.entries;
                
                if (this.entries.length === 0) {
                    container.innerHTML = '<div class="empty-journal">Keine Journal-Einträge vorhanden. Erstelle deinen ersten Eintrag!</div>';
                    return;
                }
                
                if (entriesToShow.length === 0) {
                    container.innerHTML = '<div class="empty-journal">Keine Einträge gefunden. Versuche andere Suchbegriffe oder Tags.</div>';
                    return;
                }
                
                // Sort entries by date (newest first)
                const sortedEntries = [...entriesToShow].sort((a, b) => 
                    new Date(b.created_at) - new Date(a.created_at)
                );
                
                let html = '';
                sortedEntries.forEach(entry => {
                    const date = new Date(entry.created_at).toLocaleDateString('de-DE');
                    const time = new Date(entry.created_at).toLocaleTimeString('de-DE', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                    
                    // Parse tags (handle both old category and new tags)
                    let tags = [];
                    if (entry.tags) {
                        if (typeof entry.tags === 'string') {
                            // Handle both comma-separated and JSON array strings
                            if (entry.tags.startsWith('[') && entry.tags.endsWith(']')) {
                                try {
                                    tags = JSON.parse(entry.tags);
                                } catch (e) {
                                    console.warn('Failed to parse JSON tags, using as string:', entry.tags);
                                    tags = [entry.tags];
                                }
                            } else {
                                tags = entry.tags.split(',').map(tag => tag.trim()).filter(tag => tag);
                            }
                        } else if (Array.isArray(entry.tags)) {
                            tags = entry.tags;
                        }
                    }
                    // Don't add category to tags - handle separately
                    
                    const tagsHtml = tags.map(tag => `<span class="journal-tag">${tag}</span>`).join('');
                    const categoryHtml = entry.category ? `<span class="journal-kategorie">${entry.category}</span>` : '';
                    
                    html += `
                        <div class="journal-entry" data-entry-id="${entry.id}">
                            <div class="journal-entry-header">
                                <h3 class="journal-entry-title">${entry.title}</h3>
                                <div class="journal-entry-actions">
                                    <button class="delete-entry-btn" data-entry-id="${entry.id}" title="Eintrag löschen">
                                        <i data-lucide="trash-2" style="width: 16px; height: 16px;"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="journal-entry-content">${InternalLinkParser.parseInternalLinks(entry.content)}</div>
                            <div class="journal-entry-meta">
                                ${categoryHtml}
                                <div class="journal-entry-tags">
                                    ${tagsHtml}
                                </div>
                                <span class="journal-entry-date">${date} • ${time}</span>
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
                
                // Initialize Lucide icons
                if (window.lucide) {
                    lucide.createIcons();
                }
                
                // Add right-click handlers for delete buttons
                this.addDeleteHandlers();
            },

            createEntryElement(entry) {
                const entryCard = document.createElement('div');
                entryCard.className = 'ziel-card';
                entryCard.dataset.entryId = entry.id;
                
                const entryDate = new Date(entry.entry_date || entry.date);
                const formattedDate = entryDate.toLocaleDateString('de-DE', {
                    day: '2-digit',
                    month: '2-digit', 
                    year: 'numeric'
                });
                
                // Ensure tags is always an array before mapping
                const tags = Array.isArray(entry.tags) ? entry.tags : 
                           (entry.tags ? (typeof entry.tags === 'string' ? JSON.parse(entry.tags) : []) : []);
                const tagsHtml = tags.length > 0 
                    ? tags.map(tag => `<span class="todo-tag normal" style="margin-right: 0.5rem;">${tag}</span>`).join('')
                    : '';
                
                entryCard.innerHTML = `
                    <div class="ziel-header">
                        <div class="ziel-name">${entry.title}</div>
                        <div class="ziel-beschreibung">${entry.content}</div>
                    </div>
                    <div class="ziel-progress-section">
                        <div class="ziel-progress-header">
                            <span class="ziel-progress-label">${formattedDate}</span>
                            <button class="delete-entry-btn" data-entry-id="${entry.id}" style="background: none; border: none; color: #cc0000; cursor: pointer; padding: 0.25rem; font-size: 0.9rem;" title="Eintrag löschen">
                                🗑️
                            </button>
                        </div>
                        <div style="margin-top: 0.5rem;">
                            ${tagsHtml}
                        </div>
                    </div>
                `;
                
                return entryCard;
            },
            
            async deleteEntry(entryId) {
                try {
                    // Delete from database if authenticated
                    if (supabase?.isAuthenticated()) {
                        // Delete journal entry
                        await supabase.delete('journal_entries', entryId);
                        // Delete associated tags
                        if (window.cloudStorage) {
                            await supabase.delete('journal_tags', `journal_entry_id=eq.${entryId}`);
                            }
                    }
                    
                    // Remove from local entries array
                    this.entries = this.entries.filter(entry => entry.id != entryId);
                    this.filteredEntries = this.filteredEntries.filter(entry => entry.id != entryId);
                    
                    // Refresh current view
                    this.renderEntries();
                    
                    // Refresh analytics if initialized
                    if (window.JournalTagAnalytics && window.JournalTagAnalytics.isInitialized) {
                        setTimeout(async () => {
                            await window.JournalTagAnalytics.updateCategoryButtons();
                            await window.JournalTagAnalytics.loadAndDisplayAnalytics();
                        }, 100);
                    }
                    
                    } catch (error) {
                    console.error('❌ Error deleting journal entry:', error);
                    alert('Fehler beim Löschen des Eintrags: ' + error.message);
                }
            },

            addDeleteHandlers() {
                document.querySelectorAll('.journal-entry').forEach(entry => {
                    entry.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        
                        // Hide all other delete buttons first
                        document.querySelectorAll('.journal-entry').forEach(el => {
                            el.classList.remove('show-delete');
                        });
                        
                        // Show delete button for this entry
                        entry.classList.add('show-delete');
                        
                        // Hide delete button after 3 seconds
                        setTimeout(() => {
                            entry.classList.remove('show-delete');
                        }, 3000);
                    });
                    
                    // Hide delete button on regular click
                    entry.addEventListener('click', (e) => {
                        // Don't hide if clicking the delete button
                        if (!e.target.closest('.delete-entry-btn')) {
                            entry.classList.remove('show-delete');
                        }
                    });
                    
                    // Add delete button click handler
                    const deleteBtn = entry.querySelector('.delete-entry-btn');
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const entryId = deleteBtn.getAttribute('data-entry-id');
                            this.deleteEntry(entryId);
                        });
                    }
                });
            },

            search() {
                // Search disabled - no search bar available
                this.filteredEntries = this.entries;
                this.renderEntries();
            },

            getEntryTags(entry) {
                let tags = [];
                if (entry.tags) {
                    if (typeof entry.tags === 'string') {
                        tags = entry.tags.split(',').map(tag => tag.trim()).filter(tag => tag);
                    } else if (Array.isArray(entry.tags)) {
                        tags = entry.tags;
                    }
                } else if (entry.category) {
                    // Migration: use old category as a tag
                    tags = [entry.category];
                }
                return tags;
            }
        };

        // Make JournalManager globally available
        window.JournalManager = JournalManager;

        // === TERMIN MANAGEMENT ===
        const TerminManager = {
            termine: [], // In-memory storage for demo
            
            async loadTermine(forceReload = false) {
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('TerminManager');
                    this.termine = [];
                    this.displayTermine();
                    return;
                }
                
                try {
                    const user = supabase.getCurrentUser();
                    const data = await supabase.query(`termine?user_id=eq.${user.id}&select=*`);
                    
                    if (data && Array.isArray(data)) {
                        this.termine = data;
                        this.displayTermine();
                    } else {
                        this.termine = [];
                        this.displayTermine();
                    }
                } catch (error) {
                    console.error('❌ TerminManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            showAddTerminModal() {
                const modal = document.getElementById('add-termin-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('termin-date').value = today;
                
                // Leave time field empty - user can fill if needed
                document.getElementById('termin-time').value = '';
            },
            
            hideAddTerminModal() {
                const modal = document.getElementById('add-termin-modal');
                const form = document.getElementById('add-termin-form');
                const submitBtn = form.querySelector('button[type="submit"]');
                
                modal.classList.add('hide');
                form.reset();
                delete form.dataset.editId; // Clear edit mode
                if (submitBtn) {
                    submitBtn.textContent = 'Hinzufügen'; // Reset button text
                }
            },
            
            async addTermin(terminData) {
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('TerminManager', 'add appointments');
                    alert('Fehler: Nicht authentifiziert. Termin kann nicht gespeichert werden.');
                    return;
                }
                
                const termin = {
                    title: terminData.title,
                    description: terminData.description,
                    date: terminData.date,
                    time: terminData.time,
                    user_id: supabase.getCurrentUser().id,
                    created_at: new Date().toISOString()
                };
                
                try {
                    const result = await supabase.insert('termine', termin);
                    if (result && result.length > 0) {
                        this.termine.push(result[0]);
                        } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ TerminManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Termins: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                this.displayTermine();
            },
            
            async updateTermin(terminId, terminData) {
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('TerminManager', 'update appointments');
                    alert('Fehler: Nicht authentifiziert. Termin kann nicht aktualisiert werden.');
                    return;
                }
                
                const terminIndex = this.termine.findIndex(t => t.id == terminId);
                if (terminIndex === -1) {
                    console.error('❌ TerminManager: Termin not found for update:', terminId);
                    alert('Termin nicht gefunden!');
                    return;
                }
                
                const updatedTermin = {
                    ...this.termine[terminIndex],
                    title: terminData.title,
                    description: terminData.description,
                    date: terminData.date,
                    time: terminData.time,
                    updated_at: new Date().toISOString()
                };
                
                try {
                    await supabase.update('termine', updatedTermin, terminId);
                    this.termine[terminIndex] = updatedTermin;
                    } catch (error) {
                    console.error('❌ TerminManager: Error updating in cloud:', error);
                    alert('Fehler beim Aktualisieren des Termins: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                this.displayTermine();
            },
            
            displayTermine() {
                console.log('📅 TerminManager.displayTermine() called');
                const container = document.getElementById('termine-container');
                if (!container) {
                    console.error('❌ Termine container DOM element not found - check if #termine-container exists');
                    return;
                }
                
                // Clear container
                container.innerHTML = '';
                
                if (this.termine.length === 0) {
                    console.log('ℹ️ No termine to display - showing empty state message');
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem; grid-column: 1 / -1;">Keine Termine vorhanden</p>';
                    return;
                }

                // Sort by date/time (earliest first)
                const sortedTermine = this.termine.sort((a, b) => {
                    const dateTimeA = new Date(`${a.date}T${a.time || '00:00'}`);
                    const dateTimeB = new Date(`${b.date}T${b.time || '00:00'}`);
                    return dateTimeA - dateTimeB;
                });
                
                // Add termine
                sortedTermine.forEach((termin, index) => {
                    const terminElement = this.createTerminElement(termin);
                    container.appendChild(terminElement);
                });
                
                },
            
            createTerminElement(termin) {
                const terminCard = document.createElement('div');
                terminCard.className = 'termin-card';
                terminCard.dataset.terminId = termin.id;
                
                const terminDate = new Date(termin.date);
                const formattedDate = terminDate.toLocaleDateString('de-DE', {
                    weekday: 'long',
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                });
                
                let displayDate = formattedDate;
                if (termin.time) {
                    const timeDate = new Date(`${termin.date}T${termin.time}`);
                    const formattedTime = timeDate.toLocaleTimeString('de-DE', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    displayDate += `, ${formattedTime}`;
                }
                
                // Calculate days until appointment
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const appointmentDate = new Date(termin.date);
                appointmentDate.setHours(0, 0, 0, 0);
                const daysDifference = Math.ceil((appointmentDate - today) / (1000 * 60 * 60 * 24));
                
                let daysUntilText = '';
                let badgeColor1 = '';
                let badgeColor2 = '';
                
                if (daysDifference === 0) {
                    daysUntilText = 'Heute';
                    badgeColor1 = '#ef4444';
                    badgeColor2 = '#dc2626';
                } else if (daysDifference === 1) {
                    daysUntilText = 'Morgen';
                    badgeColor1 = '#f97316';
                    badgeColor2 = '#ea580c';
                } else if (daysDifference === -1) {
                    daysUntilText = 'Gestern';
                    badgeColor1 = '#6b7280';
                    badgeColor2 = '#4b5563';
                } else if (daysDifference > 1) {
                    daysUntilText = `in ${daysDifference} Tagen`;
                    badgeColor1 = '#3b82f6';
                    badgeColor2 = '#2563eb';
                } else if (daysDifference < -1) {
                    daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                    badgeColor1 = '#6b7280';
                    badgeColor2 = '#4b5563';
                }
                
                // Set CSS custom properties for badge colors
                const badgeColorVars = `--badge-color-1: ${badgeColor1}; --badge-color-2: ${badgeColor2};`;
                
                terminCard.style.cssText += badgeColorVars;
                
                terminCard.innerHTML = `
                    <div class="termin-days-until">${daysUntilText}</div>
                    <div class="termin-date">${displayDate}</div>
                    <div class="termin-title">${termin.title}</div>
                    <div class="termin-description">${termin.description}</div>
                    <div class="termin-edit-icon" onclick="TerminManager.editTermin('${termin.id}')">✎</div>
                    <div class="termin-delete-icon" onclick="TerminManager.deleteTermin('${termin.id}')">🗑</div>
                `;
                
                return terminCard;
            },
            
            async editTermin(terminId) {
                console.log('🖊️ Edit termin clicked:', terminId);
                console.log('📋 Available termine:', this.termine);
                
                const termin = this.termine.find(t => t.id == terminId);
                if (!termin) {
                    console.error('❌ Termin not found:', terminId);
                    alert('Termin nicht gefunden!');
                    return;
                }
                
                // Pre-fill the form with existing values
                document.getElementById('termin-title').value = termin.title;
                document.getElementById('termin-description').value = termin.description;
                document.getElementById('termin-date').value = termin.date;
                document.getElementById('termin-time').value = termin.time || '';
                
                // Store the ID for updating
                const form = document.getElementById('add-termin-form');
                form.dataset.editId = terminId;
                
                // Change button text
                const submitBtn = form.querySelector('button[type="submit"]');
                submitBtn.textContent = 'Termin aktualisieren';
                
                // Show modal
                this.showAddTerminModal();
            },
            
            async deleteTermin(terminId) {
                if (!confirm('Möchtest du diesen Termin wirklich löschen?')) {
                    return;
                }
                
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('TerminManager', 'delete appointments');
                    alert('Fehler: Nicht authentifiziert. Termin kann nicht gelöscht werden.');
                    return;
                }
                
                try {
                    await supabase.delete('termine', terminId);
                    } catch (error) {
                    console.error('❌ TerminManager: Error deleting from cloud:', error);
                    alert('Fehler beim Löschen: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                // Remove from local array
                this.termine = this.termine.filter(t => t.id != terminId);
                
                // Pure cloud mode - no localStorage caching
                
                // Refresh view
                this.displayTermine();
                
                }
        };

        // Make TerminManager globally available
        window.TerminManager = TerminManager;

        // Right-click handling for dynamic buttons
        document.addEventListener('contextmenu', (e) => {
            // Right-click on dynamic pomodoro button to reset
            if (e.target.closest('#dynamic-pomodoro-btn')) {
                e.preventDefault();
                console.log('🍅 Right-click on dynamic Pomodoro - resetting timer');
                if (window.PomodoroTimer) {
                    window.PomodoroTimer.reset();
                    // Update main buttons after reset
                    if (window.QuickBar) {
                        window.QuickBar.updateDynamicButtons();
                    }
                }
            }
        });

        // === INITIALIZE ===
        document.addEventListener('DOMContentLoaded', async () => {
            // Logout is now handled by separate logout.html page
            
            // SECURITY: Clear URL parameters immediately to prevent credential exposure
            if (window.location.search) {
                console.log('🔒 SECURITY: Clearing URL parameters to prevent credential exposure');
                // Clear URL parameters without page reload
                const url = new URL(window.location.href);
                url.search = '';
                window.history.replaceState({}, document.title, url.toString());
            }
            
            // Setup @ autocomplete for journal textarea
            const journalTextarea = document.getElementById('journal-content');
            if (journalTextarea) {
                InternalLinkParser.setupAutocomplete(journalTextarea);}
            
            // Initialize mobile todo system
            if (window.MobileTodoManager) {
                MobileTodoManager.initMobileDetection();
                window.devLog('📱 Mobile todo system initialized');
            }
            
            // Hide QuickBar initially until authentication is confirmed
            const quickbar = document.getElementById('quickbar');
            if (quickbar) {
                quickbar.style.display = 'none';
            }
            
            // Initialize Supabase first
            if (window.initializeSupabase) {
                window.initializeSupabase();
            }
            
            // Initialize authentication (this will handle data loading via showDashboard)
            await Auth.init();
            
            // Initialize Wiki
            if (window.Wiki) {
                Wiki.init();
            }
            
            // Initialize Lucide icons globally
            if (window.lucide) {
                lucide.createIcons();
            }
            
            // ResourceManager will be initialized after its definition (moved down)
            
            // Logout button is already handled by Auth.setupEventListeners()
            
            // Journal form submission
            const journalForm = document.querySelector('.journal-form');
            if (journalForm) {
                journalForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const input = this.querySelector('.journal-input');
                    if (input.value.trim()) {
                        console.log('Journal entry:', input.value);
                        input.value = '';
                    }
                });
            }
            
            // Add Todo Button
            const addTodoBtn = document.getElementById('add-todo-btn');
            if (addTodoBtn) {
                addTodoBtn.addEventListener('click', () => {
                    TodoManager.showAddTodoModal();
                });
            }
            
            // Chart Easter Egg Button (just for visual consistency - no functionality needed)
            
            // Clear Archive Button
            const clearArchiveBtn = document.getElementById('clear-archive-btn');
            if (clearArchiveBtn) {
                clearArchiveBtn.addEventListener('click', () => {
                    TodoManager.clearArchive();
                });
            }
            
            // Cancel Todo Button
            const cancelTodoBtn = document.getElementById('cancel-todo-btn');
            if (cancelTodoBtn) {
                cancelTodoBtn.addEventListener('click', () => {
                    TodoManager.hideAddTodoModal();
                });
            }
            
            // Add Todo Form Submission
            const addTodoForm = document.getElementById('add-todo-form');
            if (addTodoForm) {
                addTodoForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const todoData = {
                        title: document.getElementById('todo-title').value,
                        category: document.getElementById('todo-category').value,
                        priority: document.getElementById('todo-priority').value,
                        deadline: document.getElementById('todo-deadline').value,
                        time: document.getElementById('todo-time').value
                    };
                    
                    await TodoManager.addTodo(todoData);
                    TodoManager.hideAddTodoModal();
                    
                    // Force refresh after modal closes
                    setTimeout(() => {
                        TodoManager.refreshCurrentView();
                    }, 100);
                });
            }
            
            // Close modal when clicking outside
            const addTodoModal = document.getElementById('add-todo-modal');
            if (addTodoModal) {
                addTodoModal.addEventListener('click', (e) => {
                    if (e.target === addTodoModal) {
                        TodoManager.hideAddTodoModal();
                    }
                });
            }

            // === MOBILE TODO EVENT LISTENERS ===
            
            // Mobile quick todo button
            const mobileQuickTodoBtn = document.getElementById('mobile-quick-todo-btn');
            if (mobileQuickTodoBtn) {
                mobileQuickTodoBtn.addEventListener('click', () => {
                    MobileTodoManager.showModal();
                });
            }
            
            // Mobile todo form submission
            const mobileTodoForm = document.getElementById('mobile-todo-form');
            if (mobileTodoForm) {
                mobileTodoForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    await MobileTodoManager.submitTodo();
                });
            }
            
            // Mobile todo close buttons
            const mobileCloseBtn = document.getElementById('mobile-todo-close');
            const mobileCancelBtn = document.getElementById('mobile-todo-cancel');
            
            if (mobileCloseBtn) {
                mobileCloseBtn.addEventListener('click', () => {
                    MobileTodoManager.hideModal();
                });
            }
            
            if (mobileCancelBtn) {
                mobileCancelBtn.addEventListener('click', () => {
                    MobileTodoManager.hideModal();
                });
            }
            
            // Close mobile modal when clicking outside
            const mobileTodoModal = document.getElementById('mobile-todo-modal');
            if (mobileTodoModal) {
                mobileTodoModal.addEventListener('click', (e) => {
                    if (e.target === mobileTodoModal) {
                        MobileTodoManager.hideModal();
                    }
                });
            }
            
            // === GOAL EVENT LISTENERS ===
            
            // Add Goal Button
            const addGoalBtn = document.getElementById('add-goal-btn');
            if (addGoalBtn) {
                addGoalBtn.addEventListener('click', () => {
                    GoalManager.showAddGoalModal();
                });
            }
            
            // Cancel Goal Button
            const cancelGoalBtn = document.getElementById('cancel-goal-btn');
            if (cancelGoalBtn) {
                cancelGoalBtn.addEventListener('click', () => {
                    GoalManager.hideAddGoalModal();
                });
            }
            
            // Add Goal Form Submission
            const addGoalForm = document.getElementById('add-goal-form');
            if (addGoalForm) {
                addGoalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const goalData = {
                        name: document.getElementById('goal-name').value,
                        description: document.getElementById('goal-description').value,
                        category: document.getElementById('goal-category').value,
                        deadline: document.getElementById('goal-deadline').value,
                        startValue: document.getElementById('goal-start-value').value || '0',
                        targetValue: document.getElementById('goal-target-value').value
                    };
                    
                    await GoalManager.addGoal(goalData);
                    GoalManager.hideAddGoalModal();
                });
            }
            
            // Timeframe change listener - automatically update deadline
            const goalTimeframeSelect = document.getElementById('goal-timeframe');
            if (goalTimeframeSelect) {
                goalTimeframeSelect.addEventListener('change', (e) => {
                    const deadlineInput = document.getElementById('goal-deadline');
                    if (deadlineInput) {
                        deadlineInput.value = GoalManager.calculateDeadline(e.target.value);
                    }
                });
            }
            
            // Close goal modal when clicking outside
            const addGoalModal = document.getElementById('add-goal-modal');
            if (addGoalModal) {
                addGoalModal.addEventListener('click', (e) => {
                    if (e.target === addGoalModal) {
                        GoalManager.hideAddGoalModal();
                    }
                });
            }
            
            // Clear Goal Archive Button
            const clearGoalArchiveBtn = document.getElementById('clear-goal-archive-btn');
            if (clearGoalArchiveBtn) {
                clearGoalArchiveBtn.addEventListener('click', () => {
                    GoalManager.clearGoalArchive();
                });
            }
            
            // === WIKI EVENT LISTENERS ===
            
            // Cancel Wiki Button
            const cancelWikiBtn = document.getElementById('cancel-wiki-btn');
            if (cancelWikiBtn) {
                cancelWikiBtn.addEventListener('click', () => {
                    Wiki.hideAddModal();
                });
            }
            
            // Close wiki modal when clicking outside
            const addWikiModal = document.getElementById('add-wiki-modal');
            if (addWikiModal) {
                addWikiModal.addEventListener('click', (e) => {
                    if (e.target === addWikiModal) {
                        Wiki.hideAddModal();
                    }
                });
            }
            
            // === JOURNAL EVENT LISTENERS ===

            // Journal Search Input
            const journalSearchInput = document.getElementById('journal-search');
            if (journalSearchInput) {
                journalSearchInput.addEventListener('input', () => {
                    clearTimeout(JournalManager.searchTimeout);
                    JournalManager.searchTimeout = setTimeout(() => JournalManager.search(), 300);
                });
            }
            
            // Cancel Journal Button
            const cancelJournalBtn = document.getElementById('cancel-journal-btn');
            if (cancelJournalBtn) {
                cancelJournalBtn.addEventListener('click', () => {
                    JournalManager.hideAddJournalModal();
                });
            }
            // Add Journal Form Submission
            const addJournalForm = document.getElementById('add-journal-form');
            if (addJournalForm) {
                addJournalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const entryData = {
                        title: document.getElementById('journal-title').value,
                        content: document.getElementById('journal-content').value,
                        category: document.getElementById('journal-category').value,
                        date: new Date().toISOString().split('T')[0] // Add current date
                    };
                    
                    await JournalManager.addEntry(entryData);
                    JournalManager.hideAddJournalModal();
                });
            }
            
            // Close journal modal when clicking outside
            const addJournalModal = document.getElementById('add-journal-modal');
            if (addJournalModal) {
                addJournalModal.addEventListener('click', (e) => {
                    if (e.target === addJournalModal) {
                        JournalManager.hideAddJournalModal();
                    }
                });
            }
            
            // === TERMIN EVENT LISTENERS ===
            
            // Add Termin Button
            const addTerminBtn = document.getElementById('add-termin-btn');
            if (addTerminBtn) {
                addTerminBtn.addEventListener('click', () => {
                    TerminManager.showAddTerminModal();
                });
            }
            
            // Add Journal Button
            const addJournalBtn = document.getElementById('add-journal-btn');
            if (addJournalBtn) {
                addJournalBtn.addEventListener('click', () => {
                    document.getElementById('add-journal-modal').classList.remove('hide');
                });
            }
            
            // Add Wiki Button  
            const addWikiBtn = document.getElementById('add-wiki-btn');
            if (addWikiBtn) {
                addWikiBtn.addEventListener('click', () => {
                    document.getElementById('add-wiki-modal').classList.remove('hide');
                });
            }
            
            // Add Vision Button
            const addVisionBtn = document.getElementById('add-vision-btn');
            if (addVisionBtn) {
                addVisionBtn.addEventListener('click', () => {
                    document.getElementById('add-vision-modal').classList.remove('hide');
                });
            }
            
            // Cancel Termin Button
            const cancelTerminBtn = document.getElementById('cancel-termin-btn');
            if (cancelTerminBtn) {
                cancelTerminBtn.addEventListener('click', () => {
                    TerminManager.hideAddTerminModal();
                });
            }
            
            // Add Termin Form Submission
            const addTerminForm = document.getElementById('add-termin-form');
            if (addTerminForm) {
                addTerminForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const terminData = {
                        title: document.getElementById('termin-title').value,
                        description: document.getElementById('termin-description').value,
                        date: document.getElementById('termin-date').value,
                        time: document.getElementById('termin-time').value
                    };
                    
                    // Check if we're editing an existing termin
                    const editId = addTerminForm.dataset.editId;
                    if (editId) {
                        await TerminManager.updateTermin(editId, terminData);
                    } else {
                        await TerminManager.addTermin(terminData);
                    }
                    
                    TerminManager.hideAddTerminModal();
                });
            }
            
            // Close termin modal when clicking outside
            const addTerminModal = document.getElementById('add-termin-modal');
            if (addTerminModal) {
                addTerminModal.addEventListener('click', (e) => {
                    if (e.target === addTerminModal) {
                        TerminManager.hideAddTerminModal();
                    }
                });
            }
            
            // Load routine states on page load
            loadRoutineStates();
            
            // Update routine progress to reflect loaded states
            updateRoutineProgress();
            
            // Initialize settings functionality
            initializeSettings();
            
            // Todo counter is now initialized in showDashboard() after authentication
            
            // === EDIT GOAL VALUE MODAL EVENT LISTENERS ===
            // Event listeners are now set up globally at the end of the script
            
            // === RESOURCE MANAGER ===
            const ResourceManager = {
                resources: [],
                textsnippets: [],
                
                async loadResources() {
                    if (!supabase?.isAuthenticated()) {
                        window.logAuthWarning('ResourceManager');
                        this.resources = [];
                        this.textsnippets = [];
                        this.renderResources();
                        return;
                    }
                    
                    try {
                        // Ensure cloudStorage is initialized
                        if (!window.cloudStorage) {
                            console.warn('CloudStorage not yet initialized, retrying...');
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                        this.resources = await window.cloudStorage.getResources() || [];
                        
                        // Filter text snippets from regular resources
                        this.textsnippets = this.resources.filter(resource => resource.category === 'textsnippets');
                        this.resources = this.resources.filter(resource => resource.category !== 'textsnippets');
                        
                        // Migrate old emoji icons to lucide icons (one-time migration)
                        this.migrateEmojiIcons();
                        
                        this.renderResources();
                        } catch (error) {
                        console.error('❌ ResourceManager: Error loading from cloud:', error);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                },
                
                renderResources() {
                    window.devLog('🎨 ResourceManager.renderResources() called with', this.resources.length, 'resources');
                    // Render all categories at once in block layout
                    this.displayResourcesForCategory('privat');
                    this.displayResourcesForCategory('crypto'); 
                    this.displayResourcesForCategory('arbeit');
                    this.displayResourcesForCategory('uni');
                    this.renderTextSnippets();
                },
                
                displayResourcesForCategory(category) {
                    const container = document.getElementById(`resource-${category}`);
                    if (!container) return;
                    
                    let filteredResources = [];
                    
                    switch(category) {
                        case 'privat':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Privat'
                            );
                            break;
                        case 'arbeit':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Arbeit'
                            );
                            break;
                        case 'uni':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Uni'
                            );
                            break;
                        case 'crypto':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Crypto'
                            );
                            break;
                    }
                    
                    let html = '';
                    
                    if (filteredResources.length === 0) {
                        html = '<div class="empty-resources">Keine Resources vorhanden</div>';
                    } else {
                        filteredResources.forEach(resource => {
                            const icon = resource.icon || 'link';
                            const description = resource.description || '';
                            html += `
                                <div class="resource-item" 
                                     onclick="window.open('${resource.url}', '_blank')"
                                     oncontextmenu="event.preventDefault(); ResourceManager.showDeleteConfirm('${resource.id}')"
                                     title="Rechtsklick zum Löschen">
                                    <div class="resource-info">
                                        <div class="resource-icon">
                                            <i data-lucide="${icon}" style="width: 16px; height: 16px;"></i>
                                        </div>
                                        <div class="resource-details">
                                            <div class="resource-title">${resource.title}</div>
                                            ${description ? `<div class="resource-description">${description}</div>` : ''}
                                        </div>
                                    </div>
                                </div>
                            `;
                        });
                    }
                    
                    container.innerHTML = html;
                    
                    // Enhanced Lucide initialization with icon verification
                    setTimeout(() => {
                        if (window.lucide) {
                            lucide.createIcons();
                            console.log('🎨 Lucide icons initialized for resource category:', category);
                            
                            // Verify icons are actually rendered
                            setTimeout(() => {
                                const actionBtns = container.querySelectorAll('.resource-actions');
                                
                                actionBtns.forEach((actions, index) => {
                                    const buttons = actions.querySelectorAll('button');
                                    const icons = actions.querySelectorAll('svg');
                                    
                                    // Force re-render if icons missing
                                    if (buttons.length > 0 && icons.length === 0) {
                                        console.log('⚠️ Missing icons detected, forcing re-render...');
                                        lucide.createIcons();
                                    }
                                });
                            }, 50);
                        }
                    }, 150);
                },
                
                showAddResourceModal(preselectedCategory = null) {
                    const modal = document.getElementById('add-resource-modal');
                    modal.classList.remove('hide');
                    
                    // Preselect category if provided
                    if (preselectedCategory) {
                        const categorySelect = document.getElementById('resource-category');
                        const categoryMapping = {
                            'privat': 'Privat',
                            'crypto': 'Crypto', 
                            'arbeit': 'Arbeit',
                            'uni': 'Uni'
                        };
                        const mappedCategory = categoryMapping[preselectedCategory];
                        if (mappedCategory && categorySelect) {
                            categorySelect.value = mappedCategory;
                        }
                    }
                    
                    document.getElementById('resource-title').focus();
                },
                
                hideAddResourceModal() {
                    const modal = document.getElementById('add-resource-modal');
                    modal.classList.add('hide');
                    document.getElementById('add-resource-form').reset();
                },

                showDeleteConfirm(resourceId, resourceTitle) {
                    // Hide any existing delete icons first
                    document.querySelectorAll('.delete-overlay').forEach(overlay => overlay.remove());
                    
                    // Find the resource item
                    const resourceItem = event.target.closest('.resource-item');
                    if (!resourceItem) return;
                    
                    // Create delete overlay
                    const deleteOverlay = document.createElement('div');
                    deleteOverlay.className = 'delete-overlay';
                    deleteOverlay.innerHTML = `
                        <div class="delete-icon" onclick="event.stopPropagation(); ResourceManager.confirmDelete('${resourceId}')">
                            <i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>
                        </div>
                    `;
                    
                    resourceItem.appendChild(deleteOverlay);
                    
                    // Initialize lucide icons for the new delete icon
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                    
                    // Auto-hide after 3 seconds or when clicking elsewhere
                    setTimeout(() => deleteOverlay.remove(), 3000);
                    
                    // Hide when clicking elsewhere
                    const hideOnClick = (e) => {
                        if (!deleteOverlay.contains(e.target)) {
                            deleteOverlay.remove();
                            document.removeEventListener('click', hideOnClick);
                        }
                    };
                    setTimeout(() => document.addEventListener('click', hideOnClick), 100);
                },

                confirmDelete(resourceId) {
                    // Remove the overlay
                    document.querySelectorAll('.delete-overlay').forEach(overlay => overlay.remove());
                    // Delete the resource
                    this.deleteResource(resourceId);
                },
                
                async addResource(resourceData) {
                    if (!supabase?.isAuthenticated()) {
                        window.logAuthWarning('ResourceManager', 'add resources');
                        alert('Fehler: Nicht authentifiziert. Resource kann nicht gespeichert werden.');
                        return;
                    }
                    
                    const resource = {
                        title: resourceData.title,
                        category: resourceData.category,
                        url: resourceData.url,
                        description: resourceData.description || '',
                        icon: resourceData.icon || 'link',
                        user_id: supabase.getCurrentUser().id,
                        created_at: new Date().toISOString()
                    };
                    
                    try {
                        await cloudStorage.saveResource(resource);
                        // Reload resources from cloud to get updated data with proper IDs
                        await this.loadResources();
                        
                        } catch (error) {
                        console.error('❌ ResourceManager: Error saving resource:', error);
                        alert('Fehler beim Speichern der Resource: ' + error.message);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                },
                
                async deleteResource(resourceId) {
                    if (!supabase?.isAuthenticated()) {
                        window.logAuthWarning('ResourceManager', 'delete resources');
                        alert('Fehler: Nicht authentifiziert. Resource kann nicht gelöscht werden.');
                        return;
                    }
                    
                    try {
                        await cloudStorage.deleteResource(resourceId);
                        // Pure cloud mode - no localStorage
                        
                        // Reload resources from cloud to get updated list
                        await this.loadResources();
                        
                        } catch (error) {
                        console.error('❌ ResourceManager: Error deleting resource:', error);
                        alert('Fehler beim Löschen der Resource: ' + error.message);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                },
                
                editResource(resourceId) {
                    const resource = this.resources.find(r => r.id === resourceId);
                    if (!resource) return;
                    
                    // Populate form with existing data
                    document.getElementById('resource-title').value = resource.title;
                    document.getElementById('resource-category').value = resource.category;
                    document.getElementById('resource-url').value = resource.url;
                    document.getElementById('resource-description').value = resource.description || '';
                    document.getElementById('resource-icon').value = resource.icon || '';
                    
                    // Mark form as editing
                    const form = document.getElementById('add-resource-form');
                    form.dataset.editId = resourceId;
                    
                    this.showAddResourceModal();
                },
                
                selectIcon(iconName) {
                    const iconInput = document.getElementById('resource-icon');
                    if (iconInput) {
                        iconInput.value = iconName;
                    }
                },
                
                toggleIconInput() {
                    const iconInput = document.getElementById('resource-icon');
                    const toggleBtn = event.target;
                    
                    if (iconInput.readOnly) {
                        iconInput.readOnly = false;
                        iconInput.placeholder = 'Type lucide icon name manually...';
                        iconInput.focus();
                        toggleBtn.textContent = 'Use icon palette';
                    } else {
                        iconInput.readOnly = true;
                        iconInput.placeholder = 'Click icon below or type manually';
                        toggleBtn.textContent = 'Enable manual typing';
                    }
                },
                
                migrateEmojiIcons() {
                    const emojiToLucideMap = {
                        '📧': 'mail',
                        '💼': 'briefcase',
                        '📚': 'book',
                        '🏠': 'home',
                        '💬': 'message-circle',
                        '🏦': 'building',
                        '🔧': 'wrench',
                        '📊': 'bar-chart-3',
                        '📝': 'file-text',
                        '👥': 'users',
                        '🌐': 'globe',
                        '💰': 'dollar-sign',
                        '🎯': 'target',
                        '⚡': 'zap',
                        '🔐': 'lock',
                        '🔗': 'link',
                        '🚀': 'rocket',
                        '🎨': 'palette',
                        '🏃': 'activity',
                        '🤖': 'bot',
                        '🌱': 'sprout'
                    };
                    
                    if (!supabase?.isAuthenticated()) {
                        return; // Skip migration if not authenticated
                    }
                    
                    let migrationNeeded = false;
                    
                    this.resources.forEach(resource => {
                        if (emojiToLucideMap[resource.icon]) {
                            resource.icon = emojiToLucideMap[resource.icon];
                            migrationNeeded = true;
                        }
                    });
                    
                    if (migrationNeeded) {
                        // Pure cloud mode - only save to cloud
                        this.resources.forEach(resource => cloudStorage.saveResource(resource));
                    }
                },
                
                // === TEXT SNIPPETS FUNCTIONALITY ===
                
                async loadTextSnippets() {
                    if (!supabase?.isAuthenticated()) {
                        this.textsnippets = [];
                        this.renderTextSnippets();
                        return;
                    }
                    
                    try {
                        // Load text snippets from resources table with special category
                        const allResources = await cloudStorage.getResources() || [];
                        this.textsnippets = allResources.filter(resource => resource.category === 'textsnippets');
                        this.renderTextSnippets();
                    } catch (error) {
                        console.error('❌ Error loading text snippets:', error);
                        this.textsnippets = [];
                        this.renderTextSnippets();
                    }
                },
                
                renderTextSnippets() {
                    const container = document.getElementById('resource-textsnippets');
                    if (!container) return;
                    
                    if (this.textsnippets.length === 0) {
                        container.innerHTML = '<div class="no-resources">Noch keine Text Snippets vorhanden</div>';
                        return;
                    }
                    
                    container.innerHTML = this.textsnippets.map(snippet => {
                        const escapedText = snippet.title.replace(/'/g, "&apos;").replace(/"/g, "&quot;");
                        return `
                            <div class="textsnippet-item" data-id="${snippet.id}">
                                <i data-lucide="clipboard-list" style="width: 16px; height: 16px;"></i>
                                <span class="textsnippet-text">${snippet.title}</span>
                                <span class="textsnippet-copy-feedback">
                                    <i data-lucide="check" style="width: 16px; height: 16px;"></i>
                                </span>
                                <div class="delete-icon" onclick="event.stopPropagation(); ResourceManager.deleteTextSnippet('${snippet.id}')" title="Löschen">
                                    <i data-lucide="x" style="width: 14px; height: 14px;"></i>
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    // Add click and context menu event listeners after rendering
                    container.querySelectorAll('.textsnippet-item').forEach(item => {
                        // Left click = copy (only if not clicking delete button)
                        item.addEventListener('click', (e) => {
                            if (!e.target.closest('.delete-icon')) {
                                const text = item.querySelector('.textsnippet-text').textContent;
                                this.copyToClipboard(text, item);
                            }
                        });
                        
                        // Right click = show delete button
                        item.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            
                            // Hide all other delete buttons first
                            document.querySelectorAll('.textsnippet-item .delete-icon').forEach(icon => {
                                icon.classList.remove('show');
                            });
                            
                            // Show this item's delete button
                            const deleteIcon = item.querySelector('.delete-icon');
                            if (deleteIcon) {
                                deleteIcon.classList.add('show');
                            }
                        });
                    });
                    
                    // Add global click handler to hide delete buttons when clicking outside (only once)
                    if (!this.textsnippetClickHandlerAdded) {
                        document.addEventListener('click', (e) => {
                            if (!e.target.closest('.textsnippet-item')) {
                                document.querySelectorAll('.textsnippet-item .delete-icon').forEach(icon => {
                                    icon.classList.remove('show');
                                });
                            }
                        });
                        this.textsnippetClickHandlerAdded = true;
                    }
                    
                    // Initialize Lucide icons for text snippets
                    if (window.lucide) {
                        lucide.createIcons();
                        window.devLog('🎨 Lucide icons initialized for text snippets');
                    }
                },
                
                async copyToClipboard(text, element) {
                    try {
                        await navigator.clipboard.writeText(text);
                        
                        // Show feedback
                        const feedback = element.querySelector('.textsnippet-copy-feedback');
                        if (feedback) {
                            feedback.classList.add('show');
                            setTimeout(() => {
                                feedback.classList.remove('show');
                            }, 1500);
                        }
                    } catch (error) {
                        console.error('❌ Failed to copy to clipboard:', error);
                        // Fallback for older browsers
                        const textArea = document.createElement('textarea');
                        textArea.value = text;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                    }
                },
                
                showAddTextSnippetModal() {
                    const modal = document.getElementById('add-textsnippet-modal');
                    modal.classList.remove('hide');
                    // Focus the textarea
                    setTimeout(() => {
                        const textInput = document.getElementById('textsnippet-text');
                        if (textInput) textInput.focus();
                    }, 100);
                },
                
                hideAddTextSnippetModal() {
                    const modal = document.getElementById('add-textsnippet-modal');
                    modal.classList.add('hide');
                    document.getElementById('add-textsnippet-form').reset();
                },
                
                async addTextSnippet(text = null) {
                    // If called with text parameter (from form), use it directly
                    // If called without text (from old button), show modal
                    if (!text) {
                        this.showAddTextSnippetModal();
                        return;
                    }
                    
                    if (!text || text.trim() === '') return;
                    
                    const snippet = {
                        title: text.trim(),
                        description: 'Text Snippet',
                        url: '', // Empty URL for text snippets
                        category: 'textsnippets',
                        icon: 'clipboard-list'
                    };
                    
                    try {
                        await cloudStorage.saveResource(snippet);
                        this.textsnippets.push(snippet);
                        this.renderTextSnippets();
                        this.hideAddTextSnippetModal();
                    } catch (error) {
                        console.error('❌ Error adding text snippet:', error);
                        alert('Fehler beim Hinzufügen des Text Snippets');
                    }
                },
                
                async deleteTextSnippet(id) {
                    try {
                        // Hide all delete buttons first
                        document.querySelectorAll('.textsnippet-item .delete-icon').forEach(icon => {
                            icon.classList.remove('show');
                        });
                        
                        await cloudStorage.deleteResource(id);
                        this.textsnippets = this.textsnippets.filter(s => s.id !== id);
                        this.renderTextSnippets();
                    } catch (error) {
                        console.error('❌ Error deleting text snippet:', error);
                        alert('Fehler beim Löschen des Text Snippets');
                    }
                }
                
            };
            
            // Make ResourceManager global
            window.ResourceManager = ResourceManager;
            
            // Initialize ResourceManager now that it's properly defined
            ResourceManager.loadResources();
            
            // Add event listener for text snippet add button
            const addTextSnippetBtn = document.getElementById('add-textsnippet-btn');
            if (addTextSnippetBtn) {
                addTextSnippetBtn.addEventListener('click', () => {
                    ResourceManager.addTextSnippet();
                });
            }

            // === TRADING RULES MANAGER ===
            const TradingRulesManager = {
                rules: [],
                
                async loadTradingRules() {
                    if (!supabase?.isAuthenticated()) {
                        window.logAuthWarning('TradingRulesManager');
                        this.rules = [];
                        this.renderTradingRules();
                        return;
                    }
                    
                    try {
                        const cloudRules = await cloudStorage.getTradingRules();
                        if (cloudRules && Array.isArray(cloudRules) && cloudRules.length > 0) {
                            this.rules = cloudRules;
                            } else {
                            this.rules = [];
                            await this.createSampleRules();
                        }
                        
                        this.renderTradingRules();
                        } catch (error) {
                        console.error('❌ TradingRulesManager: Error loading from cloud:', error);
                        console.error('Error details:', error.message);
                        console.error('Error stack:', error.stack);
                        // Don't re-throw - just show empty state
                        this.rules = [];
                        this.renderTradingRules();
                    }
                },
                
                renderTradingRules() {
                    console.log('🎨 TradingRulesManager.renderTradingRules() called with', this.rules.length, 'rules');
                    
                    // Render all categories
                    this.displayRulesForCategory('Risk Management');
                    this.displayRulesForCategory('Entry Rules');
                    this.displayRulesForCategory('Exit Rules');
                    this.displayRulesForCategory('Psychology & Discipline');
                    this.displayRulesForCategory('Time Management');
                },
                
                displayRulesForCategory(category) {
                    // Find the resource-block for this category
                    const blocks = document.querySelectorAll('.resource-block[data-category]');
                    let container = null;
                    
                    blocks.forEach(block => {
                        if (block.getAttribute('data-category') === category) {
                            container = block.querySelector('.resource-links');
                        }
                    });
                    
                    if (!container) return;
                    
                    // Filter rules for this category
                    const filteredRules = this.rules.filter(rule => rule.category === category);
                    
                    // Clear container
                    container.innerHTML = '';
                    
                    if (filteredRules.length === 0) {
                        container.innerHTML = '<div class="no-items">No rules yet. Click + to add one.</div>';
                        return;
                    }
                    
                    // Render each rule
                    filteredRules.forEach(rule => {
                        console.log('🎨 Rendering rule:', rule.title, 'with ID:', rule.id, typeof rule.id);
                        
                        const ruleEl = document.createElement('div');
                        ruleEl.className = 'resource-item';
                        ruleEl.title = 'Rechtsklick zum Löschen';
                        ruleEl.innerHTML = `
                            <div class="resource-info">
                                <div class="resource-details">
                                    <div class="resource-title">${rule.title}</div>
                                    ${rule.description ? `<div class="resource-description">${InternalLinkParser.parseInternalLinks(rule.description)}</div>` : ''}
                                </div>
                            </div>
                        `;
                        
                        // Add right-click context menu - capture rule.id in closure
                        const ruleId = rule.id;
                        console.log('📋 Setting up context menu for rule ID:', ruleId, typeof ruleId);
                        
                        ruleEl.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            console.log('📋 Context menu triggered with ID:', ruleId, typeof ruleId);
                            this.showContextMenu(e, ruleId);
                        });
                        
                        container.appendChild(ruleEl);
                    });
                    
                    // Re-render Lucide icons
                    if (typeof lucide !== 'undefined' && lucide.createIcons) {
                        lucide.createIcons();
                    }
                },
                
                showAddRuleModal(category = '') {
                    const modal = document.getElementById('add-trading-rule-modal');
                    const categorySelect = document.getElementById('trading-rule-category');
                    
                    if (category && categorySelect) {
                        categorySelect.value = category;
                    }
                    
                    modal.classList.remove('hide');
                },
                
                hideAddRuleModal() {
                    const modal = document.getElementById('add-trading-rule-modal');
                    const form = document.getElementById('add-trading-rule-form');
                    
                    modal.classList.add('hide');
                    
                    if (form) {
                        form.reset();
                    }
                },
                
                async createRule(ruleData) {
                    try {
                        // Add creation timestamp
                        ruleData.created_at = new Date().toISOString();
                        
                        // Save to cloud storage - this should update ruleData.id
                        const savedRule = await cloudStorage.saveTradingRule(ruleData);// Only add to local array if not already there and has valid ID
                        if (ruleData.id) {
                            // Check if already exists in local array
                            const existingIndex = this.rules.findIndex(r => r.id === ruleData.id);
                            if (existingIndex === -1) {
                                this.rules.push(ruleData);
                            }
                        } else {
                            console.error('❌ Rule was saved but has no ID!', ruleData);
                        }
                        
                        // Re-render all categories to be safe
                        this.renderTradingRules();
                        
                        // Hide modal
                        this.hideAddRuleModal();
                        
                    } catch (error) {
                        console.error('❌ Error creating trading rule:', error);
                        throw error;
                    }
                },
                
                showContextMenu(event, ruleId) {
                    event.preventDefault();
                    event.stopPropagation();
                    
                    console.log('📋 Context menu shown for rule ID:', ruleId, typeof ruleId);
                    this.currentRuleId = ruleId;
                    const contextMenu = document.getElementById('trading-rules-context-menu');
                    
                    // Position the context menu
                    contextMenu.style.left = event.pageX + 'px';
                    contextMenu.style.top = event.pageY + 'px';
                    contextMenu.style.display = 'block';
                    
                    // Create lucide icons in context menu
                    if (window.lucide) lucide.createIcons();
                },
                
                hideContextMenu() {
                    const contextMenu = document.getElementById('trading-rules-context-menu');
                    if (contextMenu) {
                        contextMenu.style.display = 'none';
                    }
                    this.currentRuleId = null;
                },
                
                async deleteRuleFromMenu() {if (!this.currentRuleId) return;
                    
                    // Save the ID before hiding the context menu (which sets currentRuleId to null)
                    const ruleIdToDelete = this.currentRuleId;
                    this.hideContextMenu();
                    await this.deleteRule(ruleIdToDelete);
                },

                async deleteRule(ruleId) {// Check for invalid ID
                    if (!ruleId || ruleId === null || ruleId === 'null' || ruleId === undefined) {
                        console.error('❌ Cannot delete rule: Invalid ID:', ruleId);
                        return;
                    }
                    
                    // Pure cloud mode - no confirmation popup, immediate delete
                    try {
                        await cloudStorage.deleteTradingRule(ruleId);
                        
                        // Remove from local array
                        this.rules = this.rules.filter(rule => rule.id !== ruleId);
                        
                        // Re-render all categories
                        this.renderTradingRules();
                        
                        } catch (error) {
                        console.error('❌ Error deleting trading rule:', error);
                    }
                },

                async createSampleRules() {
                    const sampleRules = [
                        {
                            title: "Never risk more than 2% per trade",
                            category: "Risk Management",
                            description: "Protect capital by limiting risk per position"
                        },
                        {
                            title: "Always set stop loss before entry",
                            category: "Entry Rules",
                            description: "Plan exit strategy before entering position"
                        },
                        {
                            title: "Take profits at resistance levels",
                            category: "Exit Rules",
                            description: "Use technical analysis to identify exit points"
                        }
                    ];

                    try {
                        for (const ruleData of sampleRules) {
                            await cloudStorage.saveTradingRule(ruleData);
                            // Only push to local array if it has a valid ID
                            if (ruleData.id) {
                                this.rules.push(ruleData);
                            } else {
                                console.error('❌ Sample rule created but has no ID:', ruleData);
                            }
                        }
                        } catch (error) {
                        console.error('❌ Error creating sample rules:', error);
                        console.error('❌ Error details:', error.message);
                    }
                },

                async testDatabaseConnection() {
                    // Test 1: Check authentication
                    if (!supabase?.isAuthenticated()) {
                        console.error('❌ Test failed: Not authenticated');
                        return;
                    }
                    
                    const user = supabase.getCurrentUser();
                    // Test 2: Try to query the table
                    try {
                        const result = await supabase.query(`trading_rules?user_id=eq.${user.id}&select=*`);
                        } catch (error) {
                        console.error('❌ Table query failed:', error);
                        console.error('❌ This likely means the trading_rules table does not exist in Supabase');
                    }
                    
                    // Test 3: Try to insert a test record
                    try {
                        const testRule = {
                            title: 'Test Rule - Delete Me',
                            description: 'This is a test rule',
                            category: 'Test',
                            user_id: user.id
                        };
                        
                        const insertResult = await supabase.insert('trading_rules', [testRule]);
                        // Clean up test record
                        if (insertResult && insertResult[0]?.id) {
                            await supabase.delete('trading_rules', insertResult[0].id);
                            console.log('🧹 Test record cleaned up');
                        }
                    } catch (error) {
                        console.error('❌ Insert test failed:', error);
                    }
                },

                async checkDatabaseSchema() {
                    if (!supabase?.isAuthenticated()) {
                        window.logAuthWarning('TradingRulesManager', 'save rules');
                        return;
                    }
                    
                    const user = supabase.getCurrentUser();
                    
                    try {
                        // Get a sample record to see the structure
                        const result = await supabase.query(`trading_rules?user_id=eq.${user.id}&select=*&limit=1`);
                        if (result && result[0]) {
                            Object.keys(result[0]).forEach(key => {
                                console.log(`  - ${key}: ${result[0][key]} (${typeof result[0][key]})`);
                            });
                            
                            if (!result[0].id) {
                                console.error('❌ PROBLEM FOUND: Database records have NO id column!');
                                console.error('❌ This explains why rules show as having null IDs');
                            } else {
                                }
                        }
                    } catch (error) {
                        console.error('❌ Error checking schema:', error);
                    }
                },

                async cleanupInvalidRules() {
                    console.log('🧹 Cleaning up rules with invalid IDs...');
                    
                    const invalidRules = this.rules.filter(rule => !rule.id || rule.id === null || rule.id === 'null');if (invalidRules.length > 0) {
                        // Remove invalid rules from local array
                        this.rules = this.rules.filter(rule => rule.id && rule.id !== null && rule.id !== 'null');
                        
                        // Re-render
                        this.renderTradingRules();
                        
                        }
                }
            };
            
            // Make TradingRulesManager global
            window.TradingRulesManager = TradingRulesManager;

            // === VISION MANAGER ===
            const VisionManager = {
                visions: [],
                
                async loadVisions() {
                    try {
                        if (window.supabase?.isAuthenticated()) {
                            const user = window.supabase.getCurrentUser();
                            if (user) {
                                const data = await window.supabase.query(`visions?user_id=eq.${user.id}&select=*&order=display_order.asc.nullslast,created_at.asc`);
                                this.visions = data || [];
                                this.renderVisions();
                                return;
                            }
                        }
                        
                        // Pure cloud mode - no localStorage fallback
                        this.visions = [];
                        this.renderVisions();
                    } catch (error) {
                        this.visions = [];
                        this.renderVisions();
                    }
                },
                
                renderVisions() {
                    const container = document.getElementById('vision-entries');
                    if (!container) return;
                    
                    if (this.visions.length === 0) {
                        container.innerHTML = `
                            <div style="text-align: center; padding: 3rem; color: var(--text-secondary);">
                                <i data-lucide="eye" style="width: 48px; height: 48px; margin-bottom: 1rem;"></i>
                                <p>Noch keine Vision Cards erstellt.</p>
                                <p>Klicke auf den + Button um zu beginnen!</p>
                            </div>
                        `;
                        if (window.lucide) lucide.createIcons();
                        return;
                    }
                    
                    const html = this.visions.map(vision => `
                        <div class="vision-card" 
                             draggable="true"
                             onclick="VisionManager.editVision('${vision.id}')" 
                             oncontextmenu="VisionManager.showContextMenu(event, '${vision.id}'); return false;"
                             ondragstart="VisionManager.handleDragStart(event)"
                             ondragover="VisionManager.handleDragOver(event)"
                             ondrop="VisionManager.handleDrop(event)"
                             ondragend="VisionManager.handleDragEnd(event)"
                             data-vision-id="${vision.id}"
                             data-display-order="${vision.display_order || 0}">
                            <div class="vision-card-icon">
                                <i data-lucide="${vision.icon}" style="width: 40px; height: 40px;"></i>
                            </div>
                            <div class="vision-card-title">${vision.title}</div>
                            ${vision.description ? `<div class="vision-card-description">${vision.description}</div>` : ''}
                        </div>
                    `).join('');
                    
                    container.innerHTML = html;
                    if (window.lucide) lucide.createIcons();
                    
                    // Hide context menu when clicking elsewhere
                    document.addEventListener('click', this.hideContextMenu.bind(this));
                },

                showAddVisionModal() {
                    document.getElementById('add-vision-modal').classList.remove('hide');
                    // Reset form
                    document.getElementById('add-vision-form').reset();
                    document.getElementById('vision-icon').value = 'star';
                },
                
                hideAddVisionModal() {
                    document.getElementById('add-vision-modal').classList.add('hide');
                },
                
                selectIcon(iconName) {
                    document.getElementById('vision-icon').value = iconName;
                    // Update selected state
                    document.querySelectorAll('#add-vision-modal .icon-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    document.querySelector(`#add-vision-modal .icon-btn[onclick*="${iconName}"]`).classList.add('selected');
                },
                
                async addVision(formData) {
                    try {
                        if (!window.supabase?.isAuthenticated()) {
                            alert('Bitte anmelden, um Vision Cards zu erstellen.');
                            return;
                        }
                        
                        const user = window.supabase.getCurrentUser();
                        if (!user) {
                            alert('Benutzerinformationen nicht verfügbar. Bitte erneut anmelden.');
                            return;
                        }
                        
                        // Get next display_order (max + 1)
                        const maxOrder = this.visions.length > 0 ? Math.max(...this.visions.map(v => v.display_order || 0)) : 0;
                        
                        const vision = {
                            id: Date.now().toString(),
                            user_id: user.id,
                            title: formData.title,
                            description: formData.description || '',
                            icon: formData.icon,
                            display_order: maxOrder + 1,
                            created_at: new Date().toISOString()
                        };

                        // Pure cloud mode - no localStorage fallback
                        await window.supabase.upsert('visions', vision, ['user_id', 'title', 'created_at']);
                        this.hideAddVisionModal();
                        await this.loadVisions();
                    } catch (error) {
                        alert('Fehler beim Erstellen der Vision Card: ' + error.message);
                    }
                },

                async deleteVision(visionId) {
                    if (!confirm('Vision Card wirklich löschen?')) return;
                    
                    try {
                        if (!window.supabase?.isAuthenticated()) {
                            alert('Bitte anmelden, um Vision Cards zu löschen.');
                            return;
                        }
                        
                        // Pure cloud mode - no localStorage fallback
                        await window.supabase.delete('visions', visionId);
                        
                        await this.loadVisions();
                    } catch (error) {
                        alert('Fehler beim Löschen der Vision Card: ' + error.message);
                    }
                },

                editVision(visionId) {
                    // Placeholder for edit functionality
                    alert('Vision bearbeiten - Coming Soon! 🎯');
                },

                // Drag and drop functionality
                draggedElement: null,
                
                handleDragStart(event) {
                    this.draggedElement = event.target.closest('.vision-card');
                    this.draggedElement.style.opacity = '0.5';
                    event.dataTransfer.effectAllowed = 'move';
                    event.dataTransfer.setData('text/html', this.draggedElement.outerHTML);
                },
                
                handleDragOver(event) {
                    if (event.preventDefault) {
                        event.preventDefault();
                    }
                    event.dataTransfer.dropEffect = 'move';
                    
                    const targetCard = event.target.closest('.vision-card');
                    if (targetCard && targetCard !== this.draggedElement) {
                        const container = document.getElementById('vision-entries');
                        const afterElement = this.getDragAfterElement(container, event.clientY);
                        
                        if (afterElement == null) {
                            container.appendChild(this.draggedElement);
                        } else {
                            container.insertBefore(this.draggedElement, afterElement);
                        }
                    }
                    
                    return false;
                },
                
                handleDrop(event) {
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    
                    // Update display order based on new positions
                    this.updateDisplayOrder();
                    
                    return false;
                },
                
                handleDragEnd(event) {
                    if (this.draggedElement) {
                        this.draggedElement.style.opacity = '1';
                        this.draggedElement = null;
                    }
                },
                
                getDragAfterElement(container, y) {
                    const draggableElements = [...container.querySelectorAll('.vision-card:not(.dragging)')];
                    
                    return draggableElements.reduce((closest, child) => {
                        const box = child.getBoundingClientRect();
                        const offset = y - box.top - box.height / 2;
                        
                        if (offset < 0 && offset > closest.offset) {
                            return { offset: offset, element: child };
                        } else {
                            return closest;
                        }
                    }, { offset: Number.NEGATIVE_INFINITY }).element;
                },
                
                async updateDisplayOrder() {
                    try {
                        if (!window.supabase?.isAuthenticated()) {
                            console.warn('Not authenticated - cannot update display order');
                            return;
                        }
                        
                        const container = document.getElementById('vision-entries');
                        const visionCards = container.querySelectorAll('.vision-card');
                        
                        // Update display order for each vision based on current DOM position
                        const updates = [];
                        visionCards.forEach((card, index) => {
                            const visionId = card.getAttribute('data-vision-id');
                            const newDisplayOrder = index + 1; // Start from 1
                            updates.push({
                                id: visionId,
                                display_order: newDisplayOrder
                            });
                        });
                        
                        // Batch update display orders in Supabase
                        for (const update of updates) {
                            await window.supabase.update('visions', update.id, { display_order: update.display_order });
                        }
                        
                        // Update local visions array to match new order
                        this.visions.forEach(vision => {
                            const update = updates.find(u => u.id === vision.id);
                            if (update) {
                                vision.display_order = update.display_order;
                            }
                        });
                        
                        // Sort local array by display_order
                        this.visions.sort((a, b) => (a.display_order || 0) - (b.display_order || 0));
                        
                    } catch (error) {
                        console.error('Error updating display order:', error);
                        // Reload visions to reset to server state
                        await this.loadVisions();
                    }
                },

                currentVisionId: null,

                showContextMenu(event, visionId) {
                    event.preventDefault();
                    event.stopPropagation();
                    
                    this.currentVisionId = visionId;
                    const contextMenu = document.getElementById('vision-context-menu');
                    
                    // Position the context menu
                    contextMenu.style.left = event.pageX + 'px';
                    contextMenu.style.top = event.pageY + 'px';
                    contextMenu.style.display = 'block';
                    
                    // Create lucide icons in context menu
                    if (window.lucide) lucide.createIcons();
                },

                hideContextMenu() {
                    const contextMenu = document.getElementById('vision-context-menu');
                    if (contextMenu) {
                        contextMenu.style.display = 'none';
                    }
                    this.currentVisionId = null;
                },

                async deleteVisionFromMenu() {
                    if (!this.currentVisionId) return;
                    
                    this.hideContextMenu();
                    await this.deleteVision(this.currentVisionId);
                },

                // Drag and Drop functionality
                draggedElement: null,

                handleDragStart(event) {
                    this.draggedElement = event.target.closest('.vision-card');
                    this.draggedElement.classList.add('dragging');
                    
                    event.dataTransfer.effectAllowed = 'move';
                    event.dataTransfer.setData('text/html', this.draggedElement.outerHTML);
                },

                handleDragOver(event) {
                    event.preventDefault();
                    event.dataTransfer.dropEffect = 'move';
                    
                    const afterElement = this.getDragAfterElement(event.currentTarget.parentElement, event.clientY);
                    const container = document.getElementById('vision-entries');
                    
                    if (afterElement == null) {
                        container.appendChild(this.draggedElement);
                    } else {
                        container.insertBefore(this.draggedElement, afterElement);
                    }
                },

                handleDrop(event) {
                    event.preventDefault();
                    this.updateDisplayOrder();
                },

                handleDragEnd(event) {
                    const dragging = document.querySelector('.dragging');
                    if (dragging) {
                        dragging.classList.remove('dragging');
                    }
                    this.draggedElement = null;
                },

                getDragAfterElement(container, y) {
                    const draggableElements = [...container.querySelectorAll('.vision-card:not(.dragging)')];
                    
                    return draggableElements.reduce((closest, child) => {
                        const box = child.getBoundingClientRect();
                        const offset = y - box.top - box.height / 2;
                        
                        if (offset < 0 && offset > closest.offset) {
                            return { offset: offset, element: child };
                        } else {
                            return closest;
                        }
                    }, { offset: Number.NEGATIVE_INFINITY }).element;
                },

                async updateDisplayOrder() {
                    if (!window.supabase?.isAuthenticated()) return;
                    
                    try {
                        const visionCards = document.querySelectorAll('.vision-card');
                        const updates = [];
                        
                        visionCards.forEach((card, index) => {
                            const visionId = card.dataset.visionId;
                            updates.push({
                                id: visionId,
                                display_order: index + 1
                            });
                        });
                        
                        // Update display_order in database
                        for (const update of updates) {
                            await window.supabase.update('visions', { display_order: update.display_order }, update.id);
                        }
                        
                        // Update local visions array order
                        this.visions.sort((a, b) => {
                            const aOrder = updates.find(u => u.id == a.id)?.display_order || 0;
                            const bOrder = updates.find(u => u.id == b.id)?.display_order || 0;
                            return aOrder - bOrder;
                        });
                        
                    } catch (error) {
                        console.error('Error updating display order:', error);
                        // Reload visions on error
                        this.loadVisions();
                    }
                }
            };
            
            // Make VisionManager globally available
            window.VisionManager = VisionManager;
            
            // Initialize VisionManager
            VisionManager.loadVisions();

            // === QUICK NOTES FUNCTIONALITY ===
            const QuickNotes = {
                textarea: null,
                saveTimeout: null,

                init() {
                    this.textarea = document.getElementById('quicknotes-textarea');
                    if (!this.textarea) return;

                    // Load existing notes
                    this.loadNotes();
                    
                    // Initial auto-resize
                    this.autoResize();

                    // Auto-save on input with debounce + auto-resize
                    this.textarea.addEventListener('input', () => {
                        this.autoResize();
                        clearTimeout(this.saveTimeout);
                        this.saveTimeout = setTimeout(() => {
                            this.saveNotes();
                        }, 1000); // Save 1 second after user stops typing
                    });

                    // Save on blur (when user clicks away)
                    this.textarea.addEventListener('blur', () => {
                        clearTimeout(this.saveTimeout);
                        this.saveNotes();
                    });
                },

                async loadNotes() {
                    try {
                        if (!window.cloudStorage) return;
                        
                        const notes = await window.cloudStorage.getNotes('quicknotes');
                        if (notes && this.textarea) {
                            this.textarea.value = notes;
                            // Auto-resize after loading content
                            setTimeout(() => this.autoResize(), 100);
                        }
                    } catch (error) {
                        console.error('Error loading quick notes:', error);
                    }
                },

                autoResize() {
                    if (!this.textarea) return;
                    
                    // Reset height to auto to get correct scrollHeight
                    this.textarea.style.height = 'auto';
                    
                    // Set height to scrollHeight (content height)
                    const newHeight = Math.max(200, this.textarea.scrollHeight);
                    this.textarea.style.height = newHeight + 'px';
                },

                async saveNotes() {
                    try {
                        if (!window.cloudStorage || !this.textarea) return;
                        
                        const content = this.textarea.value;
                        await window.cloudStorage.saveNotes('quicknotes', content);
                        } catch (error) {
                        console.error('Error saving quick notes:', error);
                    }
                }
            };

            // Initialize Quick Notes when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => QuickNotes.init());
            } else {
                QuickNotes.init();
            }

            // Make QuickNotes global for debugging
            window.QuickNotes = QuickNotes;

            // === JOURNAL DELETE BUTTONS ===
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-entry-btn')) {
                    const entryId = e.target.dataset.entryId;
                    if (entryId) {
                        JournalManager.deleteEntry(entryId);
                    }
                }
            });

            // === RESOURCE EVENT LISTENERS ===
            
            // Add Resource Button
            const addResourceBtn = document.getElementById('add-resource-btn');
            if (addResourceBtn) {
                addResourceBtn.addEventListener('click', () => {
                    ResourceManager.showAddResourceModal();
                });
            }

            // Add to Category Buttons - different behavior for todos vs resources
            const addToCategoryBtns = document.querySelectorAll('.add-to-category-btn');
            addToCategoryBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const category = btn.getAttribute('data-category');
                    // Check if we're in the todos tab
                    const todoTab = document.getElementById('tab-todos');
                    const resourceTab = document.getElementById('tab-ressourcen');
                    
                    if (todoTab && todoTab.classList.contains('active')) {
                        // We're in todos tab - open todo modal
                        if (window.TodoManager && typeof window.TodoManager.showAddTodoModal === 'function') {
                            window.TodoManager.showAddTodoModal(category);
                        }
                    } else if (resourceTab && resourceTab.classList.contains('active')) {
                        // We're in resources tab - open resource modal
                        ResourceManager.showAddResourceModal(category);
                    }
                });
            });
            
            // Add Resource Form Submission
            const addResourceForm = document.getElementById('add-resource-form');
            if (addResourceForm) {
                addResourceForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const resourceData = {
                        title: document.getElementById('resource-title').value,
                        category: document.getElementById('resource-category').value,
                        url: document.getElementById('resource-url').value,
                        description: document.getElementById('resource-description').value,
                        icon: document.getElementById('resource-icon').value
                    };
                    
                    // Check if we're editing an existing resource
                    const editId = addResourceForm.dataset.editId;
                    if (editId) {
                        // Update existing resource
                        const resource = ResourceManager.resources.find(r => r.id === editId);
                        if (resource) {
                            if (!supabase?.isAuthenticated()) {
                                window.logAuthWarning('ResourceManager', 'update resources');
                                alert('Fehler: Nicht authentifiziert. Resource kann nicht aktualisiert werden.');
                                return;
                            }
                            
                            Object.assign(resource, resourceData);
                            try {
                                await cloudStorage.saveResource(resource);
                                ResourceManager.renderResources();
                                } catch (error) {
                                console.error('❌ ResourceManager: Error updating resource:', error);
                                alert('Fehler beim Aktualisieren der Resource: ' + error.message);
                                throw error; // Don't hide errors in pure cloud mode
                            }
                        }
                        // Clear edit mode
                        delete addResourceForm.dataset.editId;
                    } else {
                        // Add new resource
                        await ResourceManager.addResource(resourceData);
                    }
                    
                    ResourceManager.hideAddResourceModal();
                });
            }
            
            // Add Text Snippet Form Submission
            const addTextSnippetForm = document.getElementById('add-textsnippet-form');
            if (addTextSnippetForm) {
                addTextSnippetForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const textData = document.getElementById('textsnippet-text').value.trim();
                    
                    if (!textData) {
                        alert('Bitte geben Sie einen Text ein');
                        return;
                    }
                    
                    await ResourceManager.addTextSnippet(textData);
                });
            }
            
            // === TRADING RULES EVENT LISTENERS ===
            
            // Add Trading Rule Button
            const addTradingRuleBtn = document.getElementById('add-trading-rule-btn');
            if (addTradingRuleBtn) {
                addTradingRuleBtn.addEventListener('click', () => {
                    TradingRulesManager.showAddRuleModal();
                });
            }
            
            // Add Trading Rule Form Submission
            const addTradingRuleForm = document.getElementById('add-trading-rule-form');
            if (addTradingRuleForm) {
                addTradingRuleForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const ruleData = {
                        title: document.getElementById('trading-rule-title').value.trim(),
                        category: document.getElementById('trading-rule-category').value,
                        description: document.getElementById('trading-rule-description').value.trim()
                    };
                    
                    if (!ruleData.title || !ruleData.category) {
                        alert('Please fill in all required fields');
                        return;
                    }
                    
                    try {
                        await TradingRulesManager.createRule(ruleData);
                    } catch (error) {
                        console.error('❌ Error creating trading rule:', error);
                        alert('Error creating trading rule: ' + error.message);
                    }
                });
            }
            
            // Close trading rule modal when clicking outside
            const addTradingRuleModal = document.getElementById('add-trading-rule-modal');
            if (addTradingRuleModal) {
                addTradingRuleModal.addEventListener('click', (e) => {
                    if (e.target === addTradingRuleModal) {
                        TradingRulesManager.hideAddRuleModal();
                    }
                });
            }
            
            // TradingRulesManager initialization handled in main authentication flow
            
            // Hide trading rules context menu when clicking elsewhere
            document.addEventListener('click', () => {
                if (window.TradingRulesManager) {
                    TradingRulesManager.hideContextMenu();
                }
            });
            
            // Close resource modal when clicking outside
            const addResourceModal = document.getElementById('add-resource-modal');
            if (addResourceModal) {
                addResourceModal.addEventListener('click', (e) => {
                    if (e.target === addResourceModal) {
                        ResourceManager.hideAddResourceModal();
                    }
                });
            }
            
            // Close text snippet modal when clicking outside
            const addTextSnippetModal = document.getElementById('add-textsnippet-modal');
            if (addTextSnippetModal) {
                addTextSnippetModal.addEventListener('click', (e) => {
                    if (e.target === addTextSnippetModal) {
                        ResourceManager.hideAddTextSnippetModal();
                    }
                });
            }
            
            // Add Vision Form Handler
            const addVisionForm = document.getElementById('add-vision-form');
            if (addVisionForm) {
                addVisionForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const formData = {
                        title: document.getElementById('vision-title').value.trim(),
                        description: document.getElementById('vision-description').value.trim(),
                        icon: document.getElementById('vision-icon').value
                    };
                    
                    if (!formData.title || !formData.icon) {
                        alert('Bitte füllen Sie alle Pflichtfelder aus.');
                        return;
                    }
                    
                    await VisionManager.addVision(formData);
                });
            }
            
            // Close vision modal when clicking outside
            const addVisionModal = document.getElementById('add-vision-modal');
            if (addVisionModal) {
                addVisionModal.addEventListener('click', (e) => {
                    if (e.target === addVisionModal) {
                        VisionManager.hideAddVisionModal();
                    }
                });
            }
            
            // Render resources when Resources tab is selected (don't reload from scratch)
            const ressourcenTab = document.querySelector('[data-tab="ressourcen"]');
            if (ressourcenTab) {
                ressourcenTab.addEventListener('click', () => {
                    // Only render existing resources, don't reload from cloud/storage
                    ResourceManager.renderResources();
                    console.log('🎨 Resources tab clicked - rendering existing resources');
                });
            }
            
            // Render trading rules when Trading Rules tab is selected (don't reload from scratch)
            const tradingRulesTab = document.querySelector('[data-tab="trading-rules"]');
            if (tradingRulesTab) {
                tradingRulesTab.addEventListener('click', () => {
                    // Only render existing trading rules, don't reload from cloud/storage
                    TradingRulesManager.renderTradingRules();
                    console.log('🎨 Trading Rules tab clicked - rendering existing rules');
                });
            }
            
            // ResourceManager initialization moved to main DOMContentLoaded listener
            window.ResourceManager = ResourceManager;
            
            // === SIMPLE LOGOUT (URL-based) ===
            // === ROUTINE RESET FUNCTIONALITY ===
            // Use event delegation to catch button clicks even if tab is loaded later
            document.addEventListener('click', async function(e) {
                if (e.target && e.target.id === 'reset-routines-btn') {
                    console.log('🖱️ Reset routines button clicked');
                    
                    const confirmed = confirm(
                        '⚠️ ACHTUNG: Routine-Datenbank komplett zurücksetzen?\n\n' +
                        '• Löscht ALLE Routine-Daten (lokal und cloud)\n' +
                        '• Setzt alle Counter auf 0\n' +
                        '• Betrifft alle Geräte\n' +
                        '• Kann nicht rückgängig gemacht werden\n\n' +
                        'Fortfahren?'
                    );
                    
                    if (confirmed) {
                        const success = await resetRoutineDatabase();
                        if (success) {
                            alert('✅ Routine-Datenbank wurde komplett zurückgesetzt!\n\nBitte refreshe die Seite auf allen Geräten.');
                            window.location.reload();
                        } else {
                            alert('❌ Fehler beim Zurücksetzen. Bitte Console prüfen.');
                        }
                    } else {
                        console.log('❌ User cancelled reset');
                    }
                }
            });
            
            // Complete Routine Database Reset Function
            async function resetRoutineDatabase() {
                try {
                    // 1. Clear all localStorage routine data (old and new)
                    const keysToRemove = [
                        'routineCompletionData',
                        'routine_completions_cache', 
                        'monthlyRoutineCompletions',
                        'routineData',
                        'lastRoutineResetDate',
                        'routineResetTime',
                        'morningRoutineStreak',
                        'eveningRoutineStreak',
                        'simple_routine_data' // New system
                    ];
                    
                    keysToRemove.forEach(key => {
                        if (localStorage.getItem(key)) {
                            localStorage.removeItem(key);}
                    });
                    
                    // 2. Clear Supabase tables if authenticated
                    if (window.supabase && window.supabase.isAuthenticated()) {
                        const user = window.supabase.getCurrentUser();
                        try {
                            // Delete old system data
                            await window.supabase.delete('routine_completions', `user_id=eq.${user.id}`);
                            // Delete new system data
                            await window.supabase.delete('simple_routines', `user_id=eq.${user.id}`);
                            } catch (error) {
                            console.warn('⚠️ Could not clear cloud data:', error);
                        }
                    }
                    
                    // 3. Reset routine checkboxes on page
                    const morningCheckboxes = document.querySelectorAll('#morning-routine input[type="checkbox"]');
                    const eveningCheckboxes = document.querySelectorAll('#evening-routine input[type="checkbox"]');
                    
                    [...morningCheckboxes, ...eveningCheckboxes].forEach(checkbox => {
                        checkbox.checked = false;
                        const label = checkbox.nextElementSibling;
                        if (label) {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    });
                    // 4. Reset routine counters to 0 - DISABLED to prevent CloudCounters conflict
                    // NOTE: This code was interfering with CloudCounters by overriding the correct values
                    /*
                    const streakTiles = document.querySelectorAll('.streak-tile');
                    if (streakTiles.length >= 2) {
                        const morningTile = streakTiles[0];
                        const eveningTile = streakTiles[1];
                        
                        const morningNumber = morningTile?.querySelector('.streak-number');
                        const eveningNumber = eveningTile?.querySelector('.streak-number');
                        
                        if (morningNumber) morningNumber.textContent = '0';
                        if (eveningNumber) eveningNumber.textContent = '0';
                        
                        }
                    */
                    
                    // 5. Reset new simple routine manager if available
                    if (window.simpleRoutineManager) {
                        await window.simpleRoutineManager.reset();
                        }
                    
                    console.log('🎉 Routine database reset complete!');
                    return true;
                    
                } catch (error) {
                    console.error('❌ Error during routine reset:', error);
                    return false;
                }
            }
            
            // === DEBUG ROUTINE SYSTEM ===
            window.debugRoutineSystem = function() {
                console.log('======================');
                
                // Check localStorage
                const simpleData = localStorage.getItem('simple_routine_data');
                console.log('📱 simple_routine_data:', simpleData ? JSON.parse(simpleData) : 'NOT FOUND');
                
                const oldData = localStorage.getItem('routineCompletionData');
                console.log('📱 routineCompletionData (old):', oldData ? JSON.parse(oldData) : 'NOT FOUND');
                
                // Check SimpleRoutineManager
                if (window.simpleRoutineManager) {
                    console.log('📅 Today:', window.simpleRoutineManager.today);
                } else {
                    console.log('❌ SimpleRoutineManager NOT FOUND');
                }
                
                // Check checkboxes
                const morningCheckboxes = document.querySelectorAll('#morning-routine input[type="checkbox"]');
                const eveningCheckboxes = document.querySelectorAll('#evening-routine input[type="checkbox"]');
                
                // Debug: Morning checkboxes count
                console.log(`🌅 Morning checkboxes: ${morningCheckboxes.length} found`);
                
                // Debug: Evening checkboxes count  
                console.log(`🌙 Evening checkboxes: ${eveningCheckboxes.length} found`);
                
                // Check counters
                const streakTiles = document.querySelectorAll('.streak-tile');
                streakTiles.forEach((tile, index) => {
                    const number = tile.querySelector('.streak-number');
                    const label = tile.querySelector('.streak-label');
                    console.log(`- Tile ${index}: ${label?.textContent} = ${number?.textContent}`);
                });
                
                alert('Debug info logged to console - press F12 to see details');
            };
            
            // === GLOBAL ROUTINE RESET HANDLER ===
            window.handleRoutineReset = async function() {
                console.log('🖱️ handleRoutineReset called via onclick');
                
                const confirmed = confirm(
                    '⚠️ ACHTUNG: Routine-Datenbank komplett zurücksetzen?\n\n' +
                    '• Löscht ALLE Routine-Daten (lokal und cloud)\n' +
                    '• Setzt alle Counter auf 0\n' +
                    '• Betrifft alle Geräte\n' +
                    '• Kann nicht rückgängig gemacht werden\n\n' +
                    'Fortfahren?'
                );
                
                if (confirmed) {
                    const success = await resetRoutineDatabase();
                    if (success) {
                        alert('✅ Routine-Datenbank wurde komplett zurückgesetzt!\n\nBitte refreshe die Seite auf allen Geräten.');
                        window.location.reload();
                    } else {
                        alert('❌ Fehler beim Zurücksetzen. Bitte Console prüfen.');
                    }
                } else {
                    console.log('❌ User cancelled reset');
                }
            };
            
            // Initialize hash-based navigation
            initializeFromHash();
            
            // Add hash change event listener
            window.addEventListener('hashchange', handleHashChange);
            
            // Initialize URL hash for current active tab (only if authenticated)
            setTimeout(() => {
                if (supabase?.isAuthenticated()) {
                    const activeTab = document.querySelector('.nav-tab.active');
                    if (activeTab && !window.location.hash) {
                        const tabId = activeTab.getAttribute('data-tab');
                        if (tabId && tabHashMapping[tabId]) {
                            const hash = tabHashMapping[tabId];
                            window.history.replaceState(null, null, `#${hash}`);
                            window.devLog(`🔗 Initial tab loaded: ${tabId}, URL set to #${hash}`);
                        }
                    }
                }
            }, 100);
            
            // Pure cloud counter system - no force refresh needed
            setTimeout(() => {
                // Only initialize cloud counters if not already done
                if (window.CloudCounters && !window.CloudCounters.isInitialized && supabase?.isAuthenticated()) {
                    window.CloudCounters.init();
                }
                
                // Debug function for checking todo counts
                window.debugTodoCount = async function() {
                    if (!supabase?.isAuthenticated()) {
                        // Debug: Not authenticated
                        return;
                    }
                    
                    const now = new Date();
                    const currentMonth = now.getMonth() + 1;
                    const currentYear = now.getFullYear();
                    const startOfMonth = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-01`;
                    const endOfMonth = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-31`;
                    
                    const user = supabase.getCurrentUser();
                    
                    console.log('📅 Date range:', startOfMonth, 'to', endOfMonth);
                    
                    // All todos this month
                    const allTodos = await supabase.query(`todos?user_id=eq.${user.id}&created_at=gte.${startOfMonth}&created_at=lt.${endOfMonth}&select=*`);
                    // Completed todos this month  
                    const completedTodos = await supabase.query(`todos?user_id=eq.${user.id}&completed=eq.true&created_at=gte.${startOfMonth}&created_at=lt.${endOfMonth}&select=*`);
                    return { all: allTodos, completed: completedTodos };
                };
                
            }, 2000);
            
            // Mobile debug removed for cleaner console output
        });

        // === WIKI MANAGER ===
        const Wiki = {
            entries: [],
            filteredEntries: [],
            
            init() {this.loadEntries();
                this.setupEventListeners();
                this.render();
            },
            
            setupEventListeners() {
                const form = document.getElementById('add-wiki-form');
                
                if (form) {
                    form.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.addEntry();
                    });
                }
            },
            
            showAddModal() {
                const modal = document.getElementById('add-wiki-modal');
                if (modal) {
                    modal.classList.remove('hide');
                    document.getElementById('wiki-title').focus();
                }
            },
            
            hideAddModal() {
                const modal = document.getElementById('add-wiki-modal');
                if (modal) {
                    modal.classList.add('hide');
                    document.getElementById('add-wiki-form').reset();
                }
            },
            
            async addEntry() {
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('Wiki', 'add entries');
                    alert('Fehler: Nicht authentifiziert. Wiki-Eintrag kann nicht gespeichert werden.');
                    return;
                }
                
                const title = document.getElementById('wiki-title').value;
                const content = document.getElementById('wiki-content').value;
                const tagsText = document.getElementById('wiki-tags').value;
                
                if (!title || !content) {
                    alert('Bitte fülle alle Pflichtfelder aus');
                    return;
                }
                
                const tags = tagsText ? tagsText.split(',').map(tag => tag.trim()).filter(tag => tag) : ['allgemein'];
                
                // Generate a unique ID for the wiki entry
                const entryId = Date.now(); // Use timestamp as ID
                
                const entry = {
                    id: entryId, // Manually set ID since table doesn't auto-generate
                    title,
                    content,
                    tags,
                    user_id: supabase.getCurrentUser().id,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                };
                
                // Remove any undefined fields that might cause issues
                Object.keys(entry).forEach(key => {
                    if (entry[key] === undefined || entry[key] === null) {
                        delete entry[key];
                    }
                });
                
                try {
                    // Use array format for insert
                    const result = await supabase.insert('crypto_wiki_entries', [entry]);
                    if (result && result.length > 0) {
                        this.entries.push(result[0]);
                        } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ Wiki: Error saving to cloud:', error);
                    console.error('❌ Wiki: Error details:', error.message);
                    alert('Fehler beim Speichern des Wiki-Eintrags: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                this.hideAddModal();
                this.render();
                
                },
            
            async deleteEntry(id) {
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('Wiki', 'delete entries');
                    alert('Fehler: Nicht authentifiziert. Wiki-Eintrag kann nicht gelöscht werden.');
                    return;
                }
                
                const entry = this.entries.find(e => e.id === id);
                if (!entry) return;
                
                try {
                    await supabase.delete('crypto_wiki_entries', `id=eq.${id}`);
                    } catch (error) {
                    console.error('❌ Wiki: Error deleting from cloud:', error);
                    alert('Fehler beim Löschen des Wiki-Eintrags: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                // Remove from local array
                this.entries = this.entries.filter(e => e.id !== id);
                
                // Pure cloud mode - no localStorage
                
                this.render();
                },
            
            search(query = '') {
                // Search disabled - no search bar available
                this.filteredEntries = this.entries;
                this.render();
            },

            render() {
                const container = document.getElementById('wiki-entries');
                if (!container) return;
                
                const entriesToShow = this.filteredEntries.length > 0 
                    ? this.filteredEntries : this.entries;
                
                if (entriesToShow.length === 0) {
                    container.innerHTML = '<div class="empty-wiki">No wiki entries found. Add your first knowledge entry!</div>';
                    return;
                }
                
                const html = entriesToShow
                    .sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at))
                    .map(entry => this.renderEntry(entry))
                    .join('');
                
                container.innerHTML = html;
                
                // Initialize Lucide icons after rendering
                setTimeout(() => {
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                    // Add right-click handlers for delete buttons
                    this.addDeleteHandlers();
                }, 100);
            },
            
            renderEntry(entry) {
                const tagsHtml = entry.tags ? entry.tags.map(tag => `<span class="journal-tag">${tag}</span>`).join('') : '';
                const categoryHtml = entry.category ? `<span class="journal-kategorie">${entry.category}</span>` : '';
                const date = new Date(entry.created_at).toLocaleDateString('de-DE');
                const time = new Date(entry.created_at).toLocaleTimeString('de-DE', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                return `
                    <div class="journal-entry" data-entry-id="${entry.id}">
                        <div class="journal-entry-header">
                            <h3 class="journal-entry-title">${entry.title}</h3>
                            <div class="journal-entry-actions">
                                <button class="delete-entry-btn" onclick="Wiki.deleteEntry('${entry.id}')" title="Delete">
                                    <i data-lucide="trash-2" style="width: 16px; height: 16px;"></i>
                                </button>
                            </div>
                        </div>
                        <div class="journal-entry-content">${entry.content}</div>
                        <div class="journal-entry-meta">
                            ${categoryHtml}
                            <div class="journal-entry-tags">
                                ${tagsHtml}
                            </div>
                            <span class="journal-entry-date">${date} • ${time}</span>
                        </div>
                    </div>
                `;
            },
            
            async loadEntries() {
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('Wiki');
                    this.entries = [];
                    this.render();
                    return;
                }
                
                try {
                    await this.loadFromCloud();
                } catch (error) {
                    console.error('❌ Wiki: Error loading entries:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },

            async saveEntries() {
                // Pure cloud mode - no localStorage saving
                if (!supabase?.isAuthenticated()) {
                    window.logAuthWarning('Wiki', 'save entries');
                    return;
                }
                
                try {
                    await this.saveToCloud();
                } catch (error) {
                    console.error('❌ Wiki: Error saving entries:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            async loadFromCloud() {
                try {
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        throw new Error('No user found');
                    }

                    const data = await supabase.query(`crypto_wiki_entries?user_id=eq.${user.id}&order=updated_at.desc&select=*`);
                    
                    if (data && Array.isArray(data)) {
                        this.entries = data;
                        this.render();
                    } else {
                        this.entries = [];
                        this.render();
                    }
                } catch (error) {
                    console.error('❌ Wiki: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },

            addDeleteHandlers() {
                document.querySelectorAll('.journal-entry').forEach(entry => {
                    entry.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        
                        // Hide all other delete buttons first
                        document.querySelectorAll('.journal-entry').forEach(el => {
                            el.classList.remove('show-delete');
                        });
                        
                        // Show delete button for this entry
                        entry.classList.add('show-delete');
                        
                        // Hide delete button after 3 seconds
                        setTimeout(() => {
                            entry.classList.remove('show-delete');
                        }, 3000);
                    });
                    
                    // Hide delete button on regular click
                    entry.addEventListener('click', (e) => {
                        // Don't hide if clicking the delete button
                        if (!e.target.closest('.delete-entry-btn')) {
                            entry.classList.remove('show-delete');
                        }
                    });
                    
                    // Add delete button click handler (in addition to onclick in HTML)
                    const deleteBtn = entry.querySelector('.delete-entry-btn');
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                        });
                    }
                });
            },
            
            async saveToCloud() {
                try {
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        console.log('❌ Wiki: No user found');
                        return;
                    }

                    // We'll save entries individually when they're created/updated
                    } catch (error) {
                    console.error('❌ Wiki: Error saving to cloud:', error);
                }
            },

            async saveEntryToCloud(entry) {
                try {
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        throw new Error('No user found');
                    }

                    const entryWithUserId = {
                        ...entry,
                        user_id: user.id
                    };

                    const data = await supabase.insert('crypto_wiki_entries', entryWithUserId);
                    
                    if (!data || !Array.isArray(data) || data.length === 0) {
                        throw new Error('Insert did not return data');
                    }

                    return true;
                } catch (error) {
                    console.error('❌ Wiki: Error in saveEntryToCloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },

            async deleteEntryFromCloud(entryId) {
                try {
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        throw new Error('No user found');
                    }

                    const result = await supabase.delete('crypto_wiki_entries', `id=eq.${entryId}`);
                    
                    return true;
                } catch (error) {
                    console.error('❌ Wiki: Error in deleteEntryFromCloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            }
        };

        // Make Wiki globally available
        window.Wiki = Wiki;

        // === QUICK ADD CLASS ===
        class QuickAdd {
            constructor() {
                this.isVisible = false;
                this.overlay = null;
                this.modal = null;
                window.devLog('⚡ QuickAdd initialized');
            }
            
            show() {
                if (this.isVisible) return;
                
                console.log('⚡ QuickAdd: Showing modal');
                this.createModal();
                this.isVisible = true;
            }
            
            hide() {
                if (!this.isVisible) return;
                
                console.log('⚡ QuickAdd: Hiding modal');
                if (this.overlay) {
                    this.overlay.remove();
                    this.overlay = null;
                    this.modal = null;
                }
                this.isVisible = false;
            }
            
            createModal() {
                // Create overlay
                this.overlay = document.createElement('div');
                this.overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    z-index: 2000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                
                // Create modal
                this.modal = document.createElement('div');
                this.modal.style.cssText = `
                    background: white;
                    border-radius: 8px;
                    padding: 2rem;
                    min-width: 400px;
                    max-width: 500px;
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
                `;
                
                this.modal.innerHTML = `
                    <h3 style="margin: 0 0 1rem 0; font-size: 1.2rem;">⚡ Quick Add Todo</h3>
                    <form id="quick-add-form" autocomplete="off">
                        <input type="text" id="quick-todo-title" placeholder="Todo eingeben..." autocomplete="off"
                               style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 1rem; font-size: 1rem;" />
                        
                        <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                            <select id="quick-todo-category" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="privat">Privat</option>
                                <option value="uni">Uni</option>
                                <option value="arbeit">Arbeit</option>
                            </select>
                            
                            <select id="quick-todo-priority" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="mittel">Mittel</option>
                                <option value="wichtig">Wichtig</option>
                                <option value="dringend">Dringend</option>
                            </select>
                        </div>
                        
                        <input type="date" id="quick-todo-deadline" 
                               style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 1rem;" />
                        
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                            <button type="button" id="quick-add-cancel" 
                                    style="padding: 0.5rem 1rem; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">
                                Abbrechen
                            </button>
                            <button type="submit" 
                                    style="padding: 0.5rem 1rem; border: none; background: #059669; color: white; border-radius: 4px; cursor: pointer;">
                                Hinzufügen
                            </button>
                        </div>
                    </form>
                `;
                
                this.overlay.appendChild(this.modal);
                document.body.appendChild(this.overlay);
                
                // Set today as default deadline
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('quick-todo-deadline').value = today;
                
                // Focus title input
                const titleInput = document.getElementById('quick-todo-title');
                setTimeout(() => titleInput.focus(), 100);
                
                // Event listeners
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // Close on overlay click
                this.overlay.addEventListener('click', (e) => {
                    if (e.target === this.overlay) {
                        this.hide();
                    }
                });
                
                // Close on ESC key
                document.addEventListener('keydown', this.handleKeydown.bind(this));
                
                // Cancel button
                document.getElementById('quick-add-cancel').addEventListener('click', () => {
                    this.hide();
                });
                
                // Form submit
                document.getElementById('quick-add-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleSubmit();
                });
            }
            
            handleKeydown(e) {
                if (e.key === 'Escape' && this.isVisible) {
                    this.hide();
                }
            }
            
            async handleSubmit() {
                const title = document.getElementById('quick-todo-title').value.trim();
                const category = document.getElementById('quick-todo-category').value;
                const priority = document.getElementById('quick-todo-priority').value;
                const deadline = document.getElementById('quick-todo-deadline').value;
                
                if (!title) {
                    alert('Bitte gib einen Todo-Titel ein!');
                    return;
                }
                
                // Map priority string to integer for database
                const priorityMap = {
                    'mittel': 2,
                    'wichtig': 3,
                    'dringend': 4
                };
                
                const todo = {
                    text: title,  // Database uses 'text', not 'title'
                    category: category,
                    priority: priorityMap[priority] || 2,  // Convert to integer
                    date: deadline || null,  // Database uses 'date', not 'deadline'
                    time: null,  // No time specified in quick-add
                    completed: false,
                    created_at: new Date().toISOString()
                };
                
                try {
                    console.log('⚡ QuickAdd: Saving todo:', todo);
                    
                    // Check if authenticated
                    if (!window.supabase?.isAuthenticated()) {
                        alert('Nicht authentifiziert! Bitte logge dich ein.');
                        return;
                    }
                    
                    // Save using CloudStorage directly for more reliability
                    if (window.cloudStorage) {
                        await window.cloudStorage.saveTodo(todo);
                        } else if (window.TodoManager) {
                        await window.TodoManager.saveTodo(todo);
                        } else {
                        throw new Error('No todo saving mechanism available');
                    }
                    
                    // Refresh todo display immediately after saving
                    if (window.TodoManager) {
                        // Load todos from database first
                        await window.TodoManager.loadTodos();
                        
                        // Then refresh the current view
                        if (typeof window.TodoManager.refreshCurrentView === 'function') {
                            window.TodoManager.refreshCurrentView();
                        }
                        
                        // Also update home view for counters
                        if (typeof window.TodoManager.updateHomeTodos === 'function') {
                            window.TodoManager.updateHomeTodos();
                        }
                        
                        } else {
                        console.log('⚠️ QuickAdd: TodoManager not available');
                    }
                    
                    this.hide();
                } catch (error) {
                    console.error('❌ QuickAdd: Error saving todo:', error);
                    console.error('❌ QuickAdd: Error details:', error.message, error.stack);
                    alert(`Fehler beim Speichern des Todos: ${error.message}`);
                }
            }
        }
        
        // Make QuickAdd globally available
        window.QuickAdd = new QuickAdd();

        // === POMODORO TIMER ===
        class PomodoroTimer {
            constructor() {
                this.defaultDuration = 25 * 60; // 25 minutes in seconds
                this.duration = this.defaultDuration;
                this.timeLeft = this.duration;
                this.isRunning = false;
                this.interval = null;
                this.audio = null;
                this.createNotification();
                this.setupRightClickListener();
                this.loadDurationFromSettings();
            }
            
            async loadDurationFromSettings() {
                try {
                    if (window.supabase && window.supabase.isAuthenticated()) {
                        const user = window.supabase.getCurrentUser();
                        if (!user) return;
                        
                        const data = await window.supabase.query(`user_settings?user_id=eq.${user.id}&setting_key=eq.pomodoroDuration`);
                        
                        if (data && data.length > 0) {
                            const minutes = parseInt(data[0].setting_value);
                            if (minutes >= 5 && minutes <= 60) {
                                this.setDuration(minutes);
                                // Update the input field in settings if it exists
                                const durationInput = document.getElementById('pomodoro-duration');
                                if (durationInput) {
                                    durationInput.value = minutes;
                                }
                                console.log(`🍅 Loaded Pomodoro duration: ${minutes} minutes`);
                            }
                        }
                    }
                } catch (error) {
                    console.error('❌ Error loading Pomodoro duration:', error);
                }
            }
            
            setDuration(minutes) {
                this.duration = minutes * 60; // Convert minutes to seconds
                // Only reset timeLeft if timer is not currently running
                if (!this.isRunning) {
                    this.timeLeft = this.duration;
                }
                console.log(`🍅 Pomodoro duration set to ${minutes} minutes`);
            }

            createNotification() {
                // Create audio notification
                this.audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhCT2a3PLEeSYFKoPM9dePPAkVaLvt559NEAxPqODxtmQdBjiS1/DmfSwFKnPL8N2QPQsUYLPp66hVFApGn+DyvmwhCT2Z3PLEeSYFKoPM9dePPAkVaLrn559NEAtPpuDxtmQdBjiS1/DmfSwFKnTL8N2QPAoVYLLq66hVFApFn+DyvmwhCT2Z3PLEeSYFKoPM9dePPAkVaLrn559NEAtPpuDytmQdBjiS1/DmfSwFKnTL8N2QPAoVYLPq66hVFApFn+DyvmwhCT2Z3PLEeSYFKoTM9dePPAkVaLrn559NEAtPpuDytmQdBjiS1/DmfSwFKnTL8N2QPAoVYLPq66hVFApFn+DyvmwhCT2Z3PLEeSYFKoTM9dePPAkVaLrn559NEA');
            }

            setupRightClickListener() {
                // Add right-click listener to Pomodoro button AND main actions button
                document.addEventListener('contextmenu', (e) => {
                    if (e.target.closest('[data-action="pomodoro"]') || 
                        (e.target.closest('#quickbar-actions') && this.isPomodoroActive())) {
                        e.preventDefault();
                        console.log('🍅 Right-click detected - resetting timer');
                        this.reset();
                    }
                });
            }

            isPomodoroActive() {
                return this.isRunning || this.timeLeft < this.duration;
            }

            toggle() {
                if (this.isRunning) {
                    this.stop();
                } else {
                    this.start();
                }
            }

            start() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.updateButtonState();
                
                this.interval = setInterval(() => {
                    this.timeLeft--;
                    this.updateDisplay();
                    
                    if (this.timeLeft <= 0) {
                        this.complete();
                    }
                }, 1000);
                
                console.log('🍅 Pomodoro started');
            }

            stop() {
                if (!this.isRunning) return;
                
                this.isRunning = false;
                clearInterval(this.interval);
                this.updateButtonState();
                console.log('⏸️ Pomodoro paused');
            }

            reset() {
                this.stop();
                this.timeLeft = this.duration;
                this.updateDisplay();
                this.updateButtonState();
                }

            complete() {
                this.stop();
                this.timeLeft = 0;
                this.updateDisplay();
                
                // Play notification sound
                if (this.audio) {
                    this.audio.play().catch(e => console.log('Audio notification failed:', e));
                }
                
                // Show completion message
                const minutes = Math.floor(this.duration / 60);
                alert(`🍅 Pomodoro completed! ${minutes} minutes of focus time finished.`);
                
                // Auto-reset after completion
                setTimeout(() => this.reset(), 2000);
                
                }

            updateDisplay() {
                const minutes = Math.floor(this.timeLeft / 60);
                const seconds = this.timeLeft % 60;
                const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Update document title if timer is running
                if (this.isRunning) {
                    document.title = `🍅 ${timeString} - Dash v4.1`;
                } else if (document.title.includes('🍅')) {
                    document.title = 'Dash v4.1';
                }
                
                // Update button tooltip with current time
                const pomodoroBtn = document.querySelector('[data-action="pomodoro"]');
                if (pomodoroBtn) {
                    if (this.timeLeft === this.duration && !this.isRunning) {
                        pomodoroBtn.setAttribute('data-tooltip', 'Pomodoro Timer');
                    } else {
                        const state = this.isRunning ? 'Läuft' : 'Pausiert';
                        pomodoroBtn.setAttribute('data-tooltip', `Pomodoro: ${timeString} (${state})`);
                    }
                }
            }

            updateButtonState() {
                const pomodoroBtn = document.querySelector('[data-action="pomodoro"]');
                const actionsMainBtn = document.getElementById('quickbar-actions');
                
                // Update sub-button (pomodoro button)
                if (pomodoroBtn) {
                    const icon = pomodoroBtn.querySelector('i');
                    if (icon) {
                        if (this.isRunning) {
                            // Change to pause icon when running
                            icon.setAttribute('data-lucide', 'pause-circle');
                            pomodoroBtn.style.background = '#ef4444'; // Red when running
                            pomodoroBtn.style.color = 'white';
                        } else if (this.timeLeft < this.duration) {
                            // Show play icon when paused
                            icon.setAttribute('data-lucide', 'play-circle');
                            pomodoroBtn.style.background = '#f59e0b'; // Orange when paused
                            pomodoroBtn.style.color = 'white';
                        } else {
                            // Default timer icon when reset
                            icon.setAttribute('data-lucide', 'timer');
                            pomodoroBtn.style.background = '';
                            pomodoroBtn.style.color = '';
                        }
                    }
                }
                
                // Update main actions button when Pomodoro is running/paused
                if (actionsMainBtn) {
                    const mainIcon = actionsMainBtn.querySelector('i');
                    if (mainIcon) {
                        if (this.isRunning) {
                            // Show pause icon on main button when running
                            mainIcon.setAttribute('data-lucide', 'pause-circle');
                            actionsMainBtn.style.background = '#ef4444'; // Red when running
                            actionsMainBtn.style.color = 'white';
                            actionsMainBtn.setAttribute('data-tooltip', `Pomodoro läuft - Klick zum Pausieren`);
                        } else if (this.timeLeft < this.duration) {
                            // Show play icon on main button when paused
                            mainIcon.setAttribute('data-lucide', 'play-circle');
                            actionsMainBtn.style.background = '#f59e0b'; // Orange when paused
                            actionsMainBtn.style.color = 'white';
                            actionsMainBtn.setAttribute('data-tooltip', `Pomodoro pausiert - Klick zum Fortsetzen`);
                        } else {
                            // Reset to default zap icon
                            mainIcon.setAttribute('data-lucide', 'zap');
                            actionsMainBtn.style.background = '';
                            actionsMainBtn.style.color = '';
                            actionsMainBtn.setAttribute('data-tooltip', 'Quick Actions');
                        }
                    }
                }
                
                // Refresh Lucide icons
                if (window.lucide) {
                    lucide.createIcons();
                }
                
                this.updateDisplay();
            }
        }

        // === QUICKBAR FUNCTIONALITY ===
        class QuickBar {
            constructor() {
                this.activeCategory = null;
                this.hasRunSecondFix = false;
                this.initTheme();
                this.init();
            }

            initTheme() {
                // Default to light mode (no localStorage dependency)
                const defaultTheme = 'light';
                document.documentElement.setAttribute('data-theme', defaultTheme);
                window.devLog('🎨 Initializing theme to:', defaultTheme);
                
                // Update button icon using the clean method
                setTimeout(() => {
                    this.updateDarkModeIcon(defaultTheme);
                    
                    // Fix white elements if dark mode is active
                    if (defaultTheme === 'dark') {
                        this.fixWhiteElementsInDarkMode();
                    }
                }, 200);
            }

            isPomodoroActive() {
                return window.PomodoroTimer && window.PomodoroTimer.isPomodoroActive();
            }

            init() {
                this.setupEventListeners();
                this.setupDynamicContentObserver();
                // Initialize Lucide icons for QuickBar
                setTimeout(() => {
                    if (window.lucide) {
                        lucide.createIcons();
                        console.log('🎨 Lucide icons initialized for QuickBar');
                    }
                    
                    // Re-initialize page-level add button listeners
                    this.initializePageLevelButtons();
                }, 150);
            }

            setupDynamicContentObserver() {
                // Watch for dynamic content changes
                const observer = new MutationObserver((mutations) => {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    if (currentTheme === 'dark') {
                        let shouldFix = false;
                        mutations.forEach(mutation => {
                            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                                mutation.addedNodes.forEach(node => {
                                    if (node.nodeType === 1) { // Element node
                                        shouldFix = true;
                                    }
                                });
                            }
                        });
                        
                        if (shouldFix) {
                            setTimeout(() => {
                                this.fixWhiteElementsInDarkMode();
                            }, 100);
                        }
                    }
                });

                // Start observing
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });

                console.log('👀 Dynamic content observer started');
            }

            initializePageLevelButtons() {
                window.devLog('🔗 Re-initializing page-level add button listeners...');
                
                // Add Todo Button
                const addTodoBtn = document.getElementById('add-todo-btn');
                if (addTodoBtn && !addTodoBtn.hasAttribute('data-listener-added')) {
                    addTodoBtn.addEventListener('click', () => {
                        if (window.TodoManager) {
                            TodoManager.showAddTodoModal();
                        }
                    });
                    addTodoBtn.setAttribute('data-listener-added', 'true');
                    }

                // Add Goal Button  
                const addGoalBtn = document.getElementById('add-goal-btn');
                if (addGoalBtn && !addGoalBtn.hasAttribute('data-listener-added')) {
                    addGoalBtn.addEventListener('click', () => {
                        if (window.GoalManager) {
                            GoalManager.showAddGoalModal();
                        }
                    });
                    addGoalBtn.setAttribute('data-listener-added', 'true');
                    }

                // Add Journal Button
                const addJournalBtn = document.getElementById('add-journal-btn');
                if (addJournalBtn && !addJournalBtn.hasAttribute('data-listener-added')) {
                    addJournalBtn.addEventListener('click', () => {
                        const modal = document.getElementById('journal-modal');
                        if (modal) {
                            modal.style.display = 'flex';
                        }
                    });
                    addJournalBtn.setAttribute('data-listener-added', 'true');
                    }

                // Add Resource Button
                const addResourceBtn = document.getElementById('add-resource-btn');
                if (addResourceBtn && !addResourceBtn.hasAttribute('data-listener-added')) {
                    addResourceBtn.addEventListener('click', () => {
                        if (window.ResourceManager) {
                            ResourceManager.showAddResourceModal();
                        }
                    });
                    addResourceBtn.setAttribute('data-listener-added', 'true');
                    }

                // Add Wiki Button
                const addWikiBtn = document.getElementById('add-wiki-btn');
                if (addWikiBtn && !addWikiBtn.hasAttribute('data-listener-added')) {
                    addWikiBtn.addEventListener('click', () => {
                        const modal = document.getElementById('wiki-modal');
                        if (modal) {
                            modal.style.display = 'flex';
                        }
                    });
                    addWikiBtn.setAttribute('data-listener-added', 'true');
                    }

                // Add Termin Button
                const addTerminBtn = document.getElementById('add-termin-btn');
                if (addTerminBtn && !addTerminBtn.hasAttribute('data-listener-added')) {
                    addTerminBtn.addEventListener('click', () => {
                        if (window.TerminManager) {
                            TerminManager.showAddTerminModal();
                        }
                    });
                    addTerminBtn.setAttribute('data-listener-added', 'true');
                    }
            }

            setupEventListeners() {
                // Main category button listeners
                document.addEventListener('click', (e) => {
                    if (e.target.closest('.quickbar-main-btn')) {
                        const btn = e.target.closest('.quickbar-main-btn');
                        const category = btn.dataset.category;
                        const action = btn.dataset.action;
                        
                        // Handle dynamic buttons with data-action
                        if (action && !category) {
                            this.handleAction(action, e);
                            return;
                        }
                        
                        // Handle regular category buttons with data-category
                        if (category) {
                            // Special handling for actions category when Pomodoro is active
                            if (category === 'actions' && this.isPomodoroActive()) {
                                // If Pomodoro is running or paused, clicking the main actions button directly toggles it
                                console.log('🍅 Main button clicked - toggling Pomodoro timer');
                                window.PomodoroTimer.toggle();
                                this.closeAllSubMenus(); // Close any open menus
                                return;
                            }
                            
                            this.toggleCategory(category);
                        }
                    }
                    
                    // Sub-button action listeners
                    if (e.target.closest('.quickbar-sub-btn')) {
                        const subBtn = e.target.closest('.quickbar-sub-btn');
                        const action = subBtn.dataset.action;
                        this.handleAction(action, e);
                    }

                    // Tab clicks - fix dark mode after tab switch
                    if (e.target.closest('.nav-tab')) {
                        const currentTheme = document.documentElement.getAttribute('data-theme');
                        if (currentTheme === 'dark') {
                            setTimeout(() => {
                                console.log('📑 Tab switched, fixing dark mode elements...');
                                this.fixWhiteElementsInDarkMode();
                            }, 300);
                        }
                    }
                    
                    // Close sub-menus when clicking outside
                    if (!e.target.closest('.quickbar')) {
                        this.closeAllSubMenus();
                    }
                });
            }

            toggleCategory(category) {
                if (!category) {
                    console.warn('⚠️ toggleCategory called with null/undefined category, ignoring');
                    return;
                }
                
                const categoryContainer = document.querySelector(`.quickbar-category[data-category="${category}"]`);
                const subContainer = document.getElementById(`quickbar-${category}-sub`);
                const mainBtn = document.getElementById(`quickbar-${category}`);
                const quickbar = document.getElementById('quickbar');
                
                if (this.activeCategory === category) {
                    // Close current category
                    this.closeAllSubMenus();
                    this.activeCategory = null;
                } else {
                    // Close all others, open this one
                    this.closeAllSubMenus();
                    
                    // Verify elements exist before manipulating them
                    if (!categoryContainer) {
                        console.error(`❌ Category container not found for category: ${category}`);
                        return;
                    }
                    if (!subContainer) {
                        console.error(`❌ Sub container not found for category: ${category}`);
                        return;
                    }
                    if (!mainBtn) {
                        console.error(`❌ Main button not found for category: ${category}`);
                        return;
                    }
                    
                    // Mark quickbar as having active state
                    quickbar.classList.add('has-active');
                    
                    // Mark category as active
                    categoryContainer.classList.add('active');
                    
                    // Show sub-buttons
                    subContainer.classList.add('show');
                    mainBtn.classList.add('active');
                    this.activeCategory = category;
                }
            }

            closeAllSubMenus() {
                const quickbar = document.getElementById('quickbar');
                
                // Remove has-active state from quickbar
                quickbar.classList.remove('has-active');
                
                // Remove active from all categories
                document.querySelectorAll('.quickbar-category').forEach(cat => {
                    cat.classList.remove('active');
                });
                
                // Hide all sub-buttons
                document.querySelectorAll('.quickbar-sub-buttons').forEach(sub => {
                    sub.classList.remove('show');
                });
                
                // Remove active from all main buttons
                document.querySelectorAll('.quickbar-main-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Reset active category state
                this.activeCategory = null;
            }

            handleAction(action, event = null) {
                this.closeAllSubMenus();
                
                // Reset active category to allow immediate re-opening
                this.activeCategory = null;
                
                // Refresh Lucide icons after closing menus
                setTimeout(() => {
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                }, 50);
                
                switch(action) {
                    // === ADD ACTIONS ===
                    case 'add-todo':
                        if (window.TodoManager) {
                            TodoManager.showAddTodoModal();
                        } else {
                            document.getElementById('todo-modal').style.display = 'flex';
                        }
                        break;
                    case 'add-termin':
                        if (window.TerminManager) {
                            TerminManager.showAddTerminModal();
                        } else {
                            document.getElementById('termin-modal').style.display = 'flex';
                        }
                        break;
                    case 'add-goal':
                        if (window.GoalManager) {
                            GoalManager.showAddGoalModal();
                        } else {
                            document.getElementById('goal-modal').style.display = 'flex';
                        }
                        break;
                    case 'add-resource':
                        if (window.ResourceManager) {
                            ResourceManager.showAddResourceModal();
                        } else {
                            document.getElementById('resource-modal').style.display = 'flex';
                        }
                        break;
                    case 'add-wiki':
                        if (window.WikiManager) {
                            WikiManager.showAddWikiModal();
                        } else {
                            const wikiModal = document.getElementById('add-wiki-modal');
                            if (wikiModal) {
                                wikiModal.classList.remove('hide');
                            }
                        }
                        break;
                    case 'add-journal':
                        if (window.JournalManager) {
                            JournalManager.showAddJournalModal();
                        } else {
                            const journalModal = document.getElementById('add-journal-modal');
                            if (journalModal) {
                                journalModal.classList.remove('hide');
                            }
                        }
                        break;
                    
                    // === QUICK ACTIONS ===
                    case 'global-search':
                        this.openGlobalSearch();
                        break;
                    case 'pomodoro':
                        this.openPomodoro();
                        break;
                    case 'trading-rules':
                        this.openTradingRules();
                        break;
                    
                    // === SYSTEM ACTIONS ===
                    case 'dark-mode':
                        this.toggleDarkMode();
                        break;
                    case 'pomodoro-toggle':
                        console.log('🍅 Dynamic Pomodoro button clicked');
                        if (window.PomodoroTimer) {
                            window.PomodoroTimer.toggle();
                            this.updateDynamicButtons();
                        }
                        break;
                    case 'darkmode-toggle':
                        console.log('🌙 Dynamic Dark Mode button clicked');
                        this.toggleDarkMode();
                        break;
                    case 'braindump-toggle':
                        if (event) {
                            }
                        this.toggleBrainDumpContainer();
                        break;
                    case 'settings':
                        this.openSettings();
                        break;
                    case 'logout':
                        this.handleLogout();
                        break;
                }
            }

            // === QUICK ACTIONS ===
            openGlobalSearch() {
                GlobalSearch.show();
            }

            openPomodoro() {
                // PomodoroTimer is now initialized globally at startup
                if (!window.PomodoroTimer) {
                    console.error('❌ PomodoroTimer not found! Trying to initialize...');
                    try {
                        window.PomodoroTimer = new PomodoroTimer();
                    } catch (error) {
                        console.error('❌ Failed to initialize PomodoroTimer:', error);
                        return;
                    }
                }
                
                window.PomodoroTimer.toggle();
                
                // Update dynamic buttons to show/hide the main button
                this.updateDynamicButtons();
                this.closeAllSubMenus();
            }

            openTradingRules() {
                switchTab('tab-trading-rules');
                this.closeAllSubMenus();
            }

            // === SYSTEM ACTIONS ===
            toggleDarkMode() {
                const html = document.documentElement;
                const currentTheme = html.getAttribute('data-theme') || 'light';
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                console.log('🌙 Dark Mode Toggle:', { currentTheme, newTheme });
                
                html.setAttribute('data-theme', newTheme);
                
                // Update dark mode button icon - single clean method
                this.updateDarkModeIcon(newTheme);
                
                // Fix white elements with JavaScript
                if (newTheme === 'dark') {
                    this.fixWhiteElementsInDarkMode();
                    this.updateChartsForDarkMode();
                } else {
                    this.resetLightModeStyles();
                    this.updateChartsForLightMode();
                }
                
                // Force style recalculation and cache bust
                document.body.style.display = 'none';
                document.body.offsetHeight; // Trigger reflow
                document.body.style.display = '';
                
                // Cache busting - force browser to re-render
                const timestamp = Date.now();
                document.documentElement.style.setProperty('--cache-bust', timestamp);
                
                // Additional force refresh
                if (window.getComputedStyle) {
                    window.getComputedStyle(document.body).getPropertyValue('background-color');
                }

                this.closeAllSubMenus();
            }
            
            updateDarkModeIcon(theme) {
                // Update dynamic main button for dark mode
                this.updateDynamicButtons();
                
                const darkModeBtn = document.querySelector('[data-action="dark-mode"]');
                if (!darkModeBtn) {
                    console.error('❌ Dark mode button not found');
                    return;
                }

                // Set new icon based on current theme
                // If dark theme: show sun (to switch back to light)  
                // If light theme: show moon (to switch to dark)
                const newIcon = theme === 'dark' ? 'sun' : 'moon';
                
                // Replace the entire button innerHTML with new icon
                
                darkModeBtn.innerHTML = `<i data-lucide="${newIcon}"></i>`;
                
                // Re-initialize Lucide for all icons
                setTimeout(() => {
                    if (window.lucide) {
                        lucide.createIcons();
                        
                        // Verify the icon changed
                        const updatedIcon = darkModeBtn.querySelector('i');
                        if (updatedIcon) {
                            }
                    }
                }, 100);
            }
            
            toggleBrainDumpContainer() {
                // Navigate to todos tab
                const todosTabButton = document.querySelector('[data-tab="tab-todos"]');
                
                if (todosTabButton) {
                    todosTabButton.click();
                    
                    // Force scroll to top after tab switch and show container
                    setTimeout(() => {
                        // Force scroll to top
                        window.scrollTo({ top: 0, behavior: 'instant' });
                        document.documentElement.scrollTop = 0;
                        document.body.scrollTop = 0;
                        
                        const container = document.getElementById('brain-dump-container');
                        if (container) {
                            container.style.display = 'block';
                            container.style.visibility = 'visible';
                            }
                    }, 150);
                }
            }
            
            updateDynamicButtons() {
                // Handle Dark Mode dynamic button
                const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
                const darkModeButton = document.getElementById('dynamic-darkmode');
                
                if (darkModeButton) {
                    if (isDarkMode) {
                        darkModeButton.style.display = 'block';
                    } else {
                        darkModeButton.style.display = 'none';
                    }
                }
                
                // Handle Pomodoro dynamic button
                const isPomodoroActive = this.isPomodoroActive();
                const pomodoroButton = document.getElementById('dynamic-pomodoro');
                const pomodoroBtn = document.getElementById('dynamic-pomodoro-btn');
                
                if (pomodoroButton) {
                    if (isPomodoroActive) {
                        pomodoroButton.style.display = 'block';
                        
                        // Update pomodoro button state
                        if (window.PomodoroTimer && pomodoroBtn) {
                            const isRunning = window.PomodoroTimer.isRunning;
                            
                            // Always recreate the icon to ensure it exists and is correct
                            const iconType = isRunning ? 'pause-circle' : 'play-circle';
                            const tooltipText = isRunning ? 'Pause Timer' : 'Resume Timer';
                            
                            pomodoroBtn.innerHTML = `<i data-lucide="${iconType}"></i>`;
                            pomodoroBtn.setAttribute('data-tooltip', tooltipText);
                            pomodoroBtn.classList.add('pomodoro-active');
                            
                        }
                    } else {
                        pomodoroButton.style.display = 'none';
                    }
                }
                
                // Handle Brain Dump dynamic button
                const brainDumpButton = document.getElementById('dynamic-braindump');
                const brainDumpBadge = document.getElementById('braindump-quickbar-badge');
                
                // Try both window.brainDumpManager and global brainDumpManager
                const manager = window.brainDumpManager || (typeof brainDumpManager !== 'undefined' ? brainDumpManager : null);
                
                if (brainDumpButton && manager) {
                    const count = manager.brainDumps.length;
                    if (count > 0) {
                        brainDumpButton.style.display = 'block';
                        if (brainDumpBadge) {
                            brainDumpBadge.textContent = count;
                            }
                    } else {
                        brainDumpButton.style.display = 'none';
                        }
                } else {
                    window.logAuthWarning('BrainDump', 'update dynamic buttons');
                }
                
                // Re-initialize Lucide icons for dynamic buttons
                setTimeout(() => {
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                }, 50);
            }

            fixWhiteElementsInDarkMode() {// Force fix specific known problematic elements
                const specificSelectors = [
                    '.termin-days-until',
                    '.ziel-days-until', 
                    '.delete-entry-btn',
                    '.journal-entry-actions button',
                    '.journal-tag',
                    '.wiki-tag',
                    '.todo-tag',
                    '.add-btn',
                    'button[style*="background"]',
                    'div[style*="background: #fafafa"]',
                    'span[style*="background"]'
                ];
                
                specificSelectors.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        if (selector.includes('days-until')) {
                            el.style.setProperty('background', '#2d3748', 'important');
                            el.style.setProperty('color', '#63b3ed', 'important');
                            el.style.setProperty('border', '1px solid #4a5568', 'important');
                        } else {
                            el.style.setProperty('background', '#1a1a2e', 'important');
                            el.style.setProperty('color', '#e2e8f0', 'important');
                            el.style.setProperty('border', '1px solid #2d3748', 'important');
                        }
                        console.log('🎯 Fixed element:', el.className || el.tagName);
                    });
                });
                
                // Scan ALL elements for white backgrounds
                const allElements = document.querySelectorAll('*');
                let fixedCount = 0;
                
                allElements.forEach(el => {
                    const styles = window.getComputedStyle(el);
                    const bgColor = styles.backgroundColor;
                    const inlineStyle = el.style.backgroundColor;
                    
                    // Check for any white/light colors
                    const isWhite = bgColor === 'rgb(255, 255, 255)' || 
                                   bgColor === 'rgb(250, 250, 250)' || 
                                   bgColor === 'rgb(248, 249, 250)' ||
                                   bgColor === 'white' ||
                                   inlineStyle === 'white' ||
                                   inlineStyle === '#ffffff' ||
                                   inlineStyle === '#fafafa' ||
                                   inlineStyle === 'rgb(255, 255, 255)';
                    
                    if (isWhite) {
                        // Force fix with !important
                        if (el.classList.contains('termin-days-until') || el.classList.contains('ziel-days-until')) {
                            el.style.setProperty('background-color', '#2d3748', 'important');
                            el.style.setProperty('color', '#63b3ed', 'important');
                            el.style.setProperty('border', '1px solid #4a5568', 'important');
                        } else {
                            el.style.setProperty('background-color', '#1a1a2e', 'important');
                            el.style.setProperty('color', '#e2e8f0', 'important');
                        }
                        fixedCount++;}
                });// Run once more after a delay to catch dynamically loaded content
                if (!this.hasRunSecondFix) {
                    this.hasRunSecondFix = true;
                    setTimeout(() => {
                        const allElements2 = document.querySelectorAll('*');
                        allElements2.forEach(el => {
                            const styles = window.getComputedStyle(el);
                            const bgColor = styles.backgroundColor;
                            if (bgColor === 'rgb(255, 255, 255)' || bgColor === 'rgb(250, 250, 250)') {
                                el.style.setProperty('background-color', '#1a1a2e', 'important');
                                el.style.setProperty('color', '#e2e8f0', 'important');
                            }
                        });
                    }, 1000);
                }
            }

            updateChartsForDarkMode() {
                // Update Chart.js charts for dark mode
                if (window.Chart && window.AnalyticsManager && window.AnalyticsManager.chart) {
                    const chart = window.AnalyticsManager.chart;
                    
                    // Update chart options for dark mode
                    chart.options.scales.x.ticks.color = '#e2e8f0';
                    chart.options.scales.x.grid.color = '#2d3748';
                    chart.options.scales.y.ticks.color = '#e2e8f0';
                    chart.options.scales.y.grid.color = '#2d3748';
                    
                    // Update dataset colors
                    chart.data.datasets.forEach(dataset => {
                        if (dataset.borderColor === '#000000' || dataset.borderColor === 'black') {
                            dataset.borderColor = '#63b3ed';
                        }
                        if (dataset.backgroundColor === '#000000' || dataset.backgroundColor === 'black') {
                            dataset.backgroundColor = 'rgba(99, 179, 237, 0.1)';
                        }
                    });
                    
                    chart.update();
                    }
            }

            resetLightModeStyles() {
                // Reset any inline styles that were applied by dark mode
                const elementsToReset = document.querySelectorAll('*[style*="background"]');
                elementsToReset.forEach(el => {
                    // Remove inline styles that were added by dark mode fixes
                    if (el.style.backgroundColor === '#1a1a2e' || 
                        el.style.backgroundColor === '#2d3748' ||
                        el.style.backgroundColor === 'rgb(26, 26, 46)' ||
                        el.style.backgroundColor === 'rgb(45, 55, 72)') {
                        el.style.removeProperty('background-color');
                        el.style.removeProperty('color');
                        el.style.removeProperty('border');
                    }
                });
                
                // Reset hasRunSecondFix flag
                this.hasRunSecondFix = false;
                
                }

            updateChartsForLightMode() {
                // Update Chart.js charts for light mode
                if (window.Chart && window.AnalyticsManager && window.AnalyticsManager.chart) {
                    const chart = window.AnalyticsManager.chart;
                    
                    // Update chart options for light mode
                    chart.options.scales.x.ticks.color = '#333333';
                    chart.options.scales.x.grid.color = '#e0e0e0';
                    chart.options.scales.y.ticks.color = '#333333';
                    chart.options.scales.y.grid.color = '#e0e0e0';
                    
                    // Update dataset colors
                    chart.data.datasets.forEach(dataset => {
                        if (dataset.borderColor === '#63b3ed') {
                            dataset.borderColor = '#000000';
                        }
                        if (dataset.backgroundColor === 'rgba(99, 179, 237, 0.1)') {
                            dataset.backgroundColor = 'rgba(0, 0, 0, 0.1)';
                        }
                    });
                    
                    chart.update();
                    }
            }

            openSettings() {
                // Switch to settings tab
                const allTabs = document.querySelectorAll('.tab-section');
                const allNavTabs = document.querySelectorAll('.nav-tab');
                
                // Hide all tabs
                allTabs.forEach(tab => tab.classList.remove('active'));
                // Remove active from all nav tabs
                allNavTabs.forEach(tab => tab.classList.remove('active'));
                
                // Show settings tab
                const settingsTab = document.getElementById('tab-settings');
                if (settingsTab) {
                    settingsTab.classList.add('active');
                }
                
                // Update page title
                document.title = 'Settings - Dash v4.1';
                
                }

            async handleLogout() {
                // Direct logout without confirmation popup
                try {
                    console.log('🚪 Logging out...');
                    
                    // Hide QuickBar immediately before logout
                    const quickbar = document.getElementById('quickbar');
                    if (quickbar) {
                        quickbar.style.display = 'none';
                    }
                    
                    if (window.supabase) {
                        await window.supabase.signOut();
                    }
                    
                    // Clear any local auth data
                    localStorage.removeItem('supabase.auth.token');
                    
                    // Redirect to clean URL without hash
                    window.location.href = window.location.origin;
                } catch (error) {
                    console.error('Logout error:', error);
                    // Force reload anyway to clear state
                    location.reload();
                }
            }
        }

        // Make QuickBar globally available
        window.QuickBar = new QuickBar();
        
        // Initialize PomodoroTimer globally so it's always available
        window.PomodoroTimer = new PomodoroTimer();
        window.devLog('🍅 PomodoroTimer initialized globally on startup');
        
        // Wiki and Lucide icons initialization moved to main DOMContentLoaded listener
    </script>
    
    <!-- ========================================= -->
    <!-- TRADING MANAGER -->
    <!-- ========================================= -->
    <script>
        // NEUES SIMPLES TRADING SYSTEM
        let allTrades = [];
        
        function addNewTrade() {
            const newTrade = {
                id: Date.now().toString(),
                name: 'Neuer Trade',
                einsatz: '',
                ertrag: '',
                notes: '',
                user_id: window.supabase?.getCurrentUser()?.id
            };
            
            allTrades.unshift(newTrade); // Add to beginning
            renderAllTrades();
            saveTradeToCloud(newTrade);
        }
        
        function renderAllTrades() {
            const container = document.getElementById('trades-container');
            if (!container) return;
            
            if (allTrades.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: #666; border-bottom: 1px solid #eee;">Noch keine Trades erfasst. Klicke auf + um deinen ersten Trade hinzuzufügen.</div>';
                return;
            }
            
            let html = '';
            allTrades.forEach(trade => {
                html += `<div class="trade-row-grid" data-trade-id="${trade.id}" style="display: grid; grid-template-columns: 25% 20% 20% 35%; border-bottom: 1px solid #eee; min-height: 50px;">
                    <div contenteditable="true" data-field="name" style="padding: 12px; border-right: 1px solid #eee; outline: none;" onblur="updateTrade('${trade.id}', 'name', this.textContent)">${trade.name}</div>
                    <div contenteditable="true" data-field="einsatz" style="padding: 12px; border-right: 1px solid #eee; text-align: center; outline: none;" onblur="updateTrade('${trade.id}', 'einsatz', this.textContent)">${trade.einsatz}</div>
                    <div contenteditable="true" data-field="ertrag" style="padding: 12px; border-right: 1px solid #eee; text-align: center; outline: none;" onblur="updateTrade('${trade.id}', 'ertrag', this.textContent)">${trade.ertrag}</div>
                    <div contenteditable="true" data-field="notes" style="padding: 12px; outline: none; position: relative;" onblur="updateTrade('${trade.id}', 'notes', this.textContent)" oncontextmenu="showDeleteButton(event, '${trade.id}')">${trade.notes}
                        <button id="delete-${trade.id}" style="display: none; position: absolute; top: 4px; right: 4px; background: #dc2626; color: white; border: none; width: 18px; height: 18px; font-size: 12px; cursor: pointer; border-radius: 2px;" onclick="deleteTrade('${trade.id}')">×</button>
                    </div>
                </div>`;
            });
            
            container.innerHTML = html;
        }
        
        function updateTrade(tradeId, field, value) {
            const trade = allTrades.find(t => t.id === tradeId);
            if (trade) {
                trade[field] = value;
                saveTradeToCloud(trade);
            }
        }
        
        function showDeleteButton(event, tradeId) {
            event.preventDefault();
            
            // Hide all delete buttons
            document.querySelectorAll('[id^="delete-"]').forEach(btn => {
                btn.style.display = 'none';
            });
            
            // Show this delete button
            const deleteBtn = document.getElementById('delete-' + tradeId);
            if (deleteBtn) {
                deleteBtn.style.display = 'block';
            }
        }
        
        function deleteTrade(tradeId) {
            // Remove from array
            allTrades = allTrades.filter(t => t.id !== tradeId);
            
            // Re-render
            renderAllTrades();
            
            // Delete from cloud
            if (window.supabase?.isAuthenticated()) {
                window.supabase.delete('simple_trades', tradeId);
            }
        }
        
        async function saveTradeToCloud(trade) {
            if (!window.supabase?.isAuthenticated()) return;
            
            try {
                const cloudTrade = {
                    id: trade.id,
                    name: trade.name,
                    einsatz: trade.einsatz,
                    ertrag: trade.ertrag,
                    notes: trade.notes,
                    date: new Date().toLocaleDateString('de-DE'),
                    user_id: trade.user_id
                };
                
                // Check if exists
                const existing = allTrades.find(t => t.id === trade.id && t.saved);
                if (existing) {
                    await window.supabase.update('simple_trades', cloudTrade, trade.id);
                } else {
                    await window.supabase.insert('simple_trades', [cloudTrade]);
                    trade.saved = true;
                }
            } catch (error) {
                console.error('Save error:', error);
            }
        }
        
        async function loadTrades() {
            if (!window.supabase?.isAuthenticated()) {
                allTrades = [];
                renderAllTrades();
                return;
            }
            
            try {
                const user = window.supabase.getCurrentUser();
                const data = await window.supabase.query(`simple_trades?user_id=eq.${user.id}&select=*&order=created_at.desc`);
                
                if (data && data.length > 0) {
                    allTrades = data.map(t => ({...t, saved: true}));
                } else {
                    allTrades = [];
                }
                
                renderAllTrades();
            } catch (error) {
                console.error('Load error:', error);
                allTrades = [];
                renderAllTrades();
            }
        }
        
        // Load trades when trading tab is clicked
        document.addEventListener('click', (e) => {
            if (e.target.matches('[data-tab="tab-trading"]')) {
                loadTrades();
            }
        });
        
        // Hide delete buttons when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!e.target.matches('[id^="delete-"]')) {
                document.querySelectorAll('[id^="delete-"]').forEach(btn => {
                    btn.style.display = 'none';
                });
            }
        });

        // Dummy for compatibility  
        class TradingManager {
            constructor() {}
        }
        
        // Initialize compatibility
        window.tradingManager = new TradingManager();
    </script>
    
    
    <!-- ========================================= -->
    <!-- ANALYTICS MANAGER -->
    <!-- ========================================= -->
    <script>
        // PLACEHOLDER - Real AnalyticsManager below at line 17048+
    </script>
    
    <!-- ========================================= -->
    <!-- ANALYTICS MANAGER -->
    <!-- ========================================= -->
    <!-- ========================================= -->
    <script>
        class AnalyticsManager {
            constructor() {
                this.chart = null;
                this.currentPeriod = 'week';
                this.balanceHistory = [];
                this.init();
            }

            async init() {
                // Check if supabase is available and user is authenticated
                if (!window.supabase?.isAuthenticated()) {
                    window.logAuthWarning('Analytics', 'initialize');
                    return;
                }
                
                await this.loadBalanceHistory();
                await this.checkAndRecordDailyBalance();
                this.setupPeriodButtons();
                await this.setupChart();
                await this.updateCurrentBalance();
                await this.setupHeatmap();
                await this.setupPerformanceHeatmap();
                await this.setupMorningRoutineHeatmap();
                await this.setupEveningRoutineHeatmap();
                await this.setupSportHeatmap();
            }

            async loadBalanceHistory() {
                try {
                    if (!window.supabase?.isAuthenticated()) {
                        this.balanceHistory = [];
                        return;
                    }

                    const user = window.supabase.getCurrentUser();
                    if (!user) {
                        this.balanceHistory = [];
                        return;
                    }

                    // Query balance history from cloud
                    const data = await window.supabase.query(
                        `analytics_balance_history?user_id=eq.${user.id}&select=*&order=date.asc`
                    );

                    this.balanceHistory = data || [];
                    } catch (error) {
                    console.error('Error loading balance history:', error);
                    this.balanceHistory = [];
                }
            }

            async getTrackingTime() {
                try {
                    if (!window.supabase?.isAuthenticated()) return '06:00';
                    
                    const user = window.supabase.getCurrentUser();
                    if (!user) return '06:00';

                    // Query user settings from cloud
                    const settings = await window.supabase.query(
                        `user_settings?user_id=eq.${user.id}&setting_key=eq.balanceTrackingTime&select=setting_value`
                    );

                    return settings && settings.length > 0 ? settings[0].setting_value : '06:00';
                } catch (error) {
                    console.error('Error getting tracking time:', error);
                    return '06:00';
                }
            }

            async checkAndRecordDailyBalance() {
                const now = new Date();
                const today = now.toISOString().split('T')[0];
                const lastRecorded = this.balanceHistory[this.balanceHistory.length - 1];
                
                // Get tracking time from settings (default 06:00)
                const trackingTime = await this.getTrackingTime();
                const [hours, minutes] = trackingTime.split(':').map(Number);
                
                // Create target time for today
                const targetTime = new Date();
                targetTime.setHours(hours, minutes, 0, 0);
                
                // Check if we haven't recorded today AND it's past the target time
                const hasRecordedToday = lastRecorded && lastRecorded.date === today;
                const isPastTargetTime = now >= targetTime;
                
                if (!hasRecordedToday && isPastTargetTime) {
                    await this.recordDailyBalance();
                } else if (!hasRecordedToday) {
                    // Schedule recording for target time
                    this.scheduleNextRecording(targetTime);
                }
            }

            scheduleNextRecording(targetTime) {
                const now = new Date();
                const msUntilTarget = targetTime.getTime() - now.getTime();
                
                if (msUntilTarget > 0) {
                    setTimeout(() => {
                        this.recordDailyBalance();
                    }, msUntilTarget);
                }
            }

            async recordDailyBalance() {
                try {
                    if (!window.supabase?.isAuthenticated()) {
                        return;
                    }

                    const user = window.supabase.getCurrentUser();
                    if (!user) return;

                    let balance = 0;
                    
                    // Get SOL balance from SimpleCounters
                    if (window.SimpleCounters) {
                        balance = await window.SimpleCounters.getSolBalance();
                    }
                    
                    const today = new Date().toISOString().split('T')[0];
                    
                    // Save to cloud database
                    const balanceRecord = {
                        user_id: user.id,
                        date: today,
                        balance: balance,
                        created_at: new Date().toISOString()
                    };

                    await window.supabase.insert('analytics_balance_history', [balanceRecord]);
                    // Add to local array
                    this.balanceHistory.push({
                        date: today,
                        balance: balance
                    });
                    
                    // Keep only last 365 days in memory
                    if (this.balanceHistory.length > 365) {
                        this.balanceHistory = this.balanceHistory.slice(-365);
                    }
                    
                    // Update chart if it exists
                    if (this.chart) {
                        this.updateChart();
                    }
                } catch (error) {
                    console.error('Error recording daily balance:', error);
                }
            }

            async updateCurrentBalance() {
                try {
                    let balance = 0;
                    
                    if (window.SimpleCounters) {
                        balance = await window.SimpleCounters.getSolBalance();
                    }
                    
                    const balanceElement = document.getElementById('current-sol-balance');
                    if (balanceElement) {
                        balanceElement.textContent = `Current: ${balance.toFixed(3)} SOL`;
                    }
                } catch (error) {
                    console.error('Error updating current balance:', error);
                }
            }

            setupPeriodButtons() {
                const buttons = document.querySelectorAll('.period-btn');
                buttons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        // Remove active from all buttons
                        buttons.forEach(b => b.classList.remove('active'));
                        // Add active to clicked button
                        e.target.classList.add('active');
                        // Update period and refresh chart
                        this.currentPeriod = e.target.dataset.period;
                        this.updateChart();
                    });
                });
            }

            getFilteredData() {
                const now = new Date();
                let cutoffDate;
                
                switch(this.currentPeriod) {
                    case 'week':
                        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        break;
                    case 'month':
                        cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        break;
                    case 'quarter':
                        cutoffDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                        break;
                    case 'year':
                        cutoffDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
                        break;
                    default:
                        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                }
                
                return this.balanceHistory.filter(record => {
                    const recordDate = new Date(record.date);
                    return recordDate >= cutoffDate;
                });
            }

            async setupChart() {
                const canvas = document.getElementById('solBalanceChart');
                if (!canvas || !window.Chart) return;

                // Destroy existing chart if it exists
                if (this.chart) {
                    this.chart.destroy();
                    this.chart = null;
                }

                const ctx = canvas.getContext('2d');
                
                // Prepare data
                const filteredData = this.getFilteredData();
                const labels = filteredData.map(record => {
                    const date = new Date(record.date);
                    return date.toLocaleDateString('de-DE', { month: 'short', day: 'numeric' });
                });
                
                const data = filteredData.map(record => record.balance);
                
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'SOL Balance',
                            data: data,
                            borderColor: '#000000',
                            backgroundColor: 'rgba(0, 0, 0, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'SOL Balance',
                                    font: {
                                        size: 11
                                    }
                                },
                                ticks: {
                                    font: {
                                        size: 10
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date',
                                    font: {
                                        size: 11
                                    }
                                },
                                ticks: {
                                    font: {
                                        size: 10
                                    },
                                    maxTicksLimit: 8
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            title: {
                                display: false
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        }
                    }
                });
            }

            updateChart() {
                if (!this.chart) return;
                
                const filteredData = this.getFilteredData();
                const labels = filteredData.map(record => {
                    const date = new Date(record.date);
                    return date.toLocaleDateString('de-DE', { month: 'short', day: 'numeric' });
                });
                
                const data = filteredData.map(record => record.balance);
                
                this.chart.data.labels = labels;
                this.chart.data.datasets[0].data = data;
                this.chart.update();
            }

            async setupHeatmap() {
                // Show loading state
                const statsElement = document.getElementById('heatmap-stats');
                if (statsElement) statsElement.textContent = 'Loading todo data...';
                
                await this.generateHeatmapData();
                this.renderHeatmap();
                this.updateHeatmapStats();
            }

            async generateHeatmapData() {
                try {
                    // Generate data for the last 365 days (like GitHub)
                    const today = new Date();
                    const startDate = new Date(today);
                    startDate.setDate(today.getDate() - 364); // 365 days including today
                    
                    // Start from Sunday of the week containing startDate
                    const startSunday = new Date(startDate);
                    startSunday.setDate(startDate.getDate() - startDate.getDay());
                    
                    // Check if supabase is available and user is authenticated
                    if (!window.supabase?.isAuthenticated()) {
                        console.warn('No supabase or user not authenticated for heatmap');
                        this.heatmapData = [];
                        return;
                    }
                    
                    // Get all completed todos in one query
                    const user = window.supabase.getCurrentUser();
                    if (!user) {
                        console.warn('No user logged in for heatmap');
                        this.heatmapData = [];
                        return;
                    }
                    
                    const startDateStr = startSunday.toISOString().split('T')[0];
                    const endDateStr = new Date(today.getTime() + 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                    
                    const completedTodos = await window.supabase.query(
                        `todos?user_id=eq.${user.id}&completed=eq.true&created_at=gte.${startDateStr}&created_at=lt.${endDateStr}&select=created_at,text`
                    );
                    
                    if (completedTodos && completedTodos.length > 0) {
                        }
                    
                    // Group todos by date (convert UTC to local date)
                    const todosByDate = {};
                    if (completedTodos) {
                        completedTodos.forEach(todo => {
                            // Convert UTC timestamp to local date string
                            const utcDate = new Date(todo.created_at);
                            const localDate = new Date(utcDate.getTime() - utcDate.getTimezoneOffset() * 60000);
                            const date = localDate.toISOString().split('T')[0];
                            todosByDate[date] = (todosByDate[date] || 0) + 1;
                        });
                    }
                    
                    this.heatmapData = [];
                    
                    for (let i = 0; i < 371; i++) { // 53 weeks * 7 days = 371
                        const date = new Date(startSunday);
                        date.setDate(startSunday.getDate() + i);
                        
                        // Use local date string to match with converted todo dates
                        const localDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
                        const dateStr = localDate.toISOString().split('T')[0];
                        const todoCount = todosByDate[dateStr] || 0;
                        
                        this.heatmapData.push({
                            date: dateStr,
                            count: todoCount,
                            level: this.getIntensityLevel(todoCount)
                        });
                    }
                    
                    } catch (error) {
                    console.error('Error generating heatmap data:', error);
                    this.heatmapData = [];
                }
            }

            getIntensityLevel(count) {
                if (count === 0) return 0;
                if (count <= 2) return 1;
                if (count <= 5) return 2;
                if (count <= 10) return 3;
                return 4;
            }

            renderHeatmap() {
                const gridContainer = document.getElementById('heatmap-grid');
                const monthsContainer = document.getElementById('heatmap-months');
                
                if (!gridContainer || !monthsContainer) return;
                
                // Clear existing content
                gridContainer.innerHTML = '';
                monthsContainer.innerHTML = '';
                
                // Render month labels
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                let currentMonth = -1;
                
                for (let week = 0; week < 53; week++) {
                    const weekStart = week * 7;
                    if (weekStart < this.heatmapData.length) {
                        const date = new Date(this.heatmapData[weekStart].date);
                        const month = date.getMonth();
                        
                        if (month !== currentMonth && week % 4 === 0) {
                            const monthDiv = document.createElement('div');
                            monthDiv.className = 'heatmap-month';
                            monthDiv.textContent = months[month];
                            monthDiv.style.gridColumn = `${week + 1} / span 4`;
                            monthsContainer.appendChild(monthDiv);
                            currentMonth = month;
                        }
                    }
                }
                
                // Render squares in correct grid position (column-first order for GitHub-style layout)
                for (let week = 0; week < 53; week++) {
                    for (let day = 0; day < 7; day++) {
                        const index = week * 7 + day;
                        if (index < this.heatmapData.length) {
                            const dayData = this.heatmapData[index];
                            const square = document.createElement('div');
                            square.className = `heatmap-square level-${dayData.level}`;
                            square.title = `${dayData.date}: ${dayData.count} todos completed`;
                            
                            // Set explicit grid position: column = week + 1, row = day + 1
                            square.style.gridColumn = week + 1;
                            square.style.gridRow = day + 1;
                            
                            square.addEventListener('click', () => {
                                alert(`${dayData.date}: ${dayData.count} todos completed`);
                            });
                            
                            gridContainer.appendChild(square);
                        }
                    }
                }
            }

            updateHeatmapStats() {
                const statsElement = document.getElementById('heatmap-stats');
                if (!statsElement) return;
                
                // Remove the stats text - user finds it not nice
                statsElement.textContent = '';
            }

            async setupPerformanceHeatmap() {
                // Show loading state
                const statsElement = document.getElementById('performance-heatmap-stats');
                if (statsElement) statsElement.textContent = 'Loading performance data...';
                
                await this.generatePerformanceHeatmapData();
                this.renderPerformanceHeatmap();
                this.updatePerformanceHeatmapStats();
            }

            async generatePerformanceHeatmapData() {
                try {
                    // EXACTLY the same date logic as Todo heatmap
                    const today = new Date();
                    const startDate = new Date(today);
                    startDate.setDate(today.getDate() - 364); // 365 days including today
                    
                    // Start from Sunday of the week containing startDate (SAME AS TODO)
                    const startSunday = new Date(startDate);
                    startSunday.setDate(startDate.getDate() - startDate.getDay());
                    
                    this.performanceHeatmapData = [];
                    
                    // Process balance history data
                    const performanceByDate = {};
                    
                    if (this.balanceHistory && this.balanceHistory.length > 1) {
                        // Sort by date
                        const sortedHistory = [...this.balanceHistory].sort((a, b) => 
                            new Date(a.date) - new Date(b.date)
                        );
                        
                        // Calculate daily performance compared to previous day
                        for (let i = 1; i < sortedHistory.length; i++) {
                            const current = sortedHistory[i];
                            const previous = sortedHistory[i - 1];
                            
                            // Use local date conversion SAME AS TODO HEATMAP
                            const utcDate = new Date(current.date + 'T00:00:00Z');
                            const localDate = new Date(utcDate.getTime() - utcDate.getTimezoneOffset() * 60000);
                            const dateStr = localDate.toISOString().split('T')[0];
                            
                            let performance = 'neutral';
                            if (current.balance > previous.balance) {
                                performance = 'gain';
                            } else if (current.balance < previous.balance) {
                                performance = 'loss';
                            }
                            
                            performanceByDate[dateStr] = {
                                performance: performance,
                                currentBalance: current.balance,
                                previousBalance: previous.balance,
                                change: current.balance - previous.balance
                            };
                        }
                    }
                    
                    // Generate EXACTLY 371 days like Todo heatmap (53 weeks * 7 days = 371)
                    for (let i = 0; i < 371; i++) {
                        const date = new Date(startSunday);
                        date.setDate(startSunday.getDate() + i);
                        
                        // Use local date string to match with converted dates (SAME AS TODO)
                        const localDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
                        const dateStr = localDate.toISOString().split('T')[0];
                        
                        if (performanceByDate[dateStr]) {
                            this.performanceHeatmapData.push({
                                date: dateStr,
                                ...performanceByDate[dateStr]
                            });
                        } else {
                            // No data for this day - just add empty slot
                            this.performanceHeatmapData.push({
                                date: dateStr,
                                performance: null
                            });
                        }
                    }
                    
                    } catch (error) {
                    console.error('❌ Error generating performance heatmap data:', error);
                    this.performanceHeatmapData = [];
                }
            }

            renderPerformanceHeatmap() {
                const container = document.getElementById('performance-heatmap-grid');
                if (!container || !this.performanceHeatmapData) return;
                
                // Clear existing content
                container.innerHTML = '';
                
                // Create squares with explicit grid positioning (same as Todo heatmap)
                for (let week = 0; week < 53; week++) {
                    for (let day = 0; day < 7; day++) {
                        const index = week * 7 + day;
                        if (index < this.performanceHeatmapData.length) {
                            const dayData = this.performanceHeatmapData[index];
                            const square = document.createElement('div');
                            
                            if (dayData.performance === null) {
                                // No data - use empty styling like Todo heatmap
                                square.className = 'heatmap-square level-0';
                                square.title = new Date(dayData.date).toLocaleDateString('de-DE', { 
                                    year: 'numeric', 
                                    month: 'short', 
                                    day: 'numeric' 
                                }) + '\\nNo data';
                            } else {
                                // Has performance data
                                square.className = `heatmap-square performance-${dayData.performance}`;
                                
                                // Add tooltip
                                const date = new Date(dayData.date);
                                const formattedDate = date.toLocaleDateString('de-DE', { 
                                    year: 'numeric', 
                                    month: 'short', 
                                    day: 'numeric' 
                                });
                                
                                let tooltip = `${formattedDate}`;
                                if (dayData.change !== undefined) {
                                    const changeText = dayData.change > 0 ? 
                                        `+${dayData.change.toFixed(3)} SOL` : 
                                        `${dayData.change.toFixed(3)} SOL`;
                                    tooltip += `\\n${changeText}`;
                                    tooltip += `\\n${dayData.currentBalance.toFixed(3)} SOL total`;
                                }
                                
                                square.title = tooltip;
                            }
                            
                            // Set explicit grid position: column = week + 1, row = day + 1
                            square.style.gridColumn = week + 1;
                            square.style.gridRow = day + 1;
                            
                            container.appendChild(square);
                        }
                    }
                }
                
                // Generate month labels
                this.generatePerformanceMonthLabels();
            }

            generatePerformanceMonthLabels() {
                const monthsContainer = document.getElementById('performance-heatmap-months');
                if (!monthsContainer || !this.performanceHeatmapData) return;
                
                monthsContainer.innerHTML = '';
                
                // Render month labels same as Todo heatmap
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                let currentMonth = -1;
                
                for (let week = 0; week < 53; week++) {
                    const weekStart = week * 7;
                    if (weekStart < this.performanceHeatmapData.length) {
                        const date = new Date(this.performanceHeatmapData[weekStart].date);
                        const month = date.getMonth();
                        
                        if (month !== currentMonth && week % 4 === 0) {
                            const monthDiv = document.createElement('div');
                            monthDiv.className = 'heatmap-month';
                            monthDiv.textContent = months[month];
                            monthDiv.style.gridColumn = `${week + 1} / span 4`;
                            monthsContainer.appendChild(monthDiv);
                            currentMonth = month;
                        }
                    }
                }
            }

            updatePerformanceHeatmapStats() {
                const statsElement = document.getElementById('performance-heatmap-stats');
                if (!statsElement) return;
                
                // Remove the stats text - user doesn't want it
                statsElement.textContent = '';
            }

            async setupMorningRoutineHeatmap() {
                const gridElement = document.getElementById('morning-routine-heatmap-grid');
                const monthsElement = document.getElementById('morning-routine-heatmap-months');
                if (!gridElement || !monthsElement) return;

                try {
                    const routineData = await this.generateMorningRoutineHeatmapData();
                    this.renderRoutineHeatmap('morning', gridElement, monthsElement, routineData);
                    this.updateMorningRoutineHeatmapStats(routineData);
                } catch (error) {
                    console.error('❌ Error setting up morning routine heatmap:', error);
                }
            }

            async setupEveningRoutineHeatmap() {
                const gridElement = document.getElementById('evening-routine-heatmap-grid');
                const monthsElement = document.getElementById('evening-routine-heatmap-months');
                if (!gridElement || !monthsElement) return;

                try {
                    const routineData = await this.generateEveningRoutineHeatmapData();
                    this.renderRoutineHeatmap('evening', gridElement, monthsElement, routineData);
                    this.updateEveningRoutineHeatmapStats(routineData);
                } catch (error) {
                    console.error('❌ Error setting up evening routine heatmap:', error);
                }
            }

            async generateMorningRoutineHeatmapData() {
                try {
                    // Check if supabase is available and user is authenticated
                    if (!window.supabase?.isAuthenticated()) {
                        console.warn('No supabase or user not authenticated for morning routine heatmap');
                        return {};
                    }
                    
                    const user = window.supabase.user;
                    if (!user) return {};

                    const result = await window.supabase.query(
                        `simple_routines?user_id=eq.${user.id}&select=date,routine_data`
                    );
                    console.log('🔍 Morning routine raw data:', result);
                    console.log('🔍 Result keys:', Object.keys(result || {}));
                    console.log('🔍 Result has data?', !!result?.data);
                    console.log('🔍 Result type:', typeof result);
                    console.log('🔍 Is result an array?', Array.isArray(result));
                    console.log('🔍 Result length if array:', Array.isArray(result) ? result.length : 'not array');
                    console.log('🔍 Data length:', result?.data?.length);

                    const routineData = {};
                    const dataArray = result?.data || result; // Handle both formats
                    console.log('🔧 Using data array:', dataArray);
                    console.log('🔧 Data array is array?', Array.isArray(dataArray));
                    console.log('🔧 Data array length:', dataArray?.length);
                    
                    if (dataArray && Array.isArray(dataArray)) {
                        console.log('📊 Total entries to process:', dataArray.length);
                        
                        for (let i = 0; i < dataArray.length; i++) {
                            const entry = dataArray[i];
                            console.log(`🔍 Processing entry ${i}:`, entry);
                            
                            if (!entry.routine_data) {
                                console.warn(`⚠️ No routine_data for entry ${i}:`, entry);
                                continue;
                            }
                            
                            try {
                                let data;
                                if (typeof entry.routine_data === 'string') {
                                    console.log(`📝 Parsing string data for ${entry.date}`);
                                    data = JSON.parse(entry.routine_data);
                                } else {
                                    console.log(`📦 Using object data for ${entry.date}`);
                                    data = entry.routine_data;
                                }
                                
                                console.log(`📋 Parsed data structure for ${entry.date}:`, data);
                                console.log(`📋 Available keys in data:`, Object.keys(data));
                                
                                // Access nested data structure: data[date].morning
                                const dayData = data[entry.date];
                                console.log(`🗓️ Day data for ${entry.date}:`, dayData);
                                
                                if (dayData && dayData.morning) {
                                    const morningTasks = Object.values(dayData.morning);
                                    const allCompleted = morningTasks.length > 0 && morningTasks.every(task => task === true);
                                    routineData[entry.date] = allCompleted ? 1 : 0;
                                    console.log(`📅 ${entry.date}: Morning tasks:`, morningTasks, 'All completed:', allCompleted);
                                } else {
                                    console.warn(`❓ No morning data found for ${entry.date}. DayData:`, dayData);
                                }
                            } catch (parseError) {
                                console.error('❌ Error parsing routine data for date:', entry.date, parseError);
                                console.error('❌ Raw entry that failed:', entry);
                                console.error('❌ Stack:', parseError.stack);
                            }
                        }
                    }

                    console.log('📊 Final morning routine data:', routineData);
                    return routineData;
                } catch (error) {
                    console.error('❌ Error generating morning routine heatmap data:', error);
                    return {};
                }
            }

            async generateEveningRoutineHeatmapData() {
                try {
                    // Check if supabase is available and user is authenticated
                    if (!window.supabase?.isAuthenticated()) {
                        console.warn('No supabase or user not authenticated for evening routine heatmap');
                        return {};
                    }
                    
                    const user = window.supabase.user;
                    if (!user) return {};

                    const result = await window.supabase.query(
                        `simple_routines?user_id=eq.${user.id}&select=date,routine_data`
                    );
                    console.log('🔍 Evening routine raw data:', result);

                    const routineData = {};
                    const dataArray = result?.data || result; // Handle both formats
                    if (dataArray && Array.isArray(dataArray)) {
                        console.log('📊 Total entries to process:', dataArray.length);
                        dataArray.forEach((entry, index) => {
                            console.log(`🔍 Processing entry ${index}:`, entry);
                            try {
                                const data = typeof entry.routine_data === 'string' 
                                    ? JSON.parse(entry.routine_data) 
                                    : entry.routine_data;
                                
                                console.log(`📋 Parsed data for ${entry.date}:`, data);
                                
                                // Access nested data structure: data[date].evening
                                const dayData = data[entry.date];
                                if (dayData && dayData.evening) {
                                    // Check if all evening tasks are completed
                                    const eveningTasks = Object.values(dayData.evening);
                                    const allCompleted = eveningTasks.length > 0 && eveningTasks.every(task => task === true);
                                    routineData[entry.date] = allCompleted ? 1 : 0;
                                    console.log(`📅 ${entry.date}: Evening tasks:`, eveningTasks, 'All completed:', allCompleted);
                                }
                            } catch (parseError) {
                                console.error('❌ Error parsing routine data for date:', entry.date, parseError);
                                console.error('❌ Raw entry that failed:', entry);
                            }
                        });
                    }

                    console.log('📊 Final evening routine data:', routineData);
                    return routineData;
                } catch (error) {
                    console.error('❌ Error generating evening routine heatmap data:', error);
                    return {};
                }
            }

            renderRoutineHeatmap(type, gridElement, monthsElement, data) {
                // Clear existing content
                gridElement.innerHTML = '';
                monthsElement.innerHTML = '';

                // Calculate date range (371 squares for 53 weeks)
                const endDate = new Date();
                const startDate = new Date();
                startDate.setDate(endDate.getDate() - 370);

                // Generate month labels (same as Performance heatmap)
                monthsElement.innerHTML = '';
                
                const monthNames = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
                let currentMonth = -1;
                
                for (let week = 0; week < 53; week++) {
                    const weekDate = new Date(startDate);
                    weekDate.setDate(startDate.getDate() + (week * 7));
                    const month = weekDate.getMonth();
                    
                    if (month !== currentMonth && week % 4 === 0) {
                        const monthDiv = document.createElement('div');
                        monthDiv.className = 'heatmap-month';
                        monthDiv.textContent = monthNames[month];
                        monthDiv.style.gridColumn = `${week + 1} / span 4`;
                        monthsElement.appendChild(monthDiv);
                        currentMonth = month;
                    }
                }

                // Generate heatmap squares (column-first order)
                for (let col = 0; col < 53; col++) {
                    for (let row = 0; row < 7; row++) {
                        const date = new Date(startDate);
                        date.setDate(startDate.getDate() + (col * 7) + row);
                        
                        if (date > endDate) continue;

                        const dateStr = date.toISOString().split('T')[0];
                        const isCompleted = data[dateStr] || 0;
                        const level = isCompleted ? 4 : 0; // Binary: 0 (gray) or 4 (green)
                        
                        const square = document.createElement('div');
                        square.className = `heatmap-square level-${level}`;
                        square.setAttribute('data-date', dateStr);
                        square.setAttribute('data-level', level);
                        square.style.gridColumn = col + 1;
                        square.style.gridRow = row + 1;
                        
                        // Tooltip
                        const formattedDate = date.toLocaleDateString('de-DE');
                        const status = isCompleted ? 'Completed' : 'Not completed';
                        square.title = `${formattedDate}: ${type} routine ${status}`;
                        
                        gridElement.appendChild(square);
                    }
                }
            }

            updateMorningRoutineHeatmapStats(data) {
                const statsElement = document.getElementById('morning-routine-heatmap-stats');
                if (!statsElement) return;
                
                // Remove the stats text - user doesn't want it
                statsElement.textContent = '';
            }

            updateEveningRoutineHeatmapStats(data) {
                const statsElement = document.getElementById('evening-routine-heatmap-stats');
                if (!statsElement) return;
                
                // Remove the stats text - user doesn't want it
                statsElement.textContent = '';
            }
        }

        // Initialize Analytics Manager
        window.AnalyticsManager = new AnalyticsManager();
        
        // Initialize when analytics tab is opened
        document.addEventListener('DOMContentLoaded', () => {
            const analyticsTab = document.querySelector('[data-tab="tab-analytics"]');
            if (analyticsTab) {
                analyticsTab.addEventListener('click', () => {
                    setTimeout(() => {
                        if (window.AnalyticsManager) {
                            window.AnalyticsManager.init();
                        }
                    }, 100);
                });
            }
            
            // Load saved balance tracking time from cloud
            if (window.AnalyticsManager) {
                window.AnalyticsManager.getTrackingTime().then(savedTime => {
                    const timeInput = document.getElementById('balance-tracking-time');
                    if (timeInput) timeInput.value = savedTime;
                });
            }
            
            // Load sport settings when page loads
            setTimeout(() => {
                if (window.SportManager) {
                    window.SportManager.updateSettingsUI();
                }
            }, 2000);
            
            // Save analytics settings
            const saveAnalyticsBtn = document.getElementById('save-analytics-settings');
            if (saveAnalyticsBtn) {
                saveAnalyticsBtn.addEventListener('click', async () => {
                    const timeInput = document.getElementById('balance-tracking-time');
                    if (timeInput && window.supabase?.isAuthenticated()) {
                        const user = window.supabase.getCurrentUser();
                        if (user) {
                            try {
                                // Save to cloud
                                const setting = {
                                    user_id: user.id,
                                    setting_key: 'balanceTrackingTime',
                                    setting_value: timeInput.value,
                                    updated_at: new Date().toISOString()
                                };
                                
                                await window.supabase.upsert('user_settings', setting, ['user_id', 'setting_key']);
                                alert(`Analytics Einstellungen gespeichert! SOL Balance wird täglich um ${timeInput.value} Uhr aufgezeichnet.`);
                            } catch (error) {
                                console.error('Error saving analytics settings:', error);
                                alert('Fehler beim Speichern der Einstellungen.');
                            }
                        }
                    }
                });
            }
            
            // Save Pomodoro settings
            const savePomodoroBtn = document.getElementById('save-pomodoro-settings');
            if (savePomodoroBtn) {
                savePomodoroBtn.addEventListener('click', async () => {
                    const durationInput = document.getElementById('pomodoro-duration');
                    if (durationInput && window.supabase?.isAuthenticated()) {
                        const user = window.supabase.getCurrentUser();
                        if (user) {
                            try {
                                const minutes = parseInt(durationInput.value);
                                if (minutes < 5 || minutes > 60) {
                                    alert('Bitte geben Sie eine Dauer zwischen 5 und 60 Minuten ein.');
                                    return;
                                }
                                
                                // Save to cloud
                                const setting = {
                                    user_id: user.id,
                                    setting_key: 'pomodoroDuration',
                                    setting_value: minutes.toString(),
                                    updated_at: new Date().toISOString()
                                };
                                
                                await window.supabase.upsert('user_settings', setting, ['user_id', 'setting_key']);
                                
                                // Update the PomodoroTimer with the new duration
                                if (window.PomodoroTimer) {
                                    window.PomodoroTimer.setDuration(minutes);
                                }
                                
                                alert(`Pomodoro Einstellungen gespeichert! Timer Dauer: ${minutes} Minuten.`);
                            } catch (error) {
                                console.error('Error saving Pomodoro settings:', error);
                                alert('Fehler beim Speichern der Einstellungen.');
                            }
                        }
                    }
                });
            }
            
            // Save sport settings
            const saveSportBtn = document.getElementById('save-sport-settings');
            if (saveSportBtn) {
                saveSportBtn.addEventListener('click', async () => {
                    const timeInput = document.getElementById('sport-reset-time');
                    const visibilityInput = document.getElementById('sport-visibility');
                    
                    if (window.supabase?.isAuthenticated()) {
                        const user = window.supabase.getCurrentUser();
                        if (user) {
                            try {
                                // Save reset time
                                const timeSetting = {
                                    user_id: user.id,
                                    setting_key: 'sportResetTime',
                                    setting_value: timeInput.value,
                                    updated_at: new Date().toISOString()
                                };
                                
                                // Save visibility
                                const visibilitySetting = {
                                    user_id: user.id,
                                    setting_key: 'sportContainerVisibility',
                                    setting_value: visibilityInput.checked.toString(),
                                    updated_at: new Date().toISOString()
                                };
                                
                                await window.supabase.upsert('user_settings', timeSetting, ['user_id', 'setting_key']);
                                await window.supabase.upsert('user_settings', visibilitySetting, ['user_id', 'setting_key']);
                                
                                // Apply settings immediately
                                if (window.SportManager) {
                                    window.SportManager.applySettings();
                                }
                                
                                alert(`Sport Einstellungen gespeichert! Reset Zeit: ${timeInput.value}, Sichtbarkeit: ${visibilityInput.checked ? 'An' : 'Aus'}`);
                            } catch (error) {
                                console.error('Error saving sport settings:', error);
                                alert('Fehler beim Speichern der Einstellungen.');
                            }
                        }
                    }
                });
            }
        });

        // === MOTIVATIONAL QUOTES SYSTEM ===
        class MotivationalQuotes {
            constructor() {
                this.quotes = [
                    { text: "The way to get started is to quit talking and begin doing.", author: "Walt Disney" },
                    { text: "Success is not final, failure is not fatal: it is the courage to continue that counts.", author: "Winston Churchill" },
                    { text: "Don't be afraid to give up the good to go for the great.", author: "John D. Rockefeller" },
                    { text: "The only impossible journey is the one you never begin.", author: "Tony Robbins" },
                    { text: "In the middle of difficulty lies opportunity.", author: "Albert Einstein" },
                    { text: "It does not matter how slowly you go as long as you do not stop.", author: "Confucius" },
                    { text: "Everything you've ever wanted is on the other side of fear.", author: "George Addair" },
                    { text: "Believe you can and you're halfway there.", author: "Theodore Roosevelt" },
                    { text: "The only person you are destined to become is the person you decide to be.", author: "Ralph Waldo Emerson" },
                    { text: "I have not failed. I've just found 10,000 ways that won't work.", author: "Thomas Edison" },
                    { text: "A successful man is one who can lay a firm foundation with the bricks others have thrown at him.", author: "David Brinkley" },
                    { text: "The stock market is filled with individuals who know the price of everything, but the value of nothing.", author: "Philip Fisher" },
                    { text: "Risk comes from not knowing what you're doing.", author: "Warren Buffett" },
                    { text: "The four most dangerous words in investing are: 'this time it's different.'", author: "Sir John Templeton" },
                    { text: "Time in the market beats timing the market.", author: "Ken Fisher" },
                    { text: "An investment in knowledge pays the best interest.", author: "Benjamin Franklin" },
                    { text: "The best investment you can make is in yourself.", author: "Warren Buffett" },
                    { text: "Don't put all your eggs in one basket.", author: "Andrew Carnegie" },
                    { text: "It's not how much money you make, but how much money you keep.", author: "Robert Kiyosaki" },
                    { text: "The real measure of your wealth is how much you'd be worth if you lost all your money.", author: "Anonymous" }
                ];
                this.currentQuoteIndex = this.getTodaysQuoteIndex();
            }

            getTodaysQuoteIndex() {
                // Use today's date to generate a consistent quote for the day
                const today = new Date();
                const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);
                return dayOfYear % this.quotes.length;
            }

            getCurrentQuote() {
                return this.quotes[this.currentQuoteIndex];
            }

            getRandomQuote() {
                this.currentQuoteIndex = Math.floor(Math.random() * this.quotes.length);
                return this.getCurrentQuote();
            }

            displayQuote(quote = null) {
                const quoteToDisplay = quote || this.getCurrentQuote();
                const quoteTextEl = document.getElementById('daily-quote');
                const quoteAuthorEl = document.getElementById('quote-author');

                if (quoteTextEl && quoteAuthorEl) {
                    quoteTextEl.textContent = quoteToDisplay.text;
                    quoteAuthorEl.textContent = quoteToDisplay.author;
                }
            }

            init() {
                // Display today's quote
                this.displayQuote();

                // Add refresh button functionality
                const refreshBtn = document.getElementById('refresh-quote-btn');
                if (refreshBtn) {
                    refreshBtn.addEventListener('click', () => {
                        const newQuote = this.getRandomQuote();
                        this.displayQuote(newQuote);
                        
                        // Simple feedback without excessive animation
                    });
                }
            }
        }

        // Initialize Motivational Quotes
        document.addEventListener('DOMContentLoaded', () => {
            window.motivationalQuotes = new MotivationalQuotes();
            window.motivationalQuotes.init();
        });
    </script>
    
    <!-- ========================================= -->
    <!-- CLOUD-FIRST POLICY ENFORCEMENT -->
    <!-- ========================================= -->
    <script src="CLOUD_POLICY.js"></script>
    <script>
        // Aktiviere Cloud-Policy für alle Manager
        document.addEventListener('DOMContentLoaded', function() {
            window.devLog('🛡️ Activating Cloud-First Policy enforcement...');
            
            // Validiere alle existierenden Manager
            setTimeout(() => {
                const managers = [
                    { name: 'TodoManager', obj: window.TodoManager },
                    { name: 'GoalManager', obj: window.GoalManager },
                    { name: 'JournalManager', obj: window.JournalManager },
                    { name: 'TerminManager', obj: window.TerminManager },
                    { name: 'ResourceManager', obj: window.ResourceManager },
                    { name: 'Wiki', obj: window.Wiki },
                    { name: 'SimpleRoutineManager', obj: window.simpleRoutineManager }
                ];
                
                managers.forEach(({ name, obj }) => {
                    if (obj) {} else {
                        console.warn(`⚠️ ${name}: Not found`);
                    }
                });
                
                window.devLog('📋 All future implementations must follow CLOUD_POLICY.js guidelines');
                
            }, 2000);
        });

        // === CRYPTO PRICE WIDGET ===
        class CryptoPriceWidget {
            constructor() {
                this.apiUrl = 'https://api.hyperliquid.xyz/info';
                this.allSymbols = []; // Will be populated from API
                this.allCoinsData = {}; // Full coin data from Hyperliquid
                this.overlaySymbols = ['BTC', 'ETH', 'SOL']; // Default, will be overridden by cloud data
                this.updateInterval = 60000; // 60 seconds
                this.currentPrices = {};
                this.price24hAgo = {};
                this.intervalId = null;
                this.overlay = document.querySelector('.crypto-overlay');
                
                this.init();
            }

            async loadSavedCoins() {
                try {
                    if (!window.supabase || !window.supabase.isAuthenticated()) {
                        console.warn('⚠️ Not authenticated, using default coins');
                        return null;
                    }

                    const user = window.supabase.getCurrentUser();
                    const result = await window.supabase.query(`crypto_watchlist?user_id=eq.${user.id}&select=coins`);
                    
                    if (result && result.length > 0) {
                        const coins = JSON.parse(result[0].coins);
                        return coins;
                    }
                    
                    return null;
                } catch (e) {
                    console.error('❌ Error loading saved coins from cloud:', e);
                    return null;
                }
            }

            async saveCoins() {
                try {
                    if (!window.supabase || !window.supabase.isAuthenticated()) {
                        console.warn('⚠️ Not authenticated, cannot save coins to cloud');
                        return;
                    }

                    const user = window.supabase.getCurrentUser();
                    const dataToSave = {
                        user_id: user.id,
                        coins: JSON.stringify(this.overlaySymbols),
                        updated_at: new Date().toISOString()
                    };

                    // Check if watchlist exists
                    const existing = await window.supabase.query(`crypto_watchlist?user_id=eq.${user.id}&select=*`);
                    
                    if (existing && existing.length > 0) {
                        // Update existing
                        await window.supabase.update('crypto_watchlist', dataToSave, existing[0].id);
                        } else {
                        // Create new
                        await window.supabase.insert('crypto_watchlist', [dataToSave]);
                        }
                    
                    } catch (e) {
                    console.error('❌ Could not save crypto coins to cloud:', e);
                }
            }

            async init() {
                window.devLog('🔗 Initializing New Crypto Price Widget...');
                console.log('📋 Default overlay symbols:', this.overlaySymbols);
                
                // Immediate render with defaults - no delay
                try {
                    // Show loading state immediately
                    this.showLoadingState();
                    
                    // DEBUG: Add artificial delay to see skeleton loading
                    const isDebugMode = window.location.hash.includes('debug') || localStorage.getItem('debug-loading') === 'true';
                    if (isDebugMode) {
                        console.log('🐛 DEBUG MODE: Showing loading skeleton for 3 seconds...');
                        await new Promise(resolve => setTimeout(resolve, 3000));
                    }
                    
                    // Run everything in parallel for speed
                    const [savedCoins, hyperliquidData] = await Promise.all([
                        this.loadSavedCoins(),
                        this.loadAllCoinsFromHyperliquid()
                    ]);
                    
                    // Update watchlist if we have saved coins
                    if (savedCoins && savedCoins.length > 0) {
                        this.overlaySymbols = savedCoins;
                        } else {
                        console.log('📋 Using default coins:', this.overlaySymbols);
                    }
                    
                    // Render immediately with current prices (if available)
                    this.clearAllStaticItems();
                    this.renderCoinItems();
                    this.setupEventListeners();
                    this.setupSearchFunctionality();
                    this.setupSettingsEventListeners();
                    
                    // Load price updates in background
                    this.updatePricesInBackground();
                    this.startAutoUpdate();
                    
                    this.hideLoadingState();
                    
                } catch (error) {
                    console.error('❌ Error initializing crypto widget:', error);
                    this.hideLoadingState();
                }
            }

            showLoadingState() {
                if (window.SmartLoading) {
                    window.SmartLoading.showSkeleton('crypto-overlay-items', 'watchlist', 3);
                }
            }

            hideLoadingState() {
                // Loading state is automatically replaced when renderCoinItems() is called
            }

            async updatePricesInBackground() {
                // Non-blocking price update - doesn't wait for completion
                setTimeout(async () => {
                    try {
                        await this.updatePricesAndCharts();
                    } catch (error) {
                        console.warn('Background price update failed:', error);
                    }
                }, 100);
            }

            async loadAllCoinsFromHyperliquid() {
                try {
                    // Run meta and prices requests in parallel
                    const [metaResponse, pricesResponse] = await Promise.all([
                        fetch(this.apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ type: 'meta' })
                        }),
                        fetch(this.apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ type: 'allMids' })
                        })
                    ]);

                    if (!metaResponse.ok) throw new Error(`Meta API error: ${metaResponse.status}`);
                    if (!pricesResponse.ok) throw new Error(`Prices API error: ${pricesResponse.status}`);
                    
                    const [metaData, pricesData] = await Promise.all([
                        metaResponse.json(),
                        pricesResponse.json()
                    ]);
                    
                    this.allSymbols = metaData.universe
                        .filter(coin => !coin.isDelisted)
                        .map(coin => coin.name)
                        .sort();

                    this.currentPrices = pricesData;} catch (error) {
                    console.error('❌ Error loading coins:', error);
                    // Fallback to basic coins if API fails
                    this.allSymbols = ['BTC', 'ETH', 'SOL', 'ENA', 'PENGU', 'kBONK', 'FARTCOIN'];
                    
                    // Try to load just prices as fallback
                    try {
                        await this.loadCurrentPrices();
                    } catch (priceError) {
                        console.warn('❌ Could not load fallback prices:', priceError);
                    }
                }
            }

            async loadCurrentPrices() {
                try {
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ type: 'allMids' })
                    });

                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    
                    const data = await response.json();
                    this.currentPrices = data;
                    
                    } catch (error) {
                    console.error('❌ Error loading current prices:', error);
                }
            }

            async load24hPriceChange(symbol) {
                try {
                    const now = Date.now();
                    const yesterday = now - (24 * 60 * 60 * 1000);
                    
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            type: 'candleSnapshot',
                            req: {
                                coin: symbol,
                                interval: '1h',
                                startTime: yesterday,
                                endTime: now
                            }
                        })
                    });

                    if (!response.ok) return null;
                    
                    const data = await response.json();
                    if (data && data.length > 0) {
                        const oldPrice = parseFloat(data[0].o);
                        const currentPrice = parseFloat(this.currentPrices[symbol] || 0);
                        
                        if (oldPrice && currentPrice) {
                            return ((currentPrice - oldPrice) / oldPrice) * 100;
                        }
                    }
                    
                    return null;
                } catch (error) {
                    console.warn(`Could not load 24h data for ${symbol}:`, error);
                    return null;
                }
            }

            async load7DayChart(symbol) {
                try {
                    const now = Date.now();
                    const weekAgo = now - (7 * 24 * 60 * 60 * 1000);
                    
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            type: 'candleSnapshot',
                            req: {
                                coin: symbol,
                                interval: '4h',
                                startTime: weekAgo,
                                endTime: now
                            }
                        })
                    });

                    if (!response.ok) return [];
                    
                    const data = await response.json();
                    return data.map(candle => parseFloat(candle.c));
                    
                } catch (error) {
                    console.warn(`Could not load 7d chart for ${symbol}:`, error);
                    return [];
                }
            }

            clearAllStaticItems() {
                // Remove ANY crypto-overlay-item that doesn't have the dynamic-coin-item class
                const allItems = document.querySelectorAll('.crypto-overlay-item:not(.dynamic-coin-item)');
                console.log(`🧹 Clearing ${allItems.length} static coin items...`);
                allItems.forEach((item, index) => {item.remove();
                });
            }

            setupEventListeners() {
                // Toggle overlay
                const toggleBtn = document.querySelector('.crypto-toggle-btn');
                if (toggleBtn && this.overlay) {
                    toggleBtn.addEventListener('click', () => {
                        this.overlay.classList.toggle('collapsed');
                    });
                }

                // Settings toggle
                const settingsBtn = document.querySelector('.crypto-settings-btn');
                const settingsPanel = document.querySelector('.crypto-settings-panel');
                const settingsClose = document.querySelector('.crypto-settings-close');if (settingsBtn && settingsPanel) {
                    settingsBtn.addEventListener('click', () => {
                        console.log('⚙️ Settings button clicked!');
                        const isVisible = settingsPanel.style.display !== 'none';
                        settingsPanel.style.display = isVisible ? 'none' : 'block';
                        
                        if (!isVisible) {
                            this.renderAvailableCoins();
                        }
                        console.log('📋 Settings panel display:', settingsPanel.style.display);
                    });
                }

                if (settingsClose && settingsPanel) {
                    settingsClose.addEventListener('click', () => {
                        console.log('❌ Settings close clicked!');
                        settingsPanel.style.display = 'none';
                    });
                }

                // Coin selection checkboxes
                this.allSymbols.forEach(symbol => {
                    const checkboxId = symbol === 'kBONK' ? 'coin-bonk' : `coin-${symbol.toLowerCase()}`;
                    const checkbox = document.getElementById(checkboxId);
                    if (checkbox) {
                        checkbox.checked = this.overlaySymbols.includes(symbol);
                        checkbox.addEventListener('change', async () => {
                            await this.toggleCoin(symbol, checkbox.checked);
                        });
                    } else {
                        // Checkbox not found - silently continue
                    }
                });

            }

            setupSettingsEventListeners() {// Settings search functionality
                const settingsSearchInput = document.getElementById('settings-crypto-search');
                if (settingsSearchInput) {
                    settingsSearchInput.addEventListener('input', (e) => {
                        const query = e.target.value;
                        this.renderCoinsInSettings(query);
                    });
                    
                    // Initialize with empty search to show all coins
                    this.renderCoinsInSettings();
                } else {
                    console.warn('⚠️ Settings crypto search input not found');
                }
            }

            async toggleCoin(symbol, enabled) {
                if (enabled && !this.overlaySymbols.includes(symbol)) {
                    this.overlaySymbols.push(symbol);
                } else if (!enabled) {
                    this.overlaySymbols = this.overlaySymbols.filter(s => s !== symbol);
                }
                
                await this.saveCoins();
                this.renderCoinItems();
            }

            async renderCoinItems() {
                const container = document.getElementById('crypto-overlay-items');
                if (!container) {
                    console.error('❌ crypto-overlay-items container not found');
                    return;
                }

                container.innerHTML = '';
                
                // Render all coins immediately without waiting for data
                for (const symbol of this.overlaySymbols) {
                    const item = document.createElement('div');
                    item.className = 'crypto-overlay-item dynamic-coin-item';
                    item.setAttribute('data-symbol', symbol);
                    
                    const displaySymbol = symbol === 'kBONK' ? 'BONK' : symbol;
                    const currentPrice = this.currentPrices[symbol];
                    const formattedPrice = currentPrice ? this.formatPrice(currentPrice) : '$--';
                    
                    item.innerHTML = `
                        <span class="crypto-overlay-symbol">${displaySymbol}</span>
                        <span class="crypto-overlay-price">${formattedPrice}</span>
                        <span class="crypto-overlay-change">...</span>
                    `;
                    
                    container.appendChild(item);
                }// Check if we need scrolling or centering
                this.updateTickerDisplay(container);
                
                // Load charts and price changes in background (non-blocking)
                this.loadChartsAndPriceChangesAsync();
            }

            updateTickerDisplay(container) {
                // Wait for DOM to update
                setTimeout(() => {
                    const tickerContainer = container.closest('.ticker-container');
                    const tickerContent = container;
                    
                    // Calculate total width needed vs available width
                    const containerWidth = tickerContainer.clientWidth;
                    let totalItemsWidth = 0;
                    
                    // Sum up width of all coin items
                    const items = container.querySelectorAll('.crypto-overlay-item');
                    items.forEach(item => {
                        totalItemsWidth += item.offsetWidth;
                    });
                    
                    // Add gap spacing (20px between items)
                    const totalGapsWidth = (items.length - 1) * 20;
                    const totalContentWidth = totalItemsWidth + totalGapsWidth;
                    
                    console.log(`📏 Container width: ${containerWidth}px, Content width: ${totalContentWidth}px`);
                    
                    if (totalContentWidth <= containerWidth * 0.8) {
                        // Few coins - center them statically
                        tickerContent.classList.add('center-static');
                        console.log('📍 Using centered static display');
                    } else {
                        // Many coins - use scrolling animation
                        tickerContent.classList.remove('center-static');
                        }
                }, 100);
            }

            async loadChartsAndPriceChangesAsync() {
                // Load all charts and price changes in parallel
                const promises = this.overlaySymbols.map(async (symbol) => {
                    // Load chart and price change in parallel for each coin
                    const [, change] = await Promise.all([
                        this.loadAndRenderMiniChart(symbol),
                        this.load24hPriceChange(symbol)
                    ]);
                    
                    if (change !== null) {
                        this.updatePriceChange(symbol, change);
                    }
                });
                
                // Wait for all to complete (but don't block the main render)
                await Promise.all(promises);
                }

            async loadAndRenderMiniChart(symbol) {
                const canvas = document.querySelector(`canvas[data-symbol="${symbol}"]`);
                if (!canvas) return;

                const chartData = await this.load7DayChart(symbol);
                if (chartData.length > 0) {
                    this.renderMiniChart(canvas, chartData);
                }
            }

            renderMiniChart(canvas, priceData) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                if (priceData.length < 2) return;
                
                const maxPrice = Math.max(...priceData);
                const minPrice = Math.min(...priceData);
                const priceRange = maxPrice - minPrice;
                
                if (priceRange === 0) return;
                
                // Determine line color based on trend
                const firstPrice = priceData[0];
                const lastPrice = priceData[priceData.length - 1];
                const isPositive = lastPrice >= firstPrice;
                
                ctx.strokeStyle = isPositive ? '#10b981' : '#ef4444';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                priceData.forEach((price, index) => {
                    const x = (index / (priceData.length - 1)) * (width - 4) + 2;
                    const y = height - 2 - ((price - minPrice) / priceRange) * (height - 4);
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
            }

            updatePriceChange(symbol, changePercent) {
                const item = document.querySelector(`[data-symbol="${symbol}"]`);
                if (!item) return;

                const changeElement = item.querySelector('.crypto-overlay-change');
                if (!changeElement) return;

                const isPositive = changePercent >= 0;
                const sign = isPositive ? '+' : '';
                changeElement.textContent = `${sign}${changePercent.toFixed(2)}%`;
                changeElement.className = `crypto-overlay-change ${isPositive ? 'positive' : 'negative'}`;
            }

            async fetchPrices() {
                try {
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ type: 'allMids' })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('Error fetching crypto prices:', error);
                    this.updateStatus('error', 'Connection failed');
                    return null;
                }
            }

            formatPrice(price) {
                const num = parseFloat(price);
                if (num >= 1000) {
                    return `$${num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                } else if (num >= 1) {
                    return `$${num.toFixed(2)}`; // Changed from 3 to 2 decimal places for coins ≥ 1 (like SOL, HYPE)
                } else if (num >= 0.01) {
                    return `$${num.toFixed(4)}`;
                } else {
                    return `$${num.toFixed(6)}`;
                }
            }

            calculateChange(currentPrice, previousPrice) {
                if (!previousPrice) return null;
                const change = ((currentPrice - previousPrice) / previousPrice) * 100;
                return change;
            }

            formatChange(change) {
                if (change === null) return { text: 'New', class: 'neutral' };
                
                const absChange = Math.abs(change);
                const sign = change >= 0 ? '+' : '';
                const text = `${sign}${change.toFixed(2)}%`;
                const className = change > 0 ? 'positive' : change < 0 ? 'negative' : 'neutral';
                
                return { text, class: className };
            }

            updateTile(symbol, price, change) {
                // Update overlay widget item (only for selected coins)
                if (this.overlaySymbols.includes(symbol)) {
                    const overlayItem = document.querySelector(`.crypto-overlay-item[data-symbol="${symbol}"]`);
                    if (overlayItem) {
                        const priceElement = overlayItem.querySelector('.crypto-overlay-price');
                        const changeElement = overlayItem.querySelector('.crypto-overlay-change');

                        if (priceElement && changeElement) {
                            priceElement.textContent = this.formatPrice(price);
                            
                            const changeData = this.formatChange(change);
                            changeElement.textContent = changeData.text;
                            changeElement.className = `crypto-overlay-change ${changeData.class}`;
                        }
                    } else {
                        console.warn(`Overlay item not found for ${symbol}, re-rendering...`);
                        this.renderCoinItems();
                    }
                }
            }

            updateStatus(status, message) {
                if (!this.statusIndicator || !this.statusText) return;
                
                this.statusIndicator.className = 'status-indicator';
                if (status === 'connected') {
                    this.statusIndicator.classList.add('connected');
                }
                
                this.statusText.textContent = message;
            }

            setupSearchFunctionality() {
                const searchInput = document.getElementById('crypto-search-input');
                if (!searchInput) return;

                searchInput.addEventListener('input', (e) => {
                    const query = e.target.value.toLowerCase();
                    this.filterAvailableCoins(query);
                });
            }

            renderAvailableCoins(query = '') {
                const container = document.getElementById('crypto-available-coins');
                if (!container) return;

                container.innerHTML = '';

                const filteredCoins = this.allSymbols
                    .filter(symbol => symbol.toLowerCase().includes(query.toLowerCase()))
                    .slice(0, 50); // Limit to 50 results for performance

                filteredCoins.forEach(symbol => {
                    const isAdded = this.overlaySymbols.includes(symbol);
                    const currentPrice = this.currentPrices[symbol];
                    const displaySymbol = symbol === 'kBONK' ? 'BONK' : symbol;
                    
                    const option = document.createElement('div');
                    option.className = `crypto-coin-option ${isAdded ? 'added' : ''}`;
                    option.innerHTML = `
                        <div class="crypto-coin-info">
                            <div class="crypto-coin-name">${displaySymbol}</div>
                            <div class="crypto-coin-price">${currentPrice ? this.formatPrice(currentPrice) : 'No price'}</div>
                        </div>
                        <button class="crypto-add-btn ${isAdded ? 'added' : ''}" data-symbol="${symbol}">
                            ${isAdded ? 'Remove' : 'Add'}
                        </button>
                    `;

                    const addBtn = option.querySelector('.crypto-add-btn');
                    addBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await this.toggleCoinInOverlay(symbol);
                    });

                    container.appendChild(option);
                });

                console.log(`📋 Rendered ${filteredCoins.length} available coins`);
            }

            filterAvailableCoins(query) {
                this.renderAvailableCoins(query);
            }

            async toggleCoinInOverlay(symbol) {
                if (this.overlaySymbols.includes(symbol)) {
                    // Remove coin
                    this.overlaySymbols = this.overlaySymbols.filter(s => s !== symbol);
                    console.log(`➖ Removed ${symbol} from overlay`);
                } else {
                    // Add coin
                    this.overlaySymbols.push(symbol);}

                await this.saveCoins();
                this.renderCoinItems();
                this.renderAvailableCoins(document.getElementById('crypto-search-input')?.value || '');
                // Also update settings tab if it exists
                this.renderCoinsInSettings(document.getElementById('settings-crypto-search')?.value || '');
            }

            renderCoinsInSettings(query = '') {
                const container = document.getElementById('settings-crypto-coins');
                if (!container) {
                    console.log('⚠️ Settings crypto coins container not found');
                    return;
                }

                container.innerHTML = '';

                const filteredCoins = this.allSymbols
                    .filter(symbol => symbol.toLowerCase().includes(query.toLowerCase()))
                    .slice(0, 100); // Show more results in settings than in popup

                filteredCoins.forEach(symbol => {
                    const isAdded = this.overlaySymbols.includes(symbol);
                    const currentPrice = this.currentPrices[symbol];
                    const displaySymbol = symbol === 'kBONK' ? 'BONK' : symbol;
                    
                    const coinItem = document.createElement('div');
                    coinItem.className = `settings-crypto-coin ${isAdded ? 'active' : ''}`;
                    coinItem.innerHTML = `
                        <div class="settings-crypto-info">
                            <div class="settings-crypto-symbol">${displaySymbol}</div>
                            <div class="settings-crypto-price">${currentPrice ? this.formatPrice(currentPrice) : 'No price'}</div>
                        </div>
                        <button class="settings-crypto-toggle ${isAdded ? 'active' : ''}" data-symbol="${symbol}">
                            ${isAdded ? 'Remove' : 'Add'}
                        </button>
                    `;

                    const toggleBtn = coinItem.querySelector('.settings-crypto-toggle');
                    toggleBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        console.log(`🔘 Settings toggle clicked for ${symbol}`);
                        await this.toggleCoinInOverlay(symbol);
                    });

                    container.appendChild(coinItem);
                });}

            async updatePricesAndCharts() {
                try {
                    await this.loadCurrentPrices();
                    
                    // Update existing coin displays
                    for (const symbol of this.overlaySymbols) {
                        const currentPrice = this.currentPrices[symbol];
                        if (currentPrice) {
                            this.updateCoinPrice(symbol, currentPrice);
                        }

                        // Refresh 24h change
                        const change24h = await this.load24hPriceChange(symbol);
                        if (change24h !== null) {
                            this.updatePriceChange(symbol, change24h);
                        }
                    }

                    } catch (error) {
                    console.error('❌ Error updating prices:', error);
                }
            }

            updateCoinPrice(symbol, price) {
                const item = document.querySelector(`[data-symbol="${symbol}"]`);
                if (!item) return;

                const priceElement = item.querySelector('.crypto-overlay-price');
                if (priceElement) {
                    priceElement.textContent = this.formatPrice(price);
                }
            }

            startAutoUpdate() {
                this.intervalId = setInterval(() => {
                    this.updatePricesAndCharts();
                }, this.updateInterval);
                
                console.log(`⏰ Auto-update started (${this.updateInterval / 1000}s interval)`);
            }

            stopAutoUpdate() {
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                    console.log('⏸️ Auto-update stopped');
                }
            }
        }

        // === UNIVERSAL SMART LOADING FUNCTIONS ===
        window.SmartLoading = {
            
            // Create skeleton loading for any container
            showSkeleton: function(containerId, type = 'generic', count = 3) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                let skeletonHTML = '';
                
                switch(type) {
                    case 'todo':
                        for(let i = 0; i < count; i++) {
                            skeletonHTML += `
                                <div class="skeleton-todo">
                                    <div class="skeleton skeleton-checkbox"></div>
                                    <div class="skeleton skeleton-text" style="flex: 1; width: 70%;"></div>
                                </div>
                            `;
                        }
                        break;
                        
                    case 'card':
                        for(let i = 0; i < count; i++) {
                            skeletonHTML += `
                                <div class="skeleton-card">
                                    <div class="skeleton skeleton-text large" style="width: 80%;"></div>
                                    <div class="skeleton skeleton-text" style="width: 100%;"></div>
                                    <div class="skeleton skeleton-text" style="width: 60%;"></div>
                                </div>
                            `;
                        }
                        break;
                        
                    case 'watchlist':
                        for(let i = 0; i < count; i++) {
                            skeletonHTML += `
                                <div class="skeleton-watchlist-item">
                                    <div class="skeleton-watchlist-left">
                                        <div class="skeleton skeleton-chart"></div>
                                        <div class="skeleton skeleton-symbol"></div>
                                    </div>
                                    <div class="skeleton skeleton-price"></div>
                                </div>
                            `;
                        }
                        break;
                        
                    default:
                        for(let i = 0; i < count; i++) {
                            skeletonHTML += `
                                <div style="margin-bottom: 1rem;">
                                    <div class="skeleton skeleton-text large" style="width: 70%;"></div>
                                    <div class="skeleton skeleton-text" style="width: 100%;"></div>
                                    <div class="skeleton skeleton-text" style="width: 40%;"></div>
                                </div>
                            `;
                        }
                }
                
                container.innerHTML = skeletonHTML;
            },
            
            // Remove skeleton and restore content
            hideSkeleton: function(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                // Content will be replaced by actual data rendering
            }
        };

        // DEBUG: Add button to test loading states
        window.testLoadingStates = function() {
            // Test watchlist skeleton
            if (window.SmartLoading) {
                window.SmartLoading.showSkeleton('crypto-overlay-items', 'watchlist', 3);
                setTimeout(() => {
                    if (window.cryptoPriceWidget) {
                        window.cryptoPriceWidget.renderCoinItems();
                    }
                }, 3000);
            }
            
            // Test other skeletons in different containers
            const testContainers = ['heute', 'privat', 'journal-entries', 'wiki-entries'];
            testContainers.forEach((containerId, index) => {
                const container = document.getElementById(containerId);
                if (container) {
                    const types = ['todo', 'card', 'generic'];
                    setTimeout(() => {
                        window.SmartLoading.showSkeleton(containerId, types[index % 3], 4);
                        setTimeout(() => {
                            // Restore original content (simplified)
                            container.innerHTML = '<p>Loading test completed ✅</p>';
                        }, 3000);
                    }, index * 500);
                }
            });
        };

        // Initialize crypto widget when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Wait a bit for other components to load, especially for Lucide icons
            setTimeout(() => {
                window.devLog('🚀 Starting Crypto Widget Initialization...');
                
                // Initialize Lucide icons first
                if (window.lucide) {
                    window.devLog('🎨 Initializing Lucide icons...');
                    lucide.createIcons();
                } else {
                    console.warn('⚠️ Lucide not loaded yet');
                }
                
                // Crypto widget is now initialized after authentication in showDashboard()
            }, 200);
        });
        
        // === GLOBAL GOAL EDIT MODAL EVENT LISTENERS SETUP ===
        // This needs to be outside of DOMContentLoaded to ensure it runs
        window.devLog('🎯 GLOBAL: Setting up goal edit modal event listeners...');
        
        // Make event listener initialization globally available
        window.initGoalEditModalEventListeners = function() {
            window.devLog('🎯 GLOBAL: Initializing goal edit modal event listeners...');
            
            const cancelEditGoalBtn = document.getElementById('cancel-edit-goal-value-btn');
            if (cancelEditGoalBtn) {
                // Remove existing listeners first
                const newCancelBtn = cancelEditGoalBtn.cloneNode(true);
                cancelEditGoalBtn.parentNode.replaceChild(newCancelBtn, cancelEditGoalBtn);
                
                newCancelBtn.addEventListener('click', () => {
                    console.log('🎯 GLOBAL: Cancel button clicked');
                    if (window.GoalManager && window.GoalManager.hideEditGoalValueModal) {
                        window.GoalManager.hideEditGoalValueModal();
                    } else {
                        console.error('❌ GoalManager not available');
                    }
                });
            } else {
                console.error('❌ GLOBAL: cancel-edit-goal-value-btn not found');
            }

            const editGoalForm = document.getElementById('edit-goal-value-form');
            if (editGoalForm) {
                // Remove existing listeners first
                const newForm = editGoalForm.cloneNode(true);
                editGoalForm.parentNode.replaceChild(newForm, editGoalForm);
                
                newForm.addEventListener('submit', async (e) => {
                    console.log('🎯 GLOBAL: Form submit event triggered');
                    e.preventDefault();
                    
                    const goalId = e.target.dataset.goalId;
                    console.log('🎯 GLOBAL: Form submit goalId:', goalId);
                    if (goalId && window.GoalManager && window.GoalManager.editGoalValue) {
                        await window.GoalManager.editGoalValue(goalId);
                    } else {
                        console.error('❌ GLOBAL: No goalId found or GoalManager not available');
                    }
                });
            } else {
                console.error('❌ GLOBAL: edit-goal-value-form not found');
            }
        };
        
        // Try to initialize immediately
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('🎯 GLOBAL: DOM ready, initializing...');
                window.initGoalEditModalEventListeners();
            });
        } else {
            console.log('🎯 GLOBAL: DOM already ready, initializing now...');
            window.initGoalEditModalEventListeners();
        }
        
        // Event listeners are initialized when DOM is ready and when modal opens
        // No need for redundant retries

        // === CRYPTO TICKER CONTROLLER ===
        class CryptoTicker {
            static openSettings() {
                // Open the existing crypto settings panel
                const settingsPanel = document.querySelector('.crypto-settings-panel');
                if (settingsPanel) {
                    settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
                }
            }
        }
        
        // Make CryptoTicker globally available
        window.CryptoTicker = CryptoTicker;
        
        // Initialize quick actions (request notification permission)
        document.addEventListener('DOMContentLoaded', () => {
            if ('Notification' in window && Notification.permission !== 'granted' && Notification.permission !== 'denied') {
                Notification.requestPermission();
            }
        });
        
        // Final security check on window load
        window.addEventListener('load', () => {
            // Double-check URL parameters are cleared
            if (window.location.search && (window.location.search.includes('email=') || window.location.search.includes('password='))) {
                console.log('🔒 SECURITY: Final URL parameter cleanup on window load');
                const url = new URL(window.location.href);
                url.search = '';
                window.history.replaceState({}, document.title, url.toString());
            }
        });

        // === MOBILE: Fully functional mobile todo system ===

    </script>

    <!-- Login Effects -->
    <div class="login-effects">
        <div class="data-point"></div>
        <div class="data-point"></div>
        <div class="data-point"></div>
        <div class="data-point"></div>
        <div class="data-point"></div>
        <div class="data-point"></div>
        <div class="data-point"></div>
        <div class="data-point"></div>
        <div class="data-point"></div>
        <div class="data-point"></div>
    </div>

    <!-- === ENHANCED QUICKBAR === -->

    <div id="quickbar" class="quickbar">
        
        <!-- DYNAMIC MAIN BUTTONS -->
        <!-- These buttons appear when certain actions are active -->
        
        <!-- Dynamic Pomodoro Button (appears when timer is active) -->
        <div id="dynamic-pomodoro" class="quickbar-category dynamic-main-button" style="display: none;">
            <button id="dynamic-pomodoro-btn" class="quickbar-main-btn pomodoro-active" data-action="pomodoro-toggle" data-tooltip="Pomodoro Timer">
                <i data-lucide="pause-circle"></i>
            </button>
        </div>
        
        <!-- Dynamic Dark Mode Button (appears when dark mode is active) -->
        <div id="dynamic-darkmode" class="quickbar-category dynamic-main-button" style="display: none;">
            <button id="dynamic-darkmode-btn" class="quickbar-main-btn darkmode-active" data-action="darkmode-toggle" data-tooltip="Switch to Light Mode">
                <i data-lucide="sun"></i>
            </button>
        </div>
        
        <!-- Dynamic Brain Dump Button (appears when brain dumps exist) -->
        <div id="dynamic-braindump" class="quickbar-category dynamic-main-button" style="display: none;">
            <button id="dynamic-braindump-btn" class="quickbar-main-btn braindump-active" data-action="braindump-toggle" data-tooltip="Brain Dumps verteilen">
                <i data-lucide="inbox"></i>
                <span class="quickbar-badge" id="braindump-quickbar-badge">0</span>
            </button>
        </div>
        
        <!-- ADDS Category -->
        <div class="quickbar-category" data-category="adds">
            <button id="quickbar-adds" class="quickbar-main-btn" data-category="adds" data-tooltip="Add Items">
                <i data-lucide="plus"></i>
            </button>
            <div id="quickbar-adds-sub" class="quickbar-sub-buttons" data-category="adds">
                <button class="quickbar-sub-btn" data-action="add-todo" data-tooltip="Todo hinzufügen">
                    <i data-lucide="check-square"></i>
                </button>
                <button class="quickbar-sub-btn" data-action="add-termin" data-tooltip="Termin erstellen">
                    <i data-lucide="calendar"></i>
                </button>
                <button class="quickbar-sub-btn" data-action="add-goal" data-tooltip="Ziel setzen">
                    <i data-lucide="target"></i>
                </button>
                <button class="quickbar-sub-btn" data-action="add-resource" data-tooltip="Resource speichern">
                    <i data-lucide="bookmark"></i>
                </button>
                <button class="quickbar-sub-btn" data-action="add-wiki" data-tooltip="Wiki Eintrag">
                    <i data-lucide="file-text"></i>
                </button>
                <button class="quickbar-sub-btn" data-action="add-journal" data-tooltip="Journal Eintrag">
                    <i data-lucide="book-open"></i>
                </button>
            </div>
        </div>
        
        <!-- ACTIONS Category -->
        <div class="quickbar-category" data-category="actions">
            <button id="quickbar-actions" class="quickbar-main-btn" data-category="actions" data-tooltip="Quick Actions">
                <i data-lucide="zap"></i>
            </button>
            <div id="quickbar-actions-sub" class="quickbar-sub-buttons" data-category="actions">
                <button class="quickbar-sub-btn" data-action="global-search" data-tooltip="Global Search">
                    <i data-lucide="search"></i>
                </button>
                <button class="quickbar-sub-btn" data-action="pomodoro" data-tooltip="Pomodoro Timer">
                    <i data-lucide="timer"></i>
                </button>
                <button class="quickbar-sub-btn" data-action="trading-rules" data-tooltip="Trading Rules">
                    <i data-lucide="trending-up"></i>
                </button>
            </div>
        </div>
        
        <!-- SYSTEM Category -->
        <div class="quickbar-category" data-category="system">
            <button id="quickbar-system" class="quickbar-main-btn" data-category="system" data-tooltip="System">
                <i data-lucide="settings"></i>
            </button>
            <div id="quickbar-system-sub" class="quickbar-sub-buttons" data-category="system">
                <button class="quickbar-sub-btn" data-action="dark-mode" data-tooltip="Dark Mode">
                    <i data-lucide="moon"></i>
                </button>
                <button class="quickbar-sub-btn" data-action="settings" data-tooltip="Einstellungen">
                    <i data-lucide="sliders"></i>
                </button>
                <button class="quickbar-sub-btn" data-action="logout" data-tooltip="Ausloggen">
                    <i data-lucide="log-out"></i>
                </button>
            </div>
        </div>
        
    </div>

    <!-- === BRAIN DUMP MANAGER === -->
    <script>
        class BrainDumpManager {
            constructor() {
                this.brainDumps = [];
                this.selectedDumps = new Set();
                this.isExpanded = false;
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.setupInstantSync();
                this.setupAggressiveSync();
                this.loadBrainDumps();
                
                // Check for brain dumps every 3 seconds (backup sync)
                setInterval(() => this.loadBrainDumps(), 3000);
            }
            
            setupAggressiveSync() {
                // Fast polling when user returns to tab
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        this.loadBrainDumps();
                        
                        // Extra fast sync for 5 seconds
                        let fastSyncCount = 0;
                        const fastSync = setInterval(() => {
                            this.loadBrainDumps();
                            fastSyncCount++;
                            if (fastSyncCount >= 5) {
                                clearInterval(fastSync);
                            }
                        }, 1000); // Every 1 second for 5 times
                    }
                });
                
                // Window focus sync
                window.addEventListener('focus', () => {
                    this.loadBrainDumps();
                });
            }
            
            setupEventListeners() {
                // Header click to expand/collapse
                const header = document.querySelector('.brain-dump-header');
                if (header) {
                    header.addEventListener('click', () => this.toggleExpanded());
                }
                
                // Expand button
                const expandBtn = document.getElementById('brain-dump-expand');
                if (expandBtn) {
                    expandBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.toggleExpanded();
                    });
                }
                
                // Bulk actions
                const selectAllBtn = document.getElementById('brain-dump-select-all');
                if (selectAllBtn) {
                    selectAllBtn.addEventListener('click', () => this.selectAll());
                }
                
                const distributeBtn = document.getElementById('brain-dump-distribute');
                if (distributeBtn) {
                    distributeBtn.addEventListener('click', () => this.distributeSelected());
                }
                
                const clearAllBtn = document.getElementById('brain-dump-clear-all');
                if (clearAllBtn) {
                    clearAllBtn.addEventListener('click', () => this.clearAll());
                }
            }
            
            setupInstantSync() {
                // Method 1: localStorage event listener (cross-tab communication)
                window.addEventListener('storage', (event) => {
                    console.log('🔍 DESKTOP: Storage event received', event.key, event.newValue);
                    if (event.key === 'brain_dump_sync' && event.newValue) {
                        try {
                            const notification = JSON.parse(event.newValue);
                            console.log('🔍 DESKTOP: Notification parsed', notification);
                            if (notification.type === 'NEW_BRAIN_DUMP' && notification.source === 'mobile') {
                                console.log('🔍 DESKTOP: Loading brain dumps from mobile sync');
                                this.loadBrainDumps();
                            }
                        } catch (error) {
                            console.error('❌ Error parsing sync notification:', error);
                        }
                    }
                });
                
                // Method 2: BroadcastChannel listener (modern browsers)
                if (typeof BroadcastChannel !== 'undefined') {
                    const channel = new BroadcastChannel('brain_dump_updates');
                    channel.onmessage = (event) => {
                        console.log('🔍 DESKTOP: BroadcastChannel message received', event.data);
                        if (event.data.type === 'NEW_BRAIN_DUMP' && event.data.source === 'mobile') {
                            console.log('🔍 DESKTOP: Loading brain dumps from BroadcastChannel');
                            this.loadBrainDumps();
                        }
                    };
                    
                    // Store reference for cleanup
                    this.syncChannel = channel;
                }
                
                }
            
            async loadBrainDumps() {
                console.log('🔍 DESKTOP: loadBrainDumps() called');
                try {
                    if (!window.supabase || !window.supabase.isAuthenticated()) {
                        this.brainDumps = [];
                        this.updateUI();
                        return;
                    }
                    
                    // Load todos that are brain dumps (category = 'braindump' or created via mobile)
                    const user = window.supabase.getCurrentUser();
                    const todos = await window.supabase.select('todos', '*');
                    
                    // Filter for brain dumps (category = 'braindump')
                    this.brainDumps = (todos || []).filter(todo => {
                        return todo.category === 'braindump';
                    });
                    
                    console.log(`🧠 Found ${this.brainDumps.length} brain dumps:`, this.brainDumps);
                    
                    // DEBUG: Show all todos to see what categories exist
                    if (todos && todos.length > 0) {
                        }
                    
                    this.updateUI();
                    
                    // INSTANT UPDATE: Always update quickbar toggle after loading brain dumps
                    if (window.QuickBar) {
                        window.QuickBar.updateDynamicButtons();
                        
                        // Force debug the toggle state
                        setTimeout(() => {
                            const toggleButton = document.getElementById('dynamic-braindump');
                            }, 100);
                    }
                    
                } catch (error) {
                    console.error('❌ Error loading brain dumps:', error);
                }
            }
            
            isRecentMobileCreation(createdAt) {
                // Consider todos created in the last 24 hours as potential brain dumps
                const now = new Date();
                const created = new Date(createdAt);
                const hoursDiff = (now - created) / (1000 * 60 * 60);
                return hoursDiff <= 24;
            }
            
            updateUI() {
                const container = document.getElementById('brain-dump-container');
                const badge = document.getElementById('brain-dump-badge');
                const list = document.getElementById('brain-dump-list');
                
                if (!container || !badge || !list) return;
                
                // Update badge count
                badge.textContent = this.brainDumps.length;
                
                // Hide container by default - only show via quickbar toggle
                if (this.brainDumps.length === 0) {
                    container.style.display = 'none';
                } else {
                    // Keep current display state if there are brain dumps
                    if (!container.style.display) {
                        container.style.display = 'none';
                    }
                }
                
                // Update badge visibility
                if (this.brainDumps.length > 0) {
                    badge.style.display = 'inline';
                } else {
                    badge.style.display = 'none';
                }
                
                // Update quickbar dynamic button
                if (window.QuickBar) {
                    window.QuickBar.updateDynamicButtons();
                }
                
                // Render brain dumps
                if (this.brainDumps.length === 0) {
                    list.innerHTML = '<div class="brain-dump-empty">Keine Brain Dumps vorhanden</div>';
                    return;
                }
                
                list.innerHTML = this.brainDumps.map(dump => `
                    <div class="brain-dump-item ${this.selectedDumps.has(dump.id) ? 'selected' : ''}">
                        <input type="checkbox" class="brain-dump-checkbox" 
                               data-id="${dump.id}" 
                               ${this.selectedDumps.has(dump.id) ? 'checked' : ''}>
                        <div class="brain-dump-content-area">
                            <div class="brain-dump-text">${this.escapeHtml(dump.text)}</div>
                            <div class="brain-dump-meta">
                                <div class="brain-dump-chips">
                                    ${this.renderChips(dump)}
                                </div>
                                <span>• ${this.formatRelativeTime(dump.created_at)}</span>
                            </div>
                        </div>
                        <div class="brain-dump-actions-area">
                            <button class="brain-dump-quick-action" onclick="brainDumpManager.quickDistribute(${dump.id}, 'privat')" title="Zu Privat">
                                <i data-lucide="home" style="width: 14px; height: 14px;"></i>
                            </button>
                            <button class="brain-dump-quick-action" onclick="brainDumpManager.quickDistribute(${dump.id}, 'arbeit')" title="Zu Arbeit">
                                <i data-lucide="briefcase" style="width: 14px; height: 14px;"></i>
                            </button>
                            <button class="brain-dump-quick-action" onclick="brainDumpManager.quickDistribute(${dump.id}, 'uni')" title="Zu Uni">
                                <i data-lucide="graduation-cap" style="width: 14px; height: 14px;"></i>
                            </button>
                            <button class="brain-dump-quick-action" onclick="brainDumpManager.quickDistribute(${dump.id}, 'projekte')" title="Zu Projekte">
                                <i data-lucide="rocket" style="width: 14px; height: 14px;"></i>
                            </button>
                            <button class="brain-dump-quick-action" onclick="brainDumpManager.deleteDump(${dump.id})" title="Löschen">
                                <i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>
                            </button>
                        </div>
                    </div>
                `).join('');
                
                // Re-initialize checkboxes
                list.querySelectorAll('.brain-dump-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', () => this.toggleSelection(parseInt(checkbox.dataset.id)));
                });
                
                // Re-initialize Lucide icons
                if (window.lucide) {
                    lucide.createIcons();
                }
            }
            
            renderChips(dump) {
                const chips = [];
                
                // Priority chips
                if (dump.priority === 4) {
                    chips.push('<span class="brain-dump-chip">⚡ Dringend</span>');
                } else if (dump.priority === 3) {
                    chips.push('<span class="brain-dump-chip">❗ Wichtig</span>');
                } else if (dump.priority === 1) {
                    chips.push('<span class="brain-dump-chip">💡 Idee</span>');
                }
                
                // Date chips
                if (dump.date) {
                    const today = new Date().toISOString().split('T')[0];
                    const tomorrow = new Date(Date.now() + 86400000).toISOString().split('T')[0];
                    
                    if (dump.date === today) {
                        chips.push('<span class="brain-dump-chip">📅 Heute</span>');
                    } else if (dump.date === tomorrow) {
                        chips.push('<span class="brain-dump-chip">🌅 Morgen</span>');
                    } else {
                        chips.push(`<span class="brain-dump-chip">📅 ${dump.date}</span>`);
                    }
                }
                
                // Mobile indicator
                chips.push('<span class="brain-dump-chip">📱 Mobile</span>');
                
                return chips.join('');
            }
            
            formatRelativeTime(dateStr) {
                const now = new Date();
                const created = new Date(dateStr);
                const diffMs = now - created;
                const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                const diffMins = Math.floor(diffMs / (1000 * 60));
                
                if (diffMins < 5) return 'gerade eben';
                if (diffMins < 60) return `vor ${diffMins}m`;
                if (diffHours < 24) return `vor ${diffHours}h`;
                return created.toLocaleDateString('de-DE');
            }
            
            toggleExpanded() {
                this.isExpanded = !this.isExpanded;
                
                const content = document.getElementById('brain-dump-content');
                const expandBtn = document.getElementById('brain-dump-expand');
                
                if (this.isExpanded) {
                    content.classList.add('expanded');
                    content.style.display = 'block';
                    expandBtn.classList.add('expanded');
                } else {
                    content.classList.remove('expanded');
                    content.style.display = 'none';
                    expandBtn.classList.remove('expanded');
                }
            }
            
            toggleSelection(dumpId) {
                if (this.selectedDumps.has(dumpId)) {
                    this.selectedDumps.delete(dumpId);
                } else {
                    this.selectedDumps.add(dumpId);
                }
                this.updateUI();
            }
            
            selectAll() {
                if (this.selectedDumps.size === this.brainDumps.length) {
                    // Deselect all
                    this.selectedDumps.clear();
                } else {
                    // Select all
                    this.brainDumps.forEach(dump => this.selectedDumps.add(dump.id));
                }
                this.updateUI();
            }
            
            async quickDistribute(dumpId, category) {
                try {
                    const dump = this.brainDumps.find(d => d.id === dumpId);
                    if (!dump) return;
                    
                    // Show distribution dialog with optional date/time editing
                    const distributionData = await this.showDistributionDialog(category, 1);
                    if (!distributionData) return; // User cancelled
                    
                    // Update the todo with new category, date and time
                    await window.supabase.update('todos', {
                        category: distributionData.category,
                        date: distributionData.date,
                        time: distributionData.time
                    }, dumpId);
                    
                    // Remove from brain dumps
                    this.brainDumps = this.brainDumps.filter(d => d.id !== dumpId);
                    this.selectedDumps.delete(dumpId);
                    
                    this.updateUI();
                    
                    // Force refresh of todo sections to show item in new category
                    this.forceRefreshTodos();
                    
                    // INSTANT UPDATE: Force quickbar toggle update immediately
                    if (window.QuickBar) {
                        setTimeout(() => {
                            window.QuickBar.updateDynamicButtons();
                        }, 100);
                    }
                    
                    // Show success message
                    
                } catch (error) {
                    console.error('❌ Error distributing brain dump:', error);
                }
            }
            
            async distributeSelected() {
                if (this.selectedDumps.size === 0) {
                    alert('Bitte wähle Brain Dumps zum Verteilen aus.');
                    return;
                }
                
                // Show distribution dialog with optional date/time editing
                const distributionData = await this.showDistributionDialog('privat', this.selectedDumps.size);
                if (!distributionData) return; // User cancelled
                
                try {
                    // Update all selected brain dumps with same category, date and time
                    for (const dumpId of this.selectedDumps) {
                        await window.supabase.update('todos', {
                            category: distributionData.category,
                            date: distributionData.date,
                            time: distributionData.time
                        }, dumpId);
                    }
                    
                    const count = this.selectedDumps.size;
                    
                    // Remove from brain dumps
                    this.brainDumps = this.brainDumps.filter(d => !this.selectedDumps.has(d.id));
                    this.selectedDumps.clear();
                    
                    this.updateUI();
                    
                    // Force refresh of todo sections to show items in new category
                    this.forceRefreshTodos();
                    
                    // INSTANT UPDATE: Force quickbar toggle update immediately
                    if (window.QuickBar) {
                        setTimeout(() => {
                            window.QuickBar.updateDynamicButtons();
                        }, 100);
                    }

                } catch (error) {
                    console.error('❌ Error distributing brain dumps:', error);
                    alert('Fehler beim Verteilen der Brain Dumps.');
                }
            }
            
            async deleteDump(dumpId) {
                try {
                    await window.supabase.delete('todos', dumpId);
                    
                    this.brainDumps = this.brainDumps.filter(d => d.id !== dumpId);
                    this.selectedDumps.delete(dumpId);
                    
                    this.updateUI();
                    
                } catch (error) {
                    console.error('❌ Error deleting brain dump:', error);
                }
            }
            
            async clearAll() {
                if (!confirm(`Alle ${this.brainDumps.length} Brain Dumps löschen?`)) return;
                
                try {
                    // Delete all brain dumps
                    for (const dump of this.brainDumps) {
                        await window.supabase.delete('todos', dump.id);
                    }
                    
                    const count = this.brainDumps.length;
                    this.brainDumps = [];
                    this.selectedDumps.clear();
                    
                    this.updateUI();

                } catch (error) {
                    console.error('❌ Error clearing brain dumps:', error);
                    alert('Fehler beim Löschen der Brain Dumps.');
                }
            }
            
            async showDistributionDialog(defaultCategory, itemCount) {
                return new Promise((resolve) => {
                    // Create modal dialog
                    const modal = document.createElement('div');
                    modal.className = 'brain-dump-modal-overlay';
                    modal.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.5);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10000;
                    `;
                    
                    const now = new Date();
                    const todayDate = now.toISOString().split('T')[0];
                    const currentTime = '21:00';  // Default to 21:00 (9 PM)
                    
                    modal.innerHTML = `
                        <div class="brain-dump-dialog" style="
                            background: white;
                            padding: 2rem;
                            border-radius: 8px;
                            width: 90%;
                            max-width: 400px;
                            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
                        ">
                            <h3 style="margin: 0 0 1.5rem 0; font-size: 1.2rem;">
                                ${itemCount} Brain Dump${itemCount > 1 ? 's' : ''} verteilen
                            </h3>
                            
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Kategorie:</label>
                                <select id="dist-category" style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px;">
                                    <option value="privat" ${defaultCategory === 'privat' ? 'selected' : ''}>Privat</option>
                                    <option value="arbeit" ${defaultCategory === 'arbeit' ? 'selected' : ''}>Arbeit</option>
                                    <option value="uni" ${defaultCategory === 'uni' ? 'selected' : ''}>Uni</option>
                                    <option value="projekte" ${defaultCategory === 'projekte' ? 'selected' : ''}>Projekte</option>
                                </select>
                            </div>
                            
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Datum:</label>
                                <input type="date" id="dist-date" value="${todayDate}" style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px;">
                            </div>
                            
                            <div style="margin-bottom: 2rem;">
                                <label style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Zeit:</label>
                                <input type="time" id="dist-time" value="${currentTime}" style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px;">
                            </div>
                            
                            <div style="display: flex; gap: 1rem;">
                                <button id="dist-cancel" style="flex: 1; padding: 0.75rem; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                                    Abbrechen
                                </button>
                                <button id="dist-confirm" style="flex: 1; padding: 0.75rem; background: #000; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                    Verteilen
                                </button>
                            </div>
                        </div>
                    `;
                    
                    document.body.appendChild(modal);
                    
                    // Event handlers
                    modal.querySelector('#dist-cancel').onclick = () => {
                        document.body.removeChild(modal);
                        resolve(null);
                    };
                    
                    modal.querySelector('#dist-confirm').onclick = () => {
                        const category = modal.querySelector('#dist-category').value;
                        const date = modal.querySelector('#dist-date').value;
                        const time = modal.querySelector('#dist-time').value;
                        
                        document.body.removeChild(modal);
                        resolve({ category, date, time });
                    };
                    
                    // Close on overlay click
                    modal.onclick = (e) => {
                        if (e.target === modal) {
                            document.body.removeChild(modal);
                            resolve(null);
                        }
                    };
                });
            }
            
            async forceRefreshTodos() {
                try {
                    // Use the proper TodoManager system instead of custom rendering
                    if (window.supabase && window.supabase.isAuthenticated() && window.TodoManager) {
                        // Reload todos from database using TodoManager
                        await window.TodoManager.loadTodos();
                        
                        // Refresh all category containers with proper filtering and checkboxes
                        const categories = ['privat', 'uni', 'arbeit', 'projekte'];
                        categories.forEach(category => {
                            window.TodoManager.displayTodosForCategory(category);
                        });
                        
                        this.todoRefreshSuccess = true;
                        
                        // CRITICAL FIX: Also refresh the brain dump container to remove distributed items
                        await this.loadBrainDumps();
                        
                    } else {
                        console.warn('⚠️ TodoManager not available, falling back to page refresh');
                        window.location.reload();
                    }
                    
                } catch (error) {
                    console.error('❌ Error in forceRefreshTodos:', error);
                    
                    // Fallback: Force page refresh
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);
                }
            }
            
            getCategoryDisplayName(category) {
                const names = {
                    'privat': 'Personal',
                    'uni': 'Education', 
                    'arbeit': 'Work',
                    'projekte': 'Projects'
                };
                return names[category] || category;
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            showToast(message) {
                // Simple toast notification
                const toast = document.createElement('div');
                toast.className = 'toast-notification';
                toast.textContent = message;
                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: var(--accent-primary);
                    color: var(--bg-primary);
                    padding: 1rem 1.5rem;
                    border-radius: 6px;
                    z-index: 10000;
                    font-size: 0.9rem;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                    animation: slideIn 0.3s ease;
                `;
                
                document.body.appendChild(toast);
                
                setTimeout(() => {
                    toast.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }
        
        // === SPORT MANAGER ===
        class SportManager {
            constructor() {
                this.resetTime = '06:00';
                this.containerVisible = true;
                this.completedToday = null; // Memory-based cache instead of localStorage
                this.init();
            }
            
            async init() {
                await this.loadSettings();
                await this.checkTodayStatus();
            }
            
            async loadSettings() {
                try {
                    if (!window.supabase?.isAuthenticated()) return;
                    
                    const user = window.supabase.getCurrentUser();
                    if (!user) return;
                    
                    // Load reset time
                    const timeSettings = await window.supabase.query(
                        `user_settings?user_id=eq.${user.id}&setting_key=eq.sportResetTime&select=setting_value`
                    );
                    this.resetTime = timeSettings && timeSettings.length > 0 ? timeSettings[0].setting_value : '06:00';
                    
                    // Load visibility
                    const visibilitySettings = await window.supabase.query(
                        `user_settings?user_id=eq.${user.id}&setting_key=eq.sportContainerVisibility&select=setting_value`
                    );
                    this.containerVisible = visibilitySettings && visibilitySettings.length > 0 
                        ? visibilitySettings[0].setting_value === 'true' 
                        : true;
                        
                    // Update settings UI if on settings page
                    this.updateSettingsUI();
                    
                } catch (error) {
                    console.error('Error loading sport settings:', error);
                }
            }
            
            updateSettingsUI() {
                const timeInput = document.getElementById('sport-reset-time');
                if (timeInput) timeInput.value = this.resetTime;
                
                const visibilityInput = document.getElementById('sport-visibility');
                if (visibilityInput) visibilityInput.checked = this.containerVisible;
            }
            
            applySettings() {
                if (!this.containerVisible) {
                    this.hideContainer();
                } else if (this.shouldShowToday()) {
                    this.showContainer();
                } else {
                    this.hideContainer();
                }
            }
            
            shouldShowToday() {
                // Check if it's past the reset time today
                // If yes, show container (unless already answered)
                // If no, don't show yet
                const now = new Date();
                const [resetHour, resetMinute] = this.resetTime.split(':').map(Number);
                const resetToday = new Date(now.getFullYear(), now.getMonth(), now.getDate(), resetHour, resetMinute);
                
                return now >= resetToday;
            }

            async checkTodayStatus() {
                try {
                    // First check if container should be visible at all
                    if (!this.containerVisible) {
                        this.hideContainer();
                        return;
                    }
                    
                    // Check if it's past reset time
                    if (!this.shouldShowToday()) {
                        this.hideContainer();
                        return;
                    }
                    
                    const today = new Date().toISOString().split('T')[0];
                    
                    // Check memory cache first - prevents multiple DB calls
                    if (this.completedToday === today) {
                        console.log('💪 Sport already completed today (memory cache)');
                        this.hideContainer();
                        return;
                    }
                    
                    if (!window.supabase?.isAuthenticated()) {
                        this.showContainer();
                        return;
                    }
                    
                    const user = window.supabase.user;
                    if (!user) {
                        this.showContainer();
                        return;
                    }
                    
                    // Check if sport was already logged today in database
                    const result = await window.supabase.query(
                        `sport_tracking?user_id=eq.${user.id}&date=eq.${today}`
                    );
                    
                    const dataArray = result?.data || result;
                    const todayEntry = Array.isArray(dataArray) && dataArray.length > 0 ? dataArray[0] : null;
                    
                    if (todayEntry) {
                        // Sport already logged today - update memory cache and hide
                        this.completedToday = today;
                        this.hideContainer();
                    } else {
                        // Show container
                        this.showContainer();
                    }
                } catch (error) {
                    console.warn('⚠️ Sport tracking table not found or error:', error.message);
                    // Show container anyway if visible and past reset time
                    if (this.containerVisible && this.shouldShowToday()) {
                        this.showContainer();
                    } else {
                        this.hideContainer();
                    }
                }
            }
            
            async markSportCompleted(completed) {
                const today = new Date().toISOString().split('T')[0];
                
                // Immediately update memory cache and hide container
                this.completedToday = today;
                this.hideContainer();
                
                try {
                    if (!window.supabase?.isAuthenticated()) {
                        alert('Not authenticated');
                        return;
                    }
                    
                    const user = window.supabase.user;
                    if (!user) return;
                    
                    // Check if entry already exists for today
                    const existingResult = await window.supabase.query(
                        `sport_tracking?user_id=eq.${user.id}&date=eq.${today}`
                    );
                    
                    const existingData = existingResult?.data || existingResult;
                    const hasExistingEntry = Array.isArray(existingData) && existingData.length > 0;
                    
                    if (hasExistingEntry) {
                        // Update existing entry
                        await window.supabase.update('sport_tracking', 
                            { completed: completed },
                            `user_id=eq.${user.id}&date=eq.${today}`
                        );
                        console.log(`💪 Sport updated for ${today}: ${completed}`);
                    } else {
                        // Insert new entry
                        await window.supabase.insert('sport_tracking', {
                            user_id: user.id,
                            date: today,
                            completed: completed,
                            created_at: new Date().toISOString()
                        });
                        console.log(`💪 Sport logged for ${today}: ${completed}`);
                    }
                    
                    // Show success feedback
                    if (completed) {
                        this.showSuccessFeedback();
                    }
                    
                } catch (error) {
                    console.error('❌ Error saving sport status:', error);
                    if (error.message?.includes('sport_tracking')) {
                        alert('Sport-Tracking Tabelle noch nicht angelegt. Bitte erstelle die Tabelle in Supabase.');
                    } else {
                        alert('Fehler beim Speichern');
                    }
                }
            }
            
            showContainer() {
                const container = document.getElementById('daily-sport-container');
                if (container) {
                    // Create content dynamically only when needed
                    container.innerHTML = `
                        <div class="sport-question-card">
                            <div class="sport-left">
                                <div class="sport-icon">💪</div>
                                <div class="sport-text">Hast du heute Sport gemacht?</div>
                            </div>
                            <div class="sport-actions">
                                <button class="sport-btn sport-no" onclick="window.SportManager?.markSportCompleted(false)">Nein</button>
                                <button class="sport-btn sport-yes" onclick="window.SportManager?.markSportCompleted(true)">Ja</button>
                            </div>
                        </div>
                    `;
                    container.classList.remove('hidden');
                }
            }
            
            hideContainer() {
                const container = document.getElementById('daily-sport-container');
                if (container) {
                    container.classList.add('hidden');
                    container.innerHTML = ''; // Clear content when hidden
                }
            }
            
            showSuccessFeedback() {
                // Create temporary success message - minimal style
                const feedback = document.createElement('div');
                feedback.style.cssText = `
                    position: fixed;
                    top: 2rem;
                    right: 2rem;
                    background: var(--bg-primary);
                    color: var(--text-primary);
                    border: 1px solid #000000;
                    padding: 0.75rem 1.5rem;
                    z-index: 10000;
                    font-size: 0.9rem;
                    font-weight: 500;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                feedback.innerHTML = 'Sport erledigt';
                
                document.body.appendChild(feedback);
                
                // Fade in
                setTimeout(() => {
                    feedback.style.opacity = '1';
                }, 10);
                
                // Remove after 2 seconds
                setTimeout(() => {
                    feedback.style.opacity = '0';
                    setTimeout(() => {
                        feedback.remove();
                    }, 300);
                }, 2000);
            }
        }
        
        // Initialize SportManager when everything is ready
        let sportManager;
        
        // Initialize SportManager after supabase is ready
        function initializeSportManager() {
            if (window.supabase && window.supabase.isAuthenticated() && !sportManager) {
                sportManager = new SportManager();
                window.SportManager = sportManager;
                console.log('🏋️‍♂️ SportManager initialized');
            }
        }
        
        // Initialize SportManager immediately when ready
        setTimeout(initializeSportManager, 100);
        
        // Also initialize when user switches to home tab
        const originalShowTab = window.showTab;
        if (originalShowTab) {
            window.showTab = function(tabName) {
                originalShowTab(tabName);
                if (tabName === 'home') {
                    setTimeout(initializeSportManager, 500);
                }
            };
        }
        
        // Add sport heatmap methods to AnalyticsManager
        if (window.AnalyticsManager) {
            window.AnalyticsManager.setupSportHeatmap = async function() {
                const gridElement = document.getElementById('sport-heatmap-grid');
                const monthsElement = document.getElementById('sport-heatmap-months');
                if (!gridElement || !monthsElement) return;

                try {
                    const sportData = await this.generateSportHeatmapData();
                    this.renderSportHeatmap(gridElement, monthsElement, sportData);
                    this.updateSportHeatmapStats(sportData);
                } catch (error) {
                    console.error('❌ Error setting up sport heatmap:', error);
                }
            };
            
            window.AnalyticsManager.generateSportHeatmapData = async function() {
                try {
                    if (!window.supabase?.isAuthenticated()) {
                        console.warn('No supabase or user not authenticated for sport heatmap');
                        return {};
                    }
                    
                    const user = window.supabase.user;
                    if (!user) return {};

                    const result = await window.supabase.query(
                        `sport_tracking?user_id=eq.${user.id}&select=date,completed`
                    );
                    
                    const dataArray = result?.data || result;
                    const sportData = {};
                    
                    if (Array.isArray(dataArray)) {
                        dataArray.forEach(entry => {
                            if (entry.completed) {
                                sportData[entry.date] = 1;
                            }
                        });
                    }
                    
                    return sportData;
                } catch (error) {
                    console.error('❌ Error generating sport heatmap data:', error);
                    return {};
                }
            };
            
            window.AnalyticsManager.renderSportHeatmap = function(gridElement, monthsElement, data) {
                // Use the same rendering logic as routine heatmaps
                gridElement.innerHTML = '';
                monthsElement.innerHTML = '';

                const endDate = new Date();
                const startDate = new Date();
                startDate.setDate(endDate.getDate() - 370);

                // Generate month labels (same as routine heatmaps)
                const monthNames = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
                let currentMonth = -1;
                
                for (let week = 0; week < 53; week++) {
                    const weekDate = new Date(startDate);
                    weekDate.setDate(startDate.getDate() + (week * 7));
                    const month = weekDate.getMonth();
                    
                    if (month !== currentMonth && week % 4 === 0) {
                        const monthDiv = document.createElement('div');
                        monthDiv.className = 'heatmap-month';
                        monthDiv.textContent = monthNames[month];
                        monthDiv.style.gridColumn = `${week + 1} / span 4`;
                        monthsElement.appendChild(monthDiv);
                        currentMonth = month;
                    }
                }

                // Generate heatmap squares
                for (let col = 0; col < 53; col++) {
                    for (let row = 0; row < 7; row++) {
                        const date = new Date(startDate);
                        date.setDate(startDate.getDate() + (col * 7) + row);
                        
                        if (date > endDate) continue;

                        const dateStr = date.toISOString().split('T')[0];
                        const hasSport = data[dateStr] || 0;
                        const level = hasSport ? 4 : 0; // Binary: 0 (no sport) or 4 (sport done)
                        
                        const square = document.createElement('div');
                        square.className = `heatmap-square level-${level}`;
                        square.setAttribute('data-date', dateStr);
                        square.setAttribute('data-level', level);
                        square.style.gridColumn = col + 1;
                        square.style.gridRow = row + 1;
                        
                        const formattedDate = date.toLocaleDateString('de-DE');
                        const status = hasSport ? 'Sport gemacht' : 'Kein Sport';
                        square.title = `${formattedDate}: ${status}`;
                        
                        gridElement.appendChild(square);
                    }
                }
            };
            
            window.AnalyticsManager.updateSportHeatmapStats = function(data) {
                const statsElement = document.getElementById('sport-heatmap-stats');
                if (!statsElement) return;
                
                // Remove the stats text - keep it clean like routine heatmaps
                statsElement.textContent = '';
            };
        }
        
        // Initialize Brain Dump Manager
        let brainDumpManager;
        
        // Initialize immediately
        document.addEventListener('DOMContentLoaded', () => {
            brainDumpManager = new BrainDumpManager();
            window.brainDumpManager = brainDumpManager;
            
            // Also try to initialize after auth is ready
            setTimeout(() => {
                if (window.supabase && window.supabase.isAuthenticated() && brainDumpManager) {
                    brainDumpManager.loadBrainDumps();
                }
            }, 2000);
        });
        
        // Global function to force brain dump refresh (for mobile sync)
        window.forceBrainDumpRefresh = function() {
            if (window.brainDumpManager) {
                window.brainDumpManager.loadBrainDumps();
            }
        };
        
        // Force refresh when window becomes visible (user switches back from mobile)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && window.brainDumpManager) {
                setTimeout(() => {
                    window.brainDumpManager.loadBrainDumps();
                }, 500);
            }
        });
        
        // Also refresh on window focus
        window.addEventListener('focus', () => {
            if (window.brainDumpManager) {
                setTimeout(() => {
                    window.brainDumpManager.loadBrainDumps();
                }, 500);
            }
        });
        
        // Add toast animations to document
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        // === JOURNAL TAG ANALYTICS SYSTEM ===
        
        class JournalTagAnalytics {
            constructor() {
                this.currentPeriod = 'month';
                this.currentCategory = 'all';
                this.chart = null;
                this.isInitialized = false;
            }
            
            async initialize() {
                if (this.isInitialized) return;
                
                // Fix corrupted categories first (one-time fix)
                if (window.cloudStorage) {
                    await window.cloudStorage.fixCorruptedJournalCategories();
                    await window.cloudStorage.processExistingJournalEntries();
                }
                
                await this.updateCategoryButtons();
                await this.loadAndDisplayAnalytics();
                this.isInitialized = true;
            }
            
            async updatePeriod(period) {
                this.currentPeriod = period;
                
                // Update active button
                document.querySelectorAll('.period-btn[onclick*="JournalTagAnalytics"]').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-period="${period}"][onclick*="JournalTagAnalytics"]`)?.classList.add('active');
                
                await this.loadAndDisplayAnalytics();
            }
            
            async updateCategory(category) {
                this.currentCategory = category;
                
                // Update active button
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-category="${category}"]`)?.classList.add('active');
                
                await this.loadAndDisplayAnalytics();
            }
            
            async updateCategoryButtons() {
                if (!window.cloudStorage) return;
                
                try {
                    const categories = await window.cloudStorage.getAvailableJournalCategories();
                    const container = document.querySelector('.category-filter-buttons');
                    if (!container) return;
                    
                    // Always start with "Alle" button
                    let buttonsHTML = '<button class="category-btn active" data-category="all" onclick="window.JournalTagAnalytics?.updateCategory(\'all\')">Alle</button>';
                    
                    // Add dynamic category buttons
                    categories.forEach(category => {
                        const capitalizedCategory = category.charAt(0).toUpperCase() + category.slice(1);
                        buttonsHTML += `<button class="category-btn" data-category="${category}" onclick="window.JournalTagAnalytics?.updateCategory('${category}')">${capitalizedCategory}</button>`;
                    });
                    
                    container.innerHTML = buttonsHTML;
                    } catch (error) {
                    console.error('Error updating category buttons:', error);
                }
            }
            
            async loadAndDisplayAnalytics() {
                if (!window.cloudStorage) {
                    console.error('CloudStorage not available');
                    return;
                }
                
                try {
                    const dateRange = this.getPeriodDays();
                    const analytics = await window.cloudStorage.getJournalTagAnalytics(dateRange, this.currentCategory);
                    // Debug: Check if we have any tags in database
                    if (window.supabase && window.supabase.isAuthenticated()) {
                        try {
                            const user = window.supabase.getCurrentUser();
                            const allTags = await window.supabase.query(`journal_tags?user_id=eq.${user.id}&select=*`);
                            } catch (error) {
                            }
                    }
                    
                    this.displayTagFrequency(analytics.tagFrequency);
                    this.displayTagCorrelations(analytics.tagCorrelations);
                    this.updateStats(analytics);
                } catch (error) {
                    console.error('Error loading tag analytics:', error);
                }
            }
            
            getPeriodDays() {
                switch(this.currentPeriod) {
                    case 'week': return 7;
                    case 'month': return 30;
                    case 'quarter': return 90;
                    default: return 30;
                }
            }
            
            displayTagFrequency(tagFrequency) {
                const ctx = document.getElementById('tagFrequencyChart');
                if (!ctx) return;
                
                // Destroy existing chart
                if (this.chart) {
                    this.chart.destroy();
                }
                
                const tags = Object.keys(tagFrequency);
                const frequencies = Object.values(tagFrequency);
                
                if (tags.length === 0) {
                    ctx.style.display = 'none';
                    return;
                }
                
                ctx.style.display = 'block';
                
                // Sort by frequency (descending) and take top 10
                const sorted = tags.map((tag, i) => ({ tag, count: frequencies[i] }))
                                  .sort((a, b) => b.count - a.count)
                                  .slice(0, 10);
                
                this.chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sorted.map(item => '#' + item.tag),
                        datasets: [{
                            label: 'Häufigkeit',
                            data: sorted.map(item => item.count),
                            backgroundColor: 'rgba(34, 197, 94, 0.8)',
                            borderColor: 'rgba(34, 197, 94, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                bottom: 20,
                                left: 10,
                                right: 10
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { 
                                    stepSize: 1,
                                    padding: 10
                                }
                            },
                            x: {
                                ticks: {
                                    maxRotation: 45,
                                    padding: 10
                                }
                            }
                        }
                    }
                });
            }
            
            displayTagCorrelations(correlations) {
                const container = document.getElementById('tag-correlations-list');
                if (!container) return;
                
                if (correlations.length === 0) {
                    container.innerHTML = '<div class="correlation-item">Keine Tag-Korrelationen gefunden</div>';
                    return;
                }
                
                const html = correlations.slice(0, 10).map(corr => `
                    <div class="correlation-item">
                        <div class="correlation-tags">
                            <span class="correlation-tag">#${corr.tag1}</span>
                            <span class="correlation-tag">#${corr.tag2}</span>
                        </div>
                        <div class="correlation-count">${corr.count}x</div>
                    </div>
                `).join('');
                
                container.innerHTML = html;
            }
            
            updateStats(analytics) {
                const tagStatsEl = document.getElementById('tag-stats');
                const correlationStatsEl = document.getElementById('correlation-stats');
                
                const totalTags = Object.values(analytics.tagFrequency).reduce((sum, count) => sum + count, 0);
                const uniqueTags = Object.keys(analytics.tagFrequency).length;
                
                if (tagStatsEl) {
                    tagStatsEl.textContent = `${totalTags} Tags, ${uniqueTags} unique`;
                }
                
                if (correlationStatsEl) {
                    correlationStatsEl.textContent = `${analytics.tagCorrelations.length} Korrelationen gefunden`;
                }
            }
        }
        
        // Initialize Journal Tag Analytics when analytics tab is opened
        window.JournalTagAnalytics = new JournalTagAnalytics();
        
        // Add tab switch listener to initialize analytics
        document.addEventListener('click', (e) => {
            if (e.target.matches('[data-tab="tab-analytics"]')) {
                setTimeout(() => {
                    window.JournalTagAnalytics.initialize();
                }, 100);
            }
            
            // Trading cheatsheet toggle
            if (e.target.matches('#toggle-cheatsheet')) {
                const content = document.getElementById('cheatsheet-content');
                const button = document.getElementById('toggle-cheatsheet');
                
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    button.textContent = '−';
                } else {
                    content.style.display = 'none';
                    button.textContent = '+';
                }
            }
        });
        
        // Clear all journal tags functionality
        window.clearAllTags = async function() {
            try {
                const user = window.supabase.getCurrentUser();
                const allTags = await window.supabase.query(`journal_tags?user_id=eq.${user.id}&select=id`);
                if (allTags && allTags.length > 0) {
                    for (const tag of allTags) {
                        await window.supabase.delete('journal_tags', tag.id);
                    }
                    // Refresh analytics
                    if (window.JournalTagAnalytics) {
                        window.JournalTagAnalytics.isInitialized = false;
                        await window.JournalTagAnalytics.initialize();
                    }
                } else {
                    console.log('No tags to delete');
                }
            } catch (error) {
                console.error('Error clearing tags:', error);
            }
        };
    </script>

</body>
</html>