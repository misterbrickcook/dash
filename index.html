<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-eval' 'unsafe-inline' https://unpkg.com https://cdn.jsdelivr.net; object-src 'none'; base-uri 'self';">
    <title>Dash v4.1</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2224%22 height=%2224%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22%23000000%22 stroke-width=%222%22 stroke-linecap=%22round%22 stroke-linejoin=%22round%22><path d=%22m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z%22/><path d=%22M5 3v4%22/><path d=%22M19 17v4%22/><path d=%22M3 5h4%22/><path d=%22M17 19h4%22/></svg>">
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* === DESIGN SYSTEM === */
        :root {
            /* Colors */
            --bg-primary: #ffffff;
            --bg-secondary: #F5F5F5;
            --text-primary: #333333;
            --text-secondary: #666666;
            --text-muted: #999999;
            --border-primary: #e0e0e0;
            --border-secondary: #d1d5db;
            --accent-primary: #000000;
            
            /* Typography */
            --font-size-base: 16px;
            --line-height-base: 24px;
            --font-size-sm: 14px;
            --font-size-xs: 12px;
            --font-size-lg: 18px;
            --font-size-xl: 20px;
            
            /* Spacing */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
        }

        /* === RESET & BASE === */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: var(--font-size-base);
            line-height: var(--line-height-base);
            max-width: 1400px;
            margin: 0 auto;
        }

        /* === HIDE SCROLLBARS EVERYWHERE === */
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        *::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        /* === SMART LOADING STATES & SKELETON SCREENS === */
        .skeleton {
            background: linear-gradient(90deg, 
                var(--bg-secondary) 25%, 
                rgba(255,255,255,0.8) 50%, 
                var(--bg-secondary) 75%
            );
            background-size: 200% 100%;
            animation: loading-shimmer 2s infinite;
            border-radius: 4px;
        }
        
        @keyframes loading-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .skeleton-text {
            height: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .skeleton-text.large {
            height: 1.5rem;
        }
        
        .skeleton-text.small {
            height: 0.75rem;
        }
        
        .skeleton-text:last-child {
            margin-bottom: 0;
        }
        
        .skeleton-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }
        
        .skeleton-todo {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border-primary);
        }
        
        .skeleton-checkbox {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        
        .skeleton-watchlist-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border-primary);
        }
        
        .skeleton-watchlist-left {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }
        
        .skeleton-chart {
            width: 40px;
            height: 20px;
        }
        
        .skeleton-symbol {
            width: 35px;
            height: 0.75rem;
        }
        
        .skeleton-price {
            width: 60px;
            height: 0.75rem;
        }

        /* === STICKY NAVIGATION === */
        .sticky-nav {
            position: fixed;
            top: 40px; /* Below crypto ticker */
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-primary);
            z-index: 1000;
            padding: var(--spacing-md) 0;
        }
        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            position: relative;
        }
        .nav-tab {
            text-decoration: none;
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            padding: var(--spacing-sm) var(--spacing-md);
            border: 1px solid transparent;
            transition: all 0.2s ease;
            cursor: pointer;
            background: none;
            font-family: inherit;
        }
        .nav-tab:hover { 
            color: var(--accent-primary); 
            transform: translateY(-2px);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.02), rgba(0, 0, 0, 0.05));
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        .nav-tab.active {
            color: var(--accent-primary);
            font-weight: 700;
            border: 1px solid transparent;
            background: transparent;
        }
        
        /* === LOGOUT & SETTINGS BUTTONS === */
        .nav-actions {
            position: absolute;
            right: 0;
            display: flex;
            gap: 0.25rem;
            align-items: center;
        }
        
        .logout-btn, .settings-btn {
            color: var(--text-secondary) !important;
            font-weight: 400 !important;
            background: transparent !important;
            border: none !important;
            border-color: transparent !important;
            outline: none !important;
            cursor: pointer !important;
            pointer-events: auto !important;
            position: relative !important;
            z-index: 1000 !important;
            box-shadow: none !important;
            text-transform: none !important;
            letter-spacing: normal !important;
            padding: var(--spacing-sm) var(--spacing-md) !important;
        }
        
        /* Mobile-safe hover states - override nav-tab hover */
        .logout-btn:hover, .settings-btn:hover,
        .logout-btn:active, .settings-btn:active,
        .logout-btn:focus, .settings-btn:focus {
            background: transparent !important;
            border: none !important;
            border-color: transparent !important;
        }
        
        /* Specific override for nav-tab hover border */
        .nav-tab.logout-btn:hover, .nav-tab.settings-btn:hover {
            border: none !important;
            border-color: transparent !important;
            background: transparent !important;
        }
        
        
        .logout-btn:hover span, .logout-btn:active span, .logout-btn:focus span,
        .logout-btn:hover svg, .logout-btn:active svg, .logout-btn:focus svg {
            color: #dc2626 !important;
            stroke: #dc2626 !important;
        }
        
        
        
        .settings-btn:hover span, .settings-btn:active span, .settings-btn:focus span,
        .settings-btn:hover i, .settings-btn:active i, .settings-btn:focus i {
            color: #059669 !important;
            stroke: #059669 !important;
        }
        
        
        /* Force reset any stuck hover states on mobile */
        @media (max-width: 768px) {
            .logout-btn span {
                color: #666666 !important;
            }
            .logout-btn:hover span {
                color: #dc2626 !important;
            }
        }
        
        .logout-btn span, .settings-btn span {
            font-size: 1.2rem;
            pointer-events: none !important;
        }

        /* === SMART QUICK ACTIONS BAR === */
        .quick-actions-bar {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        /* Action buttons container */
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: top center;
        }
        
        /* Collapsed state - hide action buttons */
        .quick-actions-bar.collapsed .action-buttons {
            opacity: 0;
            transform: translateY(-20px) scale(0.8);
            pointer-events: none;
        }
        
        /* Expanded state - show action buttons */
        .quick-actions-bar.expanded .action-buttons {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }
        
        /* Toggle button special styling */
        .toggle-btn {
            position: relative;
            transition: all 0.3s ease;
        }
        
        /* When expanded, toggle button can have different styling */
        .quick-actions-bar.expanded .toggle-btn {
            background: var(--accent-primary);
            color: white;
        }
        
        /* Stagger animation for individual buttons */
        .action-buttons .quick-action-btn {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .quick-actions-bar.expanded .action-buttons .quick-action-btn:nth-child(1) { transition-delay: 0.05s; }
        .quick-actions-bar.expanded .action-buttons .quick-action-btn:nth-child(2) { transition-delay: 0.1s; }
        .quick-actions-bar.expanded .action-buttons .quick-action-btn:nth-child(3) { transition-delay: 0.15s; }
        .quick-actions-bar.expanded .action-buttons .quick-action-btn:nth-child(4) { transition-delay: 0.2s; }
        .quick-actions-bar.expanded .action-buttons .quick-action-btn:nth-child(5) { transition-delay: 0.25s; }
        .quick-actions-bar.expanded .action-buttons .quick-action-btn:nth-child(6) { transition-delay: 0.3s; }
        .quick-actions-bar.expanded .action-buttons .quick-action-btn:nth-child(7) { transition-delay: 0.35s; }
        
        .quick-action-btn {
            width: 56px;
            height: 56px;
            background: white;
            border: 2px solid var(--border-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            color: var(--text-primary);
            font-size: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .quick-action-btn:hover {
            transform: scale(1.1);
            border-color: var(--accent-primary);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }
        
        .quick-action-btn:active {
            transform: scale(0.95);
        }
        
        /* Tooltip for quick actions */
        .quick-action-btn::before {
            content: attr(data-tooltip);
            position: absolute;
            left: 70px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--accent-primary);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 1001;
        }
        
        .quick-action-btn::after {
            content: '';
            position: absolute;
            left: 62px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-right: 6px solid var(--accent-primary);
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .quick-action-btn:hover::before,
        .quick-action-btn:hover::after {
            opacity: 1;
        }
        
        /* All buttons have consistent white background */
        .quick-action-btn.primary {
            background: white;
            color: var(--text-primary);
            border-color: var(--border-primary);
        }
        
        .quick-action-btn.primary::before {
            background: var(--accent-primary);
        }
        
        .quick-action-btn.primary::after {
            border-right-color: var(--accent-primary);
        }
        
        /* Responsive - hide on mobile */
        @media (max-width: 768px) {
            .quick-actions-bar {
                display: none;
            }
        }

        /* === SETTINGS PAGE === */
        .settings-container {
            max-width: 600px;
            margin: 0 auto;
        }
        
        .setting-group {
            background: #f8f9fa;
            padding: 2rem;
            margin-bottom: 2rem;
            border-radius: 12px;
            border: 1px solid #e0e0e0;
        }
        
        .setting-group h3 {
            margin: 0 0 1.5rem 0;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .setting-item:last-child {
            margin-bottom: 0;
        }
        
        .setting-item label {
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .setting-item input[type="time"] {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            max-width: 200px;
        }
        
        .setting-description {
            font-size: 0.85rem;
            color: #666666;
            margin-top: 0.25rem;
        }
        
        .btn-secondary {
            background: #6b7280 !important;
        }
        
        .btn-secondary:hover {
            background: #4b5563 !important;
        }

        /* === MAIN CONTENT === */
        .main-content { padding: 0 20px 40px 20px; }
        .tab-section { display: none; }
        .tab-section.active { display: block; }

        /* === TODO BLOCKS (same as resources) === */
        .todos-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2rem;
        }
        
        .todo-block {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 0;
            overflow: hidden;
            transition: all 0.2s ease;
            height: 400px;
            max-height: 400px;
            display: flex;
            flex-direction: column;
        }
        
        .todo-block:hover {
            border-color: #000000;
        }
        
        .todo-block-header {
            background: #f8f9fa;
            border-bottom: 1px solid #f0f0f0;
            padding: 1.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .todo-block-header h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            color: #000000;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .todo-links {
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-height: 200px;
            flex: 1;
            overflow-y: auto;
        }
        
        .todo-empty-state {
            text-align: center;
            padding: 2rem 1rem;
            color: #666666;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .todo-empty-state p {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: #333333;
        }
        
        .todo-empty-state small {
            font-size: 0.9rem;
            color: #888888;
            font-style: italic;
            line-height: 1.4;
        }

        /* === SHARED COMPONENTS === */
        .section-title {
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 3rem;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 1rem;
        }
        .card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            transition: border-color 0.2s ease;
        }
        .card:hover { border-color: #000000; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 3rem; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2rem; }
        .btn {
            padding: 0.75rem 1.5rem;
            border: 1px solid #000000;
            background: #ffffff;
            color: #000000;
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-block;
        }
        .btn:hover { background: #000000; color: #ffffff; }
        .btn.secondary { border-color: #e0e0e0; color: #666666; }
        .btn.secondary:hover { border-color: #000000; background: #f0f0f0; color: #000000; }

        /* === CHECKBOX COMPONENT === */
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .checkbox-item.todo-item {
            justify-content: space-between;
            width: 100%;
        }
        .checkbox-item.todo-item .todo-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
            min-width: 0; /* Allow shrinking */
        }
        .checkbox-item.todo-item .todo-time {
            font-size: 0.85rem;
            color: #666;
            font-weight: 500;
            flex-shrink: 0;
            margin-left: 1rem;
            text-align: right;
        }
        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            border: 2px solid #000000;
            appearance: none;
            cursor: pointer;
            flex-shrink: 0;
        }
        .checkbox-item input[type="checkbox"]:checked {
            background-color: #000000;
            position: relative;
        }
        .checkbox-item input[type="checkbox"]:checked::after {
            content: '✓';
            color: white;
            position: absolute;
            top: -2px;
            left: 2px;
            font-size: 12px;
        }
        .checkbox-item label {
            font-size: 0.95rem;
            cursor: pointer;
            line-height: 1.4;
        }

        /* === PROGRESS BAR === */
        .progress-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .progress-bar {
            flex: 1;
            height: 8px;
            background-color: #f0f0f0;
            border: 1px solid #e0e0e0;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: #000000;
            transition: width 0.3s ease;
        }

        /* === STREAK TILES === */
        .streak-overview {
            margin-bottom: 3rem;
        }
        .streak-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2rem;
        }
        .streak-tile {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .streak-tile:hover {
            border-color: #000000;
        }
        
        /* Confetti Animation - Cool celebration effect */
        .streak-tile.success-animation {
            position: relative;
            animation: confettiPulse 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes confettiPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Confetti particles */
        .confetti-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff6b6b;
            pointer-events: none;
            z-index: 1000;
        }
        
        .confetti-particle:nth-child(1) { background: #4ecdc4; }
        .confetti-particle:nth-child(2) { background: #45b7d1; }
        .confetti-particle:nth-child(3) { background: #96ceb4; }
        .confetti-particle:nth-child(4) { background: #feca57; }
        .confetti-particle:nth-child(5) { background: #ff9ff3; }
        .confetti-particle:nth-child(6) { background: #54a0ff; }
        .confetti-particle:nth-child(7) { background: #5f27cd; }
        .confetti-particle:nth-child(8) { background: #00d2d3; }
        
        @keyframes confettiFall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(60px) rotate(720deg);
                opacity: 0;
            }
        }
        
        .streak-number {
            font-size: 3rem;
            font-weight: 300;
            color: #000000;
            margin-bottom: 0.5rem;
            line-height: 1;
            transition: all 0.3s ease;
        }
        
        .streak-tile.success-animation .streak-number {
            animation: confettiNumberBounce 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes confettiNumberBounce {
            0% { 
                transform: scale(1); 
                color: #000000;
            }
            50% { 
                transform: scale(1.2); 
                color: #ff6b6b;
            }
            100% { 
                transform: scale(1); 
                color: #000000;
            }
        }
        .streak-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }
        .streak-date {
            font-size: 0.8rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* === ROUTINE SPECIFIC === */
        .routine-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
            margin-bottom: 4rem;
            height: auto;
            min-height: 300px;
        }
        .routine-section {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            min-height: 250px;
        }
        .routine-section h2 {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .routine-section .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex: 1;
            margin-bottom: 1rem;
        }

        /* === TODO SPECIFIC === */
        .category-tabs {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 3rem;
        }
        .category-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .category-tab:hover { border-color: #000000; color: #000000; }
        .category-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        
        .badge {
            background: #dc2626;
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 4px;
            min-width: 16px;
            text-align: center;
        }
        .category-content { display: none; }
        .category-content.active { display: block; }
        
        /* === ZIELE SPECIFIC TABS === */
        .ziel-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .ziel-tab:hover { border-color: #000000; color: #000000; }
        .ziel-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .ziel-content { display: none; }
        
        /* === RESOURCE TABS === */
        .resource-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .resource-tab:hover { border-color: #000000; color: #000000; }
        .resource-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .resource-content { display: none; }
        .resource-content.active { display: block; }
        .ziel-content.active { display: block; }
        
        /* === JOURNAL SPECIFIC TABS === */
        .journal-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .journal-tab:hover { border-color: #000000; color: #000000; }
        .journal-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .journal-content { display: none; }
        .journal-content.active { display: block; }
        
        /* === TAG SELECTION === */
        .tag-option {
            padding: 0.5rem 1rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            color: #666666;
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .tag-option:hover { border-color: #000000; color: #000000; }
        .tag-option.selected {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .tag-option .remove-tag {
            cursor: pointer;
            font-size: 1rem;
            opacity: 0.8;
            display: none;
        }
        .tag-option.selected .remove-tag {
            display: inline;
        }
        .tag-option .remove-tag:hover {
            opacity: 1;
        }
        .todo-section {
            margin-bottom: 2rem;
        }
        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .section-header h3 {
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #444444;
        }
        .section-divider {
            flex: 1;
            height: 1px;
            background: #e0e0e0;
        }
        .section-count {
            font-size: 0.8rem;
            color: #666666;
            background: #f0f0f0;
            padding: 0.25rem 0.75rem;
            border: 1px solid #e0e0e0;
        }
        .todo-item {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: border-color 0.2s ease;
        }
        .todo-item:hover { border-color: #000000; }
        .todo-item.completed { opacity: 0.6; background: #fafafa; }
        .todo-item.completed .todo-title { text-decoration: line-through; }
        .todo-header {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }
        .todo-content { flex: 1; }
        .todo-title {
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }
        .todo-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .todo-deadline {
            font-size: 0.8rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .todo-deadline.today { color: #000000; font-weight: 500; }
        .todo-deadline.overdue { color: #cc0000; font-weight: 500; }
        .todo-deadline.soon { color: #ff6600; font-weight: 500; }
        
        /* Days until badge (similar to termine) */
        .days-until-badge {
            display: inline-block;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-left: 0.5rem;
        }
        .days-until-badge.heute {
            background: #000000;
            color: #ffffff;
        }
        .days-until-badge.morgen {
            background: #ff6600;
            color: #ffffff;
        }
        .days-until-badge.future {
            background: #3b82f6;
            color: #ffffff;
        }
        .days-until-badge.overdue {
            background: #cc0000;
            color: #ffffff;
        }
        
        .todo-tag {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.25rem 0.75rem;
            border: 1px solid;
            color: #ffffff;
            font-weight: 500;
        }
        .todo-tag.wichtig { background-color: #ff6600; border-color: #ff6600; }
        .todo-tag.dringend { background-color: #cc0000; border-color: #cc0000; }
        .todo-tag.normal { background-color: #666666; border-color: #666666; }

        /* === ZIELE SPECIFIC === */
        .ziel-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 200px;
        }
        .ziel-kategorie {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666666;
            border: 1px solid #e0e0e0;
            padding: 0.2rem 0.5rem;
            background: #fafafa;
            white-space: nowrap;
        }
        .ziel-header {
            margin-bottom: 1rem;
            margin-right: 6rem;
        }
        .ziel-name {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }
        .ziel-beschreibung {
            font-size: 0.9rem;
            color: #666666;
            line-height: 1.5;
            margin-bottom: 2rem;
        }
        .ziel-progress-section { margin-top: auto; }
        .ziel-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .ziel-progress-label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #444444;
        }
        .ziel-percentage {
            font-size: 1rem;
            font-weight: 500;
        }

        /* === JOURNAL SPECIFIC === */
        .quick-journal {
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            margin-bottom: 3rem;
        }
        .quick-journal h2 {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .journal-form {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        .journal-input {
            flex: 1;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .journal-input:focus { outline: none; border-color: #000000; }
        .journal-entries, .wiki-content {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
        }
        
        @media (max-width: 1200px) {
            .journal-entries, .wiki-content {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .journal-entries, .wiki-content {
                grid-template-columns: 1fr;
            }
        }
        
        .journal-entry {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            margin-bottom: 0;
        }
        .journal-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1.5rem;
            gap: 1rem;
        }
        .journal-entry-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #000000;
            margin: 0;
        }
        .journal-entry-content {
            color: #374151;
            line-height: 1.6;
            margin-bottom: 1.5rem;
            white-space: pre-wrap;
        }
        .journal-entry-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }
        .journal-entry-tags {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .journal-tag {
            background: #f3f4f6;
            color: #374151;
            padding: 0.25rem 0.5rem;
            border-radius: 0;
            font-size: 0.75rem;
            font-weight: 500;
        }
        .journal-entry-date {
            color: #9ca3af;
            font-size: 0.875rem;
        }
        .journal-entry-actions {
            display: flex;
            gap: 0.5rem;
        }
        .delete-entry-btn {
            background: none;
            border: none;
            color: #ef4444;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0;
            display: none;
        }
        .delete-entry-btn:hover {
            background: #fee2e2;
        }
        .journal-entry.show-delete .delete-entry-btn {
            display: block;
        }
        .wiki-entry-source {
            background: #e0f2fe;
            color: #0369a1;
            padding: 0.25rem 0.5rem;
            border-radius: 0;
            font-size: 0.75rem;
            font-weight: 500;
            margin-left: 0.5rem;
        }
        .journal-date {
            font-size: 1rem;
            font-weight: 500;
            color: #000000;
        }
        .journal-kategorie {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666666;
            border: 1px solid #e0e0e0;
            padding: 0.4rem 1rem;
            background: #fafafa;
        }
        .journal-content {
            font-size: 0.95rem;
            line-height: 1.7;
            color: #333333;
        }

        /* === TERMINE SPECIFIC === */
        .termin-card {
            position: relative;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 0;
            padding: 1.5rem;
            box-shadow: none;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .termin-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        }
        
        /* Base styling for days badges - dezent und rechteckig wie Kategorien */
        .termin-days-until, .ziel-days-until {
            position: absolute !important;
            top: 0.5rem !important;
            background: #fafafa !important;
            color: #666666 !important;
            padding: 0.2rem 0.5rem !important;
            border: 1px solid #e0e0e0 !important;
            font-size: 0.65rem !important;
            font-weight: 500 !important;
            text-transform: uppercase !important;
            letter-spacing: 0.1em !important;
            white-space: nowrap !important;
        }
        
        /* Termine: Rechtsbündig */
        .termin-days-until {
            right: 0.5rem !important;
        }
        
        /* Ziele: Mittig */
        .ziel-days-until {
            left: 50% !important;
            transform: translateX(-50%) !important;
        }
        
        /* === RESSOURCEN GRID === */
        .resource-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 200px));
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: start;
        }
        
        .resource-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 0.75rem;
            position: relative;
            transition: all 0.2s ease;
            height: 50px;
            display: flex;
            align-items: center;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .resource-card:hover {
            border-color: #000000;
            background: #f8f8f8;
        }
        
        .resource-icon {
            margin-right: 0.5rem;
            flex-shrink: 0;
            display: flex;
            align-items: center;
        }
        
        .resource-title {
            font-size: 0.85rem;
            font-weight: 500;
            color: #000000;
            margin: 0;
            flex: 1;
            line-height: 1.2;
        }
        
        
        /* === EMOJI PALETTE === */
        .emoji-palette {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 0.25rem;
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            position: relative;
            z-index: 1;
        }
        
        .emoji-btn {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 0.25rem;
            cursor: pointer;
            font-size: 1rem;
            border-radius: 2px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 28px;
            width: 28px;
        }
        
        .emoji-btn:hover {
            background: #000000;
            border-color: #000000;
            transform: scale(1.1);
        }
        
        .btn-link {
            background: none;
            border: none;
            color: #666666;
            cursor: pointer;
            text-decoration: underline;
            font-family: inherit;
        }
        
        .btn-link:hover {
            color: #000000;
        }
        
        .resource-footer {
            margin-top: auto;
            padding-top: 1rem;
            border-top: 1px solid #f0f0f0;
        }
        
        .resource-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #000000;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            padding: 0.5rem 1rem;
            border: 1px solid #e0e0e0;
            transition: all 0.2s ease;
        }
        
        .resource-link:hover {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
        }
        
        .resource-actions {
            position: absolute;
            top: 0.4rem;
            right: 0.4rem;
            display: flex;
            gap: 0.2rem;
            opacity: 1;
            transition: opacity 0.2s ease;
            z-index: 10;
        }
        
        
        .resource-edit-btn,
        .resource-delete-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #333333;
            cursor: pointer;
            padding: 0.25rem;
            transition: all 0.2s ease;
            border-radius: 4px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        
        
        .resource-delete-btn:hover {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }
        
        .resource-edit-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.3);
            color: #3b82f6;
        }
        
        .resource-edit-btn:hover i,
        .resource-delete-btn:hover i {
            stroke: currentColor;
        }
        
        /* === RESOURCE CATEGORIES (bsp1.jpg style) === */
        .resource-category-section {
            margin-bottom: 3rem;
        }
        
        .resource-category-title {
            font-size: 1.8rem;
            font-weight: 300;
            color: #000000;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .resource-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
        }
        
        .resource-button {
            background: #333333;
            border: 1px solid #555555;
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            text-decoration: none;
            min-width: 140px;
            justify-content: flex-start;
        }
        
        .resource-button:hover {
            background: #444444;
            border-color: #666666;
            transform: translateY(-1px);
        }
        
        .resource-icon {
            font-size: 1rem;
            margin-right: 0.25rem;
        }
        
        .resource-name {
            flex: 1;
            text-align: left;
        }
        
        .resource-button .resource-actions {
            position: absolute;
            top: -0.25rem;
            right: -0.25rem;
            display: flex;
            gap: 0.125rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        
        .resource-button .resource-edit-btn,
        .resource-button .resource-delete-btn {
            background: rgba(0, 0, 0, 0.8);
            border: none;
            color: #ffffff;
            padding: 0.25rem;
            font-size: 0.7rem;
            border-radius: 2px;
            cursor: pointer;
            opacity: 1;
        }
        
        .resource-button .resource-delete-btn:hover {
            background: #cc0000;
        }
        
        .resource-button .resource-edit-btn:hover {
            background: #007acc;
        }
        
        .termin-date {
            font-size: 0.8rem;
            color: #64748b;
            font-weight: 500;
            margin-bottom: 0.75rem;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .termin-date::before {
            content: '📅';
            font-size: 0.9rem;
        }
        
        .termin-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #1e293b;
            line-height: 1.3;
        }
        
        .termin-description {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #64748b;
            margin-bottom: 1rem;
        }
        
        .termin-edit-icon, .termin-delete-icon {
            position: absolute !important;
            bottom: 1rem !important;
            width: 32px !important;
            height: 32px !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 0.85rem !important;
            transition: all 0.2s ease !important;
            cursor: pointer !important;
        }
        
        .termin-edit-icon {
            right: 3.5rem !important;
            background: rgba(59, 130, 246, 0.1) !important;
            color: #3b82f6 !important;
            top: auto !important;
        }
        
        .termin-edit-icon:hover {
            background: #3b82f6 !important;
            color: white !important;
            transform: scale(1.1) !important;
        }
        
        .termin-delete-icon {
            right: 1rem !important;
            background: rgba(239, 68, 68, 0.1) !important;
            color: #ef4444 !important;
            top: auto !important;
        }
        
        .termin-delete-icon:hover {
            background: #ef4444 !important;
            color: white !important;
            transform: scale(1.1) !important;
        }

        /* === ADD TODO MODAL === */
        .add-todo-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            padding: 1rem;
        }
        .add-todo-modal.hide { display: none; }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            padding: 1rem;
        }
        .modal.hide { display: none; }
        .modal-content {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 500px;
            position: relative;
            z-index: 4001;
        }
        .modal-content .close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            cursor: pointer;
            font-size: 1.5rem;
            color: #666;
        }
        .modal-content .close:hover {
            color: #000;
        }
        .add-todo-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 500px;
        }
        .add-todo-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .add-todo-header h2 {
            font-size: 1.5rem;
            font-weight: 500;
            color: #000000;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .form-row .form-group {
            flex: 1;
        }
        .form-group select {
            width: 100%;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .form-group select:focus { outline: none; border-color: #000000; }
        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        /* === AUTH SCREEN === */
        .auth-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 1rem;
        }
        .auth-screen.hide { display: none; }
        .auth-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 400px;
        }
        .auth-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .auth-header h2 {
            font-size: 1.5rem;
            font-weight: 500;
            color: #000000;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-group {
            margin-bottom: 1.5rem;
        }
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #000000;
            font-weight: 500;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-group input {
            width: 100%;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .form-group input:focus { outline: none; border-color: #000000; }
        .auth-btn {
            width: 100%;
            padding: 1rem;
            border: 1px solid #000000;
            background: #ffffff;
            color: #000000;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .auth-btn:hover {
            background: #000000;
            color: #ffffff;
        }
        .auth-error {
            color: #cc0000;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            display: none;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .auth-error.show { display: block; }

        /* === RESPONSIVE === */
        /* === CRYPTO WIKI STYLES === */
        .wiki-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .search-container {
            display: flex;
            flex: 1;
            min-width: 350px;
            align-items: stretch;
        }
        
        .search-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-right: none;
            border-radius: 0;
            font-size: 0.95rem;
        }
        
        .search-btn {
            padding: 0.75rem 1rem;
            border: 1px solid #d1d5db;
            border-left: none;
            border-radius: 0;
            background: #f8f9fa;
            cursor: pointer;
        }
        
        .filter-container {
            display: flex;
            gap: 1rem;
            align-items: stretch;
            flex: 1;
            min-width: 350px;
        }
        
        .filter-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0;
            font-size: 0.95rem;
            background: #ffffff;
        }
        
        .filter-input:focus {
            outline: none;
            border-color: #000000;
            box-shadow: 0 0 0 1px #000000;
        }
        
        .filter-container select {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0;
            font-size: 0.95rem;
            background: #ffffff;
        }
        
        
        .wiki-entry {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 1.5rem;
        }
        
        .wiki-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }
        
        .wiki-entry-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #000000;
            margin: 0;
        }
        
        .wiki-entry-content {
            color: #333333;
            line-height: 1.6;
            margin-bottom: 1rem;
            white-space: pre-wrap;
        }
        
        .wiki-entry-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 1rem;
            border-top: 1px solid #e0e0e0;
            font-size: 0.85rem;
            color: #666666;
        }
        
        .wiki-entry-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .wiki-tag {
            background: #e5e7eb;
            color: #374151;
            padding: 0.25rem 0.5rem;
            border-radius: 0;
            font-size: 0.75rem;
        }
        
        .wiki-entry-source {
            font-style: italic;
        }
        
        .wiki-entry-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .wiki-entry-actions button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
        }
        
        .empty-wiki {
            text-align: center;
            color: #666666;
            padding: 3rem;
        }

        /* === QUICK NOTES STYLES === */
        .quicknotes-section {
            margin-top: 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
        }

        .quicknotes-header {
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            padding: 1rem 1.5rem;
        }

        .quicknotes-header h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .quicknotes-content {
            padding: 1.5rem;
        }

        #quicknotes-textarea {
            width: 100%;
            min-height: 200px;
            padding: 1rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.9rem;
            line-height: 1.6;
            resize: none;
            box-sizing: border-box;
            overflow: hidden;
        }

        #quicknotes-textarea:focus {
            outline: none;
            border-color: #000000;
        }

        #quicknotes-textarea::placeholder {
            color: #999999;
        }

        /* === TRADING TAB STYLES === */
        .add-trade-section {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .add-trade-section h3 {
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .trade-form .form-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .trade-form .form-group {
            display: flex;
            flex-direction: column;
        }

        .trade-form .form-group label {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #333333;
        }

        .trade-form .form-group input {
            padding: 0.75rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            font-size: 0.9rem;
            width: 100%;
            box-sizing: border-box;
        }

        .trade-form .form-group input:focus {
            outline: none;
            border-color: #000000;
        }

        .trade-form .form-actions {
            display: flex;
            gap: 0.5rem;
        }

        .sol-input-group, .mcap-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .sol-input-group input, .mcap-input-group input {
            width: 100%;
        }

        .mcap-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .mcap-container input {
            flex: 1;
        }

        .mcap-select {
            min-width: 60px;
            padding: 0.75rem 0.5rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            font-size: 0.9rem;
            border-radius: 6px;
        }

        .mcap-select:focus {
            outline: none;
            border-color: #000000;
        }

        .sol-buttons, .mcap-buttons, .sol-sell-buttons {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
        }

        .sol-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.25rem;
        }

        .sol-btn, .mcap-btn, .sol-percent-btn {
            padding: 0.4rem 0.6rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 35px;
            text-align: center;
        }

        .sol-btn:hover, .mcap-btn:hover, .sol-percent-btn:hover {
            border-color: #000000;
            background: #f5f5f5;
        }

        .mcap-btn.active {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
        }

        /* === CLOSE TRADE MODAL === */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #ffffff;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.2rem;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: #000000;
        }

        .modal-body {
            padding: 1.5rem;
        }

        .trade-info {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .info-row:last-child {
            margin-bottom: 0;
        }

        .info-label {
            font-weight: 500;
            color: #666666;
        }

        .info-value {
            font-weight: 600;
            color: #000000;
        }

        /* === TRADE DETAILS MODAL === */
        .trade-details-info {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .details-section {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 1rem;
        }

        .details-section h4 {
            margin: 0 0 1rem 0;
            font-size: 0.9rem;
            font-weight: 600;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 0.5rem;
        }

        .info-grid {
            display: grid;
            gap: 0.75rem;
        }

        .notes-content, .learnings-content {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 1rem;
            min-height: 80px;
            white-space: pre-wrap;
            font-family: inherit;
            line-height: 1.5;
            color: #000000;
        }

        .learnings-content {
            border-left: 4px solid #059669;
        }

        .notes-content:empty::before {
            content: 'Keine Entry Notes verfügbar';
            color: #999999;
            font-style: italic;
        }

        .learnings-content:empty::before {
            content: 'Keine Learnings verfügbar';
            color: #999999;
            font-style: italic;
        }

        /* === MOTIVATIONAL QUOTE WIDGET === */
        .quote-widget {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 0;
            margin-bottom: 4rem;
            transition: all 0.2s ease;
        }

        .quote-widget:hover {
            border-color: #000000;
        }

        .quote-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            padding: 1.5rem;
            color: #000000;
        }

        .quote-icon {
            font-size: 1.5rem;
            color: #666666;
            min-width: 24px;
        }

        .quote-content {
            flex: 1;
        }

        .quote-text {
            font-size: 1rem;
            font-weight: 500;
            line-height: 1.6;
            margin-bottom: 0.5rem;
            color: #000000;
        }

        .quote-author {
            font-size: 0.8rem;
            color: #666666;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .quote-refresh-btn {
            background: none;
            border: 1px solid #e0e0e0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666666;
        }

        .quote-refresh-btn:hover {
            border-color: #000000;
            color: #000000;
        }

        @media (max-width: 768px) {
            .quote-container {
                flex-direction: column;
                text-align: center;
                gap: 1rem;
                padding: 1.25rem;
            }
            
            .quote-text {
                font-size: 0.9rem;
            }
        }

        /* === RESOURCES BLOCKS DESIGN === */
        .resources-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .resources-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2rem;
        }

        .resource-block {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 0;
            transition: all 0.2s ease;
            min-height: 300px;
        }

        .resource-block:hover {
            border-color: #000000;
        }

        .resource-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.25rem;
            border-bottom: 1px solid #e0e0e0;
            background: #fafafa;
        }

        .resource-block-header h3 {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 0;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #000000;
        }

        .resource-block-header i {
            color: #666666;
        }

        .add-to-category-btn {
            background: none;
            border: 1px solid #e0e0e0;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666666;
        }

        .add-to-category-btn:hover {
            border-color: #000000;
            color: #000000;
        }

        .resource-links {
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-height: 200px;
        }

        .resource-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border: 1px solid #f0f0f0;
            transition: all 0.2s ease;
            text-decoration: none;
            color: inherit;
            position: relative;
        }

        .resource-item:hover {
            border-color: #e0e0e0;
            background: #fafafa;
        }

        .delete-overlay {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            animation: fadeIn 0.2s ease;
            z-index: 10;
        }

        .delete-icon {
            background: #dc2626;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 4px rgba(220, 38, 38, 0.3);
        }

        .delete-icon:hover {
            background: #b91c1c;
            transform: scale(1.05);
            box-shadow: 0 2px 6px rgba(220, 38, 38, 0.4);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .resource-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
        }

        .resource-icon {
            color: #666666;
            min-width: 16px;
        }

        .resource-details {
            flex: 1;
        }

        .resource-title {
            font-weight: 500;
            font-size: 0.9rem;
            color: #000000;
            margin-bottom: 0.25rem;
        }

        .resource-description {
            font-size: 0.8rem;
            color: #666666;
            line-height: 1.4;
        }

        .resource-actions {
            display: flex;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .resource-action-btn {
            background: none;
            border: none;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #666666;
            transition: all 0.2s ease;
        }

        .resource-action-btn:hover {
            color: #dc2626;
        }

        .empty-resources {
            text-align: center;
            padding: 2rem 1rem;
            color: #999999;
            font-style: italic;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .resources-grid {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
            
            .resources-header {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
                text-align: center;
            }
        }

        .close-trade-form .form-group {
            margin-bottom: 1.5rem;
        }

        .close-trade-form .form-group:last-child {
            margin-bottom: 0;
        }

        .close-trade-form label {
            display: block;
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #333333;
        }

        .modal-footer {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            padding: 1.5rem;
            border-top: 1px solid #e0e0e0;
        }

        .portfolio-overview {
            margin-bottom: 2rem;
        }

        .portfolio-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
        }

        .portfolio-stat {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            text-align: center;
        }

        .stat-number {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .stat-number.positive { color: #059669; }
        .stat-number.negative { color: #dc2626; }

        .stat-label {
            font-size: 0.9rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }


        .trading-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .trades-view {
            /* Ensure only one view is visible at a time */
            width: 100%;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .section-header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .section-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .section-actions .btn {
            padding: 0.25rem 0.75rem;
            font-size: 0.85rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        /* === ANALYTICS STYLES === */
        .analytics-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .analytics-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
        }

        .analytics-card h3 {
            margin: 0 0 0.5rem 0;
            font-size: 0.9rem;
            font-weight: 500;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #000000;
            margin: 0.5rem 0;
        }

        .metric-value.positive { color: #22c55e; }
        .metric-value.negative { color: #ef4444; }

        .metric-subtitle {
            font-size: 0.8rem;
            color: #888888;
        }

        .charts-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .chart-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1.5rem;
        }

        .chart-container h3 {
            margin: 0 0 1rem 0;
            font-size: 1rem;
            font-weight: 600;
        }

        .chart-placeholder {
            height: 200px;
            background: #f8f9fa;
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666666;
            font-size: 1rem;
        }

        .analytics-charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-bottom: 1rem;
        }

        .chart-section {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1.5rem;
            height: 400px;
            max-height: 400px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chart-container {
            height: 280px;
            position: relative;
            flex: none;
        }

        .chart-container canvas {
            max-height: 100%;
            width: 100% !important;
            height: 100% !important;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin: 0 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #f0f0f0;
        }

        .chart-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-end;
        }

        .time-period-buttons {
            display: flex;
            gap: 0.25rem;
        }

        .period-btn {
            padding: 0.4rem 0.8rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            color: #666666;
            font-size: 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .period-btn:hover {
            background: #f5f5f5;
        }

        .period-btn.active {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
        }

        .chart-header h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            color: #000000;
        }

        .chart-info {
            font-size: 0.9rem;
            color: #666666;
            font-weight: 500;
        }

        /* Heatmap Styles */
        .heatmap-container {
            padding: 1rem 0;
            height: 280px;
            display: flex;
            flex-direction: column;
            flex: none;
        }

        .heatmap-months {
            display: flex;
            margin-bottom: 0.5rem;
            padding-left: 15px;
            font-size: 0.7rem;
            color: #666666;
            flex-shrink: 0;
        }

        .heatmap-month {
            flex: 1;
            text-align: left;
            min-width: 0;
        }

        .heatmap-grid {
            display: grid;
            grid-template-columns: repeat(53, 1fr);
            grid-template-rows: repeat(7, 1fr);
            gap: 1px;
            padding: 0;
            margin: 0;
            flex: 1;
            max-width: 100%;
            overflow: hidden;
        }

        .heatmap-square {
            width: 100%;
            height: 100%;
            min-width: 8px;
            min-height: 8px;
            border-radius: 1px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        @media (max-width: 768px) {
            .analytics-charts-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-container {
                height: 230px;
            }
            
            .heatmap-container {
                height: 230px;
            }
        }

        .heatmap-square:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .heatmap-square.level-0 {
            background-color: #ebedf0;
        }

        .heatmap-square.level-1 {
            background-color: #9be9a8;
        }

        .heatmap-square.level-2 {
            background-color: #40c463;
        }

        .heatmap-square.level-3 {
            background-color: #30a14e;
        }

        .heatmap-square.level-4 {
            background-color: #216e39;
        }

        /* Performance Heatmap Colors */
        .heatmap-square.performance-loss {
            background-color: #ef4444; /* Red for loss */
        }

        .heatmap-square.performance-neutral {
            background-color: #f97316; /* Orange for same */
        }

        .heatmap-square.performance-gain {
            background-color: #22c55e; /* Green for gain */
        }

        /* Performance Legend Colors */
        .legend-square.performance-loss {
            background-color: #ef4444;
        }

        .legend-square.performance-neutral {
            background-color: #f97316;
        }

        .legend-square.performance-gain {
            background-color: #22c55e;
        }

        .heatmap-legend {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-top: 1rem;
            font-size: 0.75rem;
            color: #666666;
            gap: 0.5rem;
        }

        .legend-colors {
            display: flex;
            gap: 2px;
        }

        .legend-square {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .legend-square.level-0 {
            background-color: #ebedf0;
        }

        /* === TRADING STICKY NOTE === */
        .trading-rules-sticky {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .trading-rules-sticky:hover {
            border-color: #000000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .trading-rules-sticky::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, #000000, transparent);
            animation: slideRule 4s ease-in-out infinite;
        }
        
        @keyframes slideRule {
            0%, 100% { left: -100%; opacity: 0; }
            50% { left: 100%; opacity: 1; }
        }
        
        .sticky-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid #f0f0f0;
            background: #fafafa;
        }
        
        .sticky-title {
            font-weight: 500;
            font-size: 0.9rem;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .sticky-minimize {
            background: none;
            border: none;
            font-size: 1rem;
            font-weight: 300;
            color: #666666;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            transition: all 0.3s ease;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .sticky-minimize:hover {
            color: #000000;
            transform: rotate(180deg) scale(1.1);
        }
        
        .sticky-content {
            padding: 1.5rem;
        }
        
        .rules-list {
            list-style: none;
            margin: 0;
            padding: 0;
            display: grid;
            gap: 1rem;
        }
        
        .rules-list li {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #000000;
            padding: 0.75rem;
            border: 1px solid transparent;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .rules-list li:hover {
            border-color: #e0e0e0;
            background: #fafafa;
            transform: translateX(2px);
        }
        
        .rules-list li::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #000000;
            transform: scaleY(0);
            transition: transform 0.2s ease;
            transform-origin: bottom;
        }
        
        .rules-list li:hover::before {
            transform: scaleY(1);
        }
        
        .rules-list strong {
            color: #000000;
            font-weight: 500;
        }
        
        .trading-rules-sticky.minimized .sticky-content {
            display: none;
        }
        
        
        .trading-rules-sticky.minimized .sticky-header {
            border-bottom: none;
        }
        
        @media (max-width: 768px) {
            .rules-list {
                gap: 0.75rem;
            }
            
            .rules-list li {
                font-size: 0.85rem;
                padding: 0.6rem;
                gap: 0.75rem;
            }
            
            .sticky-content {
                padding: 1rem;
            }
            
            .sticky-header {
                padding: 1rem 1.25rem;
            }
        }

        .legend-square.level-1 {
            background-color: #9be9a8;
        }

        .legend-square.level-2 {
            background-color: #40c463;
        }

        .legend-square.level-3 {
            background-color: #30a14e;
        }

        .legend-square.level-4 {
            background-color: #216e39;
        }

        .heatmap-info {
            font-size: 0.9rem;
            color: #666666;
            font-weight: 500;
        }

        .performers-section {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1.5rem;
        }

        .performers-section h3 {
            margin: 0 0 1rem 0;
            font-size: 1rem;
            font-weight: 600;
        }

        .performer-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .performer-item:last-child {
            border-bottom: none;
        }

        .token-name {
            font-weight: 500;
        }

        .token-pnl.positive { color: #22c55e; }
        .token-pnl.negative { color: #ef4444; }

        @media (max-width: 768px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
            
            .analytics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* === ENHANCED TRADE FORM STYLES === */
        .form-section {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #f0f0f0;
        }

        .form-section-title {
            margin: 0 0 1rem 0;
            font-size: 0.9rem;
            font-weight: 600;
            color: #444444;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .form-group textarea {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.9rem;
            resize: vertical;
            min-height: 80px;
        }

        .form-group textarea:focus {
            outline: none;
            border-color: #000000;
        }

        .form-group textarea::placeholder {
            color: #999999;
            font-style: italic;
        }

        .stoploss-btn.active {
            background: #fecaca !important;
            color: #dc2626 !important;
            border-color: #dc2626 !important;
        }

        .takeprofit-btn.active {
            background: #bbf7d0 !important;
            color: #059669 !important;
            border-color: #059669 !important;
        }

        /* === TRADE ACTION BUTTONS === */
        .trade-action-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            color: #666666;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .trade-action-btn:hover {
            background: transparent;
            color: #16a34a;
        }

        .trade-action-btn:hover i {
            stroke: #16a34a;
        }

        /* === TRADE BADGE ICONS === */
        .trade-badge-icon {
            width: 16px;
            height: 16px;
            margin-left: 0.5rem;
            vertical-align: middle;
        }

        .initials-icon {
            stroke: #16a34a;
            stroke-width: 2;
        }

        .free-ride-icon {
            stroke: #2563eb;
            stroke-width: 2;
        }

        .trades-table {
            overflow-x: auto;
        }

        .trade-row {
            display: grid;
            grid-template-columns: 1fr 0.8fr 1fr 1fr 0.8fr 1fr 0.8fr auto;
            gap: 0.5rem;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f0f0f0;
            align-items: center;
        }

        #open-trades-view .trade-row {
            grid-template-columns: 1fr 0.8fr 1fr 1fr 0.8fr 0.8fr 0.8fr 1fr auto;
        }

        .trade-row:last-child {
            border-bottom: none;
        }

        .trade-header {
            display: grid;
            grid-template-columns: 1fr 0.8fr 1fr 1fr 0.8fr 1fr 0.8fr auto;
            gap: 0.5rem;
            padding: 0.5rem 0;
            border-bottom: 2px solid #e0e0e0;
            font-weight: 600;
            font-size: 0.85rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        #open-trades-view .trade-header {
            grid-template-columns: 1fr 0.8fr 1fr 1fr 0.8fr 0.8fr 0.8fr 1fr auto;
        }

        .trade-token {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .trade-amount {
            font-size: 0.9rem;
        }

        .trade-risk {
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .trade-notes {
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .trade-entry-price {
            font-size: 0.9rem;
            color: #666666;
        }

        .trade-current-price {
            font-size: 0.9rem;
        }

        .trade-pnl {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .trade-pnl.positive { color: #059669; }
        .trade-pnl.negative { color: #dc2626; }

        .trade-actions {
            display: flex;
            gap: 0.5rem;
        }

        .trade-actions button {
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
        }

        .empty-trades {
            text-align: center;
            color: #666666;
            padding: 2rem;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .trade-form .form-row {
                grid-template-columns: 1fr;
            }
            
            .portfolio-stats {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .trade-row, .trade-header {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }

            .trade-row > div::before {
                content: attr(data-label) ": ";
                font-weight: 600;
                display: inline-block;
                width: 80px;
            }
        }

        /* === LUCIDE ICON STYLES === */
        .icon-palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .icon-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            background: #ffffff;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .icon-btn:hover {
            background: #f3f4f6;
            border-color: #000000;
        }
        
        .icon-btn:active {
            background: #e5e7eb;
        }

        @media (max-width: 768px) {
            /* MOBILE: Under Construction */
            
            /* Hide everything */
            body > *:not(.mobile-construction) {
                display: none !important;
            }
            
            /* Show construction page */
            body {
                margin: 0;
                padding: 0;
                background: #ffffff;
                min-height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }
            
            .mobile-construction {
                text-align: center;
                color: #000000;
            }
            
            .mobile-construction h1 {
                font-size: 2rem;
                margin: 0;
                font-weight: 400;
                letter-spacing: 0.05em;
            }
        }
        
        /* Desktop: Hide mobile construction */
        @media (min-width: 769px) {
            .mobile-construction {
                display: none;
            }
        }


        /* === CRYPTO TICKER BAR === */
        .crypto-ticker-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            z-index: 999; /* Below navbar but above content */
            display: none; /* Hidden by default, shown only after authentication */
        }
        
        .ticker-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
        }
        
        .ticker-content {
            display: flex;
            align-items: center;
            gap: 20px;
            white-space: nowrap;
            animation: scroll-ticker 40s linear infinite;
        }
        
        @keyframes scroll-ticker {
            0% { transform: translateX(100%); }
            100% { transform: translateX(-100%); }
        }
        
        /* Pause animation on hover */
        .ticker-content:hover {
            animation-play-state: paused;
        }
        
        /* When few coins, center without animation */
        .ticker-content.center-static {
            animation: none;
            transform: none;
            justify-content: center;
            width: 100%;
        }
        
        .ticker-actions {
            display: none;
        }
        
        .ticker-btn {
            display: none;
        }
        
        .ticker-btn:hover {
            display: none;
        }
        
        .ticker-btn i {
            display: none;
        }
        
        /* Ticker Item Styles */
        .crypto-overlay-item {
            display: flex;
            align-items: center;
            gap: 2px;
            white-space: nowrap;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }
        
        .crypto-overlay-item:hover {
            background: var(--bg-primary);
        }
        
        .crypto-overlay-symbol {
            font-weight: 700;
            color: var(--text-primary);
            min-width: 45px;
            font-size: 14px;
            flex-shrink: 0;
        }
        
        .crypto-overlay-price {
            font-weight: 500;
            color: var(--text-primary);
            min-width: 60px;
            font-size: 11px;
            flex-shrink: 0;
        }
        
        .crypto-overlay-change {
            font-size: 10px;
            font-weight: 500;
            min-width: 40px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .crypto-overlay-change.positive {
            color: #15803d;
        }
        
        .crypto-overlay-change.negative {
            color: #dc2626;
        }
        
        /* Adjust body padding for ticker */
        body {
            padding-top: 120px; /* 40px ticker + 80px navbar */
        }
        

        .crypto-overlay-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm);
            border-bottom: 1px solid var(--border-primary);
            background: var(--bg-secondary);
        }

        .crypto-header-buttons {
            display: flex;
            gap: var(--spacing-xs);
        }

        .crypto-settings-btn, .crypto-toggle-btn {
            background: none;
            border: 1px solid transparent;
            cursor: pointer;
            padding: var(--spacing-xs);
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .crypto-overlay-title {
            font-weight: 600;
            font-size: var(--font-size-xs);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-primary);
        }

        .crypto-settings-btn:hover, .crypto-toggle-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }


        .crypto-overlay-content {
            padding: var(--spacing-sm);
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .crypto-overlay.collapsed .crypto-overlay-content {
            max-height: 0;
            padding: 0 var(--spacing-sm);
        }

        .crypto-overlay.collapsed .crypto-toggle-btn i {
            transform: rotate(-90deg);
        }

        .crypto-overlay-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border-primary);
            position: relative;
        }

        .crypto-overlay-item:last-child {
            border-bottom: none;
        }

        .crypto-overlay-left {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .crypto-mini-chart {
            width: 40px;
            height: 20px;
            cursor: pointer;
        }

        .crypto-overlay-symbol {
            font-weight: 600;
            font-size: var(--font-size-xs);
            color: var(--text-primary);
            min-width: 35px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .crypto-overlay-data {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: var(--spacing-xs);
        }

        .crypto-overlay-price {
            font-weight: 600;
            font-size: var(--font-size-sm);
            color: var(--text-primary);
            font-family: inherit;
        }

        .crypto-overlay-change {
            font-size: var(--font-size-xs);
            font-weight: 500;
            font-family: inherit;
        }

        .crypto-overlay-change.positive {
            color: #22c55e;
        }

        .crypto-overlay-change.negative {
            color: #ef4444;
        }

        .crypto-overlay-change.neutral {
            color: var(--text-secondary);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .crypto-overlay {
                top: 80px;
                right: 10px;
                min-width: 160px;
                font-size: 0.7rem;
            }

            .crypto-overlay-header {
                padding: 0.4rem 0.6rem;
            }

            .crypto-overlay-content {
                padding: 0.4rem;
            }

            .crypto-overlay-item {
                padding: 0.3rem 0;
            }
        }

        @media (max-width: 480px) {
            .crypto-overlay {
                min-width: 140px;
                font-size: 0.65rem;
            }
        }

        /* Chart Styles */
        .crypto-chart-container {
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            margin-bottom: 0.5rem;
        }

        .crypto-chart-controls {
            display: flex;
            justify-content: center;
            margin-top: 0.5rem;
        }

        .crypto-chart-select {
            background: rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            padding: 0.2rem 0.4rem;
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        /* Settings Panel */
        .crypto-settings-panel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            z-index: 20; /* Higher than overlay content */
        }

        .crypto-settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm);
            border-bottom: 1px solid var(--border-primary);
            background: var(--bg-secondary);
            font-weight: 600;
            font-size: var(--font-size-xs);
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .crypto-settings-close {
            background: none;
            border: 1px solid transparent;
            cursor: pointer;
            padding: var(--spacing-xs);
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .crypto-settings-close:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .crypto-search {
            padding: var(--spacing-sm);
            border-bottom: 1px solid var(--border-primary);
        }

        .crypto-search input {
            width: 100%;
            padding: var(--spacing-sm);
            border: 1px solid var(--border-secondary);
            font-size: var(--font-size-xs);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: inherit;
        }

        .crypto-search input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .crypto-search input::placeholder {
            color: var(--text-muted);
        }

        .crypto-available-coins {
            padding: var(--spacing-sm);
            max-height: 200px;
            overflow-y: auto;
        }

        .crypto-coin-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-sm);
            gap: var(--spacing-sm);
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .crypto-coin-option:hover {
            border-color: var(--border-secondary);
            background: var(--bg-secondary);
        }

        .crypto-coin-option.added {
            border-color: #22c55e;
            background: var(--bg-secondary);
        }
        
        /* === SETTINGS CRYPTO MANAGEMENT === */
        .crypto-management {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .crypto-search-container input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-primary);
            font-size: var(--font-size-sm);
            border-radius: 4px;
        }
        
        .crypto-search-container input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        
        .crypto-coins-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 0.75rem;
            max-height: 400px;
            overflow-y: auto;
            padding: 0.5rem 0;
        }
        
        .settings-crypto-coin {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border: 1px solid var(--border-primary);
            background: var(--bg-secondary);
            transition: all 0.2s ease;
        }
        
        .settings-crypto-coin:hover {
            border-color: var(--accent-primary);
        }
        
        .settings-crypto-coin.active {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.05);
        }
        
        .settings-crypto-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
        }
        
        .settings-crypto-symbol {
            font-weight: 600;
            font-size: var(--font-size-sm);
            color: var(--text-primary);
            min-width: 60px;
            text-transform: uppercase;
        }
        
        .settings-crypto-price {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
            flex: 1;
        }
        
        .settings-crypto-toggle {
            background: transparent;
            border: 1px solid var(--border-primary);
            padding: 0.4rem 0.8rem;
            font-size: var(--font-size-xs);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .settings-crypto-toggle:hover {
            border-color: var(--accent-primary);
            background: var(--bg-primary);
        }
        
        .settings-crypto-toggle.active {
            background: #22c55e;
            border-color: #22c55e;
            color: white;
        }

        .crypto-coin-info {
            flex: 1;
        }

        .crypto-coin-name {
            font-size: var(--font-size-xs);
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .crypto-coin-price {
            font-size: var(--font-size-xs);
            color: var(--text-secondary);
            margin-top: 0.1rem;
        }

        .crypto-add-btn {
            background: none;
            color: var(--text-primary);
            border: 1px solid var(--border-secondary);
            padding: var(--spacing-xs) var(--spacing-sm);
            font-size: var(--font-size-xs);
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .crypto-add-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .crypto-add-btn.added {
            border-color: #ef4444;
            color: #ef4444;
        }

        .crypto-add-btn.added:hover {
            border-color: #dc2626;
            color: #dc2626;
        }
    </style>
</head>
<body>
    <!-- === CRYPTO TICKER BAR === -->
    <div id="crypto-overlay" class="crypto-ticker-bar">
        <div class="ticker-container">
            <div class="ticker-content" id="crypto-overlay-items">
                <!-- Coins will be dynamically inserted here by JavaScript -->
            </div>
        </div>
    </div>

    <!-- === ADD TODO MODAL === -->
    <div id="add-todo-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Todo hinzufügen</h2>
            </div>
            
            <form id="add-todo-form" autocomplete="off">
                <div class="form-group">
                    <label for="todo-title">Aufgabe</label>
                    <input type="text" id="todo-title" name="todo-title" placeholder="Was möchtest du erledigen?" required autocomplete="off">
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="todo-category">Kategorie</label>
                        <select id="todo-category" name="todo-category" required autocomplete="off">
                            <option value="">Kategorie wählen</option>
                            <option value="privat">Privat</option>
                            <option value="uni">Uni</option>
                            <option value="arbeit">Arbeit</option>
                            <option value="projekte">Projekte</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="todo-priority">Priorität</label>
                        <select id="todo-priority" name="todo-priority" required autocomplete="off">
                            <option value="mittel" selected>Normal</option>
                            <option value="wichtig">Wichtig</option>
                            <option value="dringend">Dringend</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="todo-deadline">Deadline (optional)</label>
                        <input type="date" id="todo-deadline" name="todo-deadline" autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="todo-time">Uhrzeit (optional)</label>
                        <input type="time" id="todo-time" name="todo-time" value="21:00" autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-todo-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Todo erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD GOAL MODAL === -->
    <div id="add-goal-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Ziel hinzufügen</h2>
            </div>
            
            <form id="add-goal-form" autocomplete="off">
                <div class="form-group">
                    <label for="goal-name">Ziel-Name</label>
                    <input type="text" id="goal-name" name="goal-name" placeholder="Was möchtest du erreichen?" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="goal-description">Beschreibung</label>
                    <textarea id="goal-description" placeholder="Detaillierte Beschreibung des Ziels..." rows="3" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-category">Kategorie</label>
                        <input type="text" id="goal-category" placeholder="z.B. Fitness, Karriere, Finanzen..." required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-deadline">Deadline</label>
                        <input type="date" id="goal-deadline" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-start-value">Startwert mit Einheit</label>
                        <input type="text" id="goal-start-value" placeholder="z.B. 80kg, 1000€, 0 Bücher..." autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-target-value">Zielwert mit Einheit</label>
                        <input type="text" id="goal-target-value" placeholder="z.B. 70kg, 5000€, 12 Bücher..." required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-goal-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Ziel erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD JOURNAL MODAL === -->
    <div id="add-journal-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Journal Eintrag hinzufügen</h2>
            </div>
            
            <form id="add-journal-form" autocomplete="off">
                <div class="form-group">
                    <label for="journal-title">Titel</label>
                    <input type="text" id="journal-title" placeholder="Titel für den Eintrag..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="journal-content">Inhalt</label>
                    <textarea id="journal-content" placeholder="Was beschäftigt dich heute...?" rows="6" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="journal-tags">Tags (kommagetrennt):</label>
                    <input type="text" id="journal-tags" placeholder="z.B. persönlich, reflektion, arbeit">
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-journal-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Journal erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD TERMIN MODAL === -->
    <div id="add-termin-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Termin hinzufügen</h2>
            </div>
            
            <form id="add-termin-form" autocomplete="off">
                <div class="form-group">
                    <label for="termin-title">Titel</label>
                    <input type="text" id="termin-title" placeholder="z.B. Zahnarzt Termin..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="termin-description">Beschreibung</label>
                    <textarea id="termin-description" placeholder="Weitere Details zum Termin..." rows="3" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="termin-date">Datum</label>
                        <input type="date" id="termin-date" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="termin-time">Uhrzeit (optional)</label>
                        <input type="time" id="termin-time" autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-termin-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Termin erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === EDIT GOAL VALUE MODAL === -->
    <div id="edit-goal-value-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2 id="edit-goal-modal-title">Fortschritt aktualisieren</h2>
            </div>
            
            <div id="edit-goal-current-status" style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; font-size: 0.9rem; color: #666;">
                <!-- Current goal status will be inserted here -->
            </div>
            
            <form id="edit-goal-value-form" autocomplete="off">
                <div class="form-group">
                    <label for="new-goal-value">Neuer aktueller Wert</label>
                    <input type="number" id="new-goal-value" name="new-goal-value" step="0.01" required autocomplete="off" style="font-size: 1.1rem; padding: 0.75rem;">
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-edit-goal-value-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Wert aktualisieren</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === AUTH SCREEN === -->
    <div id="auth-screen" class="auth-screen hide">
        <div class="auth-container">
            <div class="auth-header">
                <h2>DASHBOARD</h2>
            </div>
            
            <div class="form-group">
                <label for="login-email">Email</label>
                <input type="email" id="login-email" name="email" placeholder="your@email.com" required autocomplete="email">
            </div>
            <div class="form-group">
                <label for="login-password">Password</label>
                <input type="password" id="login-password" name="password" placeholder="Your password" required autocomplete="current-password">
            </div>
            <button id="login-btn" class="auth-btn">Login</button>
            <div id="login-error" class="auth-error"></div>
        </div>
    </div>

    <!-- === STICKY NAVIGATION === -->
    <nav class="sticky-nav">
        <div class="nav-container">
            <button class="nav-tab active" data-tab="tab-home">Home</button>
            <button class="nav-tab" data-tab="tab-todos">ToDos</button>
            <button class="nav-tab" data-tab="tab-ziele">Ziele</button>
            <button class="nav-tab" data-tab="tab-journal">Journal</button>
            <button class="nav-tab" data-tab="tab-trading">Trading</button>
            <button class="nav-tab" data-tab="tab-analytics">Analytics</button>
            <button class="nav-tab" data-tab="tab-ressourcen">Ressourcen</button>
            <button class="nav-tab" data-tab="tab-wiki">Wiki</button>
            <div class="nav-actions">
                <!-- Settings and Logout moved to Quick Actions Bar -->
            </div>
        </div>
    </nav>

    <div class="main-content">
        <!-- === HOME TAB === -->
        <section id="tab-home" class="tab-section active">
            <!-- Streak Kacheln -->
            <section class="streak-overview" style="margin-bottom: 4rem;">
                <div class="streak-grid">
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Morgenroutine</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Abendroutine</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Todos Erledigt</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0.00</div>
                        <div class="streak-label">SOL Balance</div>
                        <div class="streak-date">Live</div>
                    </div>
                </div>
            </section>

            <!-- Routinen Section -->
            <div class="routine-grid" style="margin-bottom: 4rem;">
                <div id="morning-routine" class="routine-section">
                    <h2>Morgenroutine</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="wasser-kreatin">
                            <label for="wasser-kreatin">Wasser und Kreatin</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="bbue-sport">
                            <label for="bbue-sport">BBÜ und Sport</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="tag-planen">
                            <label for="tag-planen">Tag planen</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="todos-checken">
                            <label for="todos-checken">Todos checken</label>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <div id="evening-routine" class="routine-section">
                    <h2>Abendroutine</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="journal-reflexion">
                            <label for="journal-reflexion">Tag reflektieren per Journal</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="lesen-lessons">
                            <label for="lesen-lessons">Lesen und Lessons nachhalten</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="trades-evaluieren">
                            <label for="trades-evaluieren">Trades evaluieren und Lessons nachhalten</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="naechsten-tag-planen">
                            <label for="naechsten-tag-planen">Nächsten Tag planen</label>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Heutige Aufgaben -->
            <section class="card" style="margin-bottom: 4rem;">
                <h2 style="font-size: 1.2rem; font-weight: 500; margin-bottom: 1.5rem; text-transform: uppercase; letter-spacing: 0.1em;">Heutige Aufgaben</h2>
                <div class="checkbox-group" id="home-todos">
                    <!-- Todos will be loaded from database -->
                </div>
            </section>

            <!-- Anstehende Termine -->
            <section style="margin-bottom: 4rem;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 2rem; margin-bottom: 1.5rem;">
                    <h2 style="font-size: 1.2rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.1em; margin: 0;">Anstehende Termine</h2>
                    <button id="add-termin-btn" class="btn" style="font-size: 0.7rem; padding: 0.5rem 1rem;">Add New</button>
                </div>
                <div class="grid-3" id="termine-container">
                    <!-- Termine will be loaded from TerminManager -->
                </div>
            </section>

            <!-- Motivational Quote Widget -->
            <section class="quote-widget">
                <div class="quote-container">
                    <div class="quote-icon">
                        <i data-lucide="quote" style="width: 20px; height: 20px;"></i>
                    </div>
                    <div class="quote-content">
                        <div class="quote-text" id="daily-quote">
                            "The way to get started is to quit talking and begin doing."
                        </div>
                        <div class="quote-author" id="quote-author">Walt Disney</div>
                    </div>
                    <button class="quote-refresh-btn" id="refresh-quote-btn" title="New Quote">
                        <i data-lucide="refresh-cw" style="width: 14px; height: 14px;"></i>
                    </button>
                </div>
            </section>
        </section>

        <!-- === TODOS TAB === -->
        <section id="tab-todos" class="tab-section">

            <div class="todos-grid">
                <!-- PRIVAT BLOCK -->
                <div class="todo-block">
                    <div class="todo-block-header">
                        <h3>
                            <i data-lucide="home" style="width: 18px; height: 18px;"></i>
                            Privat
                        </h3>
                        <button class="add-to-category-btn" data-category="privat" title="Add to Privat">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <div class="todo-links" id="todo-privat">
                        <div class="todo-empty-state">
                            <p>Personal</p>
                            <small>Focus on what matters most</small>
                        </div>
                        <!-- Private todos will be loaded here -->
                    </div>
                </div>

                <!-- UNI BLOCK -->
                <div class="todo-block">
                    <div class="todo-block-header">
                        <h3>
                            <i data-lucide="graduation-cap" style="width: 18px; height: 18px;"></i>
                            Uni
                        </h3>
                        <button class="add-to-category-btn" data-category="uni" title="Add to Uni">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <div class="todo-links" id="todo-uni">
                        <div class="todo-empty-state">
                            <p>Education</p>
                            <small>Build your future</small>
                        </div>
                        <!-- Uni todos will be loaded here -->
                    </div>
                </div>

                <!-- ARBEIT BLOCK -->
                <div class="todo-block">
                    <div class="todo-block-header">
                        <h3>
                            <i data-lucide="briefcase" style="width: 18px; height: 18px;"></i>
                            Arbeit
                        </h3>
                        <button class="add-to-category-btn" data-category="arbeit" title="Add to Arbeit">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <div class="todo-links" id="todo-arbeit">
                        <div class="todo-empty-state">
                            <p>Professional</p>
                            <small>Execute with precision</small>
                        </div>
                        <!-- Work todos will be loaded here -->
                    </div>
                </div>

                <!-- PROJEKTE BLOCK -->
                <div class="todo-block">
                    <div class="todo-block-header">
                        <h3>
                            <i data-lucide="trending-up" style="width: 18px; height: 18px;"></i>
                            Projekte
                        </h3>
                        <button class="add-to-category-btn" data-category="projekte" title="Add to Projekte">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <div class="todo-links" id="todo-projekte">
                        <div class="todo-empty-state">
                            <p>Projects</p>
                            <small>Transform ideas into reality</small>
                        </div>
                        <!-- Project todos will be loaded here -->
                    </div>
                </div>
            </div>
        </section>

        <!-- === ZIELE TAB === -->
        <section id="tab-ziele" class="tab-section">
            
            <div class="category-tabs">
                <button class="ziel-tab active" data-ziel-category="alle">Alle</button>
                <button class="ziel-tab" data-ziel-category="monat">Monat</button>
                <button class="ziel-tab" data-ziel-category="quartal">Quartal</button>
                <button class="ziel-tab" data-ziel-category="jahr">Jahr</button>
                <button class="ziel-tab" data-ziel-category="archiv">Archiv</button>
                <button id="add-goal-btn" class="btn" style="margin-left: 2rem;">+ Add Goal</button>
                <button id="clear-goal-archive-btn" class="btn secondary" style="margin-left: 1rem; display: none;">🗑️ Archiv leeren</button>
            </div>

            <!-- MONAT KATEGORIE -->
            <div class="ziel-content" id="ziel-monat">
                <!-- Monatsziele will be loaded from database -->
            </div>

            <!-- QUARTAL KATEGORIE -->
            <div class="ziel-content" id="ziel-quartal">
                <!-- Quartalsziele will be loaded from database -->
            </div>

            <!-- JAHR KATEGORIE -->
            <div class="ziel-content" id="ziel-jahr">
                <!-- Jahresziele will be loaded from database -->
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="ziel-content active" id="ziel-alle">
                <!-- All ziele will be loaded from database -->
            </div>

            <!-- ARCHIV KATEGORIE -->
            <div class="ziel-content" id="ziel-archiv">
                <!-- Completed/archived ziele will be loaded from database -->
            </div>

        </section>

        <!-- === JOURNAL TAB === -->
        <section id="tab-journal" class="tab-section">
            <!-- Search and Filter Bar -->
            <div class="wiki-controls">
                <div class="search-container">
                    <input type="text" id="journal-search" placeholder="Search entries and tags..." class="search-input">
                    <button class="search-btn" onclick="JournalManager.search()">
                        <i data-lucide="search" style="width: 16px; height: 16px;"></i>
                    </button>
                </div>
            </div>

            <!-- Journal Content -->
            <div class="wiki-content" id="journal-entries">
                <!-- Journal entries will be loaded here --></div>

        </section>

        <!-- === TRADING TAB === -->
        <section id="tab-trading" class="tab-section">
            
            <!-- Trading Rules Sticky Note -->
            <div class="trading-rules-sticky">
                <div class="sticky-header">
                    <span class="sticky-title">📝 Trading Grundregeln</span>
                    <button class="sticky-minimize" onclick="this.parentElement.parentElement.classList.toggle('minimized'); this.textContent = this.parentElement.parentElement.classList.contains('minimized') ? '+' : '−'" title="Ein-/Ausklappen">−</button>
                </div>
                <div class="sticky-content">
                    <ul class="rules-list">
                        <li>💰 <strong>Risk Management:</strong> Nie mehr als 2-5% pro Trade riskieren</li>
                        <li>🎯 <strong>Take Profit:</strong> Initials raus bei 2x, Rest laufen lassen</li>
                        <li>🛑 <strong>Stop Loss:</strong> Bei -20% aussteigen, keine Emotionen</li>
                        <li>📊 <strong>Research:</strong> Nur Coins traden, die du verstehst</li>
                        <li>⏰ <strong>Timing:</strong> Nicht FOMO - warten auf Setup</li>
                        <li>📝 <strong>Journal:</strong> Jeden Trade dokumentieren und lernen</li>
                    </ul>
                </div>
            </div>

            <!-- Portfolio Overview -->
            <div class="portfolio-overview">
                <div class="portfolio-stats">
                    <div class="portfolio-stat">
                        <div class="stat-number" id="sol-balance">0.00 SOL</div>
                        <div class="stat-label">SOL Balance</div>
                    </div>
                    <div class="portfolio-stat">
                        <div class="stat-number" id="sol-in-trades">0.00 SOL</div>
                        <div class="stat-label">SOL in Open Trades</div>
                    </div>
                    <div class="portfolio-stat">
                        <div class="stat-number" id="total-pnl">+0.00 SOL</div>
                        <div class="stat-label">Total P&L (SOL)</div>
                    </div>
                    <div class="portfolio-stat">
                        <div class="stat-number" id="open-trades">0</div>
                        <div class="stat-label">Open Positions</div>
                    </div>
                    <div class="portfolio-stat">
                        <div class="stat-number" id="win-rate">0%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                    <div class="portfolio-stat">
                        <div class="stat-number" id="total-pnl-usd">+$0.00</div>
                        <div class="stat-label">Total P&L (USD)</div>
                    </div>
                </div>
            </div>

            <!-- Trading Container -->
            <div class="trading-container">
                <div class="section-header">
                    <h3 id="trading-section-title">Open Positions</h3>
                    <div class="section-actions">
                        <button id="add-trade-btn" class="trade-action-btn">
                            <i data-lucide="plus" style="width: 18px; height: 18px;"></i>
                        </button>
                        <button id="refresh-prices-btn" class="trade-action-btn">
                            <i data-lucide="refresh-cw" style="width: 18px; height: 18px;"></i>
                        </button>
                        <button id="lock-btn" class="trade-action-btn">
                            <i data-lucide="lock" style="width: 18px; height: 18px;"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Open Trades View -->
                <div id="open-trades-view" class="trades-view">
                    <div class="trades-table" id="open-trades-list">
                        <div class="empty-trades">No open trades yet</div>
                    </div>
                </div>

                <!-- Closed Trades View -->
                <div id="closed-trades-view" class="trades-view" style="display: none;">
                    <div class="trades-table" id="closed-trades-list">
                        <div class="empty-trades">No closed trades yet</div>
                    </div>
                </div>
            </div>

        </section>

        <!-- === CLOSE TRADE MODAL === -->
        <div id="close-trade-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Close Trade</h3>
                    <button class="modal-close" id="close-trade-modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="trade-info">
                        <div class="info-row">
                            <span class="info-label">Token:</span>
                            <span class="info-value" id="close-trade-token">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Entry Amount:</span>
                            <span class="info-value" id="close-trade-entry-amount">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Entry McAP:</span>
                            <span class="info-value" id="close-trade-entry-mcap">-</span>
                        </div>
                    </div>
                    
                    <div class="close-trade-form">
                        <div class="form-group">
                            <label for="close-exit-mcap">Exit Market Cap</label>
                            <div class="mcap-input-group">
                                <input type="number" id="close-exit-mcap" placeholder="2.5" step="0.1" autocomplete="off">
                                <div class="mcap-buttons">
                                    <button type="button" class="mcap-btn" data-multiplier="K">K</button>
                                    <button type="button" class="mcap-btn" data-multiplier="M">M</button>
                                    <button type="button" class="mcap-btn active" data-multiplier="B">B</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="close-take-profit">SOL zu verkaufen</label>
                            <div class="sol-input-group">
                                <input type="number" id="close-take-profit" placeholder="2.0" step="0.001" autocomplete="off">
                                <div class="sol-sell-buttons">
                                    <button type="button" class="sol-percent-btn" data-percent="initials">Initials</button>
                                    <button type="button" class="sol-percent-btn" data-percent="25">25%</button>
                                    <button type="button" class="sol-percent-btn" data-percent="50">50%</button>
                                    <button type="button" class="sol-percent-btn" data-percent="75">75%</button>
                                    <button type="button" class="sol-percent-btn" data-percent="100">100%</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="close-keep-position">SOL verbleibend</label>
                            <input type="number" id="close-keep-position" placeholder="2.0" step="0.001" autocomplete="off" readonly style="background: #f8f9fa;">
                        </div>
                        
                        <div class="form-group">
                            <label for="close-trade-learnings">Learnings & Notes</label>
                            <textarea id="close-trade-learnings" placeholder="Was hast du gelernt? Warum hast du geschlossen? Fehler, Erfolge, Strategien..." rows="4" autocomplete="off" style="width: 100%; padding: 0.75rem; border: 1px solid #e0e0e0; border-radius: 4px; font-family: inherit; resize: vertical; min-height: 100px;"></textarea>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn secondary" id="close-trade-cancel">Cancel</button>
                    <button class="btn" id="close-trade-confirm">Close Trade</button>
                </div>
            </div>
        </div>

        <!-- === ADD TRADE MODAL === -->
        <div id="add-trade-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Add New Trade</h2>
                    <button class="modal-close" id="add-trade-modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="trade-form">
                        <div class="form-row">
                            <div class="form-group">
                                <label for="modal-trade-token">Token</label>
                                <input type="text" id="modal-trade-token" placeholder="BONK" autocomplete="off">
                            </div>
                            <div class="form-group">
                                <label for="modal-trade-sol-amount">SOL</label>
                                <input type="number" id="modal-trade-sol-amount" placeholder="0.5" step="0.001" autocomplete="off">
                            </div>
                            <div class="form-group">
                                <label for="modal-trade-mcap">Market Cap</label>
                                <input type="text" id="modal-trade-mcap" placeholder="2.1M" autocomplete="off">
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="modal-trade-notes">Notes</label>
                            <textarea id="modal-trade-notes" placeholder="e.g., Strong community, upcoming catalyst, technical breakout, stop loss, take profit..." rows="3" autocomplete="off"></textarea>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn secondary" id="add-trade-cancel">Cancel</button>
                    <button class="btn" id="add-trade-confirm">Add Trade</button>
                </div>
            </div>
        </div>

        <!-- === VIEW TRADE DETAILS MODAL === -->
        <div id="view-trade-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Trade Details</h3>
                    <button class="modal-close" id="view-trade-modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="trade-details-info">
                        <div class="details-section">
                            <h4>Trade Information</h4>
                            <div class="info-grid">
                                <div class="info-row">
                                    <span class="info-label">Token:</span>
                                    <span class="info-value" id="detail-token">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">SOL Amount:</span>
                                    <span class="info-value" id="detail-sol-amount">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Entry McAP:</span>
                                    <span class="info-value" id="detail-entry-mcap">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Exit McAP:</span>
                                    <span class="info-value" id="detail-exit-mcap">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Final P&L:</span>
                                    <span class="info-value" id="detail-pnl">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Entry Date:</span>
                                    <span class="info-value" id="detail-entry-date">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Exit Date:</span>
                                    <span class="info-value" id="detail-exit-date">-</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="details-section">
                            <h4>Entry Notes</h4>
                            <div class="notes-content" id="detail-entry-notes">-</div>
                        </div>
                        
                        <div class="details-section">
                            <h4>Close Learnings</h4>
                            <div class="learnings-content" id="detail-close-learnings">-</div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn secondary" id="close-details-modal">Close</button>
                </div>
            </div>
        </div>

        <!-- === ANALYTICS TAB === -->
        <section id="tab-analytics" class="tab-section">
            <div class="analytics-container">
                
                <!-- Analytics Charts Grid -->
                <div class="analytics-charts-grid">
                    <!-- SOL Balance Chart -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>SOL Balance History</h3>
                            <div class="chart-controls">
                                <div class="time-period-buttons">
                                    <button class="period-btn active" data-period="week">Woche</button>
                                    <button class="period-btn" data-period="month">Monat</button>
                                    <button class="period-btn" data-period="quarter">Quartal</button>
                                    <button class="period-btn" data-period="year">Jahr</button>
                                </div>
                                <div class="chart-info">
                                    <span id="current-sol-balance">Loading...</span>
                                </div>
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="solBalanceChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Todo Heatmap -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>Todo Activity</h3>
                            <div class="heatmap-info">
                                <span id="heatmap-stats">Loading...</span>
                            </div>
                        </div>
                        <div class="heatmap-container">
                            <div class="heatmap-months" id="heatmap-months"></div>
                            <div class="heatmap-grid" id="heatmap-grid"></div>
                            <div class="heatmap-legend">
                                <span>Less</span>
                                <div class="legend-colors">
                                    <div class="legend-square level-0" title="0 todos"></div>
                                    <div class="legend-square level-1" title="1-2 todos"></div>
                                    <div class="legend-square level-2" title="3-5 todos"></div>
                                    <div class="legend-square level-3" title="6-10 todos"></div>
                                    <div class="legend-square level-4" title="11+ todos"></div>
                                </div>
                                <span>More</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Performance Heatmap -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>Daily Performance</h3>
                            <div class="heatmap-info">
                                <span id="performance-heatmap-stats">Loading...</span>
                            </div>
                        </div>
                        <div class="heatmap-container">
                            <div class="heatmap-months" id="performance-heatmap-months"></div>
                            <div class="heatmap-grid" id="performance-heatmap-grid"></div>
                            <div class="heatmap-legend">
                                <span>Loss</span>
                                <div class="legend-colors">
                                    <div class="legend-square performance-loss" title="Loss vs previous day"></div>
                                    <div class="legend-square performance-neutral" title="Same as previous day"></div>
                                    <div class="legend-square performance-gain" title="Gain vs previous day"></div>
                                </div>
                                <span>Gain</span>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </section>

        <!-- === RESSOURCEN TAB === -->
        <section id="tab-ressourcen" class="tab-section">

            <div class="resources-grid">
                <!-- PRIVAT BLOCK -->
                <div class="resource-block">
                    <div class="resource-block-header">
                        <h3>
                            <i data-lucide="home" style="width: 18px; height: 18px;"></i>
                            Privat
                        </h3>
                        <button class="add-to-category-btn" data-category="privat" title="Add to Privat">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <div class="resource-links" id="resource-privat">
                        <!-- Private resources will be loaded here -->
                    </div>
                </div>

                <!-- CRYPTO BLOCK -->
                <div class="resource-block">
                    <div class="resource-block-header">
                        <h3>
                            <i data-lucide="trending-up" style="width: 18px; height: 18px;"></i>
                            Crypto
                        </h3>
                        <button class="add-to-category-btn" data-category="crypto" title="Add to Crypto">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <div class="resource-links" id="resource-crypto">
                        <!-- Crypto resources will be loaded here -->
                    </div>
                </div>

                <!-- ARBEIT BLOCK -->
                <div class="resource-block">
                    <div class="resource-block-header">
                        <h3>
                            <i data-lucide="briefcase" style="width: 18px; height: 18px;"></i>
                            Arbeit
                        </h3>
                        <button class="add-to-category-btn" data-category="arbeit" title="Add to Arbeit">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <div class="resource-links" id="resource-arbeit">
                        <!-- Work resources will be loaded here -->
                    </div>
                </div>

                <!-- STUDIUM BLOCK -->
                <div class="resource-block">
                    <div class="resource-block-header">
                        <h3>
                            <i data-lucide="book-open" style="width: 18px; height: 18px;"></i>
                            Studium
                        </h3>
                        <button class="add-to-category-btn" data-category="uni" title="Add to Studium">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <div class="resource-links" id="resource-uni">
                        <!-- University resources will be loaded here -->
                    </div>
                </div>
            </div> <!-- end resources-grid -->

            <!-- QUICK NOTES SECTION -->
            <div class="quicknotes-section">
                <div class="quicknotes-header">
                    <h3>Quick Notes</h3>
                </div>
                <div class="quicknotes-content">
                    <textarea id="quicknotes-textarea" placeholder="Notizen hier eingeben..."></textarea>
                </div>
            </div>

        </section>

        <!-- === SMART QUICK ACTIONS BAR === -->
        <div class="quick-actions-bar collapsed" id="quick-actions-bar">
            <!-- Toggle Button - Always visible -->
            <button class="quick-action-btn toggle-btn" data-tooltip="Quick Actions" onclick="QuickActions.toggle()" id="quick-actions-toggle">
                <i data-lucide="zap"></i>
            </button>
            
            <!-- Action Buttons - Hidden when collapsed -->
            <div class="action-buttons" id="action-buttons">
                <button class="quick-action-btn" data-tooltip="Quick Add Todo" onclick="QuickActions.addTodo()">
                    <i data-lucide="plus"></i>
                </button>
                
                <button id="timer-quick-btn" class="quick-action-btn" data-tooltip="25 Min Timer | Right-click: Reset" onclick="QuickActions.toggleTimer()" oncontextmenu="QuickActions.resetTimer(); return false;">
                    <i data-lucide="play"></i>
                </button>
                
                <button class="quick-action-btn" data-tooltip="Add Journal Entry" onclick="QuickActions.addJournalEntry()">
                    <i data-lucide="book-open"></i>
                </button>
                
                <button class="quick-action-btn" data-tooltip="Add Wiki Entry" onclick="QuickActions.addWikiEntry()">
                    <i data-lucide="file-text"></i>
                </button>
                
                <button class="quick-action-btn" data-tooltip="Add Trade" onclick="QuickActions.addTrade()">
                    <i data-lucide="trending-up"></i>
                </button>
                
                <button class="quick-action-btn" data-tooltip="Settings" onclick="QuickActions.openSettings()">
                    <i data-lucide="settings"></i>
                </button>
                
                <button class="quick-action-btn" data-tooltip="Logout" onclick="QuickActions.logout()">
                    <i data-lucide="log-out"></i>
                </button>
            </div>
        </div>

        <!-- === SETTINGS TAB === -->
        <section id="tab-settings" class="tab-section">
            
            <div class="settings-container">
                <div class="setting-group">
                    <h3>Routinen</h3>
                    <div class="setting-item">
                        <label for="routine-reset-time">Routine Reset Zeit:</label>
                        <input type="time" id="routine-reset-time" value="06:00">
                        <span class="setting-description">Zeit, zu der die Routinen täglich zurückgesetzt werden</span>
                    </div>
                    <button id="save-routine-settings" class="btn">Speichern</button>
                </div>
                
                <div class="setting-group">
                    <h3>Analytics</h3>
                    <div class="setting-item">
                        <label for="balance-tracking-time">SOL Balance Tracking Zeit:</label>
                        <input type="time" id="balance-tracking-time" value="06:00">
                        <span class="setting-description">Zeit, zu der täglich die SOL Balance für den Chart aufgezeichnet wird</span>
                    </div>
                    <button id="save-analytics-settings" class="btn">Speichern</button>
                </div>
                
                <div class="setting-group">
                    <h3>Kryptowährung Ticker</h3>
                    <div class="setting-item">
                        <div class="crypto-management">
                            <div class="crypto-search-container">
                                <input type="text" id="settings-crypto-search" placeholder="Coin suchen..." autocomplete="off">
                            </div>
                            <div class="crypto-coins-grid" id="settings-crypto-coins">
                                <!-- Will be populated with coins -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- === WIKI TAB === -->
        <section id="tab-wiki" class="tab-section">
            <!-- Search and Filter Bar -->
            <div class="wiki-controls">
                <div class="search-container">
                    <input type="text" id="wiki-search" placeholder="Search entries and tags..." class="search-input">
                    <button class="search-btn" onclick="Wiki.search()">
                        <i data-lucide="search" style="width: 16px; height: 16px;"></i>
                    </button>
                </div>
            </div>

            <!-- Wiki Content -->
            <div class="wiki-content" id="wiki-entries">
                <!-- Wiki entries will be loaded here -->
            </div>
        </section>

    </div>

    <!-- Add Resource Modal -->
    <div id="add-resource-modal" class="modal hide">
        <div class="modal-content">
            <span class="close" onclick="ResourceManager.hideAddResourceModal()">&times;</span>
            <h2>Add Resource</h2>
            <form id="add-resource-form">
                <div class="form-group">
                    <label for="resource-title">Title *</label>
                    <input type="text" id="resource-title" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="resource-category">Category *</label>
                    <select id="resource-category" required autocomplete="off">
                        <option value="">Choose category...</option>
                        <option value="Privat">Privat</option>
                        <option value="Arbeit">Arbeit</option>
                        <option value="Uni">Uni</option>
                        <option value="Crypto">Crypto</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="resource-url">URL *</label>
                    <input type="url" id="resource-url" placeholder="https://example.com" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="resource-icon">Icon (optional)</label>
                    <input type="text" id="resource-icon" placeholder="Click icon below or type lucide icon name" readonly>
                    <div class="icon-palette">
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('mail')"><i data-lucide="mail" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('briefcase')"><i data-lucide="briefcase" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('book')"><i data-lucide="book" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('home')"><i data-lucide="home" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('message-circle')"><i data-lucide="message-circle" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('building')"><i data-lucide="building" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('wrench')"><i data-lucide="wrench" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('bar-chart-3')"><i data-lucide="bar-chart-3" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('file-text')"><i data-lucide="file-text" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('users')"><i data-lucide="users" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('globe')"><i data-lucide="globe" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('dollar-sign')"><i data-lucide="dollar-sign" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('target')"><i data-lucide="target" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('zap')"><i data-lucide="zap" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('lock')"><i data-lucide="lock" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('link')"><i data-lucide="link" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('rocket')"><i data-lucide="rocket" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('palette')"><i data-lucide="palette" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('activity')"><i data-lucide="activity" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('bot')"><i data-lucide="bot" style="width: 16px; height: 16px;"></i></button>
                    </div>
                    <small style="margin-top: 0.5rem; display: block;">Click an icon above or make input editable to type manually</small>
                    <button type="button" class="btn-link" onclick="ResourceManager.toggleIconInput()" style="font-size: 0.8rem; margin-top: 0.25rem;">Enable manual typing</button>
                </div>
                
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="ResourceManager.hideAddResourceModal()">Cancel</button>
                    <button type="submit" class="btn">Add Resource</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Add Wiki Entry Modal -->
    <div id="add-wiki-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Wiki Entry hinzufügen</h2>
            </div>
            <form id="add-wiki-form" autocomplete="off">
                <div class="form-group">
                    <label for="wiki-title">Titel</label>
                    <input type="text" id="wiki-title" placeholder="Titel für den Eintrag..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="wiki-content">Inhalt</label>
                    <textarea id="wiki-content" placeholder="Beschreibung, Regeln oder Learnings..." rows="6" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="wiki-tags">Tags (kommagetrennt):</label>
                    <input type="text" id="wiki-tags" placeholder="z.B. crypto, trading, analyse">
                </div>
                
                
                
                <div class="form-actions">
                    <button type="button" id="cancel-wiki-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Wiki Eintrag erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Scripts -->
    <script src="supabase-config.js"></script>
    <script src="cloud-storage.js"></script>
    <script src="simple-counters.js"></script>
    <script src="simple-routine-system.js"></script>
    <script>
        // Debug: Check if basic JavaScript works
        console.log('🔧 JavaScript loading started...');
        
        window.addEventListener('error', function(e) {
            console.error('❌ JavaScript Error:', e.error);
            alert('JavaScript Error: ' + e.message + ' at line ' + e.lineno);
        });
        
        // === AUTHENTICATION ===
        const Auth = {
            isAuthenticated: false,
            currentUser: null,
            
            async init() {
                window.Auth = this;
                
                if (!supabase) {
                    console.log('⚠️ Demo mode - no authentication');
                    await this.showDashboard();
                    return;
                }
                
                this.currentUser = supabase.getCurrentUser();
                if (supabase.isAuthenticated()) {
                    console.log('✅ User authenticated successfully');
                    this.isAuthenticated = true;
                    await this.showDashboard();
                } else {
                    this.showAuthScreen();
                }
                
                this.setupEventListeners();
            },
            
            setupEventListeners() {
                const loginBtn = document.getElementById('login-btn');
                const logoutBtn = document.getElementById('logout-btn');
                
                if (loginBtn) {
                    loginBtn.addEventListener('click', () => this.handleLogin());
                }
                
                if (logoutBtn) {
                    logoutBtn.addEventListener('click', () => this.handleLogout());
                }
            },
            
            async handleLogin() {
                const email = document.getElementById('login-email').value;
                const password = document.getElementById('login-password').value;
                const errorEl = document.getElementById('login-error');
                
                if (!email || !password) {
                    this.showError('Please enter email and password');
                    return;
                }
                
                try {
                    const { user, error } = await supabase.signIn(email, password);
                    
                    if (error) {
                        this.showError(error);
                        return;
                    }
                    
                    if (user) {
                        this.currentUser = user;
                        this.isAuthenticated = true;
                        await this.showDashboard();
                    }
                } catch (error) {
                    this.showError(error.message);
                }
            },
            
            async handleLogout() {
                console.log('🚪 Logout clicked');
                try {
                    if (supabase && typeof supabase.signOut === 'function') {
                        await supabase.signOut();
                    }
                    // Only clear auth-related data, preserve routine/todo data
                    localStorage.removeItem('supabase.auth.token');
                    sessionStorage.clear();
                    console.log('✅ Logout successful, redirecting to login...');
                    
                    // Clear URL hash and redirect to clean login page
                    window.history.replaceState(null, null, window.location.pathname);
                    window.location.reload();
                } catch (error) {
                    console.error('❌ Logout error:', error);
                    // Only clear auth-related data, preserve user data
                    localStorage.removeItem('supabase.auth.token');
                    sessionStorage.clear();
                    window.location.reload();
                }
            },
            
            showError(message) {
                const errorEl = document.getElementById('login-error');
                if (errorEl) {
                    errorEl.textContent = message;
                    errorEl.classList.add('show');
                    setTimeout(() => errorEl.classList.remove('show'), 5000);
                }
            },
            
            showAuthScreen() {
                document.getElementById('auth-screen').classList.remove('hide');
                document.getElementById('crypto-overlay').style.display = 'none';
            },
            
            async refreshRoutineUI() {
                // Simple refresh for routine UI without retries
                console.log('🔄 Refreshing routine UI...');
                
                try {
                    // Note: Counter updates now handled by SimpleCounters
                    
                    // Dispatch update event for routine elements
                    const routineSections = document.querySelectorAll('.routine-item, .habit-item');
                    if (routineSections.length > 0) {
                        routineSections.forEach(section => {
                            const event = new Event('routineUpdate', { bubbles: true });
                            section.dispatchEvent(event);
                        });
                    }
                    
                    console.log('✅ Routine UI refreshed');
                } catch (error) {
                    console.error('❌ Error refreshing routine UI:', error);
                }
            },
            
            async showDashboard() {
                document.getElementById('auth-screen').classList.add('hide');
                document.getElementById('crypto-overlay').style.display = 'block';
                
                // Load all data after successful login
                if (supabase?.isAuthenticated()) {
                    console.log('🔄 Loading dashboard data...');
                    
                    // Load all data in parallel for better performance
                    await Promise.all([
                        TodoManager.loadTodos(),
                        GoalManager.loadGoals(),
                        JournalManager.loadEntries(),
                        TerminManager.loadTermine(),
                        // Load Wiki data if available
                        window.Wiki ? window.Wiki.loadEntries() : Promise.resolve(),
                        // Load ResourceManager data if it exists (after login)
                        window.ResourceManager ? window.ResourceManager.loadResources() : Promise.resolve()
                    ]);
                    
                    // Initialize crypto widget after authentication
                    try {
                        if (!window.cryptoPriceWidget) {
                            window.cryptoPriceWidget = new CryptoPriceWidget();
                            console.log('✅ Crypto Widget initialized after authentication');
                        }
                    } catch (error) {
                        console.error('❌ Error initializing Crypto Widget:', error);
                    }
                    
                    // Initialize routine system FIRST, then counters to avoid race condition
                    if (window.simpleRoutineManager) {
                        console.log('🔄 Re-initializing routine manager after login...');
                        await window.simpleRoutineManager.loadTodaysData();
                        window.simpleRoutineManager.restoreCheckboxes();
                        window.simpleRoutineManager.updateProgressBarsOnly();
                    }
                    
                    // Initialize counters AFTER routine system is ready
                    if (window.SimpleCounters) {
                        await window.SimpleCounters.init();
                    }
                    
                    // Render Wiki after data is loaded
                    if (window.Wiki) {
                        window.Wiki.render();
                    }
                    
                    console.log('✅ Dashboard data loaded');
                    
                    // After login, always go to home tab for clean UX
                    console.log('🏠 After login, redirecting to home tab');
                    switchTab('tab-home', true); // Update URL to #home
                } else {
                    // Initialize displays for local storage mode
                    TodoManager.updateHomeTodos();
                    TerminManager.displayTermine();
                }
            }
        };

        // === TAB SYSTEM ===
        // Mapping between tab IDs and URL hashes
        const tabHashMapping = {
            'tab-home': 'home',
            'tab-todos': 'todos',
            'tab-ziele': 'goals', 
            'tab-journal': 'journal',
            'tab-trading': 'trading',
            'tab-ressourcen': 'resources',
            'tab-wiki': 'wiki',
            'tab-settings': 'settings'
        };

        // Reverse mapping for hash to tab ID
        const hashTabMapping = Object.fromEntries(
            Object.entries(tabHashMapping).map(([key, value]) => [value, key])
        );

        function switchTab(tabId, updateHash = true) {
            document.querySelectorAll('.tab-section').forEach(section => {
                section.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            const targetSection = document.getElementById(tabId);
            const targetTab = document.querySelector(`[data-tab="${tabId}"]`);
            
            if (targetSection && targetTab) {
                targetSection.classList.add('active');
                targetTab.classList.add('active');
                
                // Update URL hash
                if (updateHash && tabHashMapping[tabId]) {
                    const hash = tabHashMapping[tabId];
                    
                    window.history.replaceState(null, null, `#${hash}`);
                    console.log(`🔗 Tab switched to ${tabId}, URL updated to #${hash}`);
                } else if (updateHash) {
                    // Fallback: if no hash mapping, clear hash
                    window.history.replaceState(null, null, window.location.pathname);
                }
            }
            
            // If switching to todos tab, load the active category
            if (tabId === 'tab-todos') {
                // Load all categories for new todo structure
                if (window.TodoManager && typeof window.TodoManager.loadAllCategories === 'function') {
                    TodoManager.loadAllCategories();
                } else {
                    // Fallback: load individual categories
                    ['privat', 'uni', 'arbeit', 'projekte'].forEach(category => {
                        if (window.TodoManager && typeof window.TodoManager.displayTodosForCategory === 'function') {
                            TodoManager.displayTodosForCategory(category);
                        }
                    });
                }
            }
            
            // If switching to home tab, update home todos
            if (tabId === 'tab-home') {
                TodoManager.updateHomeTodos();
            }
            
            // If switching to ziele tab, load the active category
            if (tabId === 'tab-ziele') {
                const activeTab = document.querySelector('.ziel-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-ziel-category') : 'alle';
                GoalManager.displayGoalsForCategory(activeCategory);
            }
            
            // If switching to journal tab, load the active category
            if (tabId === 'tab-journal') {
                const activeTab = document.querySelector('.journal-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-journal-category') : 'alle';
                JournalManager.renderEntries();
            }
            
            // If switching to resources tab, load the active category
            if (tabId === 'tab-ressourcen') {
                if (window.ResourceManager) {
                    const activeTab = document.querySelector('.resource-tab.active');
                    const activeCategory = activeTab ? activeTab.getAttribute('data-resource-category') : 'alle';
                    ResourceManager.displayResourcesForCategory(activeCategory);
                }
            }
            
            // If switching to trading tab, update portfolio stats
            if (tabId === 'tab-trading') {
                if (window.TradingManager) {
                    window.TradingManager.updatePortfolioStats();
                }
            }
        }

        // Handle hash changes for direct URL navigation
        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove the '#'
            if (hash && hashTabMapping[hash]) {
                console.log(`🔗 Hash changed to #${hash}, switching to ${hashTabMapping[hash]}`);
                switchTab(hashTabMapping[hash], false); // Don't update hash again
            } else if (!hash && supabase?.isAuthenticated()) {
                // Only default to home if authenticated (not on login screen)
                console.log('🔗 No hash found, defaulting to home (authenticated user)');
                switchTab('tab-home', false);
            }
            // If not authenticated and no hash, do nothing (stay on login screen)
        }

        // Initialize tab from URL hash on page load
        function initializeFromHash() {
            const hash = window.location.hash.slice(1);
            if (hash && hashTabMapping[hash]) {
                switchTab(hashTabMapping[hash], false);
            } else if (!hash && supabase?.isAuthenticated()) {
                // Only default to home if authenticated
                switchTab('tab-home', false);
            }
            // If not authenticated and no hash, do nothing (stay on login screen)
        }

        // === ROUTINE PROGRESS ===
        // Load saved checkbox states from cloud only (pure cloud mode)
        async function loadRoutineStates() {
            const today = new Date().toISOString().split('T')[0];
            let savedStates = {};
            
            // Pure cloud mode - no localStorage fallback needed
            console.log('☁️ Pure cloud mode - loading routine states from cloud only');
            
            // If authenticated, load from database
            if (supabase?.isAuthenticated()) {
                try {
                    const routineCompletions = getRoutineCompletions();
                    if (routineCompletions && routineCompletions.length > 0) {
                        console.log(`🔄 Loading ${routineCompletions.length} routine completions from database for ${today}`);
                        
                        // Filter for today's completions
                        const todayCompletions = routineCompletions.filter(c => c.date === today);
                        console.log(`📅 Found ${todayCompletions.length} routine completions for today`);
                        
                        // Convert database completions to checkbox states
                        todayCompletions.forEach(completion => {
                            if (completion.checkbox_id) {
                                savedStates[completion.checkbox_id] = completion.completed;
                                console.log(`✅ Restored from database: ${completion.checkbox_id} = ${completion.completed}`);
                            }
                        });
                        
                        // Pure cloud mode - no localStorage updates needed
                        console.log('☁️ Routine states loaded from cloud');
                    }
                } catch (error) {
                    console.error('Error loading routine states from database:', error);
                    // Continue with localStorage-only states
                }
            }
            
            // Apply states to checkboxes
            Object.keys(savedStates).forEach(checkboxId => {
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.checked = savedStates[checkboxId];
                    // Apply visual styling
                    const label = checkbox.nextElementSibling;
                    if (label) {
                        if (checkbox.checked) {
                            label.style.textDecoration = 'line-through';
                            label.style.color = '#999';
                        } else {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    }
                }
            });
            
            console.log(`✅ Loaded routine states for ${today}:`, savedStates);
        }
        
        // Save checkbox state to both localStorage and database
        async function saveCheckboxState(checkboxId, isChecked) {
            const today = new Date().toISOString().split('T')[0];
            
            // Pure cloud mode - no localStorage saving needed
            console.log(`☁️ Pure cloud mode: Checkbox state ${checkboxId} = ${isChecked} (not saved to localStorage)`);
            
            // Skip database save for routine checkboxes - handled by routine completion system
            const checkbox = document.getElementById(checkboxId);
            const routineSection = checkbox?.closest('.routine-section');
            
            if (routineSection) {
                console.log(`📝 Routine checkbox ${checkboxId} state saved to localStorage only - database sync handled by routine system`);
                return;
            }
            
            // Save non-routine checkboxes to database if authenticated
            if (supabase?.isAuthenticated()) {
                console.log(`💾 Saving non-routine checkbox ${checkboxId} to database...`);
                // Only save non-routine checkboxes to database
                // Routine checkboxes are handled by the routine completion system
            }
        }

        function updateRoutineProgress() {
            // DISABLED - conflicts with SimpleRoutineManager
            return;
            const routineTab = document.getElementById('tab-home');
            if (!routineTab) return;
            
            const routineSections = routineTab.querySelectorAll('.routine-section');
            
            routineSections.forEach(section => {
                const checkboxes = section.querySelectorAll('input[type="checkbox"]');
                const checkedBoxes = section.querySelectorAll('input[type="checkbox"]:checked');
                
                if (checkboxes.length === 0) return;
                
                const percentage = Math.round((checkedBoxes.length / checkboxes.length) * 100);
                
                const progressFill = section.querySelector('.progress-fill');
                if (progressFill) {
                    progressFill.style.width = percentage + '%';
                }
                
                // Optional: Log progress for debugging
                console.log(`Routine progress: ${percentage}% (${checkedBoxes.length}/${checkboxes.length})`);
                
                // Update monthly streaks based on completion status (pure cloud mode)
                const today = new Date().toISOString().split('T')[0];
                const routineType = section.querySelector('h2').textContent.includes('Morgen') ? 'morning' : 'evening';
                
                let completionStatus;
                if (percentage === 100) {
                    console.log('🔍 DEBUG: 100% reached, marking as complete');
                    completionStatus = true;
                } else {
                    console.log('🔍 DEBUG: Less than 100%, marking as incomplete');
                    completionStatus = false;
                }
                
                console.log(`☁️ Pure cloud mode: ${routineType} completion: ${completionStatus}`);
                
                // Save to cloud if authenticated (async without blocking)
                if (supabase?.isAuthenticated()) {
                    (async () => {
                        try {
                            console.log(`☁️ Saving routine completion to cloud: ${routineType} = ${completionStatus}`);
                            await cloudStorage.saveRoutineCompletion(`${routineType}_routine`, today, completionStatus);
                            
                            // Note: Counter updates now handled by SimpleCounters
                        } catch (error) {
                            console.warn('⚠️ Could not save routine completion to cloud:', error);
                        }
                    })();
                }
                
                // Note: Counter updates now handled by SimpleCounters
            });
        }

        // === CATEGORY SYSTEM (for todos) ===
        function switchCategory(categoryId) {
            const parentTab = document.querySelector('#tab-todos');
            // Hide all category contents within todos
            parentTab.querySelectorAll('.category-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all category tabs
            parentTab.querySelectorAll('.category-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-category="${categoryId}"]`).classList.add('active');
            
            // Show/hide clear archive button
            const clearArchiveBtn = document.getElementById('clear-archive-btn');
            if (clearArchiveBtn) {
                if (categoryId === 'archiv') {
                    clearArchiveBtn.style.display = 'inline-block';
                } else {
                    clearArchiveBtn.style.display = 'none';
                }
            }
            
            // Load todos for this category
            TodoManager.displayTodosForCategory(categoryId);
        }

        // === ZIELE CATEGORY SYSTEM ===
        function switchZielCategory(categoryId) {
            const parentTab = document.querySelector('#tab-ziele');
            // Hide all ziel contents
            parentTab.querySelectorAll('.ziel-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all ziel tabs
            parentTab.querySelectorAll('.ziel-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#ziel-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-ziel-category="${categoryId}"]`).classList.add('active');
            
            // Show/hide clear goal archive button
            const clearGoalArchiveBtn = document.getElementById('clear-goal-archive-btn');
            if (clearGoalArchiveBtn) {
                if (categoryId === 'archiv') {
                    clearGoalArchiveBtn.style.display = 'inline-block';
                } else {
                    clearGoalArchiveBtn.style.display = 'none';
                }
            }
            
            // Load goals for this category
            GoalManager.displayGoalsForCategory(categoryId);
        }

        // === RESOURCE CATEGORY SYSTEM ===
        function switchResourceCategory(categoryId) {
            const parentTab = document.querySelector('#tab-ressourcen');
            // Hide all resource contents
            parentTab.querySelectorAll('.resource-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all resource tabs
            parentTab.querySelectorAll('.resource-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#resource-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-resource-category="${categoryId}"]`).classList.add('active');
            
            // Load resources for this category
            ResourceManager.displayResourcesForCategory(categoryId);
        }

        // === JOURNAL CATEGORY SYSTEM ===
        function switchJournalCategory(categoryId) {
            const parentTab = document.querySelector('#tab-journal');
            // Hide all journal contents
            parentTab.querySelectorAll('.journal-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all journal tabs
            parentTab.querySelectorAll('.journal-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#journal-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-journal-category="${categoryId}"]`).classList.add('active');
            
            // Load journal entries for this category
            JournalManager.displayEntriesForCategory(categoryId);
        }

        // === SETTINGS FUNCTIONALITY ===
        function initializeSettings() {
            // Pure cloud mode - use default reset time (settings could be moved to cloud later)
            console.log('☁️ Pure cloud mode: Using default routine reset time');
            const savedResetTime = '06:00'; // Default time, no localStorage needed
            const timeInput = document.getElementById('routine-reset-time');
            if (timeInput) {
                timeInput.value = savedResetTime;
            }
            
            // Save routine settings button
            const saveBtn = document.getElementById('save-routine-settings');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    const resetTime = timeInput.value;
                    console.log('☁️ Pure cloud mode: Settings change noted but not persisted');
                    alert(`Routine Reset Zeit auf ${resetTime} temporär gesetzt! (Pure Cloud Mode - nicht dauerhaft gespeichert)`);
                    console.log(`Routine reset time noted: ${resetTime} (not persisted in pure cloud mode)`);
                });
            }
            
            // Reset routines today button
            const resetBtn = document.getElementById('reset-routines-today');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    if (confirm('Möchtest du wirklich alle Routinen für heute zurücksetzen?')) {
                        resetRoutinesToday();
                    }
                });
            }
            
            // Reset monthly todos button
            const resetTodosBtn = document.getElementById('reset-monthly-todos');
            if (resetTodosBtn) {
                resetTodosBtn.addEventListener('click', () => {
                    const now = new Date();
                    const monthName = ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni',
                                     'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
                    if (confirm(`Möchtest du wirklich den Todo-Zähler für ${monthName} ${now.getFullYear()} zurücksetzen?`)) {
                        resetMonthlyTodos();
                    }
                });
            }
        }
        
        function resetRoutinesToday() {
            const today = new Date().toISOString().split('T')[0];
            
            // Pure cloud mode - no localStorage operations needed
            console.log('☁️ Pure cloud mode: Routine reset will only affect UI, not persistent storage');
            console.log(`☁️ Resetting routines for ${today} (UI only)`);
            
            // Note: In pure cloud mode, this only resets the UI
            // The actual cloud data would need to be reset via cloud operations
            
            // Uncheck all routine checkboxes
            document.querySelectorAll('.routine-section input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
                const label = checkbox.nextElementSibling;
                if (label) {
                    label.style.textDecoration = 'none';
                    label.style.color = 'inherit';
                }
            });
            
            // Update progress displays
            updateRoutineProgress();
            // Note: Counter updates now handled by SimpleCounters
            
            alert('Routinen für heute wurden zurückgesetzt!');
            console.log('Routines reset for today');
        }
        
        function resetMonthlyTodos() {
            const now = new Date();
            const monthKey = `${now.getFullYear()}-${now.getMonth()}`;
            
            // Reset monthly todo completions
            const monthlyData = JSON.parse(localStorage.getItem('monthlyTodoCompletions') || '{}');
            monthlyData[monthKey] = 0;
            localStorage.setItem('monthlyTodoCompletions', JSON.stringify(monthlyData));
            
            // Note: Counter updates now handled by SimpleCounters
            
            const monthName = ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni',
                             'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
            alert(`Todo-Zähler für ${monthName} ${now.getFullYear()} wurde auf 0 zurückgesetzt!`);
            console.log(`Monthly todos reset for ${monthKey}`);
        }
        
        // === TODO COUNTER SYSTEMS REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        // === MOBILE-FIRST ROUTINE COMPLETIONS ===
        let globalRoutineCompletions = []; // Always keep in memory for mobile
        
        async function loadRoutineCompletions() {
            try {
                console.log('🔄 Loading routine completions (Cloud-First with Migration)...');
                
                // STEP 1: If not authenticated, use local data only
                if (!supabase?.isAuthenticated()) {
                    console.log('⚠️ Not authenticated, using local data only');
                    try {
                        const localData = localStorage.getItem('routine_completions_cache');
                        if (localData) {
                            globalRoutineCompletions = JSON.parse(localData);
                            // Note: Counter updates now handled by SimpleCounters
                        }
                    } catch (e) {
                        console.warn('⚠️ Could not read local data:', e);
                        globalRoutineCompletions = [];
                    }
                    return;
                }
                
                // STEP 2: Load cloud data
                const cloudCompletions = await supabase.query('routine_completions?select=*');
                console.log(`☁️ Loaded ${cloudCompletions?.length || 0} routine completions from cloud`);
                
                // STEP 3: Cloud-first with improved migration
                if (cloudCompletions && cloudCompletions.length > 0) {
                    // Use cloud data if available
                    globalRoutineCompletions = cloudCompletions;
                    console.log(`☁️ Using ${cloudCompletions.length} completions from cloud`);
                } else {
                    // Cloud is empty - try migration with new improved approach
                    console.log('🔍 Cloud is empty, attempting migration with new schema...');
                    const migrationSuccess = await migrateLocalDataToCloudV2();
                    
                    if (migrationSuccess) {
                        // Reload after successful migration
                        const newCloudCompletions = await supabase.query('routine_completions?select=*');
                        console.log(`🔄 After migration: ${newCloudCompletions?.length || 0} completions in cloud`);
                        globalRoutineCompletions = newCloudCompletions || [];
                    } else {
                        // Migration failed - use local data as fallback
                        console.log('⚠️ Migration failed, using local data as fallback');
                        globalRoutineCompletions = [];
                        
                        // Load from all local sources
                        const localSources = ['routine_completions_cache', 'routineCompletionData'];
                        for (const source of localSources) {
                            try {
                                const localData = localStorage.getItem(source);
                                if (localData) {
                                    const parsed = JSON.parse(localData);
                                    
                                    if (source === 'routineCompletionData') {
                                        // Convert old format
                                        Object.keys(parsed).forEach(date => {
                                            const dayData = parsed[date];
                                            if (dayData.morning !== undefined) {
                                                globalRoutineCompletions.push({
                                                    template_id: 'morning_routine',
                                                    date: date,
                                                    completed: dayData.morning
                                                });
                                            }
                                            if (dayData.evening !== undefined) {
                                                globalRoutineCompletions.push({
                                                    template_id: 'evening_routine',
                                                    date: date,
                                                    completed: dayData.evening
                                                });
                                            }
                                        });
                                    } else if (Array.isArray(parsed)) {
                                        globalRoutineCompletions.push(...parsed);
                                    }
                                }
                            } catch (e) {
                                console.warn(`⚠️ Could not load fallback from ${source}:`, e);
                            }
                        }
                        console.log(`📱 Using ${globalRoutineCompletions.length} local completions as fallback`);
                    }
                }
                
                // STEP 4: Pure cloud mode - no local caching needed
                console.log('☁️ Pure cloud mode - skipping local cache storage');
                
                // STEP 5: Counter updates now handled by SimpleCounters
                
            } catch (error) {
                console.error('❌ Error loading routine completions:', error);
                // Fallback to local data on error
                try {
                    const localData = localStorage.getItem('routine_completions_cache');
                    if (localData) {
                        globalRoutineCompletions = JSON.parse(localData);
                        console.log('🔄 Fallback to local data due to error');
                    } else {
                        globalRoutineCompletions = [];
                    }
                } catch (e) {
                    globalRoutineCompletions = [];
                }
            }
        }
        
        // === IMPROVED MIGRATION FUNCTION V2 ===
        async function migrateLocalDataToCloudV2() {
            try {
                console.log('🚀 Starting IMPROVED migration (V2) of local routine data to cloud...');
                
                // Get current user
                const currentUser = supabase.getCurrentUser();
                if (!currentUser || !currentUser.id) {
                    console.error('❌ No authenticated user found for migration');
                    return false;
                }
                
                console.log('👤 Starting data migration...');
                
                // Collect all local data
                const localCompletions = [];
                
                // Source 1: routineCompletionData (legacy format)
                try {
                    const legacyData = localStorage.getItem('routineCompletionData');
                    if (legacyData) {
                        const parsed = JSON.parse(legacyData);
                        console.log(`📁 Found legacy data for ${Object.keys(parsed).length} dates`);
                        
                        Object.keys(parsed).forEach(date => {
                            const dayData = parsed[date];
                            if (dayData.morning !== undefined) {
                                localCompletions.push({
                                    template_id: 'morning_routine',
                                    date: date,
                                    completed: Boolean(dayData.morning),
                                    user_id: currentUser.id
                                });
                            }
                            if (dayData.evening !== undefined) {
                                localCompletions.push({
                                    template_id: 'evening_routine',
                                    date: date,
                                    completed: Boolean(dayData.evening),
                                    user_id: currentUser.id
                                });
                            }
                        });
                    }
                } catch (e) {
                    console.warn('⚠️ Could not parse legacy routine data:', e);
                }
                
                console.log(`📊 Prepared ${localCompletions.length} completions for migration`);
                
                if (localCompletions.length === 0) {
                    console.log('📭 No local data found to migrate');
                    return true;
                }
                
                // Remove duplicates based on user_id + template_id + date
                const uniqueCompletions = [];
                const seen = new Set();
                
                localCompletions.forEach(completion => {
                    const key = `${completion.user_id}_${completion.template_id}_${completion.date}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueCompletions.push(completion);
                    }
                });
                
                console.log(`🔍 After deduplication: ${uniqueCompletions.length} unique completions`);
                
                // Upload to cloud
                let uploadedCount = 0;
                
                for (const completion of uniqueCompletions) {
                    try {
                        console.log(`⬆️ Uploading: ${completion.template_id} for ${completion.date} (${completion.completed})`);
                        
                        const result = await supabase.insert('routine_completions', [completion]);
                        if (result && result.length > 0) {
                            uploadedCount++;
                            console.log(`✅ Uploaded successfully`);
                        } else {
                            console.warn(`⚠️ Upload returned no result`);
                        }
                    } catch (uploadError) {
                        console.error(`❌ Failed to upload completion:`, uploadError);
                        
                        // Check if it's a duplicate key error (which is OK)
                        if (uploadError.message && uploadError.message.includes('unique constraint')) {
                            console.log(`ℹ️ Duplicate entry (already exists) - skipping`);
                            uploadedCount++; // Count as success since data exists
                        } else {
                            console.error(`❌ Real upload error:`, uploadError.message);
                        }
                    }
                }
                
                console.log(`🎉 Migration V2 complete! Successfully processed ${uploadedCount}/${uniqueCompletions.length} completions`);
                return uploadedCount > 0;
                
            } catch (error) {
                console.error('❌ Migration V2 failed:', error);
                return false;
            }
        }
        
        // === OLD MIGRATION FUNCTION (DEPRECATED) ===
        async function migrateLocalDataToCloud() {
            try {
                console.log('🚀 Starting migration of local routine data to cloud...');
                
                // Get all local routine data sources
                const sources = [
                    'routine_completions_cache',
                    'routineCompletionData',
                    'monthlyRoutineCompletions'
                ];
                
                let allLocalCompletions = [];
                
                for (const source of sources) {
                    try {
                        const data = localStorage.getItem(source);
                        if (data) {
                            let parsed = JSON.parse(data);
                            console.log(`📁 Found data in ${source}:`, parsed);
                            
                            if (source === 'routineCompletionData') {
                                // Convert old format to new format
                                Object.keys(parsed).forEach(date => {
                                    const dayData = parsed[date];
                                    if (dayData.morning !== undefined) {
                                        allLocalCompletions.push({
                                            template_id: 'morning_routine',
                                            date: date,
                                            completed: dayData.morning,
                                            user_id: supabase.getCurrentUser()?.id
                                            // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                        });
                                    }
                                    if (dayData.evening !== undefined) {
                                        allLocalCompletions.push({
                                            template_id: 'evening_routine', 
                                            date: date,
                                            completed: dayData.evening,
                                            user_id: supabase.getCurrentUser()?.id
                                            // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                        });
                                    }
                                });
                            } else if (Array.isArray(parsed)) {
                                // Add user_id to existing completions and remove any existing id
                                parsed.forEach(completion => {
                                    const cleanCompletion = {
                                        template_id: completion.template_id,
                                        date: completion.date,
                                        completed: completion.completed,
                                        user_id: supabase.getCurrentUser()?.id
                                        // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                    };
                                    allLocalCompletions.push(cleanCompletion);
                                });
                            }
                        }
                    } catch (e) {
                        console.warn(`⚠️ Could not parse ${source}:`, e);
                    }
                }
                
                console.log(`📊 Found ${allLocalCompletions.length} local completions to migrate`);
                
                if (allLocalCompletions.length === 0) {
                    console.log('📭 No local data found to migrate');
                    return true; // No data to migrate is considered success
                }
                
                // Clean all completions: remove any existing IDs and ensure clean data
                const cleanedCompletions = allLocalCompletions.map(completion => ({
                    template_id: completion.template_id,
                    date: completion.date,
                    completed: completion.completed,
                    user_id: completion.user_id || supabase.getCurrentUser()?.id
                    // Explicitly exclude: id, created_at, updated_at - these will be auto-generated
                }));
                
                console.log(`🧹 Cleaned data, removing ${allLocalCompletions.length - cleanedCompletions.length} invalid entries`);
                
                // Upload to cloud in batches
                const batchSize = 50;
                let uploaded = 0;
                let hasErrors = false;
                
                for (let i = 0; i < cleanedCompletions.length; i += batchSize) {
                    const batch = cleanedCompletions.slice(i, i + batchSize);
                    try {
                        const result = await supabase.insert('routine_completions', batch);
                        if (result) {
                            uploaded += batch.length;
                            console.log(`✅ Uploaded batch: ${uploaded}/${cleanedCompletions.length}`);
                        } else {
                            console.error('❌ Batch upload returned no result');
                            hasErrors = true;
                        }
                    } catch (batchError) {
                        console.error('❌ Batch upload failed:', batchError);
                        hasErrors = true;
                        
                        // Check if it's an RLS error
                        if (batchError.message && batchError.message.includes('row-level security')) {
                            console.error('🔒 RLS Error: Please run the fix-routine-completions-rls.sql file in Supabase');
                            return false; // Stop migration on RLS error
                        }
                    }
                }
                
                if (hasErrors && uploaded === 0) {
                    console.log('❌ Migration failed completely');
                    return false;
                } else if (hasErrors) {
                    console.log(`⚠️ Migration partially successful: ${uploaded}/${cleanedCompletions.length} uploaded`);
                    return uploaded > 0; // Partial success
                } else {
                    console.log(`🎉 Migration complete! Uploaded ${uploaded} routine completions to cloud`);
                    return true;
                }
                
            } catch (error) {
                console.error('❌ Migration failed:', error);
                return false;
            }
        }
        
        // Mobile-safe function that uses memory first, localStorage as fallback
        function getRoutineCompletions() {
            if (globalRoutineCompletions && globalRoutineCompletions.length > 0) {
                console.log('📱 Using routine completions from memory (Mobile-safe)');
                return globalRoutineCompletions;
            }
            
            // Fallback to localStorage if available
            try {
                const cached = localStorage.getItem('routine_completions_cache');
                if (cached) {
                    const parsed = JSON.parse(cached);
                    console.log('💾 Using routine completions from localStorage fallback');
                    return parsed;
                }
            } catch (e) {
                console.warn('⚠️ localStorage read failed, using empty array');
            }
            
            return [];
        }
        
        // === CLOUD-BASED ROUTINE STREAK UPDATER REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        // === LOCAL FALLBACK FOR ROUTINE STREAKS REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        // === MONTHLY STREAK DISPLAY FUNCTIONS REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        function getRoutineCompletions() {
            // Return empty array for now
            return [];
        }
        
        // === MAKE FUNCTIONS GLOBALLY AVAILABLE ===
        window.getRoutineCompletions = getRoutineCompletions;
        window.loadRoutineCompletions = loadRoutineCompletions;
        window.loadRoutineStates = loadRoutineStates;
        window.updateRoutineProgress = updateRoutineProgress;

        // === EVENT LISTENERS ===
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Skip action buttons - they have their own handlers
                if (tab.id === 'logout-btn' || tab.id === 'settings-btn') return;
                
                const tabId = tab.getAttribute('data-tab');
                if (tabId) switchTab(tabId);
            });
        });
        
        // Settings button event listener
        const settingsBtn = document.getElementById('settings-btn');
        if (settingsBtn) {
            settingsBtn.addEventListener('click', () => {
                console.log('Settings clicked');
                switchTab('tab-settings');
            });
        }

        // Setup Settings hover animations
        function setupActionButtonHovers() {
            const settingsBtn = document.getElementById('settings-btn');
            
            if (settingsBtn?.querySelector('svg')) {
                settingsBtn.onmouseenter = function() {
                    const svg = settingsBtn.querySelector('svg');
                    if (svg) {
                        svg.style.stroke = '#059669';
                        svg.style.color = '#059669';
                    }
                };
                settingsBtn.onmouseleave = function() {
                    const svg = settingsBtn.querySelector('svg');
                    if (svg) {
                        svg.style.stroke = '';
                        svg.style.color = '';
                    }
                };
            }
        }
        
        // Setup action button hovers after Lucide
        setTimeout(setupActionButtonHovers, 1000);


        // Todo category tabs
        document.querySelectorAll('.category-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-category');
                switchCategory(categoryId);
            });
        });

        // Ziele category tabs
        document.querySelectorAll('.ziel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-ziel-category');
                switchZielCategory(categoryId);
            });
        });

        // Resource category tabs
        document.querySelectorAll('.resource-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-resource-category');
                switchResourceCategory(categoryId);
            });
        });

        // Journal category tabs
        document.querySelectorAll('.journal-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-journal-category');
                switchJournalCategory(categoryId);
            });
        });

        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', async function() {
                // ToDo-Items als completed markieren
                const todoItem = this.closest('.todo-item');
                if (todoItem) {
                    todoItem.classList.toggle('completed', this.checked);
                }
                
                // Routine-Progress aktualisieren (nur bei Routine-Checkboxen)
                const routineSection = this.closest('.routine-section');
                if (routineSection) {
                    // Apply visual styling immediately
                    const label = this.nextElementSibling;
                    if (label) {
                        if (this.checked) {
                            label.style.textDecoration = 'line-through';
                            label.style.color = '#999';
                        } else {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    }
                    
                    // DISABLED - SimpleRoutineManager handles this
                    // await saveCheckboxState(this.id, this.checked);
                    // updateRoutineProgress();
                }
            });
        });

        // === TODO MANAGEMENT ===
        const TodoManager = {
            todos: [], // In-memory storage for demo
            
            priorityIntToString(priorityInt) {
                switch(priorityInt) {
                    case 1: return 'mittel'; // Map old niedrig to mittel
                    case 2: return 'mittel';
                    case 3: return 'wichtig';
                    case 4: return 'dringend';
                    default: return 'mittel';
                }
            },
            
            getPriorityString(priority) {
                if (typeof priority === 'string') {
                    return priority;
                }
                return this.priorityIntToString(priority);
            },
            
            getPriorityDisplay(priority) {
                const priorityStr = this.getPriorityString(priority);
                return priorityStr.charAt(0).toUpperCase() + priorityStr.slice(1);
            },
            
            async loadTodos() {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TodoManager: Not authenticated - pure cloud mode requires authentication');
                    this.todos = [];
                    return;
                }
                
                try {
                    const user = supabase.getCurrentUser();
                    const data = await supabase.query(`todos?user_id=eq.${user.id}&select=*`);
                    if (data && Array.isArray(data)) {
                        // Transform database data to match UI expectations
                        this.todos = data.map(todo => {
                            // Convert priority integer back to string
                            let priorityString = 'mittel';
                            switch(todo.priority) {
                                case 1: priorityString = 'mittel'; break; // Map old niedrig to mittel
                                case 2: priorityString = 'mittel'; break;
                                case 3: priorityString = 'wichtig'; break;
                                case 4: priorityString = 'dringend'; break;
                                default: priorityString = 'mittel';
                            }
                            
                            return {
                                ...todo,
                                title: todo.text, // Map text to title for UI
                                deadline: todo.date, // Use date field only (no due_date)
                                priority: priorityString // Convert integer to string
                            };
                        });
                        this.refreshCurrentView();
                        this.updateHomeTodos();
                    } else {
                        console.log('☁️ TodoManager: No todos found in cloud');
                        this.todos = [];
                    }
                } catch (error) {
                    console.error('❌ TodoManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            showAddTodoModal() {
                const modal = document.getElementById('add-todo-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('todo-deadline').value = today;
            },
            
            hideAddTodoModal() {
                const modal = document.getElementById('add-todo-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-todo-form').reset();
                // Reset to default values
                document.getElementById('todo-time').value = '21:00';
                document.getElementById('todo-priority').value = 'mittel';
            },
            
            async addTodo(todoData) {
                // DON'T create due_date with timezone - it causes issues
                // Just store date and time separately
                
                // Convert priority string to integer
                let priorityInt = 2; // Default to mittel
                switch(todoData.priority) {
                    case 'niedrig': priorityInt = 1; break; // Keep for backwards compatibility
                    case 'mittel': priorityInt = 2; break;
                    case 'wichtig': priorityInt = 3; break;
                    case 'dringend': priorityInt = 4; break;
                    default: priorityInt = 2;
                }
                
                const todo = {
                    text: todoData.title,
                    category: todoData.category,
                    priority: priorityInt,
                    date: todoData.deadline || null,
                    time: todoData.time || null,
                    // Remove due_date field to avoid timezone issues
                    completed: false,
                    user_id: supabase?.user?.id || 'anonymous'
                };
                
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TodoManager: Not authenticated - cannot add todo in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Todo kann nicht gespeichert werden.');
                    return;
                }
                
                try {
                    const result = await supabase.insert('todos', todo);
                    console.log('💾 Supabase insert result:', result);
                    if (result && Array.isArray(result) && result.length > 0) {
                        // Transform the database result to match UI expectations
                        const dbTodo = result[0];
                        console.log('☁️ TodoManager: Todo saved to cloud with ID:', dbTodo.id);
                        const uiTodo = {
                            ...dbTodo,
                            title: dbTodo.text,
                            deadline: dbTodo.date, // Use date field only
                            priority: this.priorityIntToString(dbTodo.priority || 1)
                        };
                        this.todos.push(uiTodo);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ TodoManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Todos: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.category-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-category') : 'heute';
                
                console.log('🔄 Refreshing view for category:', activeCategory);
                
                this.displayTodosForCategory(activeCategory);
                
                // Also update home todos
                this.updateHomeTodos();
                
                // Update overdue badge
                this.updateOverdueBadge();
            },
            
            updateOverdueBadge() {
                // Count overdue todos
                const today = new Date();
                const todayStr = today.getFullYear() + '-' + 
                               String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(today.getDate()).padStart(2, '0');
                
                const overdueCount = this.todos.filter(todo => 
                    todo.date && todo.date < todayStr && !todo.completed
                ).length;
                
                const badge = document.getElementById('overdue-count');
                if (badge) {
                    if (overdueCount > 0) {
                        badge.textContent = overdueCount;
                        badge.style.display = 'inline';
                    } else {
                        badge.style.display = 'none';
                    }
                }
            },
            
            displayTodosForCategory(category) {
                const container = document.getElementById(category);
                if (!container) return;
                
                let filteredTodos = [];
                
                switch(category) {
                    case 'heute':
                        // Get today without timezone conversion
                        const today = new Date();
                        const todayStr = today.getFullYear() + '-' + 
                                       String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                                       String(today.getDate()).padStart(2, '0');
                        
                        // Include both today's todos AND overdue todos
                        filteredTodos = this.todos.filter(todo => 
                            todo.date && todo.date <= todayStr && !todo.completed
                        );
                        break;
                    case 'alle':
                        filteredTodos = this.todos.filter(todo => !todo.completed);
                        break;
                    case 'archiv':
                        filteredTodos = this.todos.filter(todo => todo.completed);
                        break;
                    default:
                        filteredTodos = this.todos.filter(todo => 
                            todo.category === category && !todo.completed
                        );
                }
                // Sort by date first, then by time
                filteredTodos.sort((a, b) => {
                    // First by date
                    const dateA = a.date || '9999-12-31';
                    const dateB = b.date || '9999-12-31';
                    const dateComparison = dateA.localeCompare(dateB);
                    
                    if (dateComparison !== 0) {
                        return dateComparison;
                    }
                    
                    // Then by time
                    const timeA = a.time || '23:59';
                    const timeB = b.time || '23:59';
                    return timeA.localeCompare(timeB);
                });
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredTodos.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Todos vorhanden</p>';
                    return;
                }
                
                // Create grid for todos
                const grid = document.createElement('div');
                grid.className = 'grid-3'; // 3-spaltig für kompaktere Todo-Kacheln
                
                // Display todos
                filteredTodos.forEach(todo => {
                    const todoElement = this.createTodoElement(todo);
                    grid.appendChild(todoElement);
                });
                
                container.appendChild(grid);
            },
            
            createTodoElement(todo) {
                const todoCard = document.createElement('div');
                todoCard.className = `ziel-card${todo.completed ? ' completed' : ''}`;
                todoCard.dataset.todoId = todo.id;
                
                // COMPLETELY AVOID DATE PARSING - just use raw strings
                let deadlineClass = '';
                let deadlineText = '';
                
                if (todo.date) {
                    // Get today as YYYY-MM-DD string (no timezone conversion)
                    const today = new Date();
                    const todayStr = today.getFullYear() + '-' + 
                                   String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                                   String(today.getDate()).padStart(2, '0');
                    
                    const isToday = todo.date === todayStr;
                    
                    if (todo.time) {
                        // Todo has both date and time
                        const todoDate = new Date(todo.date + 'T' + todo.time);
                        const now = new Date();
                        
                        if (isToday) {
                            // Check if time has passed for today
                            if (todoDate < now) {
                                deadlineClass = 'overdue';
                                deadlineText = `Überfällig ${todo.time}`;
                            } else {
                                deadlineClass = 'today';
                                deadlineText = `Heute ${todo.time}`;
                            }
                        } else if (todo.date < todayStr) {
                            // Past date - definitely overdue
                            deadlineClass = 'overdue';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = `Überfällig ${germanDate} ${todo.time}`;
                        } else {
                            // Future date
                            deadlineClass = 'soon';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = `${germanDate} ${todo.time}`;
                        }
                    } else {
                        // Todo has only date, no time
                        if (isToday) {
                            deadlineClass = 'today';
                            deadlineText = 'Heute';
                        } else if (todo.date < todayStr) {
                            // Past date - overdue
                            deadlineClass = 'overdue';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = `Überfällig ${germanDate}`;
                        } else {
                            // Future date
                            deadlineClass = 'soon';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = germanDate;
                        }
                    }
                } else {
                    deadlineText = 'Kein Termin';
                    deadlineClass = 'none';
                }
                
                // Calculate days until deadline (similar to termine)
                let daysUntilText = '';
                let daysUntilBadge = '';
                if (todo.date) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const todoDateObj = new Date(todo.date);
                    todoDateObj.setHours(0, 0, 0, 0);
                    const daysDifference = Math.ceil((todoDateObj - today) / (1000 * 60 * 60 * 24));
                    
                    if (daysDifference === 0) {
                        daysUntilText = 'Heute';
                        daysUntilBadge = `<span class="days-until-badge heute">Heute</span>`;
                    } else if (daysDifference === 1) {
                        daysUntilText = 'Morgen';
                        daysUntilBadge = `<span class="days-until-badge morgen">Morgen</span>`;
                    } else if (daysDifference === -1) {
                        daysUntilText = 'Gestern';
                        daysUntilBadge = `<span class="days-until-badge overdue">1 Tag überfällig</span>`;
                    } else if (daysDifference > 1) {
                        daysUntilText = `in ${daysDifference} Tagen`;
                        daysUntilBadge = `<span class="days-until-badge future">${daysDifference} Tage</span>`;
                    } else if (daysDifference < -1) {
                        daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                        daysUntilBadge = `<span class="days-until-badge overdue">${Math.abs(daysDifference)} Tage überfällig</span>`;
                    }
                }

                todoCard.innerHTML = `
                    <div class="ziel-kategorie">${todo.category}</div>
                    <div class="ziel-header">
                        <div class="ziel-name">${todo.title}</div>
                        <div class="ziel-beschreibung">
                            <span class="todo-deadline ${deadlineClass}">${deadlineText}</span>
                            ${daysUntilBadge}
                        </div>
                    </div>
                    <div class="ziel-progress-section">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <input type="checkbox" class="todo-checkbox" ${todo.completed ? 'checked' : ''} 
                                   onchange="TodoManager.toggleTodo('${todo.id}')"
                                   style="width: 20px; height: 20px; border: 2px solid #000; appearance: none; cursor: pointer;">
                            <span class="todo-tag ${TodoManager.getPriorityString(todo.priority)}" style="margin-left: auto;">${TodoManager.getPriorityDisplay(todo.priority)}</span>
                        </div>
                    </div>
                `;
                
                // Add checkbox styling
                const checkbox = todoCard.querySelector('.todo-checkbox');
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        this.style.backgroundColor = '#000';
                        this.innerHTML = '<span style="color: white; position: absolute; top: -2px; left: 2px; font-size: 12px;">✓</span>';
                    } else {
                        this.style.backgroundColor = 'transparent';
                        this.innerHTML = '';
                    }
                });
                
                // Set initial checkbox state
                if (todo.completed) {
                    checkbox.style.backgroundColor = '#000';
                    checkbox.innerHTML = '<span style="color: white; position: absolute; top: -2px; left: 2px; font-size: 12px;">✓</span>';
                }
                
                return todoCard;
            },
            
            async toggleTodo(todoId) {
                
                const todo = this.todos.find(t => String(t.id) === String(todoId));
                if (todo) {
                    const wasCompleted = todo.completed;
                    todo.completed = !todo.completed;
                    
                    // Update counter display when todo status changes (now cloud-based)
                    if (todo.completed !== wasCompleted) {
                        console.log('☁️ Todo status changed, will refresh cloud counter after database update...');
                    }
                    
                    if (supabase?.isAuthenticated()) {
                        try {
                            console.log('💾 Updating in database - ID:', todo.id, 'Type:', typeof todo.id, 'Completed:', todo.completed);
                            
                            // Make sure we use the right ID type
                            const updateId = Number.isInteger(Number(todo.id)) ? Number(todo.id) : todo.id;
                            const result = await supabase.update('todos', { completed: todo.completed }, updateId);
                            
                            console.log('💾 Database update result:', result);
                            
                            console.log('✅ Database update successful');
                            
                            // Refresh simple counter after successful database update
                            if (todo.completed !== wasCompleted) {
                                console.log('☁️ Refreshing todo counter via SimpleCounters...');
                                if (window.SimpleCounters) {
                                    window.SimpleCounters.onTodoChanged();
                                }
                            }
                            
                        } catch (error) {
                            console.error('❌ Database update failed:', error);
                            alert('Fehler: ' + error.message + '\nTodo wird nicht gespeichert!');
                            // Revert on error
                            todo.completed = wasCompleted;
                            return; // Don't refresh if update failed
                        }
                    }
                    
                    this.refreshCurrentView();
                    this.updateHomeTodos();
                } else {
                    console.error('❌ Todo not found for ID:', todoId);
                    alert('Todo nicht gefunden! ID: ' + todoId);
                }
            },
            
            async clearArchive() {
                console.log('☁️ TodoManager: clearArchive() called (pure cloud mode)');
                if (!confirm('Wirklich alle erledigten Todos dauerhaft löschen?\n\nDiese Aktion kann nicht rückgängig gemacht werden!')) {
                    console.log('🔍 Archive clear cancelled by user');
                    return;
                }
                
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TodoManager: Not authenticated - cannot clear archive in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Archive kann nicht geleert werden.');
                    return;
                }
                
                const completedTodos = this.todos.filter(todo => todo.completed);
                console.log('☁️ TodoManager: Deleting', completedTodos.length, 'completed todos from cloud');
                
                try {
                    // Delete from cloud database
                    for (const todo of completedTodos) {
                        console.log(`☁️ Deleting todo from cloud: ID ${todo.id}, Title: "${todo.title}"`);
                        if (!todo.id) {
                            console.warn(`⚠️ Skipping todo without ID: "${todo.title}"`);
                            continue;
                        }
                        const result = await supabase.delete('todos', String(todo.id));
                        console.log(`✅ Delete result for ${todo.id}:`, result);
                    }
                    console.log('☁️ TodoManager: All completed todos deleted from cloud');
                    
                    // Remove from local array
                    this.todos = this.todos.filter(todo => !todo.completed);
                    
                    // Refresh current view
                    this.refreshCurrentView();
                    
                    alert(`✅ ${completedTodos.length} erledigte Todos wurden gelöscht!`);
                } catch (error) {
                    console.error('❌ TodoManager: Error deleting from cloud:', error);
                    alert('Fehler beim Löschen aus der Cloud: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            updateHomeTodos() {
                const homeContainer = document.getElementById('home-todos');
                if (!homeContainer) return;
                
                // Show today's and overdue uncompleted todos on home
                const today = new Date();
                const todayStr = today.getFullYear() + '-' + 
                               String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(today.getDate()).padStart(2, '0');
                
                const todayTodos = this.todos.filter(todo => 
                    todo.date && todo.date <= todayStr && !todo.completed
                ).sort((a, b) => {
                    // First sort by date (overdue first)
                    const dateA = a.date || '9999-12-31';
                    const dateB = b.date || '9999-12-31';
                    const dateComparison = dateA.localeCompare(dateB);
                    
                    if (dateComparison !== 0) {
                        return dateComparison;
                    }
                    
                    // Then by time
                    const timeA = a.time || '23:59';
                    const timeB = b.time || '23:59';
                    return timeA.localeCompare(timeB);
                });
                
                homeContainer.innerHTML = '';
                
                if (todayTodos.length === 0) {
                    homeContainer.innerHTML = '<p style="text-align: center; color: #666; padding: 1rem;">Keine Todos für heute</p>';
                    return;
                }
                
                todayTodos.forEach(todo => {
                    const todoItem = document.createElement('div');
                    todoItem.className = 'checkbox-item todo-item';
                    todoItem.innerHTML = `
                        <div class="todo-left">
                            <input type="checkbox" id="home-todo-${todo.id}" onchange="TodoManager.toggleTodo('${todo.id}')">
                            <label for="home-todo-${todo.id}">
                                ${todo.title} 
                                <span class="todo-tag ${TodoManager.getPriorityString(todo.priority)}" style="margin-left: 0.5rem;">${TodoManager.getPriorityDisplay(todo.priority)}</span>
                            </label>
                        </div>
                        <span class="todo-time">${todo.time || '21:00'}</span>
                    `;
                    homeContainer.appendChild(todoItem);
                });
                
                // Also update overdue badge when updating home
                this.updateOverdueBadge();
            }
        };

        // Make TodoManager globally available
        window.TodoManager = TodoManager;

        // === GOAL MANAGEMENT ===
        const GoalManager = {
            goals: [], // In-memory storage for demo
            
            async loadGoals() {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ GoalManager: Not authenticated - pure cloud mode requires authentication');
                    this.goals = [];
                    return;
                }
                
                try {
                    const user = supabase.getCurrentUser();
                    const data = await supabase.query(`goals?user_id=eq.${user.id}&select=*`);
                    console.log('☁️ GoalManager: Raw goals from cloud:', data);
                    if (data && Array.isArray(data)) {
                        // Transform database data to match UI expectations
                        this.goals = data.map(goal => {
                            console.log('🔄 Transforming goal:', goal);
                            return {
                                ...goal,
                                name: goal.title, // Map title to name for UI
                                deadline: goal.target_date, // Map target_date to deadline for UI
                                progress: goal.progress || 0, // Use DB progress field
                                timeframe: goal.timeframe || 'monat', // Use DB timeframe field
                                completed: goal.completed, // Use DB completed field
                                // Map new progress fields
                                startValue: goal.start_value,
                                targetValue: goal.target_value, 
                                currentValue: goal.current_value,
                                unit: goal.unit
                            };
                        });
                        this.refreshCurrentView();
                    } else {
                        console.log('☁️ GoalManager: No goals found in cloud');
                        this.goals = [];
                    }
                } catch (error) {
                    console.error('❌ GoalManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            // Calculate automatic deadlines based on timeframe
            calculateDeadline(timeframe) {
                const now = new Date();
                
                switch(timeframe) {
                    case 'monat': {
                        // Last day of current month - use day 0 of next month
                        const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                        // Format manually to avoid timezone issues
                        const year = endOfMonth.getFullYear();
                        const month = String(endOfMonth.getMonth() + 1).padStart(2, '0');
                        const day = String(endOfMonth.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    case 'quartal': {
                        // Last day of current quarter
                        const currentQuarter = Math.floor(now.getMonth() / 3);
                        const quarterEndMonth = (currentQuarter + 1) * 3; // 3, 6, 9, 12
                        const endOfQuarter = new Date(now.getFullYear(), quarterEndMonth, 0);
                        // Format manually to avoid timezone issues
                        const year = endOfQuarter.getFullYear();
                        const month = String(endOfQuarter.getMonth() + 1).padStart(2, '0');
                        const day = String(endOfQuarter.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    case 'jahr': {
                        // December 31st of current year
                        const year = now.getFullYear();
                        return `${year}-12-31`;
                    }
                    default:
                        return now.toISOString().split('T')[0];
                }
            },
            
            showAddGoalModal() {
                const modal = document.getElementById('add-goal-modal');
                modal.classList.remove('hide');
                
                // Set default deadline based on current timeframe selection
                const timeframeSelect = document.getElementById('goal-timeframe');
                const deadlineInput = document.getElementById('goal-deadline');
                if (timeframeSelect && deadlineInput) {
                    deadlineInput.value = this.calculateDeadline(timeframeSelect.value);
                }
            },
            
            hideAddGoalModal() {
                const modal = document.getElementById('add-goal-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-goal-form').reset();
            },
            
            calculateProgress(startValue, targetValue, currentValue) {
                if (startValue === targetValue) return 100; // Edge case
                const progress = ((currentValue - startValue) / (targetValue - startValue)) * 100;
                return Math.max(0, Math.min(100, Math.round(progress))); // Clamp between 0-100
            },
            
            async addGoal(goalData) {
                const goal = {
                    id: Date.now().toString(),
                    name: goalData.name,
                    description: goalData.description,
                    category: goalData.category,
                    timeframe: goalData.timeframe, // WICHTIG: timeframe für Filterung
                    deadline: goalData.deadline,
                    unit: goalData.unit || '',
                    startValue: goalData.startValue || 0,
                    targetValue: goalData.targetValue,
                    currentValue: goalData.startValue || 0, // Start with start value
                    progress: 0, // Will be calculated
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                // Calculate initial progress
                goal.progress = this.calculateProgress(goal.startValue, goal.targetValue, goal.currentValue);
                
                console.log('🎯 Created goal with progress data:', {
                    name: goal.name,
                    startValue: goal.startValue,
                    targetValue: goal.targetValue,
                    currentValue: goal.currentValue,
                    unit: goal.unit,
                    progress: goal.progress
                });
                
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ GoalManager: Not authenticated - cannot add goal in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Ziel kann nicht gespeichert werden.');
                    return;
                }
                
                try {
                    // Map UI fields to database schema - all progress fields now supported
                    const dbGoal = {
                        title: goal.name,
                        description: goal.description,
                        category: goal.category,
                        target_date: goal.deadline,
                        progress: goal.progress,
                        timeframe: goal.timeframe,
                        completed: goal.completed,
                        start_value: goal.startValue,
                        target_value: goal.targetValue, 
                        current_value: goal.currentValue,
                        unit: goal.unit,
                        user_id: supabase?.user?.id
                    };
                    
                    console.log('☁️ GoalManager: Saving goal to cloud:', dbGoal);
                    const result = await supabase.insert('goals', dbGoal);
                    console.log('☁️ GoalManager: Cloud result:', result);
                    
                    if (result && Array.isArray(result) && result.length > 0) {
                        // Use database result and transform back to UI format
                        const savedGoal = {
                            ...result[0],
                            name: result[0].title,
                            deadline: result[0].target_date,
                            timeframe: result[0].timeframe,
                            progress: result[0].progress,
                            completed: result[0].completed,
                            startValue: result[0].start_value,
                            targetValue: result[0].target_value,
                            currentValue: result[0].current_value,
                            unit: result[0].unit,
                            database_id: result[0].id // Store real DB ID for updates
                        };
                        this.goals.push(savedGoal);
                        console.log('☁️ GoalManager: Goal saved to cloud with ID:', result[0].id);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ GoalManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Ziels: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('Goal added:', goal);
                console.log('All goals after adding:', this.goals);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.ziel-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-ziel-category') : 'alle';
                
                console.log('🎯 Goals refresh - active category:', activeCategory);
                console.log('🎯 All goals:', this.goals.map(g => ({name: g.name, category: g.category, timeframe: g.timeframe})));
                
                this.displayGoalsForCategory(activeCategory);
            },
            
            displayGoalsForCategory(category) {
                const container = document.getElementById(`ziel-${category}`);
                if (!container) return;
                
                let filteredGoals = [];
                
                switch(category) {
                    case 'monat':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'monat' && !goal.completed
                        );
                        break;
                    case 'quartal':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'quartal' && !goal.completed
                        );
                        break;
                    case 'jahr':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'jahr' && !goal.completed
                        );
                        break;
                    case 'alle':
                        filteredGoals = this.goals.filter(goal => !goal.completed);
                        break;
                    case 'archiv':
                        filteredGoals = this.goals.filter(goal => goal.completed);
                        break;
                }
                
                // Sort by deadline
                filteredGoals.sort((a, b) => new Date(a.deadline) - new Date(b.deadline));
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredGoals.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Ziele vorhanden</p>';
                    return;
                }
                
                // Create grid for goals
                const grid = document.createElement('div');
                grid.className = 'grid-2';
                
                // Display goals
                filteredGoals.forEach(goal => {
                    const goalElement = this.createGoalElement(goal);
                    grid.appendChild(goalElement);
                });
                
                container.appendChild(grid);
            },
            
            createGoalElement(goal) {
                const goalCard = document.createElement('div');
                goalCard.className = `termin-card${goal.completed ? ' completed' : ''}`;
                goalCard.dataset.goalId = goal.id;
                
                // Calculate days until deadline (exactly like termine)
                let daysUntilText = '';
                let badgeColor1 = '';
                let badgeColor2 = '';
                let formattedDeadline = '';
                
                if (goal.deadline) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const goalDate = new Date(goal.deadline);
                    goalDate.setHours(0, 0, 0, 0);
                    const daysDifference = Math.ceil((goalDate - today) / (1000 * 60 * 60 * 24));
                    
                    // Format deadline like termine
                    formattedDeadline = goalDate.toLocaleDateString('de-DE', {
                        weekday: 'long',
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric'
                    });
                    
                    // Badge styling (exactly like termine)
                    if (daysDifference === 0) {
                        daysUntilText = 'Heute';
                        badgeColor1 = '#ef4444';
                        badgeColor2 = '#dc2626';
                    } else if (daysDifference === 1) {
                        daysUntilText = 'Morgen';
                        badgeColor1 = '#f97316';
                        badgeColor2 = '#ea580c';
                    } else if (daysDifference === -1) {
                        daysUntilText = 'Gestern';
                        badgeColor1 = '#6b7280';
                        badgeColor2 = '#4b5563';
                    } else if (daysDifference > 1) {
                        daysUntilText = `in ${daysDifference} Tagen`;
                        badgeColor1 = '#3b82f6';
                        badgeColor2 = '#2563eb';
                    } else if (daysDifference < -1) {
                        daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                        badgeColor1 = '#6b7280';
                        badgeColor2 = '#4b5563';
                    }
                }
                
                // Set CSS custom properties for badge colors (like terme)
                const badgeColorVars = `--badge-color-1: ${badgeColor1}; --badge-color-2: ${badgeColor2};`;
                goalCard.style.cssText += badgeColorVars;
                
                // Prepare progress display  
                const hasProgressData = goal.hasOwnProperty('startValue') && goal.hasOwnProperty('targetValue');
                console.log('🔍 hasProgressData:', hasProgressData);
                console.log('🔍 currentValue:', goal.currentValue, typeof goal.currentValue);
                const progressSection = hasProgressData ? `
                    <div class="goal-progress-section" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0;">
                        <div class="goal-values" style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem; color: #666;">
                            <span>${goal.startValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                            <span style="font-weight: 600; color: #000;">${goal.currentValue || goal.startValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                            <span>${goal.targetValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                        </div>
                        <div class="progress-container" style="background: #f0f0f0; height: 6px; border-radius: 3px; overflow: hidden;">
                            <div class="progress-fill" style="background: linear-gradient(90deg, #3b82f6, #1d4ed8); height: 100%; width: ${goal.progress || 0}%; transition: width 0.3s ease;"></div>
                        </div>
                        <div style="text-align: center; margin-top: 0.5rem; font-size: 0.9rem; font-weight: 600; color: #1d4ed8;">
                            ${goal.progress || 0}%
                        </div>
                    </div>
                ` : '';
                
                console.log('🔍 progressSection generated:', hasProgressData ? 'YES' : 'NO');
                console.log('🔍 progressSection length:', progressSection.length);

                goalCard.innerHTML = `
                    ${daysUntilText ? `<div class="ziel-days-until">${daysUntilText}</div>` : ''}
                    <div class="ziel-kategorie">${goal.category}</div>
                    ${formattedDeadline ? `<div class="termin-date">🎯 ${formattedDeadline}</div>` : ''}
                    <div class="termin-title">${goal.name}</div>
                    <div class="termin-description">${goal.description}</div>
                    ${progressSection}
                    <div class="termin-edit-icon" onclick="GoalManager.showEditGoalValueModal('${goal.id}')">✎</div>
                    <div class="termin-delete-icon" onclick="GoalManager.deleteGoal('${goal.id}')">🗑</div>
                `;
                
                return goalCard;
            },
            
            async updateGoalProgress(goalId, newProgress) {
                const goal = this.goals.find(g => g.id == goalId); // Use == for flexible ID matching
                if (goal) {
                    const oldProgress = goal.progress;
                    goal.progress = parseInt(newProgress);
                    goal.completed = goal.progress >= 100;
                    
                    console.log('🎯 Updating goal:', goal.name, 'to progress:', goal.progress);
                    
                    // Check if goal has real database ID or use database_id field
                    const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                    
                    if (supabase?.isAuthenticated() && dbId) {
                        try {
                            console.log('💾 Updating goal in database with ID:', dbId);
                            const result = await supabase.update('goals', { 
                                progress: goal.progress,
                                completed: goal.completed
                            }, dbId);
                            console.log('✅ Goal progress updated in cloud database:', result);
                        } catch (error) {
                            console.error('❌ Error updating goal progress:', error);
                            // Don't revert - keep local change even if DB fails
                            console.warn('⚠️ Goal updated locally only (database update failed)');
                        }
                    } else {
                        console.warn('⚠️ Goal updated locally only (no database ID or not authenticated)');
                    }
                    
                    console.log('✅ Goal progress updated locally:', goal);
                    this.refreshCurrentView();
                } else {
                    console.error('❌ Goal not found for ID:', goalId);
                }
            },
            
            showEditGoalValueModal(goalId) {
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                const currentValue = goal.currentValue || goal.startValue || 0;
                const unit = goal.unit ? ` ${goal.unit}` : '';
                
                // Set modal title and current status
                document.getElementById('edit-goal-modal-title').textContent = `Fortschritt für "${goal.name}"`;
                document.getElementById('edit-goal-current-status').innerHTML = `
                    <strong>Aktueller Status:</strong><br>
                    Start: <strong>${goal.startValue}${unit}</strong> → 
                    Ziel: <strong>${goal.targetValue}${unit}</strong><br>
                    Aktuell: <strong>${currentValue}${unit}</strong> 
                    (${goal.progress || 0}% erreicht)
                `;
                
                // Pre-fill current value
                document.getElementById('new-goal-value').value = currentValue;
                
                // Store goal ID for form submission
                document.getElementById('edit-goal-value-form').dataset.goalId = goalId;
                
                // Show modal
                document.getElementById('edit-goal-value-modal').classList.remove('hide');
                
                // Ensure event listeners are set up when modal opens
                console.log('🎯 Modal opened, reinitializing event listeners...');
                if (window.initGoalEditModalEventListeners) {
                    window.initGoalEditModalEventListeners();
                }
                
                // Focus input
                setTimeout(() => {
                    document.getElementById('new-goal-value').focus();
                    document.getElementById('new-goal-value').select();
                }, 100);
            },
            
            hideEditGoalValueModal() {
                document.getElementById('edit-goal-value-modal').classList.add('hide');
                document.getElementById('edit-goal-value-form').reset();
                delete document.getElementById('edit-goal-value-form').dataset.goalId;
            },
            
            async editGoalValue(goalId) {
                console.log('🎯 editGoalValue called with goalId:', goalId);
                
                // This method is now called by the modal form submission
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    console.error('❌ Goal not found for ID:', goalId);
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                console.log('🎯 Found goal:', goal.name, 'Current value:', goal.currentValue);
                
                const newValueInput = document.getElementById('new-goal-value').value;
                console.log('🎯 Input value:', newValueInput);
                
                const newValue = parseFloat(newValueInput);
                if (isNaN(newValue)) {
                    console.error('❌ Invalid number:', newValueInput);
                    alert('Bitte eine gültige Zahl eingeben!');
                    return;
                }
                
                console.log('🎯 Parsed new value:', newValue);
                
                // Pure cloud mode - require authentication
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ GoalManager: Not authenticated - cannot update goal value in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Ziel-Wert kann nicht aktualisiert werden.');
                    return;
                }
                
                const unit = goal.unit ? ` ${goal.unit}` : '';
                
                // Update values
                const oldCurrentValue = goal.currentValue;
                const oldProgress = goal.progress;
                
                goal.currentValue = newValue;
                goal.progress = this.calculateProgress(goal.startValue, goal.targetValue, goal.currentValue);
                goal.completed = goal.progress >= 100;
                
                console.log('🎯 Updated values:', {
                    oldCurrentValue,
                    newCurrentValue: goal.currentValue,
                    oldProgress,
                    newProgress: goal.progress,
                    startValue: goal.startValue,
                    targetValue: goal.targetValue
                });
                
                // Update in database - use database ID
                const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                console.log('🎯 Database ID for update:', dbId);
                
                if (dbId) {
                    try {
                        console.log('💾 Updating goal in database...');
                        const updateData = { 
                            current_value: goal.currentValue, // Use DB field name
                            progress: goal.progress,
                            completed: goal.completed
                        };
                        console.log('💾 Update data:', updateData);
                        
                        await supabase.update('goals', updateData, dbId);
                        console.log('✅ Goal value updated in database');
                    } catch (error) {
                        console.error('❌ Error updating goal value:', error);
                        alert('Fehler beim Speichern: ' + error.message);
                        return;
                    }
                } else {
                    console.error('❌ No valid database ID found for goal:', goal);
                    alert('Fehler: Kann Ziel nicht in der Datenbank aktualisieren (keine gültige ID).');
                    return;
                }
                
                // Hide modal and refresh view
                console.log('🎯 Hiding modal and refreshing view...');
                this.hideEditGoalValueModal();
                this.refreshCurrentView();
                
                console.log('✅ Goal value updated:', goal.name, `${goal.currentValue}${unit}`, `${goal.progress}%`);
            },
            
            async deleteGoal(goalId) {
                if (!confirm('Dieses Ziel ins Archiv verschieben?\n\n(Es wird als abgeschlossen markiert und ins Archiv verschoben)')) {
                    return;
                }
                
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    console.error('❌ Goal not found for archiving:', goalId);
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                console.log('📦 Archiving goal:', goal.name);
                
                // Mark as completed (move to archive)
                const oldCompleted = goal.completed;
                goal.completed = true;
                goal.progress = 100; // Set to 100% when archived
                
                // Update in database if authenticated and has real DB ID
                const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                
                if (supabase?.isAuthenticated() && dbId) {
                    try {
                        console.log('💾 Updating goal in database with ID:', dbId);
                        await supabase.update('goals', { 
                            completed: true,
                            progress: 100
                        }, dbId);
                        console.log('✅ Goal archived in database');
                    } catch (error) {
                        console.error('❌ Error archiving goal in database:', error);
                        alert('Fehler beim Archivieren: ' + error.message);
                        // Revert on error
                        goal.completed = oldCompleted;
                        return;
                    }
                }
                
                // Refresh current view
                this.refreshCurrentView();
                
                console.log('✅ Goal archived successfully:', goal.name);
            },
            
            async clearGoalArchive() {
                if (!confirm('Wirklich alle erledigten Ziele dauerhaft löschen?\n\nDiese Aktion kann nicht rückgängig gemacht werden!')) {
                    return;
                }
                
                const completedGoals = this.goals.filter(goal => goal.completed);
                console.log('🗑️ Deleting', completedGoals.length, 'completed goals from archive');
                
                if (supabase?.isAuthenticated()) {
                    try {
                        // Delete from database (only goals with database IDs)
                        for (const goal of completedGoals) {
                            const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                            if (hasDbId) {
                                await supabase.delete('goals', goal.id);
                                console.log('💾 Deleted goal from database:', goal.name);
                            } else {
                                console.log('💾 Skipped local-only goal:', goal.name);
                            }
                        }
                        console.log('✅ All database goals deleted');
                    } catch (error) {
                        console.error('❌ Error deleting goals from database:', error);
                        alert('Fehler beim Löschen aus der Datenbank: ' + error.message);
                        return;
                    }
                }
                
                // Remove from local array
                this.goals = this.goals.filter(goal => !goal.completed);
                
                // Refresh current view
                this.refreshCurrentView();
                
                alert(`✅ ${completedGoals.length} erledigte Ziele wurden gelöscht!`);
            },
            
            clearLocalGoals() {
                if (confirm('Alle lokalen Ziele löschen? (Nur Ziele die nicht in der Datenbank sind)\n\nDas kann alte/kaputte Ziele entfernen.')) {
                    const before = this.goals.length;
                    // Keep only goals that look like they have database IDs
                    this.goals = this.goals.filter(goal => {
                        const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                        return hasDbId;
                    });
                    const after = this.goals.length;
                    console.log(`🗑️ Removed ${before - after} local-only goals`);
                    this.refreshCurrentView();
                    alert(`${before - after} lokale Ziele gelöscht!`);
                }
            },
            
            editGoalProgress(goalId) {
                console.log('✏️ Edit goal progress - ID:', goalId, 'Type:', typeof goalId);
                const goal = this.goals.find(g => g.id == goalId); // Flexible matching
                if (!goal) {
                    console.error('❌ Goal not found for edit. ID:', goalId);
                    console.log('❌ Available goals:', this.goals.map(g => ({id: g.id, name: g.name})));
                    return;
                }
                console.log('✏️ Editing goal:', goal.name, 'Current progress:', goal.progress);
                
                // Find the goal card and progress percentage element
                const goalCard = document.querySelector(`[data-goal-id="${goalId}"]`);
                const percentageElement = goalCard.querySelector('.ziel-percentage');
                const progressFill = goalCard.querySelector('.progress-fill');
                
                // Create inline edit container
                const editContainer = document.createElement('div');
                editContainer.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; background: #f9f9f9; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px;';
                
                // Create progress input
                const input = document.createElement('input');
                input.type = 'number';
                input.min = '0';
                input.max = '100';
                input.value = goal.progress;
                input.style.cssText = 'width: 50px; padding: 2px 4px; border: 1px solid #ccc; font-size: 0.9rem; text-align: center;';
                
                // Create complete button
                const completeBtn = document.createElement('button');
                completeBtn.textContent = '✓ Erledigt';
                completeBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; border: 1px solid #28a745; background: #28a745; color: white; border-radius: 3px; cursor: pointer;';
                
                // Create cancel button
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = '×';
                cancelBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; border: 1px solid #ccc; background: #f8f9fa; border-radius: 3px; cursor: pointer;';
                
                editContainer.appendChild(input);
                editContainer.appendChild(completeBtn);
                editContainer.appendChild(cancelBtn);
                
                // Replace percentage display with edit container
                const originalText = percentageElement.textContent;
                percentageElement.replaceWith(editContainer);
                input.focus();
                input.select();
                
                // Prevent double execution
                let isHandled = false;
                
                // Handle save/cancel
                const saveProgress = async () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    const newValue = parseInt(input.value);
                    if (!isNaN(newValue) && newValue >= 0 && newValue <= 100) {
                        await this.updateGoalProgress(goalId, newValue);
                        
                        // Update UI
                        const newPercentageElement = document.createElement('span');
                        newPercentageElement.className = 'ziel-percentage';
                        newPercentageElement.textContent = `${newValue}%`;
                        editContainer.replaceWith(newPercentageElement);
                        
                        // Update progress bar
                        progressFill.style.width = `${newValue}%`;
                        
                        // Refresh view if goal completed
                        if (newValue >= 100) {
                            this.refreshCurrentView();
                        }
                    } else {
                        cancelEdit();
                    }
                };
                
                const markComplete = async () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    await this.updateGoalProgress(goalId, 100);
                    
                    // Update UI
                    const newPercentageElement = document.createElement('span');
                    newPercentageElement.className = 'ziel-percentage';
                    newPercentageElement.textContent = '100%';
                    editContainer.replaceWith(newPercentageElement);
                    
                    // Update progress bar
                    progressFill.style.width = '100%';
                    
                    // Refresh view to move to archive
                    this.refreshCurrentView();
                };
                
                const cancelEdit = () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    const newPercentageElement = document.createElement('span');
                    newPercentageElement.className = 'ziel-percentage';
                    newPercentageElement.textContent = originalText;
                    editContainer.replaceWith(newPercentageElement);
                };
                
                // Event listeners
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveProgress();
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
                
                completeBtn.addEventListener('click', markComplete);
                cancelBtn.addEventListener('click', cancelEdit);
                
                // Auto-save on blur for input
                input.addEventListener('blur', (e) => {
                    // Only if user didn't click on buttons
                    setTimeout(() => {
                        if (!isHandled && document.contains(editContainer)) {
                            saveProgress();
                        }
                    }, 100);
                });
            }
        };

        // Make GoalManager globally available
        window.GoalManager = GoalManager;

        // === JOURNAL MANAGEMENT ===
        const JournalManager = {
            entries: [], // In-memory storage for demo
            filteredEntries: [], // Filtered entries for display
            searchTimeout: null,
            
            async loadEntries() {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ JournalManager: Not authenticated - pure cloud mode requires authentication');
                    this.entries = [];
                    return;
                }
                
                try {
                    const data = await supabase.select('journal_entries', '*');
                    if (data && Array.isArray(data)) {
                        // Transform database data to ensure tags is always an array
                        this.entries = data.map(entry => {
                            let tags = [];
                            if (Array.isArray(entry.tags)) {
                                tags = entry.tags;
                            } else if (entry.tags) {
                                if (typeof entry.tags === 'string') {
                                    try {
                                        // Try to parse as JSON first
                                        tags = JSON.parse(entry.tags);
                                        if (!Array.isArray(tags)) {
                                            // If it's not an array, treat as single tag
                                            tags = [entry.tags];
                                        }
                                    } catch (e) {
                                        // If JSON.parse fails, treat as single tag
                                        tags = [entry.tags];
                                    }
                                } else {
                                    tags = [entry.tags];
                                }
                            }
                            return {
                                ...entry,
                                tags: tags
                            };
                        });
                        this.filteredEntries = [...this.entries]; // Initialize filtered entries
                        this.renderEntries();
                    } else {
                        console.log('☁️ JournalManager: No entries found in cloud');
                        this.entries = [];
                        this.filteredEntries = [];
                    }
                } catch (error) {
                    console.error('❌ JournalManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            showAddJournalModal() {
                const modal = document.getElementById('add-journal-modal');
                modal.classList.remove('hide');
            },
            
            hideAddJournalModal() {
                const modal = document.getElementById('add-journal-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-journal-form').reset();
            },
            
            async addEntry(entryData) {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ JournalManager: Not authenticated - cannot add entry in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Journal-Eintrag kann nicht gespeichert werden.');
                    return;
                }
                
                const entry = {
                    title: entryData.title,
                    content: entryData.content,
                    tags: entryData.tags || [], // Array of tags
                    date: entryData.date, // Keep date for local use
                    entry_date: entryData.date, // Use entry_date for database
                    user_id: supabase?.user?.id,
                    created_at: new Date().toISOString()
                };
                
                try {
                    // Create database entry without 'date' and 'created_at' fields (auto-generated)
                    const dbEntry = { ...entry };
                    delete dbEntry.date;
                    delete dbEntry.created_at;
                    console.log('☁️ JournalManager: Saving entry to cloud:', dbEntry);
                    const result = await supabase.insert('journal_entries', dbEntry);
                    if (result && result.length > 0) {
                        this.entries.push(result[0]);
                        console.log('☁️ JournalManager: Entry saved to cloud with ID:', result[0].id);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ JournalManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Journal-Eintrags: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('☁️ JournalManager: Entry added:', entry);
                
                // Update filtered entries and refresh view
                this.filteredEntries = [...this.entries];
                this.renderEntries();
            },
            
            renderEntries() {
                const container = document.getElementById('journal-entries');
                if (!container) return;
                
                // Use filteredEntries if available, otherwise use all entries
                const entriesToShow = this.filteredEntries.length > 0 || document.getElementById('journal-search').value 
                    ? this.filteredEntries 
                    : this.entries;
                
                if (this.entries.length === 0) {
                    container.innerHTML = '<div class="empty-journal">Keine Journal-Einträge vorhanden. Erstelle deinen ersten Eintrag!</div>';
                    return;
                }
                
                if (entriesToShow.length === 0) {
                    container.innerHTML = '<div class="empty-journal">Keine Einträge gefunden. Versuche andere Suchbegriffe oder Tags.</div>';
                    return;
                }
                
                // Sort entries by date (newest first)
                const sortedEntries = [...entriesToShow].sort((a, b) => 
                    new Date(b.created_at) - new Date(a.created_at)
                );
                
                let html = '';
                sortedEntries.forEach(entry => {
                    const date = new Date(entry.created_at).toLocaleDateString('de-DE');
                    const time = new Date(entry.created_at).toLocaleTimeString('de-DE', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                    
                    // Parse tags (handle both old category and new tags)
                    let tags = [];
                    if (entry.tags) {
                        if (typeof entry.tags === 'string') {
                            tags = entry.tags.split(',').map(tag => tag.trim()).filter(tag => tag);
                        } else if (Array.isArray(entry.tags)) {
                            tags = entry.tags;
                        }
                    } else if (entry.category) {
                        // Migration: use old category as a tag
                        tags = [entry.category];
                    }
                    
                    const tagsHtml = tags.map(tag => `<span class="journal-tag">${tag}</span>`).join('');
                    
                    html += `
                        <div class="journal-entry" data-entry-id="${entry.id}">
                            <div class="journal-entry-header">
                                <h3 class="journal-entry-title">${entry.title}</h3>
                                <div class="journal-entry-actions">
                                    <button class="delete-entry-btn" data-entry-id="${entry.id}" title="Eintrag löschen">
                                        <i data-lucide="trash-2" style="width: 16px; height: 16px;"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="journal-entry-content">${entry.content}</div>
                            <div class="journal-entry-meta">
                                <div class="journal-entry-tags">
                                    ${tagsHtml}
                                </div>
                                <span class="journal-entry-date">${date} • ${time}</span>
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
                
                // Initialize Lucide icons
                if (window.lucide) {
                    lucide.createIcons();
                }
                
                // Add right-click handlers for delete buttons
                this.addDeleteHandlers();
            },

            
            createEntryElement(entry) {
                const entryCard = document.createElement('div');
                entryCard.className = 'ziel-card';
                entryCard.dataset.entryId = entry.id;
                
                const entryDate = new Date(entry.entry_date || entry.date);
                const formattedDate = entryDate.toLocaleDateString('de-DE', {
                    day: '2-digit',
                    month: '2-digit', 
                    year: 'numeric'
                });
                
                // Ensure tags is always an array before mapping
                const tags = Array.isArray(entry.tags) ? entry.tags : 
                           (entry.tags ? (typeof entry.tags === 'string' ? JSON.parse(entry.tags) : []) : []);
                const tagsHtml = tags.length > 0 
                    ? tags.map(tag => `<span class="todo-tag normal" style="margin-right: 0.5rem;">${tag}</span>`).join('')
                    : '';
                
                entryCard.innerHTML = `
                    <div class="ziel-header">
                        <div class="ziel-name">${entry.title}</div>
                        <div class="ziel-beschreibung">${entry.content}</div>
                    </div>
                    <div class="ziel-progress-section">
                        <div class="ziel-progress-header">
                            <span class="ziel-progress-label">${formattedDate}</span>
                            <button class="delete-entry-btn" data-entry-id="${entry.id}" style="background: none; border: none; color: #cc0000; cursor: pointer; padding: 0.25rem; font-size: 0.9rem;" title="Eintrag löschen">
                                🗑️
                            </button>
                        </div>
                        <div style="margin-top: 0.5rem;">
                            ${tagsHtml}
                        </div>
                    </div>
                `;
                
                return entryCard;
            },
            
            async deleteEntry(entryId) {
                try {
                    // Delete from database if authenticated
                    if (supabase?.isAuthenticated()) {
                        await supabase.delete('journal_entries', entryId);
                        console.log('✅ Journal entry deleted from database:', entryId);
                    }
                    
                    // Remove from local entries array
                    this.entries = this.entries.filter(entry => entry.id != entryId);
                    this.filteredEntries = this.filteredEntries.filter(entry => entry.id != entryId);
                    
                    // Refresh current view
                    this.renderEntries();
                    
                    console.log('✅ Journal entry deleted:', entryId);
                } catch (error) {
                    console.error('❌ Error deleting journal entry:', error);
                    alert('Fehler beim Löschen des Eintrags: ' + error.message);
                }
            },

            addDeleteHandlers() {
                document.querySelectorAll('.journal-entry').forEach(entry => {
                    entry.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        
                        // Hide all other delete buttons first
                        document.querySelectorAll('.journal-entry').forEach(el => {
                            el.classList.remove('show-delete');
                        });
                        
                        // Show delete button for this entry
                        entry.classList.add('show-delete');
                        
                        // Hide delete button after 3 seconds
                        setTimeout(() => {
                            entry.classList.remove('show-delete');
                        }, 3000);
                    });
                    
                    // Hide delete button on regular click
                    entry.addEventListener('click', (e) => {
                        // Don't hide if clicking the delete button
                        if (!e.target.closest('.delete-entry-btn')) {
                            entry.classList.remove('show-delete');
                        }
                    });
                    
                    // Add delete button click handler
                    const deleteBtn = entry.querySelector('.delete-entry-btn');
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const entryId = deleteBtn.getAttribute('data-entry-id');
                            this.deleteEntry(entryId);
                        });
                    }
                });
            },

            search() {
                const query = document.getElementById('journal-search').value.toLowerCase();
                
                this.filteredEntries = this.entries.filter(entry => {
                    if (!query) return true;
                    
                    return entry.title.toLowerCase().includes(query) ||
                           entry.content.toLowerCase().includes(query) ||
                           this.getEntryTags(entry).some(tag => tag.toLowerCase().includes(query));
                });
                
                this.renderEntries();
            },

            getEntryTags(entry) {
                let tags = [];
                if (entry.tags) {
                    if (typeof entry.tags === 'string') {
                        tags = entry.tags.split(',').map(tag => tag.trim()).filter(tag => tag);
                    } else if (Array.isArray(entry.tags)) {
                        tags = entry.tags;
                    }
                } else if (entry.category) {
                    // Migration: use old category as a tag
                    tags = [entry.category];
                }
                return tags;
            }
        };

        // Make JournalManager globally available
        window.JournalManager = JournalManager;

        // === TERMIN MANAGEMENT ===
        const TerminManager = {
            termine: [], // In-memory storage for demo
            
            async loadTermine(forceReload = false) {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TerminManager: Not authenticated - pure cloud mode requires authentication');
                    this.termine = [];
                    this.displayTermine();
                    return;
                }
                
                try {
                    console.log('☁️ TerminManager: Loading termine from cloud...');
                    const user = supabase.getCurrentUser();
                    const data = await supabase.query(`termine?user_id=eq.${user.id}&select=*`);
                    
                    if (data && Array.isArray(data)) {
                        this.termine = data;
                        this.displayTermine();
                    } else {
                        console.log('☁️ TerminManager: No termine found in cloud');
                        this.termine = [];
                        this.displayTermine();
                    }
                } catch (error) {
                    console.error('❌ TerminManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            showAddTerminModal() {
                const modal = document.getElementById('add-termin-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('termin-date').value = today;
                
                // Leave time field empty - user can fill if needed
                document.getElementById('termin-time').value = '';
            },
            
            hideAddTerminModal() {
                const modal = document.getElementById('add-termin-modal');
                const form = document.getElementById('add-termin-form');
                const submitBtn = form.querySelector('button[type="submit"]');
                
                modal.classList.add('hide');
                form.reset();
                delete form.dataset.editId; // Clear edit mode
                if (submitBtn) {
                    submitBtn.textContent = 'Hinzufügen'; // Reset button text
                }
            },
            
            async addTermin(terminData) {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TerminManager: Not authenticated - cannot add termin in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Termin kann nicht gespeichert werden.');
                    return;
                }
                
                const termin = {
                    title: terminData.title,
                    description: terminData.description,
                    date: terminData.date,
                    time: terminData.time,
                    user_id: supabase.getCurrentUser().id,
                    created_at: new Date().toISOString()
                };
                
                try {
                    console.log('☁️ TerminManager: Saving termin to cloud:', termin.title);
                    const result = await supabase.insert('termine', termin);
                    if (result && result.length > 0) {
                        this.termine.push(result[0]);
                        console.log('☁️ TerminManager: Termin saved to cloud with ID:', result[0].id);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ TerminManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Termins: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('☁️ TerminManager: Termin added:', termin);
                this.displayTermine();
            },
            
            async updateTermin(terminId, terminData) {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TerminManager: Not authenticated - cannot update termin in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Termin kann nicht aktualisiert werden.');
                    return;
                }
                
                const terminIndex = this.termine.findIndex(t => t.id == terminId);
                if (terminIndex === -1) {
                    console.error('❌ TerminManager: Termin not found for update:', terminId);
                    alert('Termin nicht gefunden!');
                    return;
                }
                
                const updatedTermin = {
                    ...this.termine[terminIndex],
                    title: terminData.title,
                    description: terminData.description,
                    date: terminData.date,
                    time: terminData.time,
                    updated_at: new Date().toISOString()
                };
                
                try {
                    console.log('☁️ TerminManager: Updating termin in cloud:', terminId);
                    await supabase.update('termine', updatedTermin, terminId);
                    this.termine[terminIndex] = updatedTermin;
                    console.log('☁️ TerminManager: Termin updated in cloud');
                } catch (error) {
                    console.error('❌ TerminManager: Error updating in cloud:', error);
                    alert('Fehler beim Aktualisieren des Termins: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('☁️ TerminManager: Termin updated:', updatedTermin);
                this.displayTermine();
            },
            
            displayTermine() {
                console.log('📅 TerminManager.displayTermine() called');
                console.log('📊 Current termine in memory:', this.termine);
                
                const container = document.getElementById('termine-container');
                if (!container) {
                    console.error('❌ Termine container DOM element not found - check if #termine-container exists');
                    return;
                }
                
                console.log('✅ Termine container found:', container);
                
                // Clear container
                container.innerHTML = '';
                
                if (this.termine.length === 0) {
                    console.log('ℹ️ No termine to display - showing empty state message');
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem; grid-column: 1 / -1;">Keine Termine vorhanden</p>';
                    return;
                }
                
                
                // Sort by date/time (earliest first)
                const sortedTermine = this.termine.sort((a, b) => {
                    const dateTimeA = new Date(`${a.date}T${a.time || '00:00'}`);
                    const dateTimeB = new Date(`${b.date}T${b.time || '00:00'}`);
                    return dateTimeA - dateTimeB;
                });
                
                console.log('🔄 Termine sorted by date:', sortedTermine.map(t => `${t.title} - ${t.date}`));
                
                // Add termine
                sortedTermine.forEach((termin, index) => {
                    console.log(`🔄 Creating element for termin ${index + 1}:`, termin.title);
                    const terminElement = this.createTerminElement(termin);
                    container.appendChild(terminElement);
                });
                
                console.log('✅ All termine rendered to DOM');
            },
            
            createTerminElement(termin) {
                const terminCard = document.createElement('div');
                terminCard.className = 'termin-card';
                terminCard.dataset.terminId = termin.id;
                
                const terminDate = new Date(termin.date);
                const formattedDate = terminDate.toLocaleDateString('de-DE', {
                    weekday: 'long',
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                });
                
                let displayDate = formattedDate;
                if (termin.time) {
                    const timeDate = new Date(`${termin.date}T${termin.time}`);
                    const formattedTime = timeDate.toLocaleTimeString('de-DE', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    displayDate += `, ${formattedTime}`;
                }
                
                // Calculate days until appointment
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const appointmentDate = new Date(termin.date);
                appointmentDate.setHours(0, 0, 0, 0);
                const daysDifference = Math.ceil((appointmentDate - today) / (1000 * 60 * 60 * 24));
                
                let daysUntilText = '';
                let badgeColor1 = '';
                let badgeColor2 = '';
                
                if (daysDifference === 0) {
                    daysUntilText = 'Heute';
                    badgeColor1 = '#ef4444';
                    badgeColor2 = '#dc2626';
                } else if (daysDifference === 1) {
                    daysUntilText = 'Morgen';
                    badgeColor1 = '#f97316';
                    badgeColor2 = '#ea580c';
                } else if (daysDifference === -1) {
                    daysUntilText = 'Gestern';
                    badgeColor1 = '#6b7280';
                    badgeColor2 = '#4b5563';
                } else if (daysDifference > 1) {
                    daysUntilText = `in ${daysDifference} Tagen`;
                    badgeColor1 = '#3b82f6';
                    badgeColor2 = '#2563eb';
                } else if (daysDifference < -1) {
                    daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                    badgeColor1 = '#6b7280';
                    badgeColor2 = '#4b5563';
                }
                
                // Set CSS custom properties for badge colors
                const badgeColorVars = `--badge-color-1: ${badgeColor1}; --badge-color-2: ${badgeColor2};`;
                
                terminCard.style.cssText += badgeColorVars;
                
                terminCard.innerHTML = `
                    <div class="termin-days-until">${daysUntilText}</div>
                    <div class="termin-date">${displayDate}</div>
                    <div class="termin-title">${termin.title}</div>
                    <div class="termin-description">${termin.description}</div>
                    <div class="termin-edit-icon" onclick="TerminManager.editTermin('${termin.id}')">✎</div>
                    <div class="termin-delete-icon" onclick="TerminManager.deleteTermin('${termin.id}')">🗑</div>
                `;
                
                return terminCard;
            },
            
            async editTermin(terminId) {
                console.log('🖊️ Edit termin clicked:', terminId);
                console.log('📋 Available termine:', this.termine);
                
                const termin = this.termine.find(t => t.id == terminId);
                if (!termin) {
                    console.error('❌ Termin not found:', terminId);
                    alert('Termin nicht gefunden!');
                    return;
                }
                
                console.log('✅ Found termin for editing:', termin);
                
                // Pre-fill the form with existing values
                document.getElementById('termin-title').value = termin.title;
                document.getElementById('termin-description').value = termin.description;
                document.getElementById('termin-date').value = termin.date;
                document.getElementById('termin-time').value = termin.time || '';
                
                // Store the ID for updating
                const form = document.getElementById('add-termin-form');
                form.dataset.editId = terminId;
                
                // Change button text
                const submitBtn = form.querySelector('button[type="submit"]');
                submitBtn.textContent = 'Termin aktualisieren';
                
                console.log('📝 Form prepared for editing, opening modal...');
                
                // Show modal
                this.showAddTerminModal();
            },
            
            async deleteTermin(terminId) {
                if (!confirm('Möchtest du diesen Termin wirklich löschen?')) {
                    return;
                }
                
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TerminManager: Not authenticated - cannot delete termin in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Termin kann nicht gelöscht werden.');
                    return;
                }
                
                try {
                    console.log('☁️ TerminManager: Deleting termin from cloud:', terminId);
                    await supabase.delete('termine', terminId);
                    console.log('☁️ TerminManager: Termin deleted from cloud');
                } catch (error) {
                    console.error('❌ TerminManager: Error deleting from cloud:', error);
                    alert('Fehler beim Löschen: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                // Remove from local array
                this.termine = this.termine.filter(t => t.id != terminId);
                
                // Pure cloud mode - no localStorage caching
                
                // Refresh view
                this.displayTermine();
                
                console.log('☁️ TerminManager: Termin deleted successfully');
            }
        };

        // Make TerminManager globally available
        window.TerminManager = TerminManager;

        // === INITIALIZE ===
        document.addEventListener('DOMContentLoaded', async () => {
            // Logout is now handled by separate logout.html page
            
            console.log('✅ DOM loaded');
            
            // Initialize Supabase first
            if (window.initializeSupabase) {
                window.initializeSupabase();
            }
            
            // Initialize authentication (this will handle data loading via showDashboard)
            await Auth.init();
            
            // Initialize Wiki
            if (window.Wiki) {
                Wiki.init();
            }
            
            // Initialize Lucide icons globally
            if (window.lucide) {
                lucide.createIcons();
            }
            
            // ResourceManager will be initialized after its definition (moved down)
            
            // Logout button is already handled by Auth.setupEventListeners()
            
            // Journal form submission
            const journalForm = document.querySelector('.journal-form');
            if (journalForm) {
                journalForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const input = this.querySelector('.journal-input');
                    if (input.value.trim()) {
                        console.log('Journal entry:', input.value);
                        input.value = '';
                    }
                });
            }
            
            // Add Todo Button
            const addTodoBtn = document.getElementById('add-todo-btn');
            if (addTodoBtn) {
                addTodoBtn.addEventListener('click', () => {
                    TodoManager.showAddTodoModal();
                });
            }
            
            // Clear Archive Button
            const clearArchiveBtn = document.getElementById('clear-archive-btn');
            if (clearArchiveBtn) {
                clearArchiveBtn.addEventListener('click', () => {
                    TodoManager.clearArchive();
                });
            }
            
            // Cancel Todo Button
            const cancelTodoBtn = document.getElementById('cancel-todo-btn');
            if (cancelTodoBtn) {
                cancelTodoBtn.addEventListener('click', () => {
                    TodoManager.hideAddTodoModal();
                });
            }
            
            // Add Todo Form Submission
            const addTodoForm = document.getElementById('add-todo-form');
            if (addTodoForm) {
                addTodoForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const todoData = {
                        title: document.getElementById('todo-title').value,
                        category: document.getElementById('todo-category').value,
                        priority: document.getElementById('todo-priority').value,
                        deadline: document.getElementById('todo-deadline').value,
                        time: document.getElementById('todo-time').value
                    };
                    
                    console.log('📝 Form data being sent:', todoData);
                    console.log('📝 Priority element value:', document.getElementById('todo-priority').value);
                    console.log('📝 Priority element selectedIndex:', document.getElementById('todo-priority').selectedIndex);
                    
                    await TodoManager.addTodo(todoData);
                    TodoManager.hideAddTodoModal();
                });
            }
            
            // Close modal when clicking outside
            const addTodoModal = document.getElementById('add-todo-modal');
            if (addTodoModal) {
                addTodoModal.addEventListener('click', (e) => {
                    if (e.target === addTodoModal) {
                        TodoManager.hideAddTodoModal();
                    }
                });
            }
            
            // === GOAL EVENT LISTENERS ===
            
            // Add Goal Button
            const addGoalBtn = document.getElementById('add-goal-btn');
            if (addGoalBtn) {
                addGoalBtn.addEventListener('click', () => {
                    GoalManager.showAddGoalModal();
                });
            }
            
            // Cancel Goal Button
            const cancelGoalBtn = document.getElementById('cancel-goal-btn');
            if (cancelGoalBtn) {
                cancelGoalBtn.addEventListener('click', () => {
                    GoalManager.hideAddGoalModal();
                });
            }
            
            // Add Goal Form Submission
            const addGoalForm = document.getElementById('add-goal-form');
            if (addGoalForm) {
                addGoalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const goalData = {
                        name: document.getElementById('goal-name').value,
                        description: document.getElementById('goal-description').value,
                        category: document.getElementById('goal-category').value,
                        timeframe: document.getElementById('goal-timeframe').value,
                        deadline: document.getElementById('goal-deadline').value,
                        unit: document.getElementById('goal-unit').value,
                        startValue: parseFloat(document.getElementById('goal-start-value').value) || 0,
                        targetValue: parseFloat(document.getElementById('goal-target-value').value)
                    };
                    
                    await GoalManager.addGoal(goalData);
                    GoalManager.hideAddGoalModal();
                });
            }
            
            // Timeframe change listener - automatically update deadline
            const goalTimeframeSelect = document.getElementById('goal-timeframe');
            if (goalTimeframeSelect) {
                goalTimeframeSelect.addEventListener('change', (e) => {
                    const deadlineInput = document.getElementById('goal-deadline');
                    if (deadlineInput) {
                        deadlineInput.value = GoalManager.calculateDeadline(e.target.value);
                    }
                });
            }
            
            // Close goal modal when clicking outside
            const addGoalModal = document.getElementById('add-goal-modal');
            if (addGoalModal) {
                addGoalModal.addEventListener('click', (e) => {
                    if (e.target === addGoalModal) {
                        GoalManager.hideAddGoalModal();
                    }
                });
            }
            
            // Clear Goal Archive Button
            const clearGoalArchiveBtn = document.getElementById('clear-goal-archive-btn');
            if (clearGoalArchiveBtn) {
                clearGoalArchiveBtn.addEventListener('click', () => {
                    GoalManager.clearGoalArchive();
                });
            }
            
            // === WIKI EVENT LISTENERS ===
            
            // Cancel Wiki Button
            const cancelWikiBtn = document.getElementById('cancel-wiki-btn');
            if (cancelWikiBtn) {
                cancelWikiBtn.addEventListener('click', () => {
                    Wiki.hideAddModal();
                });
            }
            
            // Close wiki modal when clicking outside
            const addWikiModal = document.getElementById('add-wiki-modal');
            if (addWikiModal) {
                addWikiModal.addEventListener('click', (e) => {
                    if (e.target === addWikiModal) {
                        Wiki.hideAddModal();
                    }
                });
            }
            
            // === JOURNAL EVENT LISTENERS ===
            

            // Journal Search Input
            const journalSearchInput = document.getElementById('journal-search');
            if (journalSearchInput) {
                journalSearchInput.addEventListener('input', () => {
                    clearTimeout(JournalManager.searchTimeout);
                    JournalManager.searchTimeout = setTimeout(() => JournalManager.search(), 300);
                });
            }
            
            // Cancel Journal Button
            const cancelJournalBtn = document.getElementById('cancel-journal-btn');
            if (cancelJournalBtn) {
                cancelJournalBtn.addEventListener('click', () => {
                    JournalManager.hideAddJournalModal();
                });
            }
            // Add Journal Form Submission
            const addJournalForm = document.getElementById('add-journal-form');
            if (addJournalForm) {
                addJournalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const tagsInput = document.getElementById('journal-tags').value.trim();
                    const tags = tagsInput ? tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag) : ['allgemein'];
                    
                    const entryData = {
                        title: document.getElementById('journal-title').value,
                        content: document.getElementById('journal-content').value,
                        tags: tags
                    };
                    
                    await JournalManager.addEntry(entryData);
                    JournalManager.hideAddJournalModal();
                });
            }
            
            // Close journal modal when clicking outside
            const addJournalModal = document.getElementById('add-journal-modal');
            if (addJournalModal) {
                addJournalModal.addEventListener('click', (e) => {
                    if (e.target === addJournalModal) {
                        JournalManager.hideAddJournalModal();
                    }
                });
            }
            
            // === TERMIN EVENT LISTENERS ===
            
            // Add Termin Button
            const addTerminBtn = document.getElementById('add-termin-btn');
            if (addTerminBtn) {
                addTerminBtn.addEventListener('click', () => {
                    TerminManager.showAddTerminModal();
                });
            }
            
            // Cancel Termin Button
            const cancelTerminBtn = document.getElementById('cancel-termin-btn');
            if (cancelTerminBtn) {
                cancelTerminBtn.addEventListener('click', () => {
                    TerminManager.hideAddTerminModal();
                });
            }
            
            // Add Termin Form Submission
            const addTerminForm = document.getElementById('add-termin-form');
            if (addTerminForm) {
                addTerminForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const terminData = {
                        title: document.getElementById('termin-title').value,
                        description: document.getElementById('termin-description').value,
                        date: document.getElementById('termin-date').value,
                        time: document.getElementById('termin-time').value
                    };
                    
                    // Check if we're editing an existing termin
                    const editId = addTerminForm.dataset.editId;
                    if (editId) {
                        await TerminManager.updateTermin(editId, terminData);
                    } else {
                        await TerminManager.addTermin(terminData);
                    }
                    
                    TerminManager.hideAddTerminModal();
                });
            }
            
            // Close termin modal when clicking outside
            const addTerminModal = document.getElementById('add-termin-modal');
            if (addTerminModal) {
                addTerminModal.addEventListener('click', (e) => {
                    if (e.target === addTerminModal) {
                        TerminManager.hideAddTerminModal();
                    }
                });
            }
            
            // Load routine states on page load
            loadRoutineStates();
            
            // Update routine progress to reflect loaded states
            updateRoutineProgress();
            
            // Initialize settings functionality
            initializeSettings();
            
            // Todo counter is now initialized in showDashboard() after authentication
            
            // === EDIT GOAL VALUE MODAL EVENT LISTENERS ===
            // Event listeners are now set up globally at the end of the script
            
            // === RESOURCE MANAGER ===
            const ResourceManager = {
                resources: [],
                
                async loadResources() {
                    if (!supabase?.isAuthenticated()) {
                        console.error('❌ ResourceManager: Not authenticated - pure cloud mode requires authentication');
                        this.resources = [];
                        this.renderResources();
                        return;
                    }
                    
                    try {
                        console.log('☁️ ResourceManager: Loading resources from cloud...');
                        this.resources = await cloudStorage.getResources() || [];
                        
                        // Migrate old emoji icons to lucide icons (one-time migration)
                        this.migrateEmojiIcons();
                        
                        this.renderResources();
                        console.log('☁️ ResourceManager: Load completed');
                    } catch (error) {
                        console.error('❌ ResourceManager: Error loading from cloud:', error);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                },
                
                renderResources() {
                    console.log('🎨 ResourceManager.renderResources() called with', this.resources.length, 'resources');
                    // Render all categories at once in block layout
                    this.displayResourcesForCategory('privat');
                    this.displayResourcesForCategory('crypto'); 
                    this.displayResourcesForCategory('arbeit');
                    this.displayResourcesForCategory('uni');
                },
                
                displayResourcesForCategory(category) {
                    const container = document.getElementById(`resource-${category}`);
                    if (!container) return;
                    
                    let filteredResources = [];
                    
                    switch(category) {
                        case 'privat':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Privat'
                            );
                            break;
                        case 'arbeit':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Arbeit'
                            );
                            break;
                        case 'uni':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Uni'
                            );
                            break;
                        case 'crypto':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Crypto'
                            );
                            break;
                    }
                    
                    let html = '';
                    
                    if (filteredResources.length === 0) {
                        html = '<div class="empty-resources">Keine Resources vorhanden</div>';
                    } else {
                        filteredResources.forEach(resource => {
                            const icon = resource.icon || 'link';
                            const description = resource.description || '';
                            html += `
                                <div class="resource-item" 
                                     onclick="window.open('${resource.url}', '_blank')"
                                     oncontextmenu="event.preventDefault(); ResourceManager.showDeleteConfirm('${resource.id}')"
                                     title="Rechtsklick zum Löschen">
                                    <div class="resource-info">
                                        <div class="resource-icon">
                                            <i data-lucide="${icon}" style="width: 16px; height: 16px;"></i>
                                        </div>
                                        <div class="resource-details">
                                            <div class="resource-title">${resource.title}</div>
                                            ${description ? `<div class="resource-description">${description}</div>` : ''}
                                        </div>
                                    </div>
                                </div>
                            `;
                        });
                    }
                    
                    container.innerHTML = html;
                    
                    // Enhanced Lucide initialization with icon verification
                    setTimeout(() => {
                        if (window.lucide) {
                            lucide.createIcons();
                            console.log('🎨 Lucide icons initialized for resource category:', category);
                            
                            // Verify icons are actually rendered
                            setTimeout(() => {
                                const actionBtns = container.querySelectorAll('.resource-actions');
                                
                                actionBtns.forEach((actions, index) => {
                                    const buttons = actions.querySelectorAll('button');
                                    const icons = actions.querySelectorAll('svg');
                                    
                                    // Force re-render if icons missing
                                    if (buttons.length > 0 && icons.length === 0) {
                                        console.log('⚠️ Missing icons detected, forcing re-render...');
                                        lucide.createIcons();
                                    }
                                });
                            }, 50);
                        }
                    }, 150);
                },
                
                showAddResourceModal(preselectedCategory = null) {
                    const modal = document.getElementById('add-resource-modal');
                    modal.classList.remove('hide');
                    
                    // Preselect category if provided
                    if (preselectedCategory) {
                        const categorySelect = document.getElementById('resource-category');
                        const categoryMapping = {
                            'privat': 'Privat',
                            'crypto': 'Crypto', 
                            'arbeit': 'Arbeit',
                            'uni': 'Uni'
                        };
                        const mappedCategory = categoryMapping[preselectedCategory];
                        if (mappedCategory && categorySelect) {
                            categorySelect.value = mappedCategory;
                        }
                    }
                    
                    document.getElementById('resource-title').focus();
                },
                
                hideAddResourceModal() {
                    const modal = document.getElementById('add-resource-modal');
                    modal.classList.add('hide');
                    document.getElementById('add-resource-form').reset();
                },

                showDeleteConfirm(resourceId, resourceTitle) {
                    // Hide any existing delete icons first
                    document.querySelectorAll('.delete-overlay').forEach(overlay => overlay.remove());
                    
                    // Find the resource item
                    const resourceItem = event.target.closest('.resource-item');
                    if (!resourceItem) return;
                    
                    // Create delete overlay
                    const deleteOverlay = document.createElement('div');
                    deleteOverlay.className = 'delete-overlay';
                    deleteOverlay.innerHTML = `
                        <div class="delete-icon" onclick="event.stopPropagation(); ResourceManager.confirmDelete('${resourceId}')">
                            <i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>
                        </div>
                    `;
                    
                    resourceItem.appendChild(deleteOverlay);
                    
                    // Initialize lucide icons for the new delete icon
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                    
                    // Auto-hide after 3 seconds or when clicking elsewhere
                    setTimeout(() => deleteOverlay.remove(), 3000);
                    
                    // Hide when clicking elsewhere
                    const hideOnClick = (e) => {
                        if (!deleteOverlay.contains(e.target)) {
                            deleteOverlay.remove();
                            document.removeEventListener('click', hideOnClick);
                        }
                    };
                    setTimeout(() => document.addEventListener('click', hideOnClick), 100);
                },

                confirmDelete(resourceId) {
                    // Remove the overlay
                    document.querySelectorAll('.delete-overlay').forEach(overlay => overlay.remove());
                    // Delete the resource
                    this.deleteResource(resourceId);
                },
                
                async addResource(resourceData) {
                    if (!supabase?.isAuthenticated()) {
                        console.error('❌ ResourceManager: Not authenticated - cannot add resource in pure cloud mode');
                        alert('Fehler: Nicht authentifiziert. Resource kann nicht gespeichert werden.');
                        return;
                    }
                    
                    const resource = {
                        title: resourceData.title,
                        category: resourceData.category,
                        url: resourceData.url,
                        description: resourceData.description || '',
                        icon: resourceData.icon || 'link',
                        user_id: supabase.getCurrentUser().id,
                        created_at: new Date().toISOString()
                    };
                    
                    try {
                        console.log('☁️ ResourceManager: Saving resource to cloud:', resource.title);
                        await cloudStorage.saveResource(resource);
                        console.log('☁️ ResourceManager: Resource saved to cloud successfully');
                        
                        // Reload resources from cloud to get updated data with proper IDs
                        console.log('🔄 Reloading resources to get updated list...');
                        await this.loadResources();
                        
                        console.log('☁️ ResourceManager: Resource added:', resource.title);
                    } catch (error) {
                        console.error('❌ ResourceManager: Error saving resource:', error);
                        alert('Fehler beim Speichern der Resource: ' + error.message);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                },
                
                async deleteResource(resourceId) {
                    if (!supabase?.isAuthenticated()) {
                        console.error('❌ ResourceManager: Not authenticated - cannot delete resource in pure cloud mode');
                        alert('Fehler: Nicht authentifiziert. Resource kann nicht gelöscht werden.');
                        return;
                    }
                    
                    try {
                        console.log('☁️ ResourceManager: Deleting resource from cloud:', resourceId);
                        await cloudStorage.deleteResource(resourceId);
                        console.log('☁️ ResourceManager: Resource deleted from cloud successfully');
                        
                        // Pure cloud mode - no localStorage
                        
                        // Reload resources from cloud to get updated list
                        await this.loadResources();
                        
                        console.log('☁️ ResourceManager: Resource deleted and UI updated');
                    } catch (error) {
                        console.error('❌ ResourceManager: Error deleting resource:', error);
                        alert('Fehler beim Löschen der Resource: ' + error.message);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                },
                
                editResource(resourceId) {
                    const resource = this.resources.find(r => r.id === resourceId);
                    if (!resource) return;
                    
                    // Populate form with existing data
                    document.getElementById('resource-title').value = resource.title;
                    document.getElementById('resource-category').value = resource.category;
                    document.getElementById('resource-url').value = resource.url;
                    document.getElementById('resource-description').value = resource.description || '';
                    document.getElementById('resource-icon').value = resource.icon || '';
                    
                    // Mark form as editing
                    const form = document.getElementById('add-resource-form');
                    form.dataset.editId = resourceId;
                    
                    this.showAddResourceModal();
                },
                
                selectIcon(iconName) {
                    const iconInput = document.getElementById('resource-icon');
                    if (iconInput) {
                        iconInput.value = iconName;
                    }
                },
                
                toggleIconInput() {
                    const iconInput = document.getElementById('resource-icon');
                    const toggleBtn = event.target;
                    
                    if (iconInput.readOnly) {
                        iconInput.readOnly = false;
                        iconInput.placeholder = 'Type lucide icon name manually...';
                        iconInput.focus();
                        toggleBtn.textContent = 'Use icon palette';
                    } else {
                        iconInput.readOnly = true;
                        iconInput.placeholder = 'Click icon below or type manually';
                        toggleBtn.textContent = 'Enable manual typing';
                    }
                },
                
                migrateEmojiIcons() {
                    const emojiToLucideMap = {
                        '📧': 'mail',
                        '💼': 'briefcase',
                        '📚': 'book',
                        '🏠': 'home',
                        '💬': 'message-circle',
                        '🏦': 'building',
                        '🔧': 'wrench',
                        '📊': 'bar-chart-3',
                        '📝': 'file-text',
                        '👥': 'users',
                        '🌐': 'globe',
                        '💰': 'dollar-sign',
                        '🎯': 'target',
                        '⚡': 'zap',
                        '🔐': 'lock',
                        '🔗': 'link',
                        '🚀': 'rocket',
                        '🎨': 'palette',
                        '🏃': 'activity',
                        '🤖': 'bot',
                        '🌱': 'sprout'
                    };
                    
                    if (!supabase?.isAuthenticated()) {
                        return; // Skip migration if not authenticated
                    }
                    
                    let migrationNeeded = false;
                    
                    this.resources.forEach(resource => {
                        if (emojiToLucideMap[resource.icon]) {
                            console.log(`🔄 Migrating icon for "${resource.title}": ${resource.icon} → ${emojiToLucideMap[resource.icon]}`);
                            resource.icon = emojiToLucideMap[resource.icon];
                            migrationNeeded = true;
                        }
                    });
                    
                    if (migrationNeeded) {
                        console.log('☁️ Icon migration completed, saving to cloud');
                        // Pure cloud mode - only save to cloud
                        this.resources.forEach(resource => cloudStorage.saveResource(resource));
                    }
                },
                
            };
            
            // Make ResourceManager global
            window.ResourceManager = ResourceManager;
            
            // Initialize ResourceManager now that it's properly defined
            console.log('🔄 Initializing ResourceManager after definition...');
            ResourceManager.loadResources();

            // === QUICK NOTES FUNCTIONALITY ===
            const QuickNotes = {
                textarea: null,
                saveTimeout: null,

                init() {
                    this.textarea = document.getElementById('quicknotes-textarea');
                    if (!this.textarea) return;

                    // Load existing notes
                    this.loadNotes();
                    
                    // Initial auto-resize
                    this.autoResize();

                    // Auto-save on input with debounce + auto-resize
                    this.textarea.addEventListener('input', () => {
                        this.autoResize();
                        clearTimeout(this.saveTimeout);
                        this.saveTimeout = setTimeout(() => {
                            this.saveNotes();
                        }, 1000); // Save 1 second after user stops typing
                    });

                    // Save on blur (when user clicks away)
                    this.textarea.addEventListener('blur', () => {
                        clearTimeout(this.saveTimeout);
                        this.saveNotes();
                    });
                },

                async loadNotes() {
                    try {
                        if (!window.cloudStorage) return;
                        
                        const notes = await window.cloudStorage.getNotes('quicknotes');
                        if (notes && this.textarea) {
                            this.textarea.value = notes;
                            // Auto-resize after loading content
                            setTimeout(() => this.autoResize(), 100);
                        }
                    } catch (error) {
                        console.error('Error loading quick notes:', error);
                    }
                },

                autoResize() {
                    if (!this.textarea) return;
                    
                    // Reset height to auto to get correct scrollHeight
                    this.textarea.style.height = 'auto';
                    
                    // Set height to scrollHeight (content height)
                    const newHeight = Math.max(200, this.textarea.scrollHeight);
                    this.textarea.style.height = newHeight + 'px';
                },

                async saveNotes() {
                    try {
                        if (!window.cloudStorage || !this.textarea) return;
                        
                        const content = this.textarea.value;
                        await window.cloudStorage.saveNotes('quicknotes', content);
                        console.log('☁️ Quick notes saved to cloud');
                    } catch (error) {
                        console.error('Error saving quick notes:', error);
                    }
                }
            };

            // Initialize Quick Notes when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => QuickNotes.init());
            } else {
                QuickNotes.init();
            }

            // Make QuickNotes global for debugging
            window.QuickNotes = QuickNotes;
            
            
            // === JOURNAL DELETE BUTTONS ===
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-entry-btn')) {
                    const entryId = e.target.dataset.entryId;
                    if (entryId) {
                        JournalManager.deleteEntry(entryId);
                    }
                }
            });

            // === RESOURCE EVENT LISTENERS ===
            
            // Add Resource Button
            const addResourceBtn = document.getElementById('add-resource-btn');
            if (addResourceBtn) {
                addResourceBtn.addEventListener('click', () => {
                    ResourceManager.showAddResourceModal();
                });
            }

            // Add to Category Buttons
            const addToCategoryBtns = document.querySelectorAll('.add-to-category-btn');
            addToCategoryBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const category = btn.getAttribute('data-category');
                    ResourceManager.showAddResourceModal(category);
                });
            });
            
            // Add Resource Form Submission
            const addResourceForm = document.getElementById('add-resource-form');
            if (addResourceForm) {
                addResourceForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const resourceData = {
                        title: document.getElementById('resource-title').value,
                        category: document.getElementById('resource-category').value,
                        url: document.getElementById('resource-url').value,
                        description: document.getElementById('resource-description').value,
                        icon: document.getElementById('resource-icon').value
                    };
                    
                    // Check if we're editing an existing resource
                    const editId = addResourceForm.dataset.editId;
                    if (editId) {
                        // Update existing resource
                        const resource = ResourceManager.resources.find(r => r.id === editId);
                        if (resource) {
                            if (!supabase?.isAuthenticated()) {
                                console.error('❌ ResourceManager: Not authenticated - cannot update resource in pure cloud mode');
                                alert('Fehler: Nicht authentifiziert. Resource kann nicht aktualisiert werden.');
                                return;
                            }
                            
                            Object.assign(resource, resourceData);
                            try {
                                console.log('☁️ ResourceManager: Updating resource in cloud:', resource.title);
                                await cloudStorage.saveResource(resource);
                                ResourceManager.renderResources();
                                console.log('☁️ ResourceManager: Resource updated:', resource.title);
                            } catch (error) {
                                console.error('❌ ResourceManager: Error updating resource:', error);
                                alert('Fehler beim Aktualisieren der Resource: ' + error.message);
                                throw error; // Don't hide errors in pure cloud mode
                            }
                        }
                        // Clear edit mode
                        delete addResourceForm.dataset.editId;
                    } else {
                        // Add new resource
                        await ResourceManager.addResource(resourceData);
                    }
                    
                    ResourceManager.hideAddResourceModal();
                });
            }
            
            // Close resource modal when clicking outside
            const addResourceModal = document.getElementById('add-resource-modal');
            if (addResourceModal) {
                addResourceModal.addEventListener('click', (e) => {
                    if (e.target === addResourceModal) {
                        ResourceManager.hideAddResourceModal();
                    }
                });
            }
            
            // Render resources when Resources tab is selected (don't reload from scratch)
            const ressourcenTab = document.querySelector('[data-tab="ressourcen"]');
            if (ressourcenTab) {
                ressourcenTab.addEventListener('click', () => {
                    // Only render existing resources, don't reload from cloud/storage
                    ResourceManager.renderResources();
                    console.log('🎨 Resources tab clicked - rendering existing resources');
                });
            }
            
            // ResourceManager initialization moved to main DOMContentLoaded listener
            
            // === SIMPLE LOGOUT (URL-based) ===
            console.log('✅ Logout is now URL-based, no JavaScript needed');
            
            // === ROUTINE RESET FUNCTIONALITY ===
            // Use event delegation to catch button clicks even if tab is loaded later
            document.addEventListener('click', async function(e) {
                if (e.target && e.target.id === 'reset-routines-btn') {
                    console.log('🖱️ Reset routines button clicked');
                    
                    const confirmed = confirm(
                        '⚠️ ACHTUNG: Routine-Datenbank komplett zurücksetzen?\n\n' +
                        '• Löscht ALLE Routine-Daten (lokal und cloud)\n' +
                        '• Setzt alle Counter auf 0\n' +
                        '• Betrifft alle Geräte\n' +
                        '• Kann nicht rückgängig gemacht werden\n\n' +
                        'Fortfahren?'
                    );
                    
                    if (confirmed) {
                        console.log('✅ User confirmed reset');
                        const success = await resetRoutineDatabase();
                        if (success) {
                            alert('✅ Routine-Datenbank wurde komplett zurückgesetzt!\n\nBitte refreshe die Seite auf allen Geräten.');
                            window.location.reload();
                        } else {
                            alert('❌ Fehler beim Zurücksetzen. Bitte Console prüfen.');
                        }
                    } else {
                        console.log('❌ User cancelled reset');
                    }
                }
            });
            
            // Complete Routine Database Reset Function
            async function resetRoutineDatabase() {
                console.log('🔄 Starting complete routine database reset...');
                
                try {
                    // 1. Clear all localStorage routine data (old and new)
                    const keysToRemove = [
                        'routineCompletionData',
                        'routine_completions_cache', 
                        'monthlyRoutineCompletions',
                        'routineData',
                        'lastRoutineResetDate',
                        'routineResetTime',
                        'morningRoutineStreak',
                        'eveningRoutineStreak',
                        'simple_routine_data' // New system
                    ];
                    
                    keysToRemove.forEach(key => {
                        if (localStorage.getItem(key)) {
                            localStorage.removeItem(key);
                            console.log(`🗑️ Removed localStorage: ${key}`);
                        }
                    });
                    
                    // 2. Clear Supabase tables if authenticated
                    if (window.supabase && window.supabase.isAuthenticated()) {
                        const user = window.supabase.getCurrentUser();
                        console.log('🔄 Clearing cloud routine data for user:', user.email);
                        
                        try {
                            // Delete old system data
                            await window.supabase.delete('routine_completions', `user_id=eq.${user.id}`);
                            console.log('✅ Cleared old routine_completions table');
                            
                            // Delete new system data
                            await window.supabase.delete('simple_routines', `user_id=eq.${user.id}`);
                            console.log('✅ Cleared new simple_routines table');
                        } catch (error) {
                            console.warn('⚠️ Could not clear cloud data:', error);
                        }
                    }
                    
                    // 3. Reset routine checkboxes on page
                    const morningCheckboxes = document.querySelectorAll('#morning-routine input[type="checkbox"]');
                    const eveningCheckboxes = document.querySelectorAll('#evening-routine input[type="checkbox"]');
                    
                    [...morningCheckboxes, ...eveningCheckboxes].forEach(checkbox => {
                        checkbox.checked = false;
                        const label = checkbox.nextElementSibling;
                        if (label) {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    });
                    console.log('✅ Reset all routine checkboxes');
                    
                    // 4. Reset routine counters to 0 - DISABLED to prevent CloudCounters conflict
                    // NOTE: This code was interfering with CloudCounters by overriding the correct values
                    /*
                    const streakTiles = document.querySelectorAll('.streak-tile');
                    if (streakTiles.length >= 2) {
                        const morningTile = streakTiles[0];
                        const eveningTile = streakTiles[1];
                        
                        const morningNumber = morningTile?.querySelector('.streak-number');
                        const eveningNumber = eveningTile?.querySelector('.streak-number');
                        
                        if (morningNumber) morningNumber.textContent = '0';
                        if (eveningNumber) eveningNumber.textContent = '0';
                        
                        console.log('✅ Reset routine counters to 0');
                    }
                    */
                    
                    // 5. Reset new simple routine manager if available
                    if (window.simpleRoutineManager) {
                        await window.simpleRoutineManager.reset();
                        console.log('✅ Reset SimpleRoutineManager');
                    }
                    
                    console.log('🎉 Routine database reset complete!');
                    console.log('📝 All routine data has been cleared and counters reset');
                    console.log('🔄 Refresh the page to ensure clean state across devices');
                    
                    return true;
                    
                } catch (error) {
                    console.error('❌ Error during routine reset:', error);
                    return false;
                }
            }
            
            // === DEBUG ROUTINE SYSTEM ===
            window.debugRoutineSystem = function() {
                console.log('🔍 ROUTINE SYSTEM DEBUG');
                console.log('======================');
                
                // Check localStorage
                const simpleData = localStorage.getItem('simple_routine_data');
                console.log('📱 simple_routine_data:', simpleData ? JSON.parse(simpleData) : 'NOT FOUND');
                
                const oldData = localStorage.getItem('routineCompletionData');
                console.log('📱 routineCompletionData (old):', oldData ? JSON.parse(oldData) : 'NOT FOUND');
                
                // Check SimpleRoutineManager
                if (window.simpleRoutineManager) {
                    console.log('✅ SimpleRoutineManager exists');
                    console.log('📊 Current data:', window.simpleRoutineManager.routineData);
                    console.log('📅 Today:', window.simpleRoutineManager.today);
                } else {
                    console.log('❌ SimpleRoutineManager NOT FOUND');
                }
                
                // Check checkboxes
                const morningCheckboxes = document.querySelectorAll('#morning-routine input[type="checkbox"]');
                const eveningCheckboxes = document.querySelectorAll('#evening-routine input[type="checkbox"]');
                
                console.log('🌅 Morning checkboxes:');
                morningCheckboxes.forEach(cb => {
                    const label = cb.nextElementSibling;
                    console.log(`- ${cb.id}: checked=${cb.checked}, strikethrough=${label?.style?.textDecoration || 'none'}`);
                });
                
                console.log('🌙 Evening checkboxes:');
                eveningCheckboxes.forEach(cb => {
                    const label = cb.nextElementSibling;
                    console.log(`- ${cb.id}: checked=${cb.checked}, strikethrough=${label?.style?.textDecoration || 'none'}`);
                });
                
                // Check counters
                const streakTiles = document.querySelectorAll('.streak-tile');
                console.log('📊 Counter tiles:');
                streakTiles.forEach((tile, index) => {
                    const number = tile.querySelector('.streak-number');
                    const label = tile.querySelector('.streak-label');
                    console.log(`- Tile ${index}: ${label?.textContent} = ${number?.textContent}`);
                });
                
                alert('Debug info logged to console - press F12 to see details');
            };
            
            // === GLOBAL ROUTINE RESET HANDLER ===
            window.handleRoutineReset = async function() {
                console.log('🖱️ handleRoutineReset called via onclick');
                
                const confirmed = confirm(
                    '⚠️ ACHTUNG: Routine-Datenbank komplett zurücksetzen?\n\n' +
                    '• Löscht ALLE Routine-Daten (lokal und cloud)\n' +
                    '• Setzt alle Counter auf 0\n' +
                    '• Betrifft alle Geräte\n' +
                    '• Kann nicht rückgängig gemacht werden\n\n' +
                    'Fortfahren?'
                );
                
                if (confirmed) {
                    console.log('✅ User confirmed reset');
                    const success = await resetRoutineDatabase();
                    if (success) {
                        alert('✅ Routine-Datenbank wurde komplett zurückgesetzt!\n\nBitte refreshe die Seite auf allen Geräten.');
                        window.location.reload();
                    } else {
                        alert('❌ Fehler beim Zurücksetzen. Bitte Console prüfen.');
                    }
                } else {
                    console.log('❌ User cancelled reset');
                }
            };
            
            // Initialize hash-based navigation
            initializeFromHash();
            
            // Add hash change event listener
            window.addEventListener('hashchange', handleHashChange);
            
            // Initialize URL hash for current active tab (only if authenticated)
            setTimeout(() => {
                if (supabase?.isAuthenticated()) {
                    const activeTab = document.querySelector('.nav-tab.active');
                    if (activeTab && !window.location.hash) {
                        const tabId = activeTab.getAttribute('data-tab');
                        if (tabId && tabHashMapping[tabId]) {
                            const hash = tabHashMapping[tabId];
                            window.history.replaceState(null, null, `#${hash}`);
                            console.log(`🔗 Initial tab loaded: ${tabId}, URL set to #${hash}`);
                        }
                    }
                }
            }, 100);
            
            // Pure cloud counter system - no force refresh needed
            setTimeout(() => {
                console.log('☁️ Ensuring cloud counters are initialized...');
                
                // Only initialize cloud counters if not already done
                if (window.CloudCounters && !window.CloudCounters.isInitialized && supabase?.isAuthenticated()) {
                    window.CloudCounters.init();
                }
                
                // Debug function for checking todo counts
                window.debugTodoCount = async function() {
                    if (!supabase?.isAuthenticated()) {
                        console.log('❌ Not authenticated');
                        return;
                    }
                    
                    const now = new Date();
                    const currentMonth = now.getMonth() + 1;
                    const currentYear = now.getFullYear();
                    const startOfMonth = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-01`;
                    const endOfMonth = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-31`;
                    
                    const user = supabase.getCurrentUser();
                    
                    console.log('🔍 Debug Todo Count for', `${currentMonth}/${currentYear}`);
                    console.log('📅 Date range:', startOfMonth, 'to', endOfMonth);
                    
                    // All todos this month
                    const allTodos = await supabase.query(`todos?user_id=eq.${user.id}&created_at=gte.${startOfMonth}&created_at=lt.${endOfMonth}&select=*`);
                    console.log('📝 All todos this month:', allTodos?.length || 0, allTodos);
                    
                    // Completed todos this month  
                    const completedTodos = await supabase.query(`todos?user_id=eq.${user.id}&completed=eq.true&created_at=gte.${startOfMonth}&created_at=lt.${endOfMonth}&select=*`);
                    console.log('✅ Completed todos this month:', completedTodos?.length || 0, completedTodos);
                    
                    return { all: allTodos, completed: completedTodos };
                };
                
            }, 2000);
            
            // Mobile debug removed for cleaner console output
        });

        // === WIKI MANAGER ===
        const Wiki = {
            entries: [],
            filteredEntries: [],
            
            init() {
                console.log('🔧 Wiki: Initializing...');
                this.loadEntries();
                this.setupEventListeners();
                this.render();
            },
            
            setupEventListeners() {
                const form = document.getElementById('add-wiki-form');
                const searchInput = document.getElementById('wiki-search');
                
                if (form) {
                    form.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.addEntry();
                    });
                }
                
                if (searchInput) {
                    searchInput.addEventListener('input', () => {
                        clearTimeout(this.searchTimeout);
                        this.searchTimeout = setTimeout(() => this.search(), 300);
                    });
                }
            },
            
            showAddModal() {
                const modal = document.getElementById('add-wiki-modal');
                if (modal) {
                    modal.classList.remove('hide');
                    document.getElementById('wiki-title').focus();
                }
            },
            
            hideAddModal() {
                const modal = document.getElementById('add-wiki-modal');
                if (modal) {
                    modal.classList.add('hide');
                    document.getElementById('add-wiki-form').reset();
                }
            },
            
            async addEntry() {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ Wiki: Not authenticated - cannot add entry in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Wiki-Eintrag kann nicht gespeichert werden.');
                    return;
                }
                
                const title = document.getElementById('wiki-title').value;
                const content = document.getElementById('wiki-content').value;
                const tagsText = document.getElementById('wiki-tags').value;
                
                if (!title || !content) {
                    alert('Bitte fülle alle Pflichtfelder aus');
                    return;
                }
                
                const tags = tagsText ? tagsText.split(',').map(tag => tag.trim()).filter(tag => tag) : ['allgemein'];
                
                // Generate a unique ID for the wiki entry
                const entryId = Date.now(); // Use timestamp as ID
                
                const entry = {
                    id: entryId, // Manually set ID since table doesn't auto-generate
                    title,
                    content,
                    tags,
                    user_id: supabase.getCurrentUser().id,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                };
                
                // Remove any undefined fields that might cause issues
                Object.keys(entry).forEach(key => {
                    if (entry[key] === undefined || entry[key] === null) {
                        delete entry[key];
                    }
                });
                
                try {
                    console.log('☁️ Wiki: Saving entry to cloud:', title);
                    console.log('☁️ Wiki: Entry data:', entry);
                    
                    // Use array format for insert
                    const result = await supabase.insert('crypto_wiki_entries', [entry]);
                    console.log('☁️ Wiki: Insert result:', result);
                    
                    if (result && result.length > 0) {
                        this.entries.push(result[0]);
                        console.log('☁️ Wiki: Entry saved to cloud with ID:', result[0].id);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ Wiki: Error saving to cloud:', error);
                    console.error('❌ Wiki: Error details:', error.message);
                    alert('Fehler beim Speichern des Wiki-Eintrags: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                this.hideAddModal();
                this.render();
                
                console.log('☁️ Wiki: Entry added:', title);
            },
            
            async deleteEntry(id) {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ Wiki: Not authenticated - cannot delete entry in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Wiki-Eintrag kann nicht gelöscht werden.');
                    return;
                }
                
                const entry = this.entries.find(e => e.id === id);
                if (!entry) return;
                
                try {
                    console.log('☁️ Wiki: Deleting entry from cloud:', id);
                    await supabase.delete('crypto_wiki_entries', `id=eq.${id}`);
                    console.log('☁️ Wiki: Entry deleted from cloud');
                } catch (error) {
                    console.error('❌ Wiki: Error deleting from cloud:', error);
                    alert('Fehler beim Löschen des Wiki-Eintrags: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                // Remove from local array
                this.entries = this.entries.filter(e => e.id !== id);
                
                // Pure cloud mode - no localStorage
                
                this.render();
                console.log('☁️ Wiki: Entry deleted:', entry.title);
            },
            
            search() {
                const query = document.getElementById('wiki-search').value.toLowerCase();
                
                this.filteredEntries = this.entries.filter(entry => {
                    const matchesSearch = !query || 
                        entry.title.toLowerCase().includes(query) ||
                        entry.content.toLowerCase().includes(query) ||
                        entry.tags.some(tag => tag.toLowerCase().includes(query)) ||
                        (entry.source && entry.source.toLowerCase().includes(query));
                    
                    return matchesSearch;
                });
                
                this.render();
            },
            
            
            render() {
                const container = document.getElementById('wiki-entries');
                if (!container) return;
                
                const entriesToShow = this.filteredEntries.length > 0 || 
                    document.getElementById('wiki-search').value 
                    ? this.filteredEntries : this.entries;
                
                if (entriesToShow.length === 0) {
                    container.innerHTML = '<div class="empty-wiki">No wiki entries found. Add your first knowledge entry!</div>';
                    return;
                }
                
                const html = entriesToShow
                    .sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at))
                    .map(entry => this.renderEntry(entry))
                    .join('');
                
                container.innerHTML = html;
                
                // Initialize Lucide icons after rendering
                setTimeout(() => {
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                    // Add right-click handlers for delete buttons
                    this.addDeleteHandlers();
                }, 100);
            },
            
            renderEntry(entry) {
                const tagsHtml = entry.tags.map(tag => `<span class="journal-tag">${tag}</span>`).join('');
                const date = new Date(entry.created_at).toLocaleDateString('de-DE');
                const time = new Date(entry.created_at).toLocaleTimeString('de-DE', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                return `
                    <div class="journal-entry" data-entry-id="${entry.id}">
                        <div class="journal-entry-header">
                            <h3 class="journal-entry-title">${entry.title}</h3>
                            <div class="journal-entry-actions">
                                <button class="delete-entry-btn" onclick="Wiki.deleteEntry('${entry.id}')" title="Delete">
                                    <i data-lucide="trash-2" style="width: 16px; height: 16px;"></i>
                                </button>
                            </div>
                        </div>
                        <div class="journal-entry-content">${entry.content}</div>
                        <div class="journal-entry-meta">
                            <div class="journal-entry-tags">
                                ${tagsHtml}
                            </div>
                            <span class="journal-entry-date">${date} • ${time}</span>
                        </div>
                    </div>
                `;
            },
            
            async loadEntries() {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ Wiki: Not authenticated - pure cloud mode requires authentication');
                    this.entries = [];
                    this.render();
                    return;
                }
                
                try {
                    await this.loadFromCloud();
                } catch (error) {
                    console.error('❌ Wiki: Error loading entries:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },

            
            async saveEntries() {
                // Pure cloud mode - no localStorage saving
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ Wiki: Not authenticated - cannot save in pure cloud mode');
                    return;
                }
                
                try {
                    await this.saveToCloud();
                } catch (error) {
                    console.error('❌ Wiki: Error saving entries:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            async loadFromCloud() {
                try {
                    console.log('☁️ Wiki: Loading from cloud...');
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        throw new Error('No user found');
                    }

                    const data = await supabase.query(`crypto_wiki_entries?user_id=eq.${user.id}&order=updated_at.desc&select=*`);
                    
                    if (data && Array.isArray(data)) {
                        this.entries = data;
                        this.render();
                    } else {
                        console.log('☁️ Wiki: No entries found in cloud');
                        this.entries = [];
                        this.render();
                    }
                } catch (error) {
                    console.error('❌ Wiki: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },

            addDeleteHandlers() {
                document.querySelectorAll('.journal-entry').forEach(entry => {
                    entry.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        
                        // Hide all other delete buttons first
                        document.querySelectorAll('.journal-entry').forEach(el => {
                            el.classList.remove('show-delete');
                        });
                        
                        // Show delete button for this entry
                        entry.classList.add('show-delete');
                        
                        // Hide delete button after 3 seconds
                        setTimeout(() => {
                            entry.classList.remove('show-delete');
                        }, 3000);
                    });
                    
                    // Hide delete button on regular click
                    entry.addEventListener('click', (e) => {
                        // Don't hide if clicking the delete button
                        if (!e.target.closest('.delete-entry-btn')) {
                            entry.classList.remove('show-delete');
                        }
                    });
                    
                    // Add delete button click handler (in addition to onclick in HTML)
                    const deleteBtn = entry.querySelector('.delete-entry-btn');
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                        });
                    }
                });
            },
            
            async saveToCloud() {
                try {
                    console.log('🔄 Wiki: Saving to Supabase...');
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        console.log('❌ Wiki: No user found');
                        return;
                    }

                    // We'll save entries individually when they're created/updated
                    console.log('✅ Wiki: Cloud sync ready');
                } catch (error) {
                    console.error('❌ Wiki: Error saving to cloud:', error);
                }
            },

            async saveEntryToCloud(entry) {
                try {
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        throw new Error('No user found');
                    }

                    const entryWithUserId = {
                        ...entry,
                        user_id: user.id
                    };

                    const data = await supabase.insert('crypto_wiki_entries', entryWithUserId);
                    
                    if (!data || !Array.isArray(data) || data.length === 0) {
                        throw new Error('Insert did not return data');
                    }

                    console.log('☁️ Wiki: Entry saved to cloud:', entry.title);
                    return true;
                } catch (error) {
                    console.error('❌ Wiki: Error in saveEntryToCloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },

            async deleteEntryFromCloud(entryId) {
                try {
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        throw new Error('No user found');
                    }

                    const result = await supabase.delete('crypto_wiki_entries', `id=eq.${entryId}`);
                    
                    console.log('☁️ Wiki: Entry deleted from cloud');
                    return true;
                } catch (error) {
                    console.error('❌ Wiki: Error in deleteEntryFromCloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            }
        };

        // Make Wiki globally available
        window.Wiki = Wiki;
        
        // === POMODORO TIMER CLASS ===
        class PomodoroTimer {
            constructor() {
                this.duration = 25 * 60; // 25 minutes in seconds
                this.timeLeft = this.duration;
                this.isRunning = false;
                this.isPaused = false;
                this.interval = null;
                this.originalTitle = document.title;
                
                console.log('🍅 PomodoroTimer initialized (25 min) - Left click: start/stop, Right click: reset');
            }
            
            toggle() {
                if (this.isRunning) {
                    this.pause();
                } else {
                    this.start();
                }
            }
            
            start() {
                console.log('🍅 Timer started');
                this.isRunning = true;
                this.isPaused = false;
                
                // Update Quick Actions button
                if (window.QuickActions) {
                    window.QuickActions.updateTimerButton('pause', 'Stop Timer');
                }
                
                this.interval = setInterval(() => {
                    this.timeLeft--;
                    this.updateDisplay();
                    
                    if (this.timeLeft <= 0) {
                        this.complete();
                    }
                }, 1000);
            }
            
            pause() {
                console.log('🍅 Timer paused');
                this.isRunning = false;
                this.isPaused = true;
                
                // Update Quick Actions button
                if (window.QuickActions) {
                    window.QuickActions.updateTimerButton('play', 'Start Timer');
                }
                
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
            }
            
            complete() {
                console.log('🍅 Timer completed!');
                this.reset();
                
                // Timer completed - button will reset to play state
                
                // Show notification
                this.showNotification();
                
                // Play sound (if available)
                this.playCompletionSound();
            }
            
            reset() {
                console.log('🍅 Timer reset to 25:00');
                this.isRunning = false;
                this.isPaused = false;
                this.timeLeft = this.duration;
                
                // Update Quick Actions button
                if (window.QuickActions) {
                    window.QuickActions.updateTimerButton('play', 'Start Timer (25 min)');
                }
                
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
                
                // Reset title
                document.title = this.originalTitle;
            }
            
            updateDisplay() {
                const minutes = Math.floor(this.timeLeft / 60);
                const seconds = this.timeLeft % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Update page title
                document.title = `🍅 ${timeString} | ${this.originalTitle}`;
            }
            
            showNotification() {
                // Browser notification
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification('🍅 Pomodoro Complete!', {
                        body: '25 minutes focused work completed. Time for a break!',
                        icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="80">🍅</text></svg>'
                    });
                } else if ('Notification' in window && Notification.permission !== 'denied') {
                    // Request permission
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            this.showNotification();
                        }
                    });
                }
                
                // Fallback alert
                alert('🍅 Pomodoro Complete!\n\n25 minutes focused work completed.\nTime for a break!');
            }
            
            playCompletionSound() {
                // Create a simple beep sound
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (error) {
                    console.log('🔇 Could not play completion sound:', error);
                }
            }
        }
        
        // Make PomodoroTimer globally available
        window.PomodoroTimer = new PomodoroTimer();
        
        // === QUICK ADD CLASS ===
        class QuickAdd {
            constructor() {
                this.isVisible = false;
                this.overlay = null;
                this.modal = null;
                console.log('⚡ QuickAdd initialized');
            }
            
            show() {
                if (this.isVisible) return;
                
                console.log('⚡ QuickAdd: Showing modal');
                this.createModal();
                this.isVisible = true;
            }
            
            hide() {
                if (!this.isVisible) return;
                
                console.log('⚡ QuickAdd: Hiding modal');
                if (this.overlay) {
                    this.overlay.remove();
                    this.overlay = null;
                    this.modal = null;
                }
                this.isVisible = false;
            }
            
            createModal() {
                // Create overlay
                this.overlay = document.createElement('div');
                this.overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    z-index: 2000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                
                // Create modal
                this.modal = document.createElement('div');
                this.modal.style.cssText = `
                    background: white;
                    border-radius: 8px;
                    padding: 2rem;
                    min-width: 400px;
                    max-width: 500px;
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
                `;
                
                this.modal.innerHTML = `
                    <h3 style="margin: 0 0 1rem 0; font-size: 1.2rem;">⚡ Quick Add Todo</h3>
                    <form id="quick-add-form" autocomplete="off">
                        <input type="text" id="quick-todo-title" placeholder="Todo eingeben..." autocomplete="off"
                               style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 1rem; font-size: 1rem;" />
                        
                        <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                            <select id="quick-todo-category" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="privat">Privat</option>
                                <option value="uni">Uni</option>
                                <option value="arbeit">Arbeit</option>
                            </select>
                            
                            <select id="quick-todo-priority" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="mittel">Mittel</option>
                                <option value="wichtig">Wichtig</option>
                                <option value="dringend">Dringend</option>
                            </select>
                        </div>
                        
                        <input type="date" id="quick-todo-deadline" 
                               style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 1rem;" />
                        
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                            <button type="button" id="quick-add-cancel" 
                                    style="padding: 0.5rem 1rem; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">
                                Abbrechen
                            </button>
                            <button type="submit" 
                                    style="padding: 0.5rem 1rem; border: none; background: #059669; color: white; border-radius: 4px; cursor: pointer;">
                                Hinzufügen
                            </button>
                        </div>
                    </form>
                `;
                
                this.overlay.appendChild(this.modal);
                document.body.appendChild(this.overlay);
                
                // Set today as default deadline
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('quick-todo-deadline').value = today;
                
                // Focus title input
                const titleInput = document.getElementById('quick-todo-title');
                setTimeout(() => titleInput.focus(), 100);
                
                // Event listeners
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // Close on overlay click
                this.overlay.addEventListener('click', (e) => {
                    if (e.target === this.overlay) {
                        this.hide();
                    }
                });
                
                // Close on ESC key
                document.addEventListener('keydown', this.handleKeydown.bind(this));
                
                // Cancel button
                document.getElementById('quick-add-cancel').addEventListener('click', () => {
                    this.hide();
                });
                
                // Form submit
                document.getElementById('quick-add-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleSubmit();
                });
            }
            
            handleKeydown(e) {
                if (e.key === 'Escape' && this.isVisible) {
                    this.hide();
                }
            }
            
            async handleSubmit() {
                const title = document.getElementById('quick-todo-title').value.trim();
                const category = document.getElementById('quick-todo-category').value;
                const priority = document.getElementById('quick-todo-priority').value;
                const deadline = document.getElementById('quick-todo-deadline').value;
                
                if (!title) {
                    alert('Bitte gib einen Todo-Titel ein!');
                    return;
                }
                
                // Map priority string to integer for database
                const priorityMap = {
                    'mittel': 2,
                    'wichtig': 3,
                    'dringend': 4
                };
                
                const todo = {
                    text: title,  // Database uses 'text', not 'title'
                    category: category,
                    priority: priorityMap[priority] || 2,  // Convert to integer
                    date: deadline || null,  // Database uses 'date', not 'deadline'
                    time: null,  // No time specified in quick-add
                    completed: false,
                    created_at: new Date().toISOString()
                };
                
                try {
                    console.log('⚡ QuickAdd: Saving todo:', todo);
                    
                    // Check if authenticated
                    if (!window.supabase?.isAuthenticated()) {
                        alert('Nicht authentifiziert! Bitte logge dich ein.');
                        return;
                    }
                    
                    // Save using CloudStorage directly for more reliability
                    if (window.cloudStorage) {
                        await window.cloudStorage.saveTodo(todo);
                        console.log('✅ QuickAdd: Todo saved successfully via CloudStorage');
                    } else if (window.TodoManager) {
                        await window.TodoManager.saveTodo(todo);
                        console.log('✅ QuickAdd: Todo saved successfully via TodoManager');
                    } else {
                        throw new Error('No todo saving mechanism available');
                    }
                    
                    // Refresh todo display immediately after saving
                    if (window.TodoManager) {
                        console.log('🔄 QuickAdd: Refreshing todo display...');
                        
                        // Load todos from database first
                        await window.TodoManager.loadTodos();
                        
                        // Then refresh the current view
                        if (typeof window.TodoManager.refreshCurrentView === 'function') {
                            window.TodoManager.refreshCurrentView();
                        }
                        
                        // Also update home view for counters
                        if (typeof window.TodoManager.updateHomeTodos === 'function') {
                            window.TodoManager.updateHomeTodos();
                        }
                        
                        console.log('✅ QuickAdd: Todo display refreshed');
                    } else {
                        console.log('⚠️ QuickAdd: TodoManager not available');
                    }
                    
                    console.log('✅ QuickAdd: All done, hiding modal');
                    this.hide();
                } catch (error) {
                    console.error('❌ QuickAdd: Error saving todo:', error);
                    console.error('❌ QuickAdd: Error details:', error.message, error.stack);
                    alert(`Fehler beim Speichern des Todos: ${error.message}`);
                }
            }
        }
        
        // Make QuickAdd globally available
        window.QuickAdd = new QuickAdd();
        
        // Wiki and Lucide icons initialization moved to main DOMContentLoaded listener
    </script>
    
    <!-- ========================================= -->
    <!-- TRADING MANAGER -->
    <!-- ========================================= -->
    <script>
        class TradingManager {
            constructor() {
                this.apiKey = '35ffdb6a-2061-4573-a66b-ea263c5eaa34';
                this.trades = [];
                this.solPrice = 0;
                this.requestCount = 0;
                this.maxRequestsPerHour = 30; // Conservative limit
                
                this.init();
            }

            async init() {
                // Setup event listeners
                this.setupEventListeners();
                
                // Load trades from cloud when tab is accessed
                this.setupTabListener();
                
                // Get current SOL price
                await this.updateSolPrice();
            }

            setupEventListeners() {
                // Add trade button - show modal
                const addTradeBtn = document.getElementById('add-trade-btn');
                if (addTradeBtn) {
                    addTradeBtn.addEventListener('click', () => this.showAddTradeModal());
                }

                // Add trade modal buttons
                const addTradeConfirm = document.getElementById('add-trade-confirm');
                if (addTradeConfirm) {
                    addTradeConfirm.addEventListener('click', () => this.addTrade());
                }

                const addTradeCancel = document.getElementById('add-trade-cancel');
                if (addTradeCancel) {
                    addTradeCancel.addEventListener('click', () => this.hideAddTradeModal());
                }

                const addTradeModalClose = document.getElementById('add-trade-modal-close');
                if (addTradeModalClose) {
                    addTradeModalClose.addEventListener('click', () => this.hideAddTradeModal());
                }

                // Refresh prices button
                const refreshPricesBtn = document.getElementById('refresh-prices-btn');
                if (refreshPricesBtn) {
                    refreshPricesBtn.addEventListener('click', () => this.refreshPrices());
                }

                // Lock button (placeholder for future functionality)
                const lockBtn = document.getElementById('lock-btn');
                if (lockBtn) {
                    lockBtn.addEventListener('click', () => this.handleLockButton());
                }




                // Close trade modal buttons
                const closeModal = document.getElementById('close-trade-modal');
                const closeModalClose = document.getElementById('close-trade-modal-close');
                const closeTradeCancel = document.getElementById('close-trade-cancel');
                const closeTradeConfirm = document.getElementById('close-trade-confirm');

                // Close modal handlers
                [closeModalClose, closeTradeCancel].forEach(btn => {
                    if (btn) {
                        btn.addEventListener('click', () => this.hideCloseTradeModal());
                    }
                });

                // Close on overlay click
                if (closeModal) {
                    closeModal.addEventListener('click', (e) => {
                        if (e.target === closeModal) {
                            this.hideCloseTradeModal();
                        }
                    });
                }

                // Confirm close trade
                if (closeTradeConfirm) {
                    closeTradeConfirm.addEventListener('click', () => this.confirmCloseTrade());
                }

                // View trade details modal
                const viewTradeModalClose = document.getElementById('view-trade-modal-close');
                const closeDetailsModal = document.getElementById('close-details-modal');
                const viewTradeModal = document.getElementById('view-trade-modal');

                [viewTradeModalClose, closeDetailsModal].forEach(btn => {
                    if (btn) {
                        btn.addEventListener('click', () => this.hideViewTradeModal());
                    }
                });

                // Close view trade modal on overlay click
                if (viewTradeModal) {
                    viewTradeModal.addEventListener('click', (e) => {
                        if (e.target === viewTradeModal) {
                            this.hideViewTradeModal();
                        }
                    });
                }

                // Modal SOL amount buttons
                document.addEventListener('click', (e) => {
                    if (e.target.matches('#close-trade-modal .sol-btn')) {
                        const amount = e.target.getAttribute('data-amount');
                        document.getElementById('close-received-sol').value = amount;
                    }
                });

                // Modal market cap buttons
                document.addEventListener('click', (e) => {
                    if (e.target.matches('#close-trade-modal .mcap-btn')) {
                        const modalMcapButtons = document.querySelectorAll('#close-trade-modal .mcap-btn');
                        modalMcapButtons.forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        // Auto-calculate keep position when unit changes
                        this.calculateKeepPosition();
                    }
                });

                // Auto-calculate when exit mcap input changes
                const exitMcapInput = document.getElementById('close-exit-mcap');
                if (exitMcapInput) {
                    exitMcapInput.addEventListener('input', () => this.calculateKeepPosition());
                }

                // Auto-calculate when take profit input changes
                const takeProfitInput = document.getElementById('close-take-profit');
                if (takeProfitInput) {
                    takeProfitInput.addEventListener('input', (e) => {
                        if (e.isTrusted) {
                            this.calculateKeepPosition();
                        }
                    });
                }

                // Percentage buttons for take profit (based on current value)
                document.addEventListener('click', (e) => {
                    if (e.target.matches('#close-trade-modal .sol-percent-btn')) {
                        const percentAttr = e.target.getAttribute('data-percent');
                        if (this.currentTradeToClose && percentAttr) {
                            const percent = percentAttr === 'initials' ? 'initials' : parseFloat(percentAttr);
                            this.calculateTakeProfitFromPercent(percent);
                        }
                    }
                });
            }

            setupTabListener() {
                document.addEventListener('click', (e) => {
                    if (e.target.matches('[data-tab="tab-trading"]')) {
                        this.loadTrades();
                    }
                });
            }

            async updateSolPrice() {
                try {
                    // Use simple CoinGecko API for SOL price (no API key needed)
                    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.solPrice = data.solana?.usd || 200;
                    } else {
                        this.solPrice = 200; // Fallback
                    }
                } catch (error) {
                    this.solPrice = 200; // Fallback
                }
            }


            async addTrade() {
                const token = document.getElementById('modal-trade-token').value.trim().toUpperCase();
                const solAmount = parseFloat(document.getElementById('modal-trade-sol-amount').value);
                const entryMcap = document.getElementById('modal-trade-mcap').value.trim();
                const notes = document.getElementById('modal-trade-notes').value.trim();

                if (!token || !solAmount || !entryMcap) {
                    alert('Please fill in all required fields');
                    return;
                }

                const trade = {
                    id: Date.now().toString(),
                    token,
                    sol_amount: solAmount,
                    entry_mcap: entryMcap,
                    entry_price: this.solPrice * solAmount,
                    entry_date: new Date().toISOString(),
                    status: 'open',
                    pnl: 0,
                    user_id: window.supabase?.getCurrentUser()?.id
                };

                // Add notes if provided
                if (notes) {
                    trade.notes = notes;
                }
                
                // Store cost_basis locally until DB schema is updated
                trade._cost_basis = solAmount;

                try {
                    // Save to cloud
                    await this.saveTradeToCloud(trade);
                    
                    // Add to local array
                    this.trades.push(trade);
                    
                    // Clear form and close modal
                    this.clearAddTradeForm();
                    this.hideAddTradeModal();
                    
                    // Refresh display
                    this.renderTrades();
                    this.updatePortfolioStats();

                } catch (error) {
                    console.error('Error adding trade:', error);
                    alert('Failed to save trade');
                }
            }

            showAddTradeModal() {
                document.getElementById('add-trade-modal').style.display = 'flex';
            }

            hideAddTradeModal() {
                document.getElementById('add-trade-modal').style.display = 'none';
            }

            clearAddTradeForm() {
                document.getElementById('modal-trade-token').value = '';
                document.getElementById('modal-trade-sol-amount').value = '';
                document.getElementById('modal-trade-mcap').value = '';
                document.getElementById('modal-trade-notes').value = '';
            }

            async saveTradeToCloud(trade) {
                if (!window.supabase || !window.supabase.isAuthenticated()) {
                    throw new Error('Not authenticated');
                }

                // Create a copy with only fields that exist in the database
                const dbTrade = {
                    id: trade.id,
                    token: trade.token,
                    sol_amount: trade.sol_amount,
                    entry_mcap: trade.entry_mcap,
                    entry_price: trade.entry_price,
                    entry_date: trade.entry_date,
                    status: trade.status,
                    pnl: trade.pnl,
                    user_id: trade.user_id
                };
                
                // Add badge-related flags to database
                if (trade._initials_recovered !== undefined) dbTrade._initials_recovered = trade._initials_recovered;
                if (trade._is_free_ride_trade !== undefined) dbTrade._is_free_ride_trade = trade._is_free_ride_trade;
                if (trade._is_free_ride !== undefined) dbTrade._is_free_ride = trade._is_free_ride;
                if (trade._initials_taken !== undefined) dbTrade._initials_taken = trade._initials_taken;
                if (trade._cost_basis !== undefined) dbTrade._cost_basis = trade._cost_basis;
                
                // TODO: Add these fields when database schema is updated
                // stop_loss: trade.stop_loss,
                // take_profit: trade.take_profit,
                // notes: trade.notes
                
                await window.supabase.insert('trades', [dbTrade]);
            }

            handleLockButton() {
                const openTradesView = document.getElementById('open-trades-view');
                const closedTradesView = document.getElementById('closed-trades-view');
                const sectionTitle = document.getElementById('trading-section-title');
                const lockBtn = document.getElementById('lock-btn');
                
                if (!openTradesView || !closedTradesView || !sectionTitle || !lockBtn) {
                    console.error('Cannot find required elements for lock button');
                    return;
                }
                
                const lockIcon = lockBtn.querySelector('i[data-lucide]');
                
                // Check current state based on which view is visible
                const showingClosed = closedTradesView.style.display !== 'none';
                
                if (showingClosed) {
                    // Switch to open trades (now showing open, next action is to go to closed)
                    openTradesView.style.display = 'block';
                    closedTradesView.style.display = 'none';
                    sectionTitle.textContent = 'Open Positions';
                    if (lockBtn) {
                        lockBtn.innerHTML = '<i data-lucide="lock" style="width: 18px; height: 18px;"></i>';
                    }
                    console.log('🔒 Switched to open positions, showing lock for next action');
                } else {
                    // Switch to closed trades (now showing closed, next action is to go to open)
                    openTradesView.style.display = 'none';
                    closedTradesView.style.display = 'block';
                    sectionTitle.textContent = 'Closed Trades';
                    if (lockBtn) {
                        lockBtn.innerHTML = '<i data-lucide="unlock" style="width: 18px; height: 18px;"></i>';
                    }
                    console.log('🔓 Switched to closed trades, showing unlock for next action');
                }
                
                // Recreate icons to update the changed icon
                if (window.lucide) {
                    lucide.createIcons();
                }
            }

            async loadTrades() {
                try {
                    if (!window.supabase || !window.supabase.isAuthenticated()) {
                        return;
                    }

                    const user = window.supabase.getCurrentUser();
                    const data = await window.supabase.query(`trades?user_id=eq.${user.id}&select=*`);
                    
                    if (data) {
                        // Add cost_basis fallback for existing trades
                        this.trades = data.map(trade => {
                            if (!trade._cost_basis) {
                                trade._cost_basis = trade.sol_amount; // Fallback: cost basis = original sol amount
                            }
                            return trade;
                        });
                        this.renderTrades();
                        this.updatePortfolioStats();
                    }

                } catch (error) {
                    console.error('Error loading trades:', error);
                }
            }

            renderTrades() {
                console.log(`RENDER TRADES: Total trades: ${this.trades.length}`);
                const openTrades = this.trades.filter(t => t.status === 'open');
                const closedTrades = this.trades.filter(t => t.status === 'closed');
                
                console.log(`RENDER TRADES: Open trades: ${openTrades.length}, Closed trades: ${closedTrades.length}`);
                openTrades.forEach((trade, i) => {
                    console.log(`OPEN TRADE ${i+1}:`, {
                        id: trade.id,
                        token: trade.token,
                        sol_amount: trade.sol_amount,
                        status: trade.status,
                        cost_basis: trade._cost_basis
                    });
                });

                this.renderOpenTrades(openTrades);
                this.renderClosedTrades(closedTrades);
            }

            renderOpenTrades(trades) {
                const container = document.getElementById('open-trades-list');
                
                if (!trades.length) {
                    container.innerHTML = '<div class="empty-trades">No open trades yet</div>';
                    return;
                }

                const html = `
                    <div class="trade-header">
                        <div>Token</div>
                        <div>SOL</div>
                        <div>Entry McAP</div>
                        <div>Entry Price</div>
                        <div>Stop Loss</div>
                        <div>Take Profit</div>
                        <div>P&L</div>
                        <div>Notes</div>
                        <div>Actions</div>
                    </div>
                    ${trades.map(trade => `
                        <div class="trade-row">
                            <div class="trade-token" data-label="Token">
                                <strong>${trade.token}</strong>
                            </div>
                            <div class="trade-amount" data-label="SOL Amount">${trade.sol_amount} SOL</div>
                            <div class="trade-entry-price" data-label="Entry McAP">${trade.entry_mcap}</div>
                            <div class="trade-entry-price" data-label="Entry Price">$${trade.entry_price.toFixed(0)}</div>
                            <div class="trade-risk" data-label="Stop Loss">${trade.stop_loss || '-'}</div>
                            <div class="trade-risk" data-label="Take Profit">${trade.take_profit || '-'}</div>
                            <div class="trade-pnl ${trade.pnl >= 0 ? 'positive' : 'negative'}" data-label="P&L">
                                ${trade.pnl >= 0 ? '+' : ''}${trade.pnl.toFixed(2)} SOL
                            </div>
                            <div class="trade-notes" data-label="Notes" title="${trade.notes || ''}">${trade.notes ? (trade.notes.length > 20 ? trade.notes.substring(0, 20) + '...' : trade.notes) : '-'}</div>
                            <div class="trade-actions" data-label="Actions">
                                <button class="trade-action-btn" onclick="window.TradingManager.closeTrade('${trade.id}')" title="Close Trade">
                                    <i data-lucide="x-circle" style="width: 16px; height: 16px;"></i>
                                </button>
                            </div>
                        </div>
                    `).join('')}
                `;

                container.innerHTML = html;
                
                // Initialize lucide icons for action buttons
                setTimeout(() => {
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                }, 50);
            }

            getBadgeIconForClosedTrade(trade) {
                console.log(`🔍 Badge check for ${trade.token} (${trade.sol_amount} SOL):`, {
                    cost_basis: trade._cost_basis || trade.cost_basis,
                    final_pnl: trade.final_pnl,
                    _initials_recovered: trade._initials_recovered,
                    _is_free_ride_trade: trade._is_free_ride_trade,
                    exit_date: trade.exit_date
                });
                
                // Use the persisted flags from the database
                if (trade._initials_recovered === true) {
                    console.log(`→ Showing Initials Raus icon`);
                    return '<i data-lucide="trophy" class="trade-badge-icon initials-icon" title="Initials Raus"></i>';
                } else if (trade._is_free_ride_trade === true) {
                    console.log(`→ Showing Free Ride icon`);
                    return '<i data-lucide="rocket" class="trade-badge-icon free-ride-icon" title="Free Ride"></i>';
                }
                
                console.log(`→ No badge (flags not set)`);
                return '';
            }

            renderClosedTrades(trades) {
                const container = document.getElementById('closed-trades-list');
                
                if (!trades.length) {
                    container.innerHTML = '<div class="empty-trades">No closed trades yet</div>';
                    return;
                }

                // Sort trades by exit_date (newest first)
                const sortedTrades = [...trades].sort((a, b) => {
                    const dateA = new Date(a.exit_date || a.entry_date);
                    const dateB = new Date(b.exit_date || b.entry_date);
                    return dateB.getTime() - dateA.getTime(); // Newest first
                });

                const html = `
                    <div class="trade-header">
                        <div>Token</div>
                        <div>SOL</div>
                        <div>Entry → Exit</div>
                        <div>Entry → Exit Price</div>
                        <div>Final P&L</div>
                        <div>Notes</div>
                        <div>Date</div>
                        <div>Actions</div>
                    </div>
                    ${sortedTrades.map(trade => `
                        <div class="trade-row">
                            <div class="trade-token" data-label="Token">
                                <strong>${trade.token}</strong>
                                ${this.getBadgeIconForClosedTrade(trade)}
                            </div>
                            <div class="trade-amount" data-label="SOL Amount">${trade.sol_amount} SOL</div>
                            <div class="trade-entry-price" data-label="McAP">${trade.entry_mcap} → ${trade.exit_mcap || 'N/A'}</div>
                            <div class="trade-entry-price" data-label="Price">$${trade.entry_price.toFixed(0)} → $${(trade.exit_price || 0).toFixed(0)}</div>
                            <div class="trade-pnl ${(trade.final_pnl || 0) >= 0 ? 'positive' : 'negative'}" data-label="P&L">
                                ${(trade.final_pnl || 0) >= 0 ? '+' : ''}${(trade.final_pnl || 0).toFixed(2)} SOL
                            </div>
                            <div class="trade-notes" data-label="Notes" title="${(trade.notes || '') + (trade.close_learnings ? '\n\nLearnings: ' + trade.close_learnings : '')}">
                                ${trade.notes ? (trade.notes.length > 15 ? trade.notes.substring(0, 15) + '...' : trade.notes) : '-'}
                                ${trade.close_learnings ? '<br><small style="color: #059669; font-style: italic;">📝 Learnings</small>' : ''}
                            </div>
                            <div data-label="Date">${new Date(trade.exit_date || trade.entry_date).toLocaleDateString()}</div>
                            <div class="trade-actions" data-label="Actions">
                                <button class="trade-action-btn" onclick="window.TradingManager.viewTradeDetails('${trade.id}')" title="View Details">
                                    <i data-lucide="eye" style="width: 16px; height: 16px;"></i>
                                </button>
                                <button class="trade-action-btn" onclick="window.TradingManager.deleteTrade('${trade.id}')" title="Delete Trade">
                                    <i data-lucide="trash-2" style="width: 16px; height: 16px;"></i>
                                </button>
                            </div>
                        </div>
                    `).join('')}
                `;

                container.innerHTML = html;
                
                // Initialize lucide icons for action buttons
                setTimeout(() => {
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                }, 50);
            }

            async updatePortfolioStats() {
                const openTrades = this.trades.filter(t => t.status === 'open');
                const closedTrades = this.trades.filter(t => t.status === 'closed');
                
                // Calculate existing stats
                const totalPnl = closedTrades.reduce((sum, t) => sum + (t.final_pnl || 0), 0);
                const winningTrades = closedTrades.filter(t => (t.final_pnl || 0) > 0).length;
                const losingTrades = closedTrades.filter(t => (t.final_pnl || 0) < 0).length;
                const nonBreakevenTrades = winningTrades + losingTrades;
                const winRate = nonBreakevenTrades > 0 ? (winningTrades / nonBreakevenTrades * 100) : 0;
                
                // Calculate SOL in open trades
                const solInTrades = openTrades.reduce((sum, t) => sum + (t.sol_amount || 0), 0);
                
                // Get SOL balance from SimpleCounters
                let solBalance = 0;
                if (window.SimpleCounters) {
                    solBalance = await window.SimpleCounters.getSolBalance();
                }

                // Calculate P&L in USD
                const totalPnlUsd = totalPnl * this.solPrice;

                // Update all stats
                document.getElementById('sol-balance').textContent = `${solBalance.toFixed(2)} SOL`;
                document.getElementById('sol-in-trades').textContent = `${solInTrades.toFixed(2)} SOL`;
                document.getElementById('total-pnl').textContent = `${totalPnl >= 0 ? '+' : ''}${totalPnl.toFixed(2)} SOL`;
                document.getElementById('total-pnl').className = `stat-number ${totalPnl >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('total-pnl-usd').textContent = `${totalPnlUsd >= 0 ? '+' : ''}$${totalPnlUsd.toFixed(2)}`;
                document.getElementById('total-pnl-usd').className = `stat-number ${totalPnlUsd >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('open-trades').textContent = openTrades.length;
                document.getElementById('win-rate').textContent = `${winRate.toFixed(1)}%`;
            }

            async editTrade(tradeId) {
                const trade = this.trades.find(t => t.id === tradeId);
                if (!trade) return;

                const newMcap = prompt(`Current Market Cap for ${trade.token}:`, trade.entry_mcap);
                const newSol = prompt(`Current SOL value:`, trade.sol_amount);

                if (newMcap && newSol) {
                    trade.current_mcap = newMcap;
                    trade.current_sol = parseFloat(newSol);
                    trade.pnl = trade.current_sol - trade.sol_amount;

                    await this.updateTradeInCloud(trade);
                    this.renderTrades();
                    this.updatePortfolioStats();
                }
            }

            closeTrade(tradeId) {
                const trade = this.trades.find(t => t.id === tradeId);
                if (!trade) return;

                this.showCloseTradeModal(trade);
            }

            showCloseTradeModal(trade) {
                this.currentTradeToClose = trade;

                // Fill trade info
                document.getElementById('close-trade-token').textContent = trade.token;
                document.getElementById('close-trade-entry-amount').textContent = `${trade.sol_amount} SOL`;
                document.getElementById('close-trade-entry-mcap').textContent = trade.entry_mcap;

                // Clear form
                document.getElementById('close-exit-mcap').value = '';
                document.getElementById('close-take-profit').value = '';
                document.getElementById('close-keep-position').value = trade.sol_amount.toFixed(3); // Show current position

                // Auto-select same market cap unit as entry
                const entryMcap = trade.entry_mcap;
                let entryUnit = 'B'; // Default fallback
                
                // Extract unit from entry market cap (e.g., "2.1B" -> "B")
                if (entryMcap) {
                    const lastChar = entryMcap.slice(-1).toUpperCase();
                    if (['K', 'M', 'B'].includes(lastChar)) {
                        entryUnit = lastChar;
                    }
                }

                // Set the same unit for exit
                document.querySelectorAll('#close-trade-modal .mcap-btn').forEach(btn => btn.classList.remove('active'));
                const targetButton = document.querySelector(`#close-trade-modal .mcap-btn[data-multiplier="${entryUnit}"]`);
                if (targetButton) {
                    targetButton.classList.add('active');
                } else {
                    // Fallback to B if unit not found
                    document.querySelector('#close-trade-modal .mcap-btn[data-multiplier="B"]').classList.add('active');
                }

                // Show modal
                document.getElementById('close-trade-modal').style.display = 'flex';
            }

            hideCloseTradeModal() {
                document.getElementById('close-trade-modal').style.display = 'none';
                this.currentTradeToClose = null;
                
                // Clear form fields
                document.getElementById('close-exit-mcap').value = '';
                document.getElementById('close-take-profit').value = '';
                document.getElementById('close-keep-position').value = '';
                document.getElementById('close-trade-learnings').value = '';
            }

            calculateTakeProfitFromPercent(percent) {
                if (!this.currentTradeToClose) return;

                const exitMcapValue = parseFloat(document.getElementById('close-exit-mcap').value);
                const activeMultiplier = document.querySelector('#close-trade-modal .mcap-btn.active')?.getAttribute('data-multiplier') || 'B';
                
                // Get original investment amounts
                const originalSolAmount = this.currentTradeToClose.sol_amount;
                const originalCostBasis = this.currentTradeToClose._cost_basis !== undefined ? this.currentTradeToClose._cost_basis : originalSolAmount; // Fallback for older trades
                
                if (percent === 'initials') {
                    // Initials button: Verkaufe originalCostBasis SOL aus der aktuellen Position
                    if (!exitMcapValue || isNaN(exitMcapValue)) {
                        // Ohne Exit Mcap - verwende ursprüngliche Mengen
                        const solToSell = originalCostBasis;
                        const solRemaining = Math.max(0, originalSolAmount - solToSell);
                        
                        document.getElementById('close-take-profit').value = solToSell.toFixed(3);
                        document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                        return;
                    }
                    
                    // Mit Exit Mcap - berechne aktuelle Position und verkaufe originalCostBasis davon
                    try {
                        const entryMcap = this.currentTradeToClose.entry_mcap;
                        const entryValue = parseFloat(entryMcap);
                        const entryUnit = entryMcap.slice(-1).toUpperCase();
                        
                        const multipliers = { 'K': 1000, 'M': 1000000, 'B': 1000000000 };
                        const entryActual = entryValue * (multipliers[entryUnit] || 1000000000);
                        const exitActual = exitMcapValue * (multipliers[activeMultiplier] || 1000000000);
                        
                        const percentageChange = (exitActual - entryActual) / entryActual;
                        const currentTotalValue = originalSolAmount * (1 + percentageChange);
                        
                        const solToSell = originalCostBasis;
                        const solRemaining = Math.max(0, currentTotalValue - solToSell);
                        
                        console.log(`INITIALS: Current value ${currentTotalValue.toFixed(3)} SOL, selling ${solToSell} SOL (cost basis), keeping ${solRemaining.toFixed(3)} SOL (free ride)`);
                        
                        document.getElementById('close-take-profit').value = solToSell.toFixed(3);
                        document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                        return;
                    } catch (error) {
                        console.error('Error calculating initials:', error);
                        // Fallback
                        const solToSell = originalCostBasis;
                        const solRemaining = Math.max(0, originalSolAmount - solToSell);
                        
                        document.getElementById('close-take-profit').value = solToSell.toFixed(3);
                        document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                        return;
                    }
                }

                if (!exitMcapValue || isNaN(exitMcapValue)) {
                    // No exit mcap set yet, show percentage of current position
                    const takeProfit = (originalSolAmount * percent / 100).toFixed(3);
                    const keepPosition = (originalSolAmount * (100 - percent) / 100).toFixed(3);
                    
                    document.getElementById('close-take-profit').value = takeProfit;
                    document.getElementById('close-keep-position').value = keepPosition;
                    return;
                }

                try {
                    // Parse entry market cap
                    const entryMcap = this.currentTradeToClose.entry_mcap;
                    const entryValue = parseFloat(entryMcap);
                    const entryUnit = entryMcap.slice(-1).toUpperCase();
                    
                    // Convert both to same base
                    const multipliers = { 'K': 1000, 'M': 1000000, 'B': 1000000000 };
                    const entryActual = entryValue * (multipliers[entryUnit] || 1000000000);
                    const exitActual = exitMcapValue * (multipliers[activeMultiplier] || 1000000000);
                    
                    // Calculate percentage change
                    const percentageChange = (exitActual - entryActual) / entryActual;
                    
                    // Calculate current total value in SOL
                    const currentTotalValue = originalSolAmount * (1 + percentageChange);
                    
                    // Calculate SOL to sell (percent of current value)
                    const solToSell = currentTotalValue * (percent / 100);
                    const solRemaining = Math.max(0, currentTotalValue - solToSell);
                    
                    // Debug
                    console.log(`DEBUG: Entry ${originalSolAmount} SOL, Exit change: ${(percentageChange*100).toFixed(1)}%`);
                    console.log(`DEBUG: Current total value: ${currentTotalValue.toFixed(3)} SOL`);
                    console.log(`DEBUG: ${percent}% = ${solToSell.toFixed(3)} SOL to sell`);
                    console.log(`DEBUG: Remaining: ${solRemaining.toFixed(3)} SOL`);
                    
                    // Update inputs
                    document.getElementById('close-take-profit').value = solToSell.toFixed(3);
                    document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                    
                } catch (error) {
                    console.error('Error calculating take profit from percent:', error);
                    // Fall back to simple percentage of entry amount
                    const takeProfit = (originalSolAmount * percent / 100).toFixed(3);
                    const keepPosition = (originalSolAmount * (100 - percent) / 100).toFixed(3);
                    
                    document.getElementById('close-take-profit').value = takeProfit;
                    document.getElementById('close-keep-position').value = keepPosition;
                }
            }

            calculateKeepPosition() {
                if (!this.currentTradeToClose) return;

                const solToSell = parseFloat(document.getElementById('close-take-profit').value);
                const originalAmount = this.currentTradeToClose.sol_amount;
                
                if (!solToSell || isNaN(solToSell)) {
                    document.getElementById('close-keep-position').value = originalAmount.toFixed(3);
                    return;
                }

                const exitMcapValue = parseFloat(document.getElementById('close-exit-mcap').value);
                const activeMultiplier = document.querySelector('#close-trade-modal .mcap-btn.active')?.getAttribute('data-multiplier') || 'B';
                
                if (!exitMcapValue || isNaN(exitMcapValue)) {
                    // No exit mcap, simple calculation
                    const solRemaining = Math.max(0, originalAmount - solToSell);
                    document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                    return;
                }

                try {
                    // Parse entry market cap
                    const entryMcap = this.currentTradeToClose.entry_mcap;
                    const entryValue = parseFloat(entryMcap);
                    const entryUnit = entryMcap.slice(-1).toUpperCase();
                    
                    // Convert both to same base
                    const multipliers = { 'K': 1000, 'M': 1000000, 'B': 1000000000 };
                    const entryActual = entryValue * (multipliers[entryUnit] || 1000000000);
                    const exitActual = exitMcapValue * (multipliers[activeMultiplier] || 1000000000);
                    
                    // Calculate percentage change
                    const percentageChange = (exitActual - entryActual) / entryActual;
                    
                    // Calculate current total value and remaining position
                    const currentTotalValue = originalAmount * (1 + percentageChange);
                    const solRemaining = Math.max(0, currentTotalValue - solToSell);
                    
                    // Update remaining position
                    document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                    
                } catch (error) {
                    console.error('Error calculating keep position:', error);
                    const solRemaining = Math.max(0, originalAmount - solToSell);
                    document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                }
            }

            async confirmCloseTrade() {
                if (!this.currentTradeToClose) return;

                const mcapValue = parseFloat(document.getElementById('close-exit-mcap').value);
                const activeMultiplier = document.querySelector('#close-trade-modal .mcap-btn.active')?.getAttribute('data-multiplier') || 'B';
                const solToSell = parseFloat(document.getElementById('close-take-profit').value);
                const solRemaining = parseFloat(document.getElementById('close-keep-position').value);
                const learnings = document.getElementById('close-trade-learnings').value.trim();

                if (!mcapValue || !solToSell) {
                    alert('Please fill in all fields');
                    return;
                }

                const exitMcap = `${mcapValue}${activeMultiplier}`;
                const originalTrade = this.currentTradeToClose;
                const originalAmount = originalTrade.sol_amount;
                const originalCostBasis = originalTrade._cost_basis !== undefined ? originalTrade._cost_basis : originalAmount; // Fallback for older trades
                
                // Calculate current position value based on mcap change
                const entryMcap = originalTrade.entry_mcap;
                const entryValue = parseFloat(entryMcap);
                const entryUnit = entryMcap.slice(-1).toUpperCase();
                const multipliers = { 'K': 1000, 'M': 1000000, 'B': 1000000000 };
                const entryActual = entryValue * (multipliers[entryUnit] || 1000000000);
                const exitActual = mcapValue * (multipliers[activeMultiplier] || 1000000000);
                const percentageChange = (exitActual - entryActual) / entryActual;
                const currentPositionValue = originalAmount * (1 + percentageChange);
                
                console.log(`CLOSE TRADE: Selling ${solToSell} SOL, keeping ${solRemaining} SOL`);
                console.log(`ORIGINAL: ${originalAmount} SOL with cost basis ${originalCostBasis} SOL`);
                console.log(`CURRENT POSITION VALUE: ${currentPositionValue.toFixed(3)} SOL (${(percentageChange*100).toFixed(1)}% change)`);

                try {
                    if (solToSell >= currentPositionValue) {
                        // Full close - close the entire trade
                        originalTrade.status = 'closed';
                        originalTrade.exit_mcap = exitMcap;
                        originalTrade.exit_price = solToSell * this.solPrice; // USD value of sold amount
                        originalTrade.received_sol = solToSell;
                        originalTrade.final_pnl = solToSell - originalCostBasis;
                        originalTrade.exit_date = new Date().toISOString();
                        
                        // Add learnings if provided
                        if (learnings) {
                            originalTrade.close_learnings = learnings;
                        }

                        console.log(`FULL CLOSE: PnL = ${originalTrade.final_pnl.toFixed(3)} SOL`);
                        
                        // Add badge logic for full close
                        if (originalTrade._is_free_ride === true) {
                            originalTrade._is_free_ride_trade = true;
                            console.log(`FULL CLOSE: Setting _is_free_ride_trade = true (from free ride position)`);
                        } else if (originalCostBasis > 0 && originalTrade.final_pnl >= 0 && !originalTrade._initials_taken) {
                            originalTrade._initials_recovered = true;
                            console.log(`FULL CLOSE: Setting _initials_recovered = true (first initials recovery)`);
                        } else if (originalTrade._initials_taken === true) {
                            originalTrade._is_free_ride_trade = true;
                            console.log(`FULL CLOSE: Setting _is_free_ride_trade = true (subsequent after initials)`);
                        } else if (originalCostBasis === 0) {
                            originalTrade._is_free_ride_trade = true;
                            console.log(`FULL CLOSE: Setting _is_free_ride_trade = true (cost basis is 0)`);
                        }
                        
                        await this.updateTradeInCloud(originalTrade);
                    } else {
                        // Partial close - FREE RIDE LOGIC
                        
                        // Determine cost basis for sold portion
                        let soldCostBasis, remainingCostBasis;
                        
                        if (solToSell <= originalCostBasis) {
                            // Selling less than or equal to original cost basis
                            soldCostBasis = solToSell;
                            remainingCostBasis = originalCostBasis - solToSell;
                        } else {
                            // Selling more than original cost basis (taking profits)
                            soldCostBasis = originalCostBasis;
                            remainingCostBasis = 0; // FREE RIDE!
                        }
                        
                        console.log(`PARTIAL CLOSE: Sold cost basis = ${soldCostBasis}, Remaining cost basis = ${remainingCostBasis}`);
                        console.log(`PNL CALCULATION: ${solToSell} SOL sold - ${soldCostBasis} SOL cost = ${(solToSell - soldCostBasis).toFixed(3)} SOL PnL`);
                        
                        // Create closed trade for sold portion
                        const closedTrade = {
                            id: Date.now().toString(),
                            token: originalTrade.token,
                            sol_amount: solToSell,
                            entry_mcap: originalTrade.entry_mcap,
                            entry_price: soldCostBasis * this.solPrice, // USD value of invested amount
                            entry_date: originalTrade.entry_date,
                            status: 'closed',
                            exit_mcap: exitMcap,
                            exit_price: solToSell * this.solPrice, // USD value of sold amount
                            received_sol: solToSell,
                            final_pnl: solToSell - soldCostBasis,
                            exit_date: new Date().toISOString(),
                            user_id: originalTrade.user_id,
                            // Copy optional fields from original trade
                            notes: originalTrade.notes,
                            stop_loss: originalTrade.stop_loss,
                            take_profit: originalTrade.take_profit
                        };
                        
                        // Add learnings if provided
                        if (learnings) {
                            closedTrade.close_learnings = learnings;
                        }
                        
                        // Store cost_basis locally
                        closedTrade._cost_basis = soldCostBasis;
                        
                        // Mark trade type based on original position and what happens
                        console.log(`TRADE MARKING DEBUG:`, {
                            is_free_ride: originalTrade._is_free_ride,
                            soldCostBasis,
                            solToSell,
                            initials_taken: originalTrade._initials_taken,
                            condition1: originalTrade._is_free_ride === true,
                            condition2: soldCostBasis > 0 && solToSell >= soldCostBasis && !originalTrade._initials_taken,
                            condition3: originalTrade._initials_taken === true
                        });
                        
                        if (originalTrade._is_free_ride === true) {
                            // This trade is from a free ride position
                            closedTrade._is_free_ride_trade = true;
                            console.log(`Setting _is_free_ride_trade = true (from free ride position)`);
                        } else if (soldCostBasis > 0 && solToSell >= soldCostBasis && !originalTrade._initials_taken) {
                            // This is the FIRST "initials raus" trade (cost basis recovered or more)
                            closedTrade._initials_recovered = true;
                            originalTrade._initials_taken = true; // Mark that initials have been taken from this position
                            console.log(`Setting _initials_recovered = true (first initials recovery)`);
                        } else if (originalTrade._initials_taken === true) {
                            // Any subsequent trade after initials have been taken is a free ride
                            closedTrade._is_free_ride_trade = true;
                            console.log(`Setting _is_free_ride_trade = true (subsequent after initials)`);
                        } else {
                            // Fallback: if cost basis is 0, it's definitely a free ride trade
                            if (soldCostBasis === 0) {
                                closedTrade._is_free_ride_trade = true;
                                console.log(`Setting _is_free_ride_trade = true (cost basis is 0)`);
                            }
                        }
                        
                        // Mark if remaining position becomes free ride
                        if (remainingCostBasis === 0) {
                            originalTrade._is_free_ride = true;
                        }

                        console.log(`CLOSED TRADE: ${solToSell} SOL out, cost basis ${soldCostBasis} SOL, PnL = ${closedTrade.final_pnl.toFixed(3)} SOL`);
                        
                        // Check if there's actually something remaining
                        if (solRemaining <= 0) {
                            console.log(`WARNING: solRemaining is ${solRemaining} - marking trade as closed`);
                            originalTrade.status = 'closed';
                            originalTrade.exit_mcap = exitMcap;
                            originalTrade.exit_price = (originalAmount * this.solPrice);
                            originalTrade.received_sol = originalAmount;
                            originalTrade.final_pnl = originalAmount - originalCostBasis;
                            originalTrade.exit_date = new Date().toISOString();
                        } else {
                            // Update original trade for remaining position
                            originalTrade.sol_amount = solRemaining;
                            originalTrade._cost_basis = remainingCostBasis;
                            originalTrade.entry_mcap = exitMcap; // New entry = current level
                            originalTrade.entry_price = remainingCostBasis * this.solPrice; // USD value of remaining cost basis
                            // Keep status as 'open'
                        }

                        console.log(`REMAINING TRADE: ${solRemaining} SOL with cost basis ${remainingCostBasis} SOL`);
                        console.log(`REMAINING TRADE STATUS: ${originalTrade.status}`);
                        console.log(`REMAINING TRADE OBJECT:`, originalTrade);
                        if (remainingCostBasis === 0) {
                            console.log(`🎉 FREE RIDE ACTIVATED!`);
                        }

                        // Save both trades to cloud
                        await this.saveTradeToCloud(closedTrade);
                        await this.updateTradeInCloud(originalTrade);

                        // Add closed trade to local array
                        this.trades.push(closedTrade);
                        
                        // Update the original trade in local array too
                        const tradeIndex = this.trades.findIndex(t => t.id === originalTrade.id);
                        if (tradeIndex !== -1) {
                            this.trades[tradeIndex] = originalTrade;
                        }
                    }

                    this.renderTrades();
                    this.updatePortfolioStats();
                    this.hideCloseTradeModal();

                } catch (error) {
                    console.error('Error closing trade:', error);
                    alert('Failed to close trade');
                }
            }

            async updateTradeInCloud(trade) {
                if (!window.supabase || !window.supabase.isAuthenticated()) return;
                
                // Create a copy with only fields that exist in the database
                const dbTrade = {
                    id: trade.id,
                    token: trade.token,
                    sol_amount: trade.sol_amount,
                    entry_mcap: trade.entry_mcap,
                    entry_price: trade.entry_price,
                    entry_date: trade.entry_date,
                    status: trade.status,
                    pnl: trade.pnl,
                    user_id: trade.user_id
                };

                // Add fields that might exist for closed trades
                if (trade.exit_mcap !== undefined) dbTrade.exit_mcap = trade.exit_mcap;
                if (trade.exit_price !== undefined) dbTrade.exit_price = trade.exit_price;
                if (trade.exit_date !== undefined) dbTrade.exit_date = trade.exit_date;
                if (trade.final_pnl !== undefined) dbTrade.final_pnl = trade.final_pnl;
                if (trade.received_sol !== undefined) dbTrade.received_sol = trade.received_sol;
                if (trade.current_mcap !== undefined) dbTrade.current_mcap = trade.current_mcap;
                if (trade.current_sol !== undefined) dbTrade.current_sol = trade.current_sol;
                
                // Add badge-related flags to database
                if (trade._initials_recovered !== undefined) dbTrade._initials_recovered = trade._initials_recovered;
                if (trade._is_free_ride_trade !== undefined) dbTrade._is_free_ride_trade = trade._is_free_ride_trade;
                if (trade._is_free_ride !== undefined) dbTrade._is_free_ride = trade._is_free_ride;
                if (trade._initials_taken !== undefined) dbTrade._initials_taken = trade._initials_taken;
                if (trade._cost_basis !== undefined) dbTrade._cost_basis = trade._cost_basis;
                
                // TODO: Add these fields when database schema is updated
                // if (trade.stop_loss !== undefined) dbTrade.stop_loss = trade.stop_loss;
                // if (trade.take_profit !== undefined) dbTrade.take_profit = trade.take_profit;
                // if (trade.notes !== undefined) dbTrade.notes = trade.notes;
                
                await window.supabase.update('trades', dbTrade, trade.id);
            }

            async deleteTrade(tradeId) {
                if (!confirm('Are you sure you want to delete this trade?')) return;

                try {
                    // Remove from cloud
                    if (window.supabase && window.supabase.isAuthenticated()) {
                        await window.supabase.delete('trades', tradeId);
                    }
                    
                    // Remove from local array
                    this.trades = this.trades.filter(t => t.id !== tradeId);
                    
                    // Refresh display
                    this.renderTrades();
                    this.updatePortfolioStats();

                } catch (error) {
                    console.error('Error deleting trade:', error);
                    alert('Failed to delete trade');
                }
            }


            async refreshPrices() {
                await this.updateSolPrice();
                // Would update all current market caps here
                alert(`SOL Price updated: $${this.solPrice.toFixed(2)}`);
            }

            viewTradeDetails(tradeId) {
                const trade = this.trades.find(t => t.id === tradeId);
                if (!trade) {
                    console.error('Trade not found:', tradeId);
                    return;
                }

                // Populate modal with trade data
                document.getElementById('detail-token').textContent = trade.token;
                document.getElementById('detail-sol-amount').textContent = `${trade.sol_amount} SOL`;
                document.getElementById('detail-entry-mcap').textContent = trade.entry_mcap;
                document.getElementById('detail-exit-mcap').textContent = trade.exit_mcap || '-';
                
                const pnlValue = trade.final_pnl || 0;
                const pnlElement = document.getElementById('detail-pnl');
                pnlElement.textContent = `${pnlValue >= 0 ? '+' : ''}${pnlValue.toFixed(3)} SOL`;
                pnlElement.style.color = pnlValue >= 0 ? '#059669' : '#dc2626';
                
                document.getElementById('detail-entry-date').textContent = new Date(trade.entry_date).toLocaleDateString('de-DE');
                document.getElementById('detail-exit-date').textContent = trade.exit_date ? new Date(trade.exit_date).toLocaleDateString('de-DE') : '-';
                
                // Show notes and learnings
                const notesElement = document.getElementById('detail-entry-notes');
                notesElement.textContent = trade.notes || '';
                
                const learningsElement = document.getElementById('detail-close-learnings');
                learningsElement.textContent = trade.close_learnings || '';

                // Show modal
                document.getElementById('view-trade-modal').style.display = 'flex';
            }

            hideViewTradeModal() {
                document.getElementById('view-trade-modal').style.display = 'none';
            }
        }

        // Initialize Trading Manager
        window.TradingManager = new TradingManager();
        
        // Initialize lucide icons for trade action buttons
        setTimeout(() => {
            if (window.lucide) {
                lucide.createIcons();
                console.log('🎨 Lucide icons initialized for trade action buttons');
            }
        }, 100);
    </script>
    
    <!-- ========================================= -->
    <!-- ANALYTICS MANAGER -->
    <!-- ========================================= -->
    <script>
        class AnalyticsManager {
            constructor() {
                this.chart = null;
                this.currentPeriod = 'week';
                this.balanceHistory = [];
                this.init();
            }

            async init() {
                // Check if supabase is available and user is authenticated
                if (!window.supabase?.isAuthenticated()) {
                    console.warn('Analytics init skipped - not authenticated');
                    return;
                }
                
                await this.loadBalanceHistory();
                await this.checkAndRecordDailyBalance();
                this.setupPeriodButtons();
                await this.setupChart();
                await this.updateCurrentBalance();
                await this.setupHeatmap();
                await this.setupPerformanceHeatmap();
            }

            async loadBalanceHistory() {
                try {
                    if (!window.supabase?.isAuthenticated()) {
                        this.balanceHistory = [];
                        return;
                    }

                    const user = window.supabase.getCurrentUser();
                    if (!user) {
                        this.balanceHistory = [];
                        return;
                    }

                    // Query balance history from cloud
                    const data = await window.supabase.query(
                        `analytics_balance_history?user_id=eq.${user.id}&select=*&order=date.asc`
                    );

                    this.balanceHistory = data || [];
                    console.log(`📊 Loaded ${this.balanceHistory.length} balance history records from cloud`);
                } catch (error) {
                    console.error('Error loading balance history:', error);
                    this.balanceHistory = [];
                }
            }

            async getTrackingTime() {
                try {
                    if (!window.supabase?.isAuthenticated()) return '06:00';
                    
                    const user = window.supabase.getCurrentUser();
                    if (!user) return '06:00';

                    // Query user settings from cloud
                    const settings = await window.supabase.query(
                        `user_settings?user_id=eq.${user.id}&setting_key=eq.balanceTrackingTime&select=setting_value`
                    );

                    return settings && settings.length > 0 ? settings[0].setting_value : '06:00';
                } catch (error) {
                    console.error('Error getting tracking time:', error);
                    return '06:00';
                }
            }

            async checkAndRecordDailyBalance() {
                const now = new Date();
                const today = now.toISOString().split('T')[0];
                const lastRecorded = this.balanceHistory[this.balanceHistory.length - 1];
                
                // Get tracking time from settings (default 06:00)
                const trackingTime = await this.getTrackingTime();
                const [hours, minutes] = trackingTime.split(':').map(Number);
                
                // Create target time for today
                const targetTime = new Date();
                targetTime.setHours(hours, minutes, 0, 0);
                
                // Check if we haven't recorded today AND it's past the target time
                const hasRecordedToday = lastRecorded && lastRecorded.date === today;
                const isPastTargetTime = now >= targetTime;
                
                if (!hasRecordedToday && isPastTargetTime) {
                    await this.recordDailyBalance();
                } else if (!hasRecordedToday) {
                    // Schedule recording for target time
                    this.scheduleNextRecording(targetTime);
                }
            }

            scheduleNextRecording(targetTime) {
                const now = new Date();
                const msUntilTarget = targetTime.getTime() - now.getTime();
                
                if (msUntilTarget > 0) {
                    console.log(`📊 Next SOL balance recording scheduled for ${targetTime.toLocaleTimeString('de-DE')}`);
                    setTimeout(() => {
                        this.recordDailyBalance();
                    }, msUntilTarget);
                }
            }

            async recordDailyBalance() {
                try {
                    if (!window.supabase?.isAuthenticated()) {
                        console.log('📊 Not authenticated, skipping balance recording');
                        return;
                    }

                    const user = window.supabase.getCurrentUser();
                    if (!user) return;

                    let balance = 0;
                    
                    // Get SOL balance from SimpleCounters
                    if (window.SimpleCounters) {
                        balance = await window.SimpleCounters.getSolBalance();
                    }
                    
                    const today = new Date().toISOString().split('T')[0];
                    
                    // Save to cloud database
                    const balanceRecord = {
                        user_id: user.id,
                        date: today,
                        balance: balance,
                        created_at: new Date().toISOString()
                    };

                    await window.supabase.insert('analytics_balance_history', [balanceRecord]);
                    console.log(`📊 Saved balance record to cloud: ${balance} SOL for ${today}`);
                    
                    // Add to local array
                    this.balanceHistory.push({
                        date: today,
                        balance: balance
                    });
                    
                    // Keep only last 365 days in memory
                    if (this.balanceHistory.length > 365) {
                        this.balanceHistory = this.balanceHistory.slice(-365);
                    }
                    
                    console.log(`📊 Recorded daily SOL balance: ${balance} SOL for ${today}`);
                    
                    // Update chart if it exists
                    if (this.chart) {
                        this.updateChart();
                    }
                } catch (error) {
                    console.error('Error recording daily balance:', error);
                }
            }

            async updateCurrentBalance() {
                try {
                    let balance = 0;
                    
                    if (window.SimpleCounters) {
                        balance = await window.SimpleCounters.getSolBalance();
                    }
                    
                    const balanceElement = document.getElementById('current-sol-balance');
                    if (balanceElement) {
                        balanceElement.textContent = `Current: ${balance.toFixed(3)} SOL`;
                    }
                } catch (error) {
                    console.error('Error updating current balance:', error);
                }
            }

            setupPeriodButtons() {
                const buttons = document.querySelectorAll('.period-btn');
                buttons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        // Remove active from all buttons
                        buttons.forEach(b => b.classList.remove('active'));
                        // Add active to clicked button
                        e.target.classList.add('active');
                        // Update period and refresh chart
                        this.currentPeriod = e.target.dataset.period;
                        this.updateChart();
                    });
                });
            }

            getFilteredData() {
                const now = new Date();
                let cutoffDate;
                
                switch(this.currentPeriod) {
                    case 'week':
                        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        break;
                    case 'month':
                        cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        break;
                    case 'quarter':
                        cutoffDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                        break;
                    case 'year':
                        cutoffDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
                        break;
                    default:
                        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                }
                
                return this.balanceHistory.filter(record => {
                    const recordDate = new Date(record.date);
                    return recordDate >= cutoffDate;
                });
            }

            async setupChart() {
                const canvas = document.getElementById('solBalanceChart');
                if (!canvas || !window.Chart) return;

                // Destroy existing chart if it exists
                if (this.chart) {
                    this.chart.destroy();
                    this.chart = null;
                }

                const ctx = canvas.getContext('2d');
                
                // Prepare data
                const filteredData = this.getFilteredData();
                const labels = filteredData.map(record => {
                    const date = new Date(record.date);
                    return date.toLocaleDateString('de-DE', { month: 'short', day: 'numeric' });
                });
                
                const data = filteredData.map(record => record.balance);
                
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'SOL Balance',
                            data: data,
                            borderColor: '#000000',
                            backgroundColor: 'rgba(0, 0, 0, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'SOL Balance',
                                    font: {
                                        size: 11
                                    }
                                },
                                ticks: {
                                    font: {
                                        size: 10
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date',
                                    font: {
                                        size: 11
                                    }
                                },
                                ticks: {
                                    font: {
                                        size: 10
                                    },
                                    maxTicksLimit: 8
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            title: {
                                display: false
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        }
                    }
                });
            }

            updateChart() {
                if (!this.chart) return;
                
                const filteredData = this.getFilteredData();
                const labels = filteredData.map(record => {
                    const date = new Date(record.date);
                    return date.toLocaleDateString('de-DE', { month: 'short', day: 'numeric' });
                });
                
                const data = filteredData.map(record => record.balance);
                
                this.chart.data.labels = labels;
                this.chart.data.datasets[0].data = data;
                this.chart.update();
            }

            async setupHeatmap() {
                // Show loading state
                const statsElement = document.getElementById('heatmap-stats');
                if (statsElement) statsElement.textContent = 'Loading todo data...';
                
                await this.generateHeatmapData();
                this.renderHeatmap();
                this.updateHeatmapStats();
            }

            async generateHeatmapData() {
                try {
                    // Generate data for the last 365 days (like GitHub)
                    const today = new Date();
                    const startDate = new Date(today);
                    startDate.setDate(today.getDate() - 364); // 365 days including today
                    
                    // Start from Sunday of the week containing startDate
                    const startSunday = new Date(startDate);
                    startSunday.setDate(startDate.getDate() - startDate.getDay());
                    
                    // Check if supabase is available and user is authenticated
                    if (!window.supabase?.isAuthenticated()) {
                        console.warn('No supabase or user not authenticated for heatmap');
                        this.heatmapData = [];
                        return;
                    }
                    
                    // Get all completed todos in one query
                    const user = window.supabase.getCurrentUser();
                    if (!user) {
                        console.warn('No user logged in for heatmap');
                        this.heatmapData = [];
                        return;
                    }
                    
                    const startDateStr = startSunday.toISOString().split('T')[0];
                    const endDateStr = new Date(today.getTime() + 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                    
                    const completedTodos = await window.supabase.query(
                        `todos?user_id=eq.${user.id}&completed=eq.true&updated_at=gte.${startDateStr}&updated_at=lt.${endDateStr}&select=updated_at`
                    );
                    
                    // Group todos by date (convert UTC to local date)
                    const todosByDate = {};
                    if (completedTodos) {
                        completedTodos.forEach(todo => {
                            // Convert UTC timestamp to local date string
                            const utcDate = new Date(todo.updated_at);
                            const localDate = new Date(utcDate.getTime() - utcDate.getTimezoneOffset() * 60000);
                            const date = localDate.toISOString().split('T')[0];
                            todosByDate[date] = (todosByDate[date] || 0) + 1;
                        });
                    }
                    
                    this.heatmapData = [];
                    
                    for (let i = 0; i < 371; i++) { // 53 weeks * 7 days = 371
                        const date = new Date(startSunday);
                        date.setDate(startSunday.getDate() + i);
                        
                        // Use local date string to match with converted todo dates
                        const localDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
                        const dateStr = localDate.toISOString().split('T')[0];
                        const todoCount = todosByDate[dateStr] || 0;
                        
                        this.heatmapData.push({
                            date: dateStr,
                            count: todoCount,
                            level: this.getIntensityLevel(todoCount)
                        });
                    }
                    
                    console.log(`📊 Generated heatmap data for ${this.heatmapData.length} days with ${completedTodos?.length || 0} completed todos`);
                } catch (error) {
                    console.error('Error generating heatmap data:', error);
                    this.heatmapData = [];
                }
            }


            getIntensityLevel(count) {
                if (count === 0) return 0;
                if (count <= 2) return 1;
                if (count <= 5) return 2;
                if (count <= 10) return 3;
                return 4;
            }

            renderHeatmap() {
                const gridContainer = document.getElementById('heatmap-grid');
                const monthsContainer = document.getElementById('heatmap-months');
                
                if (!gridContainer || !monthsContainer) return;
                
                // Clear existing content
                gridContainer.innerHTML = '';
                monthsContainer.innerHTML = '';
                
                // Render month labels
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                let currentMonth = -1;
                
                for (let week = 0; week < 53; week++) {
                    const weekStart = week * 7;
                    if (weekStart < this.heatmapData.length) {
                        const date = new Date(this.heatmapData[weekStart].date);
                        const month = date.getMonth();
                        
                        if (month !== currentMonth && week % 4 === 0) {
                            const monthDiv = document.createElement('div');
                            monthDiv.className = 'heatmap-month';
                            monthDiv.textContent = months[month];
                            monthDiv.style.gridColumn = `${week + 1} / span 4`;
                            monthsContainer.appendChild(monthDiv);
                            currentMonth = month;
                        }
                    }
                }
                
                // Render squares in correct grid position (column-first order for GitHub-style layout)
                for (let week = 0; week < 53; week++) {
                    for (let day = 0; day < 7; day++) {
                        const index = week * 7 + day;
                        if (index < this.heatmapData.length) {
                            const dayData = this.heatmapData[index];
                            const square = document.createElement('div');
                            square.className = `heatmap-square level-${dayData.level}`;
                            square.title = `${dayData.date}: ${dayData.count} todos completed`;
                            
                            // Set explicit grid position: column = week + 1, row = day + 1
                            square.style.gridColumn = week + 1;
                            square.style.gridRow = day + 1;
                            
                            square.addEventListener('click', () => {
                                alert(`${dayData.date}: ${dayData.count} todos completed`);
                            });
                            
                            gridContainer.appendChild(square);
                        }
                    }
                }
            }

            updateHeatmapStats() {
                const statsElement = document.getElementById('heatmap-stats');
                if (!statsElement) return;
                
                // Remove the stats text - user finds it not nice
                statsElement.textContent = '';
            }

            async setupPerformanceHeatmap() {
                // Show loading state
                const statsElement = document.getElementById('performance-heatmap-stats');
                if (statsElement) statsElement.textContent = 'Loading performance data...';
                
                await this.generatePerformanceHeatmapData();
                this.renderPerformanceHeatmap();
                this.updatePerformanceHeatmapStats();
            }

            async generatePerformanceHeatmapData() {
                try {
                    // EXACTLY the same date logic as Todo heatmap
                    const today = new Date();
                    const startDate = new Date(today);
                    startDate.setDate(today.getDate() - 364); // 365 days including today
                    
                    // Start from Sunday of the week containing startDate (SAME AS TODO)
                    const startSunday = new Date(startDate);
                    startSunday.setDate(startDate.getDate() - startDate.getDay());
                    
                    this.performanceHeatmapData = [];
                    
                    // Process balance history data
                    const performanceByDate = {};
                    
                    if (this.balanceHistory && this.balanceHistory.length > 1) {
                        // Sort by date
                        const sortedHistory = [...this.balanceHistory].sort((a, b) => 
                            new Date(a.date) - new Date(b.date)
                        );
                        
                        // Calculate daily performance compared to previous day
                        for (let i = 1; i < sortedHistory.length; i++) {
                            const current = sortedHistory[i];
                            const previous = sortedHistory[i - 1];
                            
                            // Use local date conversion SAME AS TODO HEATMAP
                            const utcDate = new Date(current.date + 'T00:00:00Z');
                            const localDate = new Date(utcDate.getTime() - utcDate.getTimezoneOffset() * 60000);
                            const dateStr = localDate.toISOString().split('T')[0];
                            
                            let performance = 'neutral';
                            if (current.balance > previous.balance) {
                                performance = 'gain';
                            } else if (current.balance < previous.balance) {
                                performance = 'loss';
                            }
                            
                            performanceByDate[dateStr] = {
                                performance: performance,
                                currentBalance: current.balance,
                                previousBalance: previous.balance,
                                change: current.balance - previous.balance
                            };
                        }
                    }
                    
                    // Generate EXACTLY 371 days like Todo heatmap (53 weeks * 7 days = 371)
                    for (let i = 0; i < 371; i++) {
                        const date = new Date(startSunday);
                        date.setDate(startSunday.getDate() + i);
                        
                        // Use local date string to match with converted dates (SAME AS TODO)
                        const localDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
                        const dateStr = localDate.toISOString().split('T')[0];
                        
                        if (performanceByDate[dateStr]) {
                            this.performanceHeatmapData.push({
                                date: dateStr,
                                ...performanceByDate[dateStr]
                            });
                        } else {
                            // No data for this day - just add empty slot
                            this.performanceHeatmapData.push({
                                date: dateStr,
                                performance: null
                            });
                        }
                    }
                    
                    console.log(`📊 Generated performance heatmap data for ${this.performanceHeatmapData.length} days`);
                } catch (error) {
                    console.error('❌ Error generating performance heatmap data:', error);
                    this.performanceHeatmapData = [];
                }
            }

            renderPerformanceHeatmap() {
                const container = document.getElementById('performance-heatmap-grid');
                if (!container || !this.performanceHeatmapData) return;
                
                // Clear existing content
                container.innerHTML = '';
                
                // Create squares with explicit grid positioning (same as Todo heatmap)
                for (let week = 0; week < 53; week++) {
                    for (let day = 0; day < 7; day++) {
                        const index = week * 7 + day;
                        if (index < this.performanceHeatmapData.length) {
                            const dayData = this.performanceHeatmapData[index];
                            const square = document.createElement('div');
                            
                            if (dayData.performance === null) {
                                // No data - use empty styling like Todo heatmap
                                square.className = 'heatmap-square level-0';
                                square.title = new Date(dayData.date).toLocaleDateString('de-DE', { 
                                    year: 'numeric', 
                                    month: 'short', 
                                    day: 'numeric' 
                                }) + '\\nNo data';
                            } else {
                                // Has performance data
                                square.className = `heatmap-square performance-${dayData.performance}`;
                                
                                // Add tooltip
                                const date = new Date(dayData.date);
                                const formattedDate = date.toLocaleDateString('de-DE', { 
                                    year: 'numeric', 
                                    month: 'short', 
                                    day: 'numeric' 
                                });
                                
                                let tooltip = `${formattedDate}`;
                                if (dayData.change !== undefined) {
                                    const changeText = dayData.change > 0 ? 
                                        `+${dayData.change.toFixed(3)} SOL` : 
                                        `${dayData.change.toFixed(3)} SOL`;
                                    tooltip += `\\n${changeText}`;
                                    tooltip += `\\n${dayData.currentBalance.toFixed(3)} SOL total`;
                                }
                                
                                square.title = tooltip;
                            }
                            
                            // Set explicit grid position: column = week + 1, row = day + 1
                            square.style.gridColumn = week + 1;
                            square.style.gridRow = day + 1;
                            
                            container.appendChild(square);
                        }
                    }
                }
                
                // Generate month labels
                this.generatePerformanceMonthLabels();
            }

            generatePerformanceMonthLabels() {
                const monthsContainer = document.getElementById('performance-heatmap-months');
                if (!monthsContainer || !this.performanceHeatmapData) return;
                
                monthsContainer.innerHTML = '';
                
                // Render month labels same as Todo heatmap
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                let currentMonth = -1;
                
                for (let week = 0; week < 53; week++) {
                    const weekStart = week * 7;
                    if (weekStart < this.performanceHeatmapData.length) {
                        const date = new Date(this.performanceHeatmapData[weekStart].date);
                        const month = date.getMonth();
                        
                        if (month !== currentMonth && week % 4 === 0) {
                            const monthDiv = document.createElement('div');
                            monthDiv.className = 'heatmap-month';
                            monthDiv.textContent = months[month];
                            monthDiv.style.gridColumn = `${week + 1} / span 4`;
                            monthsContainer.appendChild(monthDiv);
                            currentMonth = month;
                        }
                    }
                }
            }

            updatePerformanceHeatmapStats() {
                const statsElement = document.getElementById('performance-heatmap-stats');
                if (!statsElement) return;
                
                // Remove the stats text - user doesn't want it
                statsElement.textContent = '';
            }
        }

        // Initialize Analytics Manager
        window.AnalyticsManager = new AnalyticsManager();
        
        // Initialize when analytics tab is opened
        document.addEventListener('DOMContentLoaded', () => {
            const analyticsTab = document.querySelector('[data-tab="tab-analytics"]');
            if (analyticsTab) {
                analyticsTab.addEventListener('click', () => {
                    setTimeout(() => {
                        if (window.AnalyticsManager) {
                            window.AnalyticsManager.init();
                        }
                    }, 100);
                });
            }
            
            // Load saved balance tracking time from cloud
            if (window.AnalyticsManager) {
                window.AnalyticsManager.getTrackingTime().then(savedTime => {
                    const timeInput = document.getElementById('balance-tracking-time');
                    if (timeInput) timeInput.value = savedTime;
                });
            }
            
            // Save analytics settings
            const saveAnalyticsBtn = document.getElementById('save-analytics-settings');
            if (saveAnalyticsBtn) {
                saveAnalyticsBtn.addEventListener('click', async () => {
                    const timeInput = document.getElementById('balance-tracking-time');
                    if (timeInput && window.supabase?.isAuthenticated()) {
                        const user = window.supabase.getCurrentUser();
                        if (user) {
                            try {
                                // Save to cloud
                                const setting = {
                                    user_id: user.id,
                                    setting_key: 'balanceTrackingTime',
                                    setting_value: timeInput.value,
                                    updated_at: new Date().toISOString()
                                };
                                
                                await window.supabase.upsert('user_settings', setting, ['user_id', 'setting_key']);
                                alert(`Analytics Einstellungen gespeichert! SOL Balance wird täglich um ${timeInput.value} Uhr aufgezeichnet.`);
                            } catch (error) {
                                console.error('Error saving analytics settings:', error);
                                alert('Fehler beim Speichern der Einstellungen.');
                            }
                        }
                    }
                });
            }
        });

        // === MOTIVATIONAL QUOTES SYSTEM ===
        class MotivationalQuotes {
            constructor() {
                this.quotes = [
                    { text: "The way to get started is to quit talking and begin doing.", author: "Walt Disney" },
                    { text: "Success is not final, failure is not fatal: it is the courage to continue that counts.", author: "Winston Churchill" },
                    { text: "Don't be afraid to give up the good to go for the great.", author: "John D. Rockefeller" },
                    { text: "The only impossible journey is the one you never begin.", author: "Tony Robbins" },
                    { text: "In the middle of difficulty lies opportunity.", author: "Albert Einstein" },
                    { text: "It does not matter how slowly you go as long as you do not stop.", author: "Confucius" },
                    { text: "Everything you've ever wanted is on the other side of fear.", author: "George Addair" },
                    { text: "Believe you can and you're halfway there.", author: "Theodore Roosevelt" },
                    { text: "The only person you are destined to become is the person you decide to be.", author: "Ralph Waldo Emerson" },
                    { text: "I have not failed. I've just found 10,000 ways that won't work.", author: "Thomas Edison" },
                    { text: "A successful man is one who can lay a firm foundation with the bricks others have thrown at him.", author: "David Brinkley" },
                    { text: "The stock market is filled with individuals who know the price of everything, but the value of nothing.", author: "Philip Fisher" },
                    { text: "Risk comes from not knowing what you're doing.", author: "Warren Buffett" },
                    { text: "The four most dangerous words in investing are: 'this time it's different.'", author: "Sir John Templeton" },
                    { text: "Time in the market beats timing the market.", author: "Ken Fisher" },
                    { text: "An investment in knowledge pays the best interest.", author: "Benjamin Franklin" },
                    { text: "The best investment you can make is in yourself.", author: "Warren Buffett" },
                    { text: "Don't put all your eggs in one basket.", author: "Andrew Carnegie" },
                    { text: "It's not how much money you make, but how much money you keep.", author: "Robert Kiyosaki" },
                    { text: "The real measure of your wealth is how much you'd be worth if you lost all your money.", author: "Anonymous" }
                ];
                this.currentQuoteIndex = this.getTodaysQuoteIndex();
            }

            getTodaysQuoteIndex() {
                // Use today's date to generate a consistent quote for the day
                const today = new Date();
                const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);
                return dayOfYear % this.quotes.length;
            }

            getCurrentQuote() {
                return this.quotes[this.currentQuoteIndex];
            }

            getRandomQuote() {
                this.currentQuoteIndex = Math.floor(Math.random() * this.quotes.length);
                return this.getCurrentQuote();
            }

            displayQuote(quote = null) {
                const quoteToDisplay = quote || this.getCurrentQuote();
                const quoteTextEl = document.getElementById('daily-quote');
                const quoteAuthorEl = document.getElementById('quote-author');

                if (quoteTextEl && quoteAuthorEl) {
                    quoteTextEl.textContent = quoteToDisplay.text;
                    quoteAuthorEl.textContent = quoteToDisplay.author;
                }
            }

            init() {
                // Display today's quote
                this.displayQuote();

                // Add refresh button functionality
                const refreshBtn = document.getElementById('refresh-quote-btn');
                if (refreshBtn) {
                    refreshBtn.addEventListener('click', () => {
                        const newQuote = this.getRandomQuote();
                        this.displayQuote(newQuote);
                        
                        // Simple feedback without excessive animation
                    });
                }
            }
        }

        // Initialize Motivational Quotes
        document.addEventListener('DOMContentLoaded', () => {
            window.motivationalQuotes = new MotivationalQuotes();
            window.motivationalQuotes.init();
        });
    </script>
    
    <!-- ========================================= -->
    <!-- CLOUD-FIRST POLICY ENFORCEMENT -->
    <!-- ========================================= -->
    <script src="CLOUD_POLICY.js"></script>
    <script>
        // Aktiviere Cloud-Policy für alle Manager
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🛡️ Activating Cloud-First Policy enforcement...');
            
            // Validiere alle existierenden Manager
            setTimeout(() => {
                const managers = [
                    { name: 'TodoManager', obj: window.TodoManager },
                    { name: 'GoalManager', obj: window.GoalManager },
                    { name: 'JournalManager', obj: window.JournalManager },
                    { name: 'TerminManager', obj: window.TerminManager },
                    { name: 'ResourceManager', obj: window.ResourceManager },
                    { name: 'Wiki', obj: window.Wiki },
                    { name: 'SimpleRoutineManager', obj: window.simpleRoutineManager }
                ];
                
                console.log('🔍 Validating all managers for Cloud-First compliance...');
                
                managers.forEach(({ name, obj }) => {
                    if (obj) {
                        console.log(`✅ ${name}: Available and cloud-compliant`);
                    } else {
                        console.warn(`⚠️ ${name}: Not found`);
                    }
                });
                
                console.log('📋 All future implementations must follow CLOUD_POLICY.js guidelines');
                
            }, 2000);
        });

        // === CRYPTO PRICE WIDGET ===
        class CryptoPriceWidget {
            constructor() {
                this.apiUrl = 'https://api.hyperliquid.xyz/info';
                this.allSymbols = []; // Will be populated from API
                this.allCoinsData = {}; // Full coin data from Hyperliquid
                this.overlaySymbols = ['BTC', 'ETH', 'SOL']; // Default, will be overridden by cloud data
                this.updateInterval = 60000; // 60 seconds
                this.currentPrices = {};
                this.price24hAgo = {};
                this.intervalId = null;
                this.overlay = document.querySelector('.crypto-overlay');
                
                this.init();
            }

            async loadSavedCoins() {
                try {
                    if (!window.supabase || !window.supabase.isAuthenticated()) {
                        console.warn('⚠️ Not authenticated, using default coins');
                        return null;
                    }

                    const user = window.supabase.getCurrentUser();
                    const result = await window.supabase.query(`crypto_watchlist?user_id=eq.${user.id}&select=coins`);
                    
                    if (result && result.length > 0) {
                        const coins = JSON.parse(result[0].coins);
                        console.log('☁️ Loaded coins from cloud:', coins);
                        return coins;
                    }
                    
                    console.log('☁️ No saved coins found in cloud');
                    return null;
                } catch (e) {
                    console.error('❌ Error loading saved coins from cloud:', e);
                    return null;
                }
            }

            async saveCoins() {
                try {
                    if (!window.supabase || !window.supabase.isAuthenticated()) {
                        console.warn('⚠️ Not authenticated, cannot save coins to cloud');
                        return;
                    }

                    console.log('☁️ Saving coins to cloud:', this.overlaySymbols);
                    
                    const user = window.supabase.getCurrentUser();
                    const dataToSave = {
                        user_id: user.id,
                        coins: JSON.stringify(this.overlaySymbols),
                        updated_at: new Date().toISOString()
                    };

                    // Check if watchlist exists
                    const existing = await window.supabase.query(`crypto_watchlist?user_id=eq.${user.id}&select=*`);
                    
                    if (existing && existing.length > 0) {
                        // Update existing
                        await window.supabase.update('crypto_watchlist', dataToSave, existing[0].id);
                        console.log('☁️ Updated existing watchlist in cloud');
                    } else {
                        // Create new
                        await window.supabase.insert('crypto_watchlist', [dataToSave]);
                        console.log('☁️ Created new watchlist in cloud');
                    }
                    
                    console.log('☁️ Successfully saved coins to cloud');
                } catch (e) {
                    console.error('❌ Could not save crypto coins to cloud:', e);
                }
            }

            async init() {
                console.log('🔗 Initializing New Crypto Price Widget...');
                console.log('📋 Default overlay symbols:', this.overlaySymbols);
                
                // Immediate render with defaults - no delay
                try {
                    // Show loading state immediately
                    this.showLoadingState();
                    
                    // DEBUG: Add artificial delay to see skeleton loading
                    const isDebugMode = window.location.hash.includes('debug') || localStorage.getItem('debug-loading') === 'true';
                    if (isDebugMode) {
                        console.log('🐛 DEBUG MODE: Showing loading skeleton for 3 seconds...');
                        await new Promise(resolve => setTimeout(resolve, 3000));
                    }
                    
                    // Run everything in parallel for speed
                    const [savedCoins, hyperliquidData] = await Promise.all([
                        this.loadSavedCoins(),
                        this.loadAllCoinsFromHyperliquid()
                    ]);
                    
                    // Update watchlist if we have saved coins
                    if (savedCoins && savedCoins.length > 0) {
                        this.overlaySymbols = savedCoins;
                        console.log('☁️ Loaded watchlist from cloud:', this.overlaySymbols);
                    } else {
                        console.log('📋 Using default coins:', this.overlaySymbols);
                    }
                    
                    // Render immediately with current prices (if available)
                    this.clearAllStaticItems();
                    this.renderCoinItems();
                    this.setupEventListeners();
                    this.setupSearchFunctionality();
                    this.setupSettingsEventListeners();
                    
                    // Load price updates in background
                    this.updatePricesInBackground();
                    this.startAutoUpdate();
                    
                    this.hideLoadingState();
                    
                } catch (error) {
                    console.error('❌ Error initializing crypto widget:', error);
                    this.hideLoadingState();
                }
            }

            showLoadingState() {
                if (window.SmartLoading) {
                    window.SmartLoading.showSkeleton('crypto-overlay-items', 'watchlist', 3);
                }
            }

            hideLoadingState() {
                // Loading state is automatically replaced when renderCoinItems() is called
            }

            async updatePricesInBackground() {
                // Non-blocking price update - doesn't wait for completion
                setTimeout(async () => {
                    try {
                        await this.updatePricesAndCharts();
                    } catch (error) {
                        console.warn('Background price update failed:', error);
                    }
                }, 100);
            }

            async loadAllCoinsFromHyperliquid() {
                console.log('🔄 Loading all coins from Hyperliquid...');
                
                try {
                    // Run meta and prices requests in parallel
                    const [metaResponse, pricesResponse] = await Promise.all([
                        fetch(this.apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ type: 'meta' })
                        }),
                        fetch(this.apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ type: 'allMids' })
                        })
                    ]);

                    if (!metaResponse.ok) throw new Error(`Meta API error: ${metaResponse.status}`);
                    if (!pricesResponse.ok) throw new Error(`Prices API error: ${pricesResponse.status}`);
                    
                    const [metaData, pricesData] = await Promise.all([
                        metaResponse.json(),
                        pricesResponse.json()
                    ]);
                    
                    this.allSymbols = metaData.universe
                        .filter(coin => !coin.isDelisted)
                        .map(coin => coin.name)
                        .sort();

                    this.currentPrices = pricesData;

                    console.log(`✅ Loaded ${this.allSymbols.length} coins and ${Object.keys(pricesData).length} prices from Hyperliquid`);
                    
                } catch (error) {
                    console.error('❌ Error loading coins:', error);
                    // Fallback to basic coins if API fails
                    this.allSymbols = ['BTC', 'ETH', 'SOL', 'ENA', 'PENGU', 'kBONK', 'FARTCOIN'];
                    
                    // Try to load just prices as fallback
                    try {
                        await this.loadCurrentPrices();
                    } catch (priceError) {
                        console.warn('❌ Could not load fallback prices:', priceError);
                    }
                }
            }

            async loadCurrentPrices() {
                try {
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ type: 'allMids' })
                    });

                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    
                    const data = await response.json();
                    this.currentPrices = data;
                    
                    console.log(`🔄 Updated current prices for ${Object.keys(data).length} coins`);
                } catch (error) {
                    console.error('❌ Error loading current prices:', error);
                }
            }

            async load24hPriceChange(symbol) {
                try {
                    const now = Date.now();
                    const yesterday = now - (24 * 60 * 60 * 1000);
                    
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            type: 'candleSnapshot',
                            req: {
                                coin: symbol,
                                interval: '1h',
                                startTime: yesterday,
                                endTime: now
                            }
                        })
                    });

                    if (!response.ok) return null;
                    
                    const data = await response.json();
                    if (data && data.length > 0) {
                        const oldPrice = parseFloat(data[0].o);
                        const currentPrice = parseFloat(this.currentPrices[symbol] || 0);
                        
                        if (oldPrice && currentPrice) {
                            return ((currentPrice - oldPrice) / oldPrice) * 100;
                        }
                    }
                    
                    return null;
                } catch (error) {
                    console.warn(`Could not load 24h data for ${symbol}:`, error);
                    return null;
                }
            }

            async load7DayChart(symbol) {
                try {
                    const now = Date.now();
                    const weekAgo = now - (7 * 24 * 60 * 60 * 1000);
                    
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            type: 'candleSnapshot',
                            req: {
                                coin: symbol,
                                interval: '4h',
                                startTime: weekAgo,
                                endTime: now
                            }
                        })
                    });

                    if (!response.ok) return [];
                    
                    const data = await response.json();
                    return data.map(candle => parseFloat(candle.c));
                    
                } catch (error) {
                    console.warn(`Could not load 7d chart for ${symbol}:`, error);
                    return [];
                }
            }

            clearAllStaticItems() {
                // Remove ANY crypto-overlay-item that doesn't have the dynamic-coin-item class
                const allItems = document.querySelectorAll('.crypto-overlay-item:not(.dynamic-coin-item)');
                console.log(`🧹 Clearing ${allItems.length} static coin items...`);
                allItems.forEach((item, index) => {
                    console.log(`🗑️ Removing static item ${index + 1}:`, item);
                    item.remove();
                });
            }

            setupEventListeners() {
                // Toggle overlay
                const toggleBtn = document.querySelector('.crypto-toggle-btn');
                if (toggleBtn && this.overlay) {
                    toggleBtn.addEventListener('click', () => {
                        this.overlay.classList.toggle('collapsed');
                    });
                } else {
                    console.error('❌ Toggle button not found');
                }


                // Settings toggle
                const settingsBtn = document.querySelector('.crypto-settings-btn');
                const settingsPanel = document.querySelector('.crypto-settings-panel');
                const settingsClose = document.querySelector('.crypto-settings-close');
                
                console.log('🔧 Settings button found:', settingsBtn);
                console.log('🔧 Settings panel found:', settingsPanel);
                console.log('🔧 Settings close found:', settingsClose);
                
                if (settingsBtn && settingsPanel) {
                    settingsBtn.addEventListener('click', () => {
                        console.log('⚙️ Settings button clicked!');
                        const isVisible = settingsPanel.style.display !== 'none';
                        settingsPanel.style.display = isVisible ? 'none' : 'block';
                        
                        if (!isVisible) {
                            this.renderAvailableCoins();
                        }
                        console.log('📋 Settings panel display:', settingsPanel.style.display);
                    });
                } else {
                    console.error('❌ Settings button or panel not found');
                }

                if (settingsClose && settingsPanel) {
                    settingsClose.addEventListener('click', () => {
                        console.log('❌ Settings close clicked!');
                        settingsPanel.style.display = 'none';
                    });
                }

                // Coin selection checkboxes
                this.allSymbols.forEach(symbol => {
                    const checkboxId = symbol === 'kBONK' ? 'coin-bonk' : `coin-${symbol.toLowerCase()}`;
                    const checkbox = document.getElementById(checkboxId);
                    if (checkbox) {
                        checkbox.checked = this.overlaySymbols.includes(symbol);
                        checkbox.addEventListener('change', async () => {
                            await this.toggleCoin(symbol, checkbox.checked);
                        });
                    } else {
                        console.warn(`Checkbox not found for ${symbol} (ID: ${checkboxId})`);
                    }
                });

            }

            setupSettingsEventListeners() {
                console.log('🔧 Setting up crypto settings event listeners...');
                
                // Settings search functionality
                const settingsSearchInput = document.getElementById('settings-crypto-search');
                if (settingsSearchInput) {
                    console.log('✅ Found settings crypto search input');
                    settingsSearchInput.addEventListener('input', (e) => {
                        const query = e.target.value;
                        console.log('🔍 Settings search query:', query);
                        this.renderCoinsInSettings(query);
                    });
                    
                    // Initialize with empty search to show all coins
                    this.renderCoinsInSettings();
                } else {
                    console.warn('⚠️ Settings crypto search input not found');
                }
            }

            async toggleCoin(symbol, enabled) {
                if (enabled && !this.overlaySymbols.includes(symbol)) {
                    this.overlaySymbols.push(symbol);
                } else if (!enabled) {
                    this.overlaySymbols = this.overlaySymbols.filter(s => s !== symbol);
                }
                
                await this.saveCoins();
                this.renderCoinItems();
            }

            async renderCoinItems() {
                const container = document.getElementById('crypto-overlay-items');
                if (!container) {
                    console.error('❌ crypto-overlay-items container not found');
                    return;
                }

                console.log('🔄 Rendering coins:', this.overlaySymbols);
                container.innerHTML = '';
                
                // Render all coins immediately without waiting for data
                for (const symbol of this.overlaySymbols) {
                    const item = document.createElement('div');
                    item.className = 'crypto-overlay-item dynamic-coin-item';
                    item.setAttribute('data-symbol', symbol);
                    
                    const displaySymbol = symbol === 'kBONK' ? 'BONK' : symbol;
                    const currentPrice = this.currentPrices[symbol];
                    const formattedPrice = currentPrice ? this.formatPrice(currentPrice) : '$--';
                    
                    item.innerHTML = `
                        <span class="crypto-overlay-symbol">${displaySymbol}</span>
                        <span class="crypto-overlay-price">${formattedPrice}</span>
                        <span class="crypto-overlay-change">...</span>
                    `;
                    
                    container.appendChild(item);
                }
                
                console.log(`✅ Rendered ${this.overlaySymbols.length} coin items instantly`);
                
                // Check if we need scrolling or centering
                this.updateTickerDisplay(container);
                
                // Load charts and price changes in background (non-blocking)
                this.loadChartsAndPriceChangesAsync();
            }

            updateTickerDisplay(container) {
                // Wait for DOM to update
                setTimeout(() => {
                    const tickerContainer = container.closest('.ticker-container');
                    const tickerContent = container;
                    
                    // Calculate total width needed vs available width
                    const containerWidth = tickerContainer.clientWidth;
                    let totalItemsWidth = 0;
                    
                    // Sum up width of all coin items
                    const items = container.querySelectorAll('.crypto-overlay-item');
                    items.forEach(item => {
                        totalItemsWidth += item.offsetWidth;
                    });
                    
                    // Add gap spacing (20px between items)
                    const totalGapsWidth = (items.length - 1) * 20;
                    const totalContentWidth = totalItemsWidth + totalGapsWidth;
                    
                    console.log(`📏 Container width: ${containerWidth}px, Content width: ${totalContentWidth}px`);
                    
                    if (totalContentWidth <= containerWidth * 0.8) {
                        // Few coins - center them statically
                        tickerContent.classList.add('center-static');
                        console.log('📍 Using centered static display');
                    } else {
                        // Many coins - use scrolling animation
                        tickerContent.classList.remove('center-static');
                        console.log('🔄 Using scrolling animation');
                    }
                }, 100);
            }

            async loadChartsAndPriceChangesAsync() {
                // Load all charts and price changes in parallel
                const promises = this.overlaySymbols.map(async (symbol) => {
                    // Load chart and price change in parallel for each coin
                    const [, change] = await Promise.all([
                        this.loadAndRenderMiniChart(symbol),
                        this.load24hPriceChange(symbol)
                    ]);
                    
                    if (change !== null) {
                        this.updatePriceChange(symbol, change);
                    }
                });
                
                // Wait for all to complete (but don't block the main render)
                await Promise.all(promises);
                console.log('📊 All charts and price changes loaded');
            }

            async loadAndRenderMiniChart(symbol) {
                const canvas = document.querySelector(`canvas[data-symbol="${symbol}"]`);
                if (!canvas) return;

                const chartData = await this.load7DayChart(symbol);
                if (chartData.length > 0) {
                    this.renderMiniChart(canvas, chartData);
                }
            }

            renderMiniChart(canvas, priceData) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                if (priceData.length < 2) return;
                
                const maxPrice = Math.max(...priceData);
                const minPrice = Math.min(...priceData);
                const priceRange = maxPrice - minPrice;
                
                if (priceRange === 0) return;
                
                // Determine line color based on trend
                const firstPrice = priceData[0];
                const lastPrice = priceData[priceData.length - 1];
                const isPositive = lastPrice >= firstPrice;
                
                ctx.strokeStyle = isPositive ? '#10b981' : '#ef4444';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                priceData.forEach((price, index) => {
                    const x = (index / (priceData.length - 1)) * (width - 4) + 2;
                    const y = height - 2 - ((price - minPrice) / priceRange) * (height - 4);
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
            }

            updatePriceChange(symbol, changePercent) {
                const item = document.querySelector(`[data-symbol="${symbol}"]`);
                if (!item) return;

                const changeElement = item.querySelector('.crypto-overlay-change');
                if (!changeElement) return;

                const isPositive = changePercent >= 0;
                const sign = isPositive ? '+' : '';
                changeElement.textContent = `${sign}${changePercent.toFixed(2)}%`;
                changeElement.className = `crypto-overlay-change ${isPositive ? 'positive' : 'negative'}`;
            }



            async fetchPrices() {
                try {
                    const response = await fetch(this.apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ type: 'allMids' })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('Error fetching crypto prices:', error);
                    this.updateStatus('error', 'Connection failed');
                    return null;
                }
            }

            formatPrice(price) {
                const num = parseFloat(price);
                if (num >= 1000) {
                    return `$${num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
                } else if (num >= 1) {
                    return `$${num.toFixed(3)}`;
                } else if (num >= 0.01) {
                    return `$${num.toFixed(4)}`;
                } else {
                    return `$${num.toFixed(6)}`;
                }
            }

            calculateChange(currentPrice, previousPrice) {
                if (!previousPrice) return null;
                const change = ((currentPrice - previousPrice) / previousPrice) * 100;
                return change;
            }

            formatChange(change) {
                if (change === null) return { text: 'New', class: 'neutral' };
                
                const absChange = Math.abs(change);
                const sign = change >= 0 ? '+' : '';
                const text = `${sign}${change.toFixed(2)}%`;
                const className = change > 0 ? 'positive' : change < 0 ? 'negative' : 'neutral';
                
                return { text, class: className };
            }

            updateTile(symbol, price, change) {
                // Update overlay widget item (only for selected coins)
                if (this.overlaySymbols.includes(symbol)) {
                    const overlayItem = document.querySelector(`.crypto-overlay-item[data-symbol="${symbol}"]`);
                    if (overlayItem) {
                        const priceElement = overlayItem.querySelector('.crypto-overlay-price');
                        const changeElement = overlayItem.querySelector('.crypto-overlay-change');

                        if (priceElement && changeElement) {
                            priceElement.textContent = this.formatPrice(price);
                            
                            const changeData = this.formatChange(change);
                            changeElement.textContent = changeData.text;
                            changeElement.className = `crypto-overlay-change ${changeData.class}`;
                        }
                    } else {
                        console.warn(`Overlay item not found for ${symbol}, re-rendering...`);
                        this.renderCoinItems();
                    }
                }
            }

            updateStatus(status, message) {
                if (!this.statusIndicator || !this.statusText) return;
                
                this.statusIndicator.className = 'status-indicator';
                if (status === 'connected') {
                    this.statusIndicator.classList.add('connected');
                }
                
                this.statusText.textContent = message;
            }

            setupSearchFunctionality() {
                const searchInput = document.getElementById('crypto-search-input');
                if (!searchInput) return;

                searchInput.addEventListener('input', (e) => {
                    const query = e.target.value.toLowerCase();
                    this.filterAvailableCoins(query);
                });
            }

            renderAvailableCoins(query = '') {
                const container = document.getElementById('crypto-available-coins');
                if (!container) return;

                container.innerHTML = '';

                const filteredCoins = this.allSymbols
                    .filter(symbol => symbol.toLowerCase().includes(query.toLowerCase()))
                    .slice(0, 50); // Limit to 50 results for performance

                filteredCoins.forEach(symbol => {
                    const isAdded = this.overlaySymbols.includes(symbol);
                    const currentPrice = this.currentPrices[symbol];
                    const displaySymbol = symbol === 'kBONK' ? 'BONK' : symbol;
                    
                    const option = document.createElement('div');
                    option.className = `crypto-coin-option ${isAdded ? 'added' : ''}`;
                    option.innerHTML = `
                        <div class="crypto-coin-info">
                            <div class="crypto-coin-name">${displaySymbol}</div>
                            <div class="crypto-coin-price">${currentPrice ? this.formatPrice(currentPrice) : 'No price'}</div>
                        </div>
                        <button class="crypto-add-btn ${isAdded ? 'added' : ''}" data-symbol="${symbol}">
                            ${isAdded ? 'Remove' : 'Add'}
                        </button>
                    `;

                    const addBtn = option.querySelector('.crypto-add-btn');
                    addBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await this.toggleCoinInOverlay(symbol);
                    });

                    container.appendChild(option);
                });

                console.log(`📋 Rendered ${filteredCoins.length} available coins`);
            }

            filterAvailableCoins(query) {
                this.renderAvailableCoins(query);
            }

            async toggleCoinInOverlay(symbol) {
                if (this.overlaySymbols.includes(symbol)) {
                    // Remove coin
                    this.overlaySymbols = this.overlaySymbols.filter(s => s !== symbol);
                    console.log(`➖ Removed ${symbol} from overlay`);
                } else {
                    // Add coin
                    this.overlaySymbols.push(symbol);
                    console.log(`➕ Added ${symbol} to overlay`);
                }

                await this.saveCoins();
                this.renderCoinItems();
                this.renderAvailableCoins(document.getElementById('crypto-search-input')?.value || '');
                // Also update settings tab if it exists
                this.renderCoinsInSettings(document.getElementById('settings-crypto-search')?.value || '');
            }

            renderCoinsInSettings(query = '') {
                const container = document.getElementById('settings-crypto-coins');
                if (!container) {
                    console.log('⚠️ Settings crypto coins container not found');
                    return;
                }

                console.log('🔄 Rendering coins in settings tab with query:', query);
                container.innerHTML = '';

                const filteredCoins = this.allSymbols
                    .filter(symbol => symbol.toLowerCase().includes(query.toLowerCase()))
                    .slice(0, 100); // Show more results in settings than in popup

                filteredCoins.forEach(symbol => {
                    const isAdded = this.overlaySymbols.includes(symbol);
                    const currentPrice = this.currentPrices[symbol];
                    const displaySymbol = symbol === 'kBONK' ? 'BONK' : symbol;
                    
                    const coinItem = document.createElement('div');
                    coinItem.className = `settings-crypto-coin ${isAdded ? 'active' : ''}`;
                    coinItem.innerHTML = `
                        <div class="settings-crypto-info">
                            <div class="settings-crypto-symbol">${displaySymbol}</div>
                            <div class="settings-crypto-price">${currentPrice ? this.formatPrice(currentPrice) : 'No price'}</div>
                        </div>
                        <button class="settings-crypto-toggle ${isAdded ? 'active' : ''}" data-symbol="${symbol}">
                            ${isAdded ? 'Remove' : 'Add'}
                        </button>
                    `;

                    const toggleBtn = coinItem.querySelector('.settings-crypto-toggle');
                    toggleBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        console.log(`🔘 Settings toggle clicked for ${symbol}`);
                        await this.toggleCoinInOverlay(symbol);
                    });

                    container.appendChild(coinItem);
                });

                console.log(`✅ Rendered ${filteredCoins.length} coins in settings tab`);
            }

            async updatePricesAndCharts() {
                console.log('🔄 Updating crypto prices and charts...');
                
                try {
                    await this.loadCurrentPrices();
                    
                    // Update existing coin displays
                    for (const symbol of this.overlaySymbols) {
                        const currentPrice = this.currentPrices[symbol];
                        if (currentPrice) {
                            this.updateCoinPrice(symbol, currentPrice);
                        }

                        // Refresh 24h change
                        const change24h = await this.load24hPriceChange(symbol);
                        if (change24h !== null) {
                            this.updatePriceChange(symbol, change24h);
                        }
                    }

                    console.log('✅ Crypto prices and charts updated successfully');
                } catch (error) {
                    console.error('❌ Error updating prices:', error);
                }
            }

            updateCoinPrice(symbol, price) {
                const item = document.querySelector(`[data-symbol="${symbol}"]`);
                if (!item) return;

                const priceElement = item.querySelector('.crypto-overlay-price');
                if (priceElement) {
                    priceElement.textContent = this.formatPrice(price);
                }
            }

            startAutoUpdate() {
                this.intervalId = setInterval(() => {
                    this.updatePricesAndCharts();
                }, this.updateInterval);
                
                console.log(`⏰ Auto-update started (${this.updateInterval / 1000}s interval)`);
            }

            stopAutoUpdate() {
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                    console.log('⏸️ Auto-update stopped');
                }
            }
        }

        // === UNIVERSAL SMART LOADING FUNCTIONS ===
        window.SmartLoading = {
            
            // Create skeleton loading for any container
            showSkeleton: function(containerId, type = 'generic', count = 3) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                let skeletonHTML = '';
                
                switch(type) {
                    case 'todo':
                        for(let i = 0; i < count; i++) {
                            skeletonHTML += `
                                <div class="skeleton-todo">
                                    <div class="skeleton skeleton-checkbox"></div>
                                    <div class="skeleton skeleton-text" style="flex: 1; width: 70%;"></div>
                                </div>
                            `;
                        }
                        break;
                        
                    case 'card':
                        for(let i = 0; i < count; i++) {
                            skeletonHTML += `
                                <div class="skeleton-card">
                                    <div class="skeleton skeleton-text large" style="width: 80%;"></div>
                                    <div class="skeleton skeleton-text" style="width: 100%;"></div>
                                    <div class="skeleton skeleton-text" style="width: 60%;"></div>
                                </div>
                            `;
                        }
                        break;
                        
                    case 'watchlist':
                        for(let i = 0; i < count; i++) {
                            skeletonHTML += `
                                <div class="skeleton-watchlist-item">
                                    <div class="skeleton-watchlist-left">
                                        <div class="skeleton skeleton-chart"></div>
                                        <div class="skeleton skeleton-symbol"></div>
                                    </div>
                                    <div class="skeleton skeleton-price"></div>
                                </div>
                            `;
                        }
                        break;
                        
                    default:
                        for(let i = 0; i < count; i++) {
                            skeletonHTML += `
                                <div style="margin-bottom: 1rem;">
                                    <div class="skeleton skeleton-text large" style="width: 70%;"></div>
                                    <div class="skeleton skeleton-text" style="width: 100%;"></div>
                                    <div class="skeleton skeleton-text" style="width: 40%;"></div>
                                </div>
                            `;
                        }
                }
                
                container.innerHTML = skeletonHTML;
            },
            
            // Remove skeleton and restore content
            hideSkeleton: function(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                // Content will be replaced by actual data rendering
            }
        };

        // DEBUG: Add button to test loading states
        window.testLoadingStates = function() {
            console.log('🧪 Testing loading states...');
            
            // Test watchlist skeleton
            if (window.SmartLoading) {
                window.SmartLoading.showSkeleton('crypto-overlay-items', 'watchlist', 3);
                setTimeout(() => {
                    if (window.cryptoPriceWidget) {
                        window.cryptoPriceWidget.renderCoinItems();
                    }
                }, 3000);
            }
            
            // Test other skeletons in different containers
            const testContainers = ['heute', 'privat', 'journal-entries', 'wiki-entries'];
            testContainers.forEach((containerId, index) => {
                const container = document.getElementById(containerId);
                if (container) {
                    const types = ['todo', 'card', 'generic'];
                    setTimeout(() => {
                        window.SmartLoading.showSkeleton(containerId, types[index % 3], 4);
                        setTimeout(() => {
                            // Restore original content (simplified)
                            container.innerHTML = '<p>Loading test completed ✅</p>';
                        }, 3000);
                    }, index * 500);
                }
            });
        };

        // Initialize crypto widget when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Wait a bit for other components to load, especially for Lucide icons
            setTimeout(() => {
                console.log('🚀 Starting Crypto Widget Initialization...');
                
                // Initialize Lucide icons first
                if (window.lucide) {
                    console.log('🎨 Initializing Lucide icons...');
                    lucide.createIcons();
                } else {
                    console.warn('⚠️ Lucide not loaded yet');
                }
                
                // Crypto widget is now initialized after authentication in showDashboard()
            }, 200);
        });
        
        // === GLOBAL GOAL EDIT MODAL EVENT LISTENERS SETUP ===
        // This needs to be outside of DOMContentLoaded to ensure it runs
        console.log('🎯 GLOBAL: Setting up goal edit modal event listeners...');
        
        // Make event listener initialization globally available
        window.initGoalEditModalEventListeners = function() {
            console.log('🎯 GLOBAL: Initializing goal edit modal event listeners...');
            
            const cancelEditGoalBtn = document.getElementById('cancel-edit-goal-value-btn');
            if (cancelEditGoalBtn) {
                console.log('✅ GLOBAL: Found cancel-edit-goal-value-btn, adding event listener');
                // Remove existing listeners first
                const newCancelBtn = cancelEditGoalBtn.cloneNode(true);
                cancelEditGoalBtn.parentNode.replaceChild(newCancelBtn, cancelEditGoalBtn);
                
                newCancelBtn.addEventListener('click', () => {
                    console.log('🎯 GLOBAL: Cancel button clicked');
                    if (window.GoalManager && window.GoalManager.hideEditGoalValueModal) {
                        window.GoalManager.hideEditGoalValueModal();
                    } else {
                        console.error('❌ GoalManager not available');
                    }
                });
            } else {
                console.error('❌ GLOBAL: cancel-edit-goal-value-btn not found');
            }

            const editGoalForm = document.getElementById('edit-goal-value-form');
            if (editGoalForm) {
                console.log('✅ GLOBAL: Found edit-goal-value-form, adding event listener');
                // Remove existing listeners first
                const newForm = editGoalForm.cloneNode(true);
                editGoalForm.parentNode.replaceChild(newForm, editGoalForm);
                
                newForm.addEventListener('submit', async (e) => {
                    console.log('🎯 GLOBAL: Form submit event triggered');
                    e.preventDefault();
                    
                    const goalId = e.target.dataset.goalId;
                    console.log('🎯 GLOBAL: Form submit goalId:', goalId);
                    if (goalId && window.GoalManager && window.GoalManager.editGoalValue) {
                        await window.GoalManager.editGoalValue(goalId);
                    } else {
                        console.error('❌ GLOBAL: No goalId found or GoalManager not available');
                    }
                });
            } else {
                console.error('❌ GLOBAL: edit-goal-value-form not found');
            }
        };
        
        // Try to initialize immediately
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('🎯 GLOBAL: DOM ready, initializing...');
                window.initGoalEditModalEventListeners();
            });
        } else {
            console.log('🎯 GLOBAL: DOM already ready, initializing now...');
            window.initGoalEditModalEventListeners();
        }
        
        // Event listeners are initialized when DOM is ready and when modal opens
        // No need for redundant retries

        // === SMART QUICK ACTIONS ===
        class QuickActions {
            static addTodo() {
                // Switch to todos tab
                switchTab('tab-todos');
                
                // Hide watchlist when modal opens
                this.hideWatchlist();
                
                // Show todo add modal
                setTimeout(() => {
                    if (window.TodoManager && typeof window.TodoManager.showAddTodoModal === 'function') {
                        window.TodoManager.showAddTodoModal();
                    }
                }, 300);
                
                // Todo modal will be opened
            }
            
            static toggleTimer() {
                // Check if PomodoroTimer exists and toggle it
                if (window.PomodoroTimer) {
                    if (window.PomodoroTimer.isRunning) {
                        window.PomodoroTimer.pause();
                        this.updateTimerButton('play', 'Start Timer');
                    } else {
                        window.PomodoroTimer.start();
                        this.updateTimerButton('pause', 'Stop Timer');
                    }
                } else {
                    // Create new timer and start it
                    this.createTimer(25);
                    this.updateTimerButton('pause', 'Stop Timer');
                }
            }
            
            static resetTimer() {
                // Reset timer to 25 minutes
                if (window.PomodoroTimer) {
                    window.PomodoroTimer.reset();
                }
                this.updateTimerButton('play', 'Start Timer (25 min)');
            }
            
            static updateTimerButton(iconName, tooltip) {
                console.log('🔄 Updating timer button:', iconName, tooltip);
                const button = document.getElementById('timer-quick-btn');
                if (button) {
                    // Remove old icon completely
                    const oldIcon = button.querySelector('i, svg');
                    if (oldIcon) {
                        oldIcon.remove();
                    }
                    
                    // Create new icon
                    const newIcon = document.createElement('i');
                    newIcon.setAttribute('data-lucide', iconName);
                    button.appendChild(newIcon);
                    
                    // Force Lucide to create the icon immediately
                    if (window.lucide) {
                        window.lucide.createIcons();
                        console.log('✅ New icon created:', iconName);
                    }
                    
                    // Update tooltip
                    button.setAttribute('data-tooltip', tooltip + ' | Right-click: Reset');
                } else {
                    console.error('❌ Timer button not found!');
                }
            }
            
            static addJournalEntry() {
                // Switch to journal tab
                switchTab('tab-journal');
                
                // Hide watchlist when modal opens
                this.hideWatchlist();
                
                // Show journal add modal
                setTimeout(() => {
                    if (window.JournalManager && typeof window.JournalManager.showAddJournalModal === 'function') {
                        window.JournalManager.showAddJournalModal();
                    }
                }, 300);
                
                // Journal modal will be opened
            }
            
            static addWikiEntry() {
                // Switch to wiki tab  
                switchTab('tab-wiki');
                
                // Hide watchlist when modal opens
                this.hideWatchlist();
                
                // Show wiki add modal
                setTimeout(() => {
                    if (window.Wiki && typeof window.Wiki.showAddModal === 'function') {
                        window.Wiki.showAddModal();
                    }
                }, 300);
                
                // Wiki modal will be opened
            }
            
            static addTrade() {
                // Switch to trading tab
                switchTab('tab-trading');
                
                // Hide watchlist when modal opens
                this.hideWatchlist();
                
                // Show trade add modal
                setTimeout(() => {
                    if (window.TradingManager && typeof window.TradingManager.showAddTradeModal === 'function') {
                        window.TradingManager.showAddTradeModal();
                    } else {
                        console.error('❌ TradingManager.showAddTradeModal not found');
                    }
                }, 300);
                
                // Trade modal will be opened
            }
            
            static openSettings() {
                // Manually activate settings tab since it's not in navbar anymore
                const allTabs = document.querySelectorAll('.tab-section');
                const allNavTabs = document.querySelectorAll('.nav-tab');
                
                // Hide all tabs
                allTabs.forEach(tab => tab.classList.remove('active'));
                // Remove active from all nav tabs
                allNavTabs.forEach(tab => tab.classList.remove('active'));
                
                // Show settings tab
                const settingsTab = document.getElementById('tab-settings');
                if (settingsTab) {
                    settingsTab.classList.add('active');
                }
                
                // Update page title
                document.title = 'Settings - Dash v4.1';
            }
            
            static logout() {
                // Direct logout without confirmation popup
                if (window.Auth && typeof window.Auth.handleLogout === 'function') {
                    window.Auth.handleLogout();
                }
                // User will be logged out
            }
            
            static toggle() {
                const bar = document.getElementById('quick-actions-bar');
                const toggleBtn = document.getElementById('quick-actions-toggle');
                const toggleIcon = toggleBtn.querySelector('i');
                
                if (bar.classList.contains('collapsed')) {
                    // Expand
                    bar.classList.remove('collapsed');
                    bar.classList.add('expanded');
                    
                    // Update toggle button icon and tooltip
                    if (toggleIcon) {
                        toggleIcon.setAttribute('data-lucide', 'x');
                        if (window.lucide) {
                            const newIcon = document.createElement('i');
                            newIcon.setAttribute('data-lucide', 'x');
                            toggleIcon.parentNode.replaceChild(newIcon, toggleIcon);
                            window.lucide.createIcons();
                        }
                    }
                    toggleBtn.setAttribute('data-tooltip', 'Close Quick Actions');
                    
                } else {
                    // Collapse
                    bar.classList.remove('expanded');
                    bar.classList.add('collapsed');
                    
                    // Update toggle button icon and tooltip
                    if (toggleIcon) {
                        toggleIcon.setAttribute('data-lucide', 'zap');
                        if (window.lucide) {
                            const newIcon = document.createElement('i');
                            newIcon.setAttribute('data-lucide', 'zap');
                            toggleIcon.parentNode.replaceChild(newIcon, toggleIcon);
                            window.lucide.createIcons();
                        }
                    }
                    toggleBtn.setAttribute('data-tooltip', 'Quick Actions');
                }
            }
            
            static toggleMorningRoutine() {
                // Toggle all morning routine checkboxes
                const morningCheckboxes = document.querySelectorAll('.routine-checkbox[data-routine="morning"]');
                let allChecked = true;
                
                // Check current state
                morningCheckboxes.forEach(checkbox => {
                    if (!checkbox.checked) allChecked = false;
                });
                
                // Toggle all to opposite state
                morningCheckboxes.forEach(checkbox => {
                    checkbox.checked = !allChecked;
                    checkbox.dispatchEvent(new Event('change'));
                });
                
                const status = !allChecked ? 'completed ✅' : 'reset ↺';
                this.showNotification(`🌅 Morning Routine ${status}`, 'success');
            }
            
            static toggleEveningRoutine() {
                // Toggle all evening routine checkboxes
                const eveningCheckboxes = document.querySelectorAll('.routine-checkbox[data-routine="evening"]');
                let allChecked = true;
                
                // Check current state
                eveningCheckboxes.forEach(checkbox => {
                    if (!checkbox.checked) allChecked = false;
                });
                
                // Toggle all to opposite state
                eveningCheckboxes.forEach(checkbox => {
                    checkbox.checked = !allChecked;
                    checkbox.dispatchEvent(new Event('change'));
                });
                
                const status = !allChecked ? 'completed ✅' : 'reset ↺';
                this.showNotification(`🌙 Evening Routine ${status}`, 'success');
            }
            
            static createTimer(minutes) {
                let seconds = minutes * 60;
                const startTime = Date.now();
                
                const timerInterval = setInterval(() => {
                    const remaining = Math.max(0, seconds - Math.floor((Date.now() - startTime) / 1000));
                    const mins = Math.floor(remaining / 60);
                    const secs = remaining % 60;
                    
                    document.title = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')} - Dash v4.1`;
                    
                    if (remaining <= 0) {
                        clearInterval(timerInterval);
                        document.title = 'Dash v4.1';
                        // Timer completed
                        
                        // Simple notification sound
                        if ('Notification' in window && Notification.permission === 'granted') {
                            new Notification('Timer abgelaufen!', {
                                body: `${minutes} Minuten Timer ist beendet.`,
                                icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="7"/><polyline points="12,6 12,12 16,14"/></svg>'
                            });
                        }
                    }
                }, 1000);
                
                // Timer started
            }
            
            static hideWatchlist() {
                const watchlist = document.getElementById('crypto-overlay');
                if (watchlist) {
                    watchlist.style.zIndex = '100'; // Lower z-index than modals
                }
            }
            
            static showWatchlist() {
                const watchlist = document.getElementById('crypto-overlay');
                if (watchlist) {
                    watchlist.style.zIndex = '5000'; // Original z-index
                }
            }
            
            static showNotification(message, type = 'info') {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = `quick-notification ${type}`;
                notification.textContent = message;
                
                // Add styles
                Object.assign(notification.style, {
                    position: 'fixed',
                    top: '20px',
                    left: '20px',
                    background: type === 'success' ? '#059669' : type === 'error' ? '#dc2626' : '#3b82f6',
                    color: 'white',
                    padding: '12px 18px',
                    borderRadius: '8px',
                    fontSize: '14px',
                    fontWeight: '500',
                    zIndex: '10000',
                    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
                    transform: 'translateX(100%)',
                    transition: 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
                    maxWidth: '300px'
                });
                
                document.body.appendChild(notification);
                
                // Slide in
                setTimeout(() => {
                    notification.style.transform = 'translateX(0)';
                }, 100);
                
                // Slide out and remove
                setTimeout(() => {
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }
        }
        
        // Make QuickActions globally available
        window.QuickActions = QuickActions;
        
        // === CRYPTO TICKER CONTROLLER ===
        class CryptoTicker {
            static openSettings() {
                // Open the existing crypto settings panel
                const settingsPanel = document.querySelector('.crypto-settings-panel');
                if (settingsPanel) {
                    settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
                }
            }
        }
        
        // Make CryptoTicker globally available
        window.CryptoTicker = CryptoTicker;
        
        // Initialize quick actions (request notification permission)
        document.addEventListener('DOMContentLoaded', () => {
            if ('Notification' in window && Notification.permission !== 'granted' && Notification.permission !== 'denied') {
                Notification.requestPermission();
            }
        });

        // === MOBILE: No JavaScript needed - Under Construction ===

    </script>

    <!-- === MOBILE UNDER CONSTRUCTION === -->
    <div class="mobile-construction">
        <h1>Under Construction</h1>
    </div>
</body>
</html>