<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DASHBOARD</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22 font-family=%22-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif%22 font-weight=%22700%22 fill=%22%23000000%22>A</text></svg>">
    <style>
        /* === RESET & BASE === */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #000000;
            line-height: 1.6;
            padding-top: 80px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* === STICKY NAVIGATION === */
        .sticky-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #ffffff;
            border-bottom: 1px solid #e0e0e0;
            z-index: 1000;
            padding: 1rem 0;
        }
        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 3rem;
            position: relative;
        }
        .nav-tab {
            text-decoration: none;
            color: #666666;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.5rem 1rem;
            border: 1px solid transparent;
            transition: all 0.2s ease;
            cursor: pointer;
            background: none;
            font-family: inherit;
        }
        .nav-tab:hover { border-color: #000000; color: #000000; }
        .nav-tab.active {
            color: #000000;
            font-weight: 700;
            border: 1px solid transparent;
            background: transparent;
        }
        
        /* === LOGOUT & SETTINGS BUTTONS === */
        .nav-actions {
            position: absolute;
            right: 0;
            display: flex;
            gap: 0.25rem;
            align-items: center;
        }
        
        .logout-btn, .settings-btn {
            color: #666666 !important;
            font-weight: 400 !important;
            background: transparent !important;
            border: none !important;
        }
        .logout-btn:hover, .settings-btn:hover {
            background: transparent !important;
            border: none !important;
        }
        .logout-btn:hover span {
            color: #dc2626 !important;
        }
        .settings-btn:hover span {
            color: #22c55e !important;
        }
        .logout-btn span, .settings-btn span {
            font-size: 1.2rem;
        }

        /* === SETTINGS PAGE === */
        .settings-container {
            max-width: 600px;
            margin: 0 auto;
        }
        
        .setting-group {
            background: #f8f9fa;
            padding: 2rem;
            margin-bottom: 2rem;
            border-radius: 12px;
            border: 1px solid #e0e0e0;
        }
        
        .setting-group h3 {
            margin: 0 0 1.5rem 0;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .setting-item:last-child {
            margin-bottom: 0;
        }
        
        .setting-item label {
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .setting-item input[type="time"] {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            max-width: 200px;
        }
        
        .setting-description {
            font-size: 0.85rem;
            color: #666666;
            margin-top: 0.25rem;
        }
        
        .btn-secondary {
            background: #6b7280 !important;
        }
        
        .btn-secondary:hover {
            background: #4b5563 !important;
        }

        /* === MAIN CONTENT === */
        .main-content { padding: 0 20px 40px 20px; }
        .tab-section { display: none; }
        .tab-section.active { display: block; }

        /* === SHARED COMPONENTS === */
        .section-title {
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 3rem;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 1rem;
        }
        .card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            transition: border-color 0.2s ease;
        }
        .card:hover { border-color: #000000; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 3rem; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2rem; }
        .btn {
            padding: 0.75rem 1.5rem;
            border: 1px solid #000000;
            background: #ffffff;
            color: #000000;
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-block;
        }
        .btn:hover { background: #000000; color: #ffffff; }
        .btn.secondary { border-color: #e0e0e0; color: #666666; }
        .btn.secondary:hover { border-color: #000000; background: #f0f0f0; color: #000000; }

        /* === CHECKBOX COMPONENT === */
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .checkbox-item.todo-item {
            justify-content: space-between;
            width: 100%;
        }
        .checkbox-item.todo-item .todo-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
            min-width: 0; /* Allow shrinking */
        }
        .checkbox-item.todo-item .todo-time {
            font-size: 0.85rem;
            color: #666;
            font-weight: 500;
            flex-shrink: 0;
            margin-left: 1rem;
            text-align: right;
        }
        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            border: 2px solid #000000;
            appearance: none;
            cursor: pointer;
            flex-shrink: 0;
        }
        .checkbox-item input[type="checkbox"]:checked {
            background-color: #000000;
            position: relative;
        }
        .checkbox-item input[type="checkbox"]:checked::after {
            content: '‚úì';
            color: white;
            position: absolute;
            top: -2px;
            left: 2px;
            font-size: 12px;
        }
        .checkbox-item label {
            font-size: 0.95rem;
            cursor: pointer;
            line-height: 1.4;
        }

        /* === PROGRESS BAR === */
        .progress-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .progress-bar {
            flex: 1;
            height: 8px;
            background-color: #f0f0f0;
            border: 1px solid #e0e0e0;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: #000000;
            transition: width 0.3s ease;
        }

        /* === STREAK TILES === */
        .streak-overview {
            margin-bottom: 3rem;
        }
        .streak-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
        }
        .streak-tile {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            text-align: center;
            transition: border-color 0.2s ease;
        }
        .streak-tile:hover {
            border-color: #000000;
        }
        .streak-number {
            font-size: 3rem;
            font-weight: 300;
            color: #000000;
            margin-bottom: 0.5rem;
            line-height: 1;
        }
        .streak-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }
        .streak-date {
            font-size: 0.8rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* === ROUTINE SPECIFIC === */
        .routine-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
            margin-bottom: 4rem;
            height: auto;
            min-height: 300px;
        }
        .routine-section {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            min-height: 250px;
        }
        .routine-section h2 {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .routine-section .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex: 1;
            margin-bottom: 1rem;
        }

        /* === TODO SPECIFIC === */
        .category-tabs {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 3rem;
        }
        .category-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .category-tab:hover { border-color: #000000; color: #000000; }
        .category-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .category-content { display: none; }
        .category-content.active { display: block; }
        
        /* === ZIELE SPECIFIC TABS === */
        .ziel-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .ziel-tab:hover { border-color: #000000; color: #000000; }
        .ziel-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .ziel-content { display: none; }
        .ziel-content.active { display: block; }
        
        /* === JOURNAL SPECIFIC TABS === */
        .journal-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .journal-tab:hover { border-color: #000000; color: #000000; }
        .journal-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .journal-content { display: none; }
        .journal-content.active { display: block; }
        
        /* === TAG SELECTION === */
        .tag-option {
            padding: 0.5rem 1rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            color: #666666;
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .tag-option:hover { border-color: #000000; color: #000000; }
        .tag-option.selected {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .tag-option .remove-tag {
            cursor: pointer;
            font-size: 1rem;
            opacity: 0.8;
            display: none;
        }
        .tag-option.selected .remove-tag {
            display: inline;
        }
        .tag-option .remove-tag:hover {
            opacity: 1;
        }
        .todo-section {
            margin-bottom: 2rem;
        }
        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .section-header h3 {
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #444444;
        }
        .section-divider {
            flex: 1;
            height: 1px;
            background: #e0e0e0;
        }
        .section-count {
            font-size: 0.8rem;
            color: #666666;
            background: #f0f0f0;
            padding: 0.25rem 0.75rem;
            border: 1px solid #e0e0e0;
        }
        .todo-item {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: border-color 0.2s ease;
        }
        .todo-item:hover { border-color: #000000; }
        .todo-item.completed { opacity: 0.6; background: #fafafa; }
        .todo-item.completed .todo-title { text-decoration: line-through; }
        .todo-header {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }
        .todo-content { flex: 1; }
        .todo-title {
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }
        .todo-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .todo-deadline {
            font-size: 0.8rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .todo-deadline.today { color: #000000; font-weight: 500; }
        .todo-deadline.overdue { color: #cc0000; font-weight: 500; }
        .todo-deadline.soon { color: #ff6600; font-weight: 500; }
        .todo-tag {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.25rem 0.75rem;
            border: 1px solid;
            color: #ffffff;
            font-weight: 500;
        }
        .todo-tag.wichtig { background-color: #ff6600; border-color: #ff6600; }
        .todo-tag.dringend { background-color: #cc0000; border-color: #cc0000; }
        .todo-tag.normal { background-color: #666666; border-color: #666666; }

        /* === ZIELE SPECIFIC === */
        .ziel-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 200px;
        }
        .ziel-kategorie {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666666;
            border: 1px solid #e0e0e0;
            padding: 0.25rem 0.75rem;
            background: #fafafa;
        }
        .ziel-header {
            margin-bottom: 1rem;
            margin-right: 6rem;
        }
        .ziel-name {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }
        .ziel-beschreibung {
            font-size: 0.9rem;
            color: #666666;
            line-height: 1.5;
            margin-bottom: 2rem;
        }
        .ziel-progress-section { margin-top: auto; }
        .ziel-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .ziel-progress-label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #444444;
        }
        .ziel-percentage {
            font-size: 1rem;
            font-weight: 500;
        }

        /* === JOURNAL SPECIFIC === */
        .quick-journal {
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            margin-bottom: 3rem;
        }
        .quick-journal h2 {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .journal-form {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        .journal-input {
            flex: 1;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .journal-input:focus { outline: none; border-color: #000000; }
        .journal-entry {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            margin-bottom: 2rem;
        }
        .journal-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1.5rem;
            gap: 1rem;
        }
        .journal-date {
            font-size: 1rem;
            font-weight: 500;
            color: #000000;
        }
        .journal-kategorie {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666666;
            border: 1px solid #e0e0e0;
            padding: 0.4rem 1rem;
            background: #fafafa;
        }
        .journal-content {
            font-size: 0.95rem;
            line-height: 1.7;
            color: #333333;
        }

        /* === TERMINE SPECIFIC === */
        .termin-card {
            position: relative;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            background: #fafafa;
        }
        .termin-date {
            font-size: 0.85rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }
        .termin-title {
            font-size: 1.1rem;
            font-weight: 500;
            margin-bottom: 1rem;
        }
        .termin-description {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #444444;
        }

        /* === ADD TODO MODAL === */
        .add-todo-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            padding: 1rem;
        }
        .add-todo-modal.hide { display: none; }
        .add-todo-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 500px;
        }
        .add-todo-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .add-todo-header h2 {
            font-size: 1.5rem;
            font-weight: 500;
            color: #000000;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .form-row .form-group {
            flex: 1;
        }
        .form-group select {
            width: 100%;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .form-group select:focus { outline: none; border-color: #000000; }
        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        /* === AUTH SCREEN === */
        .auth-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 1rem;
        }
        .auth-screen.hide { display: none; }
        .auth-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 400px;
        }
        .auth-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .auth-header h2 {
            font-size: 1.5rem;
            font-weight: 500;
            color: #000000;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-group {
            margin-bottom: 1.5rem;
        }
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #000000;
            font-weight: 500;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-group input {
            width: 100%;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .form-group input:focus { outline: none; border-color: #000000; }
        .auth-btn {
            width: 100%;
            padding: 1rem;
            border: 1px solid #000000;
            background: #ffffff;
            color: #000000;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .auth-btn:hover {
            background: #000000;
            color: #ffffff;
        }
        .auth-error {
            color: #cc0000;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            display: none;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .auth-error.show { display: block; }

        /* === RESPONSIVE === */
        @media (max-width: 768px) {
            .grid-2, .grid-3, .routine-grid, .streak-grid { grid-template-columns: 1fr; gap: 2rem; }
            .routine-grid { height: auto; }
            .routine-section { height: auto; min-height: 350px; }
            .main-content { padding: 0 15px 40px 15px; }
            .nav-container { flex-wrap: wrap; gap: 1rem; }
            .nav-tab { font-size: 0.8rem; padding: 0.4rem 0.8rem; }
            .ziel-kategorie { position: static; align-self: flex-start; margin-bottom: 1rem; }
            .ziel-header { margin-right: 0; }
            .journal-form { flex-direction: column; align-items: stretch; }
            .journal-entry-header { flex-direction: column; align-items: flex-start; }
        }
    </style>
</head>
<body>
    <!-- === ADD TODO MODAL === -->
    <div id="add-todo-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Todo hinzuf√ºgen</h2>
            </div>
            
            <form id="add-todo-form" autocomplete="off">
                <div class="form-group">
                    <label for="todo-title">Aufgabe</label>
                    <input type="text" id="todo-title" placeholder="Was m√∂chtest du erledigen?" required autocomplete="off">
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="todo-category">Kategorie</label>
                        <select id="todo-category" required autocomplete="off">
                            <option value="">Kategorie w√§hlen</option>
                            <option value="privat">Privat</option>
                            <option value="uni">Uni</option>
                            <option value="arbeit">Arbeit</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="todo-priority">Priorit√§t</label>
                        <select id="todo-priority" required autocomplete="off">
                            <option value="mittel" selected>Normal</option>
                            <option value="wichtig">Wichtig</option>
                            <option value="dringend">Dringend</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="todo-deadline">Deadline</label>
                        <input type="date" id="todo-deadline" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="todo-time">Uhrzeit</label>
                        <input type="time" id="todo-time" value="21:00" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-todo-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Todo erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD GOAL MODAL === -->
    <div id="add-goal-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Ziel hinzuf√ºgen</h2>
            </div>
            
            <form id="add-goal-form" autocomplete="off">
                <div class="form-group">
                    <label for="goal-name">Ziel-Name</label>
                    <input type="text" id="goal-name" placeholder="Was m√∂chtest du erreichen?" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="goal-description">Beschreibung</label>
                    <textarea id="goal-description" placeholder="Detaillierte Beschreibung des Ziels..." rows="3" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-category">Kategorie</label>
                        <input type="text" id="goal-category" placeholder="z.B. Fitness, Karriere, Finanzen..." required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-timeframe">Zeitrahmen</label>
                        <select id="goal-timeframe" required autocomplete="off">
                            <option value="monat">Monat</option>
                            <option value="quartal">Quartal</option>
                            <option value="jahr">Jahr</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-deadline">Deadline</label>
                        <input type="date" id="goal-deadline" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-progress">Fortschritt (%)</label>
                        <input type="number" id="goal-progress" min="0" max="100" value="0" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-goal-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Ziel erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD JOURNAL MODAL === -->
    <div id="add-journal-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Journal Eintrag hinzuf√ºgen</h2>
            </div>
            
            <form id="add-journal-form" autocomplete="off">
                <div class="form-group">
                    <label for="journal-title">Titel</label>
                    <input type="text" id="journal-title" placeholder="Titel f√ºr den Eintrag..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="journal-content">Inhalt</label>
                    <textarea id="journal-content" placeholder="Was besch√§ftigt dich heute...?" rows="6" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="journal-tags">Tags (mehrere m√∂glich)</label>
                        <div id="journal-tag-options" style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                            <button type="button" class="tag-option" data-tag="allgemein">
                                Allgemein
                                <span class="remove-tag">√ó</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="fitness">
                                Fitness
                                <span class="remove-tag">√ó</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="uni">
                                Uni
                                <span class="remove-tag">√ó</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="crypto">
                                Crypto
                                <span class="remove-tag">√ó</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="lesen">
                                Lesen
                                <span class="remove-tag">√ó</span>
                            </button>
                        </div>
                        <input type="hidden" id="journal-category" required>
                    </div>
                    <div class="form-group">
                        <label for="journal-date">Datum</label>
                        <input type="date" id="journal-date" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-journal-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Journal erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD TERMIN MODAL === -->
    <div id="add-termin-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Termin hinzuf√ºgen</h2>
            </div>
            
            <form id="add-termin-form" autocomplete="off">
                <div class="form-group">
                    <label for="termin-title">Titel</label>
                    <input type="text" id="termin-title" placeholder="z.B. Zahnarzt Termin..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="termin-description">Beschreibung</label>
                    <textarea id="termin-description" placeholder="Weitere Details zum Termin..." rows="3" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="termin-date">Datum</label>
                        <input type="date" id="termin-date" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="termin-time">Uhrzeit (optional)</label>
                        <input type="time" id="termin-time" autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-termin-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Termin erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === AUTH SCREEN === -->
    <div id="auth-screen" class="auth-screen hide">
        <div class="auth-container">
            <div class="auth-header">
                <h2>DASHBOARD</h2>
            </div>
            
            <div class="form-group">
                <label for="login-email">Email</label>
                <input type="email" id="login-email" placeholder="your@email.com" required>
            </div>
            <div class="form-group">
                <label for="login-password">Password</label>
                <input type="password" id="login-password" placeholder="Your password" required>
            </div>
            <button id="login-btn" class="auth-btn">Login</button>
            <div id="login-error" class="auth-error"></div>
        </div>
    </div>

    <!-- === STICKY NAVIGATION === -->
    <nav class="sticky-nav">
        <div class="nav-container">
            <button class="nav-tab active" data-tab="tab-home">Home</button>
            <button class="nav-tab" data-tab="tab-todos">ToDos</button>
            <button class="nav-tab" data-tab="tab-ziele">Ziele</button>
            <button class="nav-tab" data-tab="tab-journal">Journal</button>
            <button class="nav-tab" data-tab="tab-settings" style="display: none;">Settings</button>
            <div class="nav-actions">
                <button id="settings-btn" class="nav-tab settings-btn">
                    <span>‚öô</span>
                </button>
                <button id="logout-btn" class="nav-tab logout-btn">
                    <span>‚èª</span>
                </button>
            </div>
        </div>
    </nav>

    <div class="main-content">
        <!-- === HOME TAB === -->
        <section id="tab-home" class="tab-section active">
            <!-- Streak Kacheln -->
            <section class="streak-overview">
                <div class="streak-grid">
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Morgenroutine</div>
                        <div class="streak-date">August 2025</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Abendroutine</div>
                        <div class="streak-date">August 2025</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Todos Erledigt</div>
                        <div class="streak-date">August 2025</div>
                    </div>
                </div>
            </section>

            <!-- Routinen Section -->
            <div class="routine-grid">
                <div id="morning-routine" class="routine-section">
                    <h2>Morgenroutine</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="wasser">
                            <label for="wasser">Wasser trinken (500ml)</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="dehnen">
                            <label for="dehnen">Dehnen & Mobilit√§t</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="kreatin">
                            <label for="kreatin">Kreatin einnehmen</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="meditation">
                            <label for="meditation">Meditation (10 Min)</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="lesen">
                            <label for="lesen">Lesen (20 Min)</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="planung">
                            <label for="planung">Tag planen</label>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <div id="evening-routine" class="routine-section">
                    <h2>Abendroutine</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="reflexion">
                            <label for="reflexion">Tag reflektieren</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="morgen-prep">
                            <label for="morgen-prep">Morgen vorbereiten</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="handy-weg">
                            <label for="handy-weg">Handy wegr√§umen</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="lesen-abend">
                            <label for="lesen-abend">Lesen vor dem Schlafen</label>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Anstehende Termine -->
            <section style="margin-bottom: 3rem;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 2rem; margin-bottom: 1.5rem;">
                    <h2 style="font-size: 1.2rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.1em; margin: 0;">Anstehende Termine</h2>
                    <button id="add-termin-btn" class="btn" style="font-size: 0.7rem; padding: 0.5rem 1rem;">+ Add Termin</button>
                </div>
                <div class="grid-3" id="termine-container">
                    <!-- Termine will be loaded from TerminManager -->
                </div>
            </section>

            <!-- Heutige Aufgaben -->
            <section class="card">
                <h2 style="font-size: 1.2rem; font-weight: 500; margin-bottom: 1.5rem; text-transform: uppercase; letter-spacing: 0.1em;">Heutige Aufgaben</h2>
                <div class="checkbox-group" id="home-todos">
                    <!-- Todos will be loaded from database -->
                </div>
            </section>
        </section>

        <!-- === TODOS TAB === -->
        <section id="tab-todos" class="tab-section">
            
            <div class="category-tabs">
                <button class="category-tab active" data-category="heute">Heute</button>
                <button class="category-tab" data-category="privat">Privat</button>
                <button class="category-tab" data-category="uni">Uni</button>
                <button class="category-tab" data-category="arbeit">Arbeit</button>
                <button class="category-tab" data-category="alle">Alle</button>
                <button class="category-tab" data-category="archiv">Archiv</button>
                <button id="add-todo-btn" class="btn" style="margin-left: 2rem;">+ Add Todo</button>
                <button id="clear-archive-btn" class="btn secondary" style="margin-left: 1rem; display: none;">üóëÔ∏è Archiv leeren</button>
            </div>

            <!-- HEUTE KATEGORIE -->
            <div class="category-content active" id="heute">
                <!-- Todos for today will be loaded from database -->
            </div>

            <!-- PRIVAT KATEGORIE -->
            <div class="category-content" id="privat">
                <!-- Private todos will be loaded from database -->
            </div>

            <!-- UNI KATEGORIE -->
            <div class="category-content" id="uni">
                <!-- Uni todos will be loaded from database -->
            </div>

            <!-- ARBEIT KATEGORIE -->
            <div class="category-content" id="arbeit">
                <!-- Work todos will be loaded from database -->
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="category-content" id="alle">
                <!-- All todos will be loaded from database -->
            </div>

            <!-- ARCHIV KATEGORIE -->
            <div class="category-content" id="archiv">
                <!-- Completed/archived todos will be loaded from database -->
            </div>
        </section>

        <!-- === ZIELE TAB === -->
        <section id="tab-ziele" class="tab-section">
            
            <div class="category-tabs">
                <button class="ziel-tab active" data-ziel-category="monat">Monat</button>
                <button class="ziel-tab" data-ziel-category="quartal">Quartal</button>
                <button class="ziel-tab" data-ziel-category="jahr">Jahr</button>
                <button class="ziel-tab" data-ziel-category="alle">Alle</button>
                <button class="ziel-tab" data-ziel-category="archiv">Archiv</button>
                <button id="add-goal-btn" class="btn" style="margin-left: 2rem;">+ Add Goal</button>
                <button id="clear-goal-archive-btn" class="btn secondary" style="margin-left: 1rem; display: none;">üóëÔ∏è Archiv leeren</button>
            </div>

            <!-- MONAT KATEGORIE -->
            <div class="ziel-content active" id="ziel-monat">
                <!-- Monatsziele will be loaded from database -->
            </div>

            <!-- QUARTAL KATEGORIE -->
            <div class="ziel-content" id="ziel-quartal">
                <!-- Quartalsziele will be loaded from database -->
            </div>

            <!-- JAHR KATEGORIE -->
            <div class="ziel-content" id="ziel-jahr">
                <!-- Jahresziele will be loaded from database -->
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="ziel-content" id="ziel-alle">
                <!-- All ziele will be loaded from database -->
            </div>

            <!-- ARCHIV KATEGORIE -->
            <div class="ziel-content" id="ziel-archiv">
                <!-- Completed/archived ziele will be loaded from database -->
            </div>

        </section>

        <!-- === JOURNAL TAB === -->
        <section id="tab-journal" class="tab-section">
            
            <div class="category-tabs">
                <button class="journal-tab active" data-journal-category="alle">Alle</button>
                <button class="journal-tab" data-journal-category="allgemein">Allgemein</button>
                <button class="journal-tab" data-journal-category="fitness">Fitness</button>
                <button class="journal-tab" data-journal-category="uni">Uni</button>
                <button class="journal-tab" data-journal-category="crypto">Crypto</button>
                <button class="journal-tab" data-journal-category="lesen">Lesen</button>
                <button id="add-journal-btn" class="btn" style="margin-left: 2rem;">+ Add Journal</button>
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="journal-content active" id="journal-alle">
                <!-- All journal entries will be loaded from database -->
            </div>

            <!-- ALLGEMEIN KATEGORIE -->
            <div class="journal-content" id="journal-allgemein">
                <!-- Allgemein entries will be loaded from database -->
            </div>

            <!-- FITNESS KATEGORIE -->
            <div class="journal-content" id="journal-fitness">
                <!-- Fitness entries will be loaded from database -->
            </div>

            <!-- UNI KATEGORIE -->
            <div class="journal-content" id="journal-uni">
                <!-- Uni entries will be loaded from database -->
            </div>

            <!-- CRYPTO KATEGORIE -->
            <div class="journal-content" id="journal-crypto">
                <!-- Crypto entries will be loaded from database -->
            </div>

            <!-- LESEN KATEGORIE -->
            <div class="journal-content" id="journal-lesen">
                <!-- Lesen entries will be loaded from database -->
            </div>

        </section>

        <!-- === SETTINGS TAB === -->
        <section id="tab-settings" class="tab-section">
            <h1 class="section-title">Einstellungen</h1>
            
            <div class="settings-container">
                <div class="setting-group">
                    <h3>Routinen</h3>
                    <div class="setting-item">
                        <label for="routine-reset-time">Routine Reset Zeit:</label>
                        <input type="time" id="routine-reset-time" value="06:00">
                        <span class="setting-description">Zeit, zu der die Routinen t√§glich zur√ºckgesetzt werden</span>
                    </div>
                    <button id="save-routine-settings" class="btn">Speichern</button>
                </div>
                
                <div class="setting-group">
                    <h3>Daten</h3>
                    <div class="setting-item">
                        <button id="reset-routines-today" class="btn btn-secondary">Routinen heute zur√ºcksetzen</button>
                        <span class="setting-description">Setzt alle Routine-Checkboxes f√ºr heute zur√ºck</span>
                    </div>
                    <div class="setting-item">
                        <button id="reset-monthly-todos" class="btn btn-secondary">Todo-Z√§hler f√ºr aktuellen Monat zur√ºcksetzen</button>
                        <span class="setting-description">Setzt den monatlichen Todo-Counter auf 0 zur√ºck</span>
                    </div>
                </div>
            </div>
        </section>

    </div>

    <!-- Scripts -->
    <script src="supabase-config.js"></script>
    <script>
        // === AUTHENTICATION ===
        const Auth = {
            isAuthenticated: false,
            currentUser: null,
            
            async init() {
                window.Auth = this;
                
                if (!supabase) {
                    console.log('‚ö†Ô∏è Demo mode - no authentication');
                    this.showDashboard();
                    return;
                }
                
                this.currentUser = supabase.getCurrentUser();
                if (supabase.isAuthenticated()) {
                    console.log('‚úÖ User authenticated:', this.currentUser.email);
                    this.isAuthenticated = true;
                    this.showDashboard();
                } else {
                    this.showAuthScreen();
                }
                
                this.setupEventListeners();
            },
            
            setupEventListeners() {
                const loginBtn = document.getElementById('login-btn');
                const logoutBtn = document.getElementById('logout-btn');
                
                if (loginBtn) {
                    loginBtn.addEventListener('click', () => this.handleLogin());
                }
                
                if (logoutBtn) {
                    logoutBtn.addEventListener('click', () => this.handleLogout());
                }
            },
            
            async handleLogin() {
                const email = document.getElementById('login-email').value;
                const password = document.getElementById('login-password').value;
                const errorEl = document.getElementById('login-error');
                
                if (!email || !password) {
                    this.showError('Please enter email and password');
                    return;
                }
                
                try {
                    const { user, error } = await supabase.signIn(email, password);
                    
                    if (error) {
                        this.showError(error);
                        return;
                    }
                    
                    if (user) {
                        this.currentUser = user;
                        this.isAuthenticated = true;
                        this.showDashboard();
                    }
                } catch (error) {
                    this.showError(error.message);
                }
            },
            
            async handleLogout() {
                console.log('üö™ Logout clicked');
                try {
                    if (supabase && typeof supabase.signOut === 'function') {
                        await supabase.signOut();
                    }
                    localStorage.clear();
                    sessionStorage.clear();
                    console.log('‚úÖ Logout successful, reloading...');
                    window.location.reload();
                } catch (error) {
                    console.error('‚ùå Logout error:', error);
                    localStorage.clear();
                    sessionStorage.clear();
                    window.location.reload();
                }
            },
            
            showError(message) {
                const errorEl = document.getElementById('login-error');
                if (errorEl) {
                    errorEl.textContent = message;
                    errorEl.classList.add('show');
                    setTimeout(() => errorEl.classList.remove('show'), 5000);
                }
            },
            
            showAuthScreen() {
                document.getElementById('auth-screen').classList.remove('hide');
            },
            
            showDashboard() {
                document.getElementById('auth-screen').classList.add('hide');
            }
        };

        // === TAB SYSTEM ===
        function switchTab(tabId) {
            document.querySelectorAll('.tab-section').forEach(section => {
                section.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
            
            // If switching to todos tab, load the active category
            if (tabId === 'tab-todos') {
                const activeTab = document.querySelector('.category-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-category') : 'heute';
                TodoManager.displayTodosForCategory(activeCategory);
            }
            
            // If switching to home tab, update home todos
            if (tabId === 'tab-home') {
                TodoManager.updateHomeTodos();
            }
            
            // If switching to ziele tab, load the active category
            if (tabId === 'tab-ziele') {
                const activeTab = document.querySelector('.ziel-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-ziel-category') : 'monat';
                GoalManager.displayGoalsForCategory(activeCategory);
            }
            
            // If switching to journal tab, load the active category
            if (tabId === 'tab-journal') {
                const activeTab = document.querySelector('.journal-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-journal-category') : 'alle';
                JournalManager.displayEntriesForCategory(activeCategory);
            }
        }

        // === ROUTINE PROGRESS ===
        // Load saved checkbox states on page load
        function loadRoutineStates() {
            const today = new Date().toISOString().split('T')[0];
            const savedStates = JSON.parse(localStorage.getItem(`routineStates_${today}`) || '{}');
            
            Object.keys(savedStates).forEach(checkboxId => {
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.checked = savedStates[checkboxId];
                    // Apply visual styling
                    const label = checkbox.nextElementSibling;
                    if (label) {
                        if (checkbox.checked) {
                            label.style.textDecoration = 'line-through';
                            label.style.color = '#999';
                        } else {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    }
                }
            });
        }
        
        // Save checkbox state
        function saveCheckboxState(checkboxId, isChecked) {
            const today = new Date().toISOString().split('T')[0];
            const savedStates = JSON.parse(localStorage.getItem(`routineStates_${today}`) || '{}');
            savedStates[checkboxId] = isChecked;
            localStorage.setItem(`routineStates_${today}`, JSON.stringify(savedStates));
        }

        function updateRoutineProgress() {
            const routineTab = document.getElementById('tab-home');
            if (!routineTab) return;
            
            const routineSections = routineTab.querySelectorAll('.routine-section');
            
            routineSections.forEach(section => {
                const checkboxes = section.querySelectorAll('input[type="checkbox"]');
                const checkedBoxes = section.querySelectorAll('input[type="checkbox"]:checked');
                
                if (checkboxes.length === 0) return;
                
                const percentage = Math.round((checkedBoxes.length / checkboxes.length) * 100);
                
                const progressFill = section.querySelector('.progress-fill');
                if (progressFill) {
                    progressFill.style.width = percentage + '%';
                }
                
                // Optional: Log progress for debugging
                console.log(`Routine progress: ${percentage}% (${checkedBoxes.length}/${checkboxes.length})`);
                
                // Update monthly streaks based on completion status
                const today = new Date().toISOString().split('T')[0];
                const routineType = section.querySelector('h2').textContent.includes('Morgen') ? 'morning' : 'evening';
                const localData = JSON.parse(localStorage.getItem('routineCompletionData') || '{}');
                if (!localData[today]) localData[today] = {};
                
                if (percentage === 100) {
                    console.log('üîç DEBUG: 100% reached, marking as complete');
                    localData[today][routineType] = true;
                } else {
                    console.log('üîç DEBUG: Less than 100%, marking as incomplete');
                    localData[today][routineType] = false;
                }
                
                localStorage.setItem('routineCompletionData', JSON.stringify(localData));
                console.log(`üîç DEBUG: Saved ${routineType} completion: ${localData[today][routineType]}`);
                
                // Update streak display directly
                console.log('üîç DEBUG: Updating streak display');
                console.log('üîç DEBUG: localData:', localData);
                
                // Calculate monthly count from both legacy localStorage and new cloud cache
                const currentDate = new Date();
                const currentYear = currentDate.getFullYear();
                const currentMonth = currentDate.getMonth() + 1; // getMonth() is 0-indexed
                const currentMonthPrefix = `${currentYear}-${currentMonth.toString().padStart(2, '0')}`;
                
                console.log(`üîç DEBUG: Current month prefix: ${currentMonthPrefix}`);
                
                // First try legacy format (mobile compatibility)
                const currentMonthDates = Object.keys(localData).filter(date => date.startsWith(currentMonthPrefix));
                let monthlyCount = currentMonthDates.filter(date => localData[date][routineType] === true).length;
                console.log(`üîç DEBUG: Legacy format count for ${routineType}: ${monthlyCount}`);
                
                // Also check cloud completions - first try cache, then direct Supabase query
                let cloudCompletions = [];
                try {
                    const cloudCompletionsCache = localStorage.getItem('routine_completions_cache');
                    console.log(`üîç DEBUG: Cloud completions cache raw:`, cloudCompletionsCache);
                    
                    if (cloudCompletionsCache) {
                        cloudCompletions = JSON.parse(cloudCompletionsCache);
                        console.log(`üîç DEBUG: Found cloud completions cache with ${cloudCompletions.length} entries`);
                        
                        // Filter for current month and routine type
                        const currentMonthCloudCompletions = cloudCompletions.filter(completion => {
                            if (!completion.date || !completion.template_id) return false;
                            const completionMonth = completion.date.substring(0, 7); // "2025-08-13" -> "2025-08"
                            const expectedPrefix = currentMonthPrefix.substring(0, 7); // "2025-08-13" -> "2025-08" 
                            return completionMonth === expectedPrefix && 
                                   completion.template_id.includes(routineType) && 
                                   completion.completed === true;
                        });
                        
                        console.log(`üîç DEBUG: Current month cloud completions for ${routineType}:`, currentMonthCloudCompletions.length);
                        
                        // Count days with completed routines (group by date)
                        const completionDates = new Set(currentMonthCloudCompletions.map(c => c.date));
                        const cloudMonthlyCount = completionDates.size;
                        console.log(`üîç DEBUG: Cloud format count for ${routineType}: ${cloudMonthlyCount}`);
                        
                        // Use the higher count (in case data exists in both formats)
                        monthlyCount = Math.max(monthlyCount, cloudMonthlyCount);
                    } else {
                        console.log(`üîç DEBUG: No cloud completions cache found, trying direct Supabase query...`);
                        
                        // Try direct Supabase query if authenticated and cache is empty
                        if (supabase?.isAuthenticated()) {
                            try {
                                // Query routine completions directly from Supabase
                                const currentMonthStart = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-01`;
                                const nextMonth = currentMonth === 12 ? 1 : currentMonth + 1;
                                const nextYear = currentMonth === 12 ? currentYear + 1 : currentYear;
                                const nextMonthStart = `${nextYear}-${nextMonth.toString().padStart(2, '0')}-01`;
                                
                                console.log(`üîç DEBUG: Querying Supabase for routine completions from ${currentMonthStart} to ${nextMonthStart}`);
                                
                                // Execute the actual Supabase query
                                console.log(`üîç DEBUG: Executing Supabase query: routine_completions?date=gte.${currentMonthStart}&date=lt.${nextMonthStart}`);
                                
                                const routineCompletions = await supabase.query(`routine_completions?date=gte.${currentMonthStart}&date=lt.${nextMonthStart}`);
                                console.log(`üîç DEBUG: Supabase returned ${routineCompletions?.length || 0} routine completions:`, routineCompletions);
                                
                                if (routineCompletions && routineCompletions.length > 0) {
                                    // Filter for current routine type and count unique dates
                                    const currentRoutineCompletions = routineCompletions.filter(completion => {
                                        return completion.template_id && 
                                               completion.template_id.includes(routineType) && 
                                               completion.completed === true;
                                    });
                                    
                                    console.log(`üîç DEBUG: Found ${currentRoutineCompletions.length} ${routineType} completions from Supabase`);
                                    
                                    // Count unique dates (each day counts as 1 completion regardless of how many routine items)
                                    const uniqueDates = new Set(currentRoutineCompletions.map(c => c.date));
                                    const supabaseMonthlyCount = uniqueDates.size;
                                    console.log(`üîç DEBUG: Supabase ${routineType} count: ${supabaseMonthlyCount}`);
                                    
                                    // Use the higher count
                                    monthlyCount = Math.max(monthlyCount, supabaseMonthlyCount);
                                }
                            } catch (error) {
                                console.warn(`‚ö†Ô∏è Error querying Supabase directly:`, error);
                            }
                        } else {
                            console.log(`üîç DEBUG: Not authenticated for direct Supabase query`);
                        }
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Error checking cloud completions:`, error);
                }
                console.log(`üîç DEBUG: monthlyCount for ${routineType}:`, monthlyCount);
                const streakTiles = document.querySelectorAll('.streak-tile');
                console.log(`üîç DEBUG: Found ${streakTiles.length} streak tiles`);
                const tileIndex = routineType === 'morning' ? 0 : 1;
                const targetTile = streakTiles[tileIndex];
                console.log(`üîç DEBUG: targetTile at index ${tileIndex}:`, targetTile);
                if (targetTile) {
                    const numberElement = targetTile.querySelector('.streak-number');
                    console.log(`üîç DEBUG: numberElement:`, numberElement);
                    if (numberElement) {
                        numberElement.textContent = monthlyCount;
                        console.log(`üîç DEBUG: Set ${routineType} counter to ${monthlyCount}`);
                    }
                }
            });
        }

        // === CATEGORY SYSTEM (for todos) ===
        function switchCategory(categoryId) {
            const parentTab = document.querySelector('#tab-todos');
            // Hide all category contents within todos
            parentTab.querySelectorAll('.category-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all category tabs
            parentTab.querySelectorAll('.category-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-category="${categoryId}"]`).classList.add('active');
            
            // Show/hide clear archive button
            const clearArchiveBtn = document.getElementById('clear-archive-btn');
            if (clearArchiveBtn) {
                if (categoryId === 'archiv') {
                    clearArchiveBtn.style.display = 'inline-block';
                } else {
                    clearArchiveBtn.style.display = 'none';
                }
            }
            
            // Load todos for this category
            TodoManager.displayTodosForCategory(categoryId);
        }

        // === ZIELE CATEGORY SYSTEM ===
        function switchZielCategory(categoryId) {
            const parentTab = document.querySelector('#tab-ziele');
            // Hide all ziel contents
            parentTab.querySelectorAll('.ziel-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all ziel tabs
            parentTab.querySelectorAll('.ziel-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#ziel-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-ziel-category="${categoryId}"]`).classList.add('active');
            
            // Show/hide clear goal archive button
            const clearGoalArchiveBtn = document.getElementById('clear-goal-archive-btn');
            if (clearGoalArchiveBtn) {
                if (categoryId === 'archiv') {
                    clearGoalArchiveBtn.style.display = 'inline-block';
                } else {
                    clearGoalArchiveBtn.style.display = 'none';
                }
            }
            
            // Load goals for this category
            GoalManager.displayGoalsForCategory(categoryId);
        }

        // === JOURNAL CATEGORY SYSTEM ===
        function switchJournalCategory(categoryId) {
            const parentTab = document.querySelector('#tab-journal');
            // Hide all journal contents
            parentTab.querySelectorAll('.journal-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all journal tabs
            parentTab.querySelectorAll('.journal-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#journal-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-journal-category="${categoryId}"]`).classList.add('active');
            
            // Load journal entries for this category
            JournalManager.displayEntriesForCategory(categoryId);
        }

        // === SETTINGS FUNCTIONALITY ===
        function initializeSettings() {
            // Load saved routine reset time
            const savedResetTime = localStorage.getItem('routineResetTime') || '06:00';
            const timeInput = document.getElementById('routine-reset-time');
            if (timeInput) {
                timeInput.value = savedResetTime;
            }
            
            // Save routine settings button
            const saveBtn = document.getElementById('save-routine-settings');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    const resetTime = timeInput.value;
                    localStorage.setItem('routineResetTime', resetTime);
                    alert(`Routine Reset Zeit auf ${resetTime} gesetzt!`);
                    console.log(`Routine reset time saved: ${resetTime}`);
                });
            }
            
            // Reset routines today button
            const resetBtn = document.getElementById('reset-routines-today');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    if (confirm('M√∂chtest du wirklich alle Routinen f√ºr heute zur√ºcksetzen?')) {
                        resetRoutinesToday();
                    }
                });
            }
            
            // Reset monthly todos button
            const resetTodosBtn = document.getElementById('reset-monthly-todos');
            if (resetTodosBtn) {
                resetTodosBtn.addEventListener('click', () => {
                    const now = new Date();
                    const monthName = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
                                     'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
                    if (confirm(`M√∂chtest du wirklich den Todo-Z√§hler f√ºr ${monthName} ${now.getFullYear()} zur√ºcksetzen?`)) {
                        resetMonthlyTodos();
                    }
                });
            }
        }
        
        function resetRoutinesToday() {
            const today = new Date().toISOString().split('T')[0];
            
            // Clear routine states for today
            localStorage.removeItem(`routineStates_${today}`);
            
            // Clear routine completion data for today
            const completionData = JSON.parse(localStorage.getItem('routineCompletionData') || '{}');
            if (completionData[today]) {
                delete completionData[today];
                localStorage.setItem('routineCompletionData', JSON.stringify(completionData));
            }
            
            // Uncheck all routine checkboxes
            document.querySelectorAll('.routine-section input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
                const label = checkbox.nextElementSibling;
                if (label) {
                    label.style.textDecoration = 'none';
                    label.style.color = 'inherit';
                }
            });
            
            // Update progress and streak displays
            updateRoutineProgress();
            if (window.updateMonthlyStreakDisplays) {
                updateMonthlyStreakDisplays();
            }
            
            alert('Routinen f√ºr heute wurden zur√ºckgesetzt!');
            console.log('Routines reset for today');
        }
        
        function resetMonthlyTodos() {
            const now = new Date();
            const monthKey = `${now.getFullYear()}-${now.getMonth()}`;
            
            // Reset monthly todo completions
            const monthlyData = JSON.parse(localStorage.getItem('monthlyTodoCompletions') || '{}');
            monthlyData[monthKey] = 0;
            localStorage.setItem('monthlyTodoCompletions', JSON.stringify(monthlyData));
            
            // Update streak displays
            if (window.updateMonthlyStreakDisplays) {
                updateMonthlyStreakDisplays();
            }
            
            const monthName = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
                             'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
            alert(`Todo-Z√§hler f√ºr ${monthName} ${now.getFullYear()} wurde auf 0 zur√ºckgesetzt!`);
            console.log(`Monthly todos reset for ${monthKey}`);
        }
        
        // === TODO COUNTER INITIALIZATION ===
        function initializeTodoCounter() {
            try {
                const now = new Date();
                const monthKey = `${now.getFullYear()}-${now.getMonth()}`;
                
                const monthlyData = JSON.parse(localStorage.getItem('monthlyTodoCompletions') || '{}');
                const todoCount = monthlyData[monthKey] || 0;
                
                console.log(`üîç DEBUG: Initializing todo counter for ${['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
                         'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()]} ${now.getFullYear()}: ${todoCount}`);
                
                // Update the third streak tile (todos)
                const streakTiles = document.querySelectorAll('.streak-tile');
                const todoTile = streakTiles[2]; // Third tile is todos
                if (todoTile) {
                    const numberElement = todoTile.querySelector('.streak-number');
                    const dateElement = todoTile.querySelector('.streak-date');
                    if (numberElement && dateElement) {
                        numberElement.textContent = todoCount;
                        dateElement.textContent = `${['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
                                                    'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()]} ${now.getFullYear()}`;
                        console.log(`üîç DEBUG: Todo counter initialized to ${todoCount}`);
                    }
                } else {
                    console.error('Todo tile not found');
                }
            } catch (error) {
                console.error('Error initializing todo counter:', error);
            }
        }
        
        // === ROUTINE COMPLETIONS LOADER ===
        async function loadRoutineCompletions() {
            try {
                console.log('üîÑ Loading routine completions from Supabase...');
                
                if (!supabase?.isAuthenticated()) {
                    console.log('‚ö†Ô∏è Not authenticated, skipping routine completions load');
                    return;
                }
                
                // Query routine completions from Supabase
                const routineCompletions = await supabase.query('routine_completions?select=*');
                console.log(`‚úÖ Loaded ${routineCompletions?.length || 0} routine completions from database:`, routineCompletions);
                
                if (routineCompletions && routineCompletions.length > 0) {
                    // Cache in localStorage for offline access
                    localStorage.setItem('routine_completions_cache', JSON.stringify(routineCompletions));
                    console.log('üíæ Cached routine completions in localStorage');
                } else {
                    console.log('‚ÑπÔ∏è No routine completions found in database');
                    // Ensure empty cache if no data
                    localStorage.setItem('routine_completions_cache', JSON.stringify([]));
                }
            } catch (error) {
                console.error('‚ùå Error loading routine completions:', error);
                // Set empty cache on error
                localStorage.setItem('routine_completions_cache', JSON.stringify([]));
            }
        }

        // === EVENT LISTENERS ===
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Skip logout and settings buttons - they have their own handlers
                if (tab.id === 'logout-btn' || tab.id === 'settings-btn') return;
                
                const tabId = tab.getAttribute('data-tab');
                if (tabId) switchTab(tabId);
            });
        });
        
        // Settings button event listener
        const settingsBtn = document.getElementById('settings-btn');
        if (settingsBtn) {
            settingsBtn.addEventListener('click', () => {
                console.log('Settings clicked');
                switchTab('tab-settings');
            });
        }

        // Todo category tabs
        document.querySelectorAll('.category-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-category');
                switchCategory(categoryId);
            });
        });

        // Ziele category tabs
        document.querySelectorAll('.ziel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-ziel-category');
                switchZielCategory(categoryId);
            });
        });

        // Journal category tabs
        document.querySelectorAll('.journal-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-journal-category');
                switchJournalCategory(categoryId);
            });
        });

        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                // ToDo-Items als completed markieren
                const todoItem = this.closest('.todo-item');
                if (todoItem) {
                    todoItem.classList.toggle('completed', this.checked);
                }
                
                // Routine-Progress aktualisieren (nur bei Routine-Checkboxen)
                const routineSection = this.closest('.routine-section');
                if (routineSection) {
                    // Apply visual styling immediately
                    const label = this.nextElementSibling;
                    if (label) {
                        if (this.checked) {
                            label.style.textDecoration = 'line-through';
                            label.style.color = '#999';
                        } else {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    }
                    
                    // Save checkbox state
                    saveCheckboxState(this.id, this.checked);
                    updateRoutineProgress();
                }
            });
        });

        // === TODO MANAGEMENT ===
        const TodoManager = {
            todos: [], // In-memory storage for demo
            
            priorityIntToString(priorityInt) {
                switch(priorityInt) {
                    case 1: return 'mittel'; // Map old niedrig to mittel
                    case 2: return 'mittel';
                    case 3: return 'wichtig';
                    case 4: return 'dringend';
                    default: return 'mittel';
                }
            },
            
            getPriorityString(priority) {
                if (typeof priority === 'string') {
                    return priority;
                }
                return this.priorityIntToString(priority);
            },
            
            getPriorityDisplay(priority) {
                const priorityStr = this.getPriorityString(priority);
                return priorityStr.charAt(0).toUpperCase() + priorityStr.slice(1);
            },
            
            async loadTodos() {
                if (!supabase?.isAuthenticated()) return;
                try {
                    const data = await supabase.select('todos', '*');
                    if (data && Array.isArray(data)) {
                        // Transform database data to match UI expectations
                        this.todos = data.map(todo => {
                            // Convert priority integer back to string
                            let priorityString = 'mittel';
                            switch(todo.priority) {
                                case 1: priorityString = 'mittel'; break; // Map old niedrig to mittel
                                case 2: priorityString = 'mittel'; break;
                                case 3: priorityString = 'wichtig'; break;
                                case 4: priorityString = 'dringend'; break;
                                default: priorityString = 'mittel';
                            }
                            
                            return {
                                ...todo,
                                title: todo.text, // Map text to title for UI
                                deadline: todo.date, // Use date field only (no due_date)
                                priority: priorityString // Convert integer to string
                            };
                        });
                        this.refreshCurrentView();
                        this.updateHomeTodos();
                    }
                } catch (error) {
                    console.error('Error loading todos:', error);
                }
            },
            
            showAddTodoModal() {
                const modal = document.getElementById('add-todo-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('todo-deadline').value = today;
            },
            
            hideAddTodoModal() {
                const modal = document.getElementById('add-todo-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-todo-form').reset();
                // Reset to default values
                document.getElementById('todo-time').value = '21:00';
                document.getElementById('todo-priority').value = 'mittel';
            },
            
            async addTodo(todoData) {
                // DON'T create due_date with timezone - it causes issues
                // Just store date and time separately
                
                // Convert priority string to integer
                let priorityInt = 2; // Default to mittel
                switch(todoData.priority) {
                    case 'niedrig': priorityInt = 1; break; // Keep for backwards compatibility
                    case 'mittel': priorityInt = 2; break;
                    case 'wichtig': priorityInt = 3; break;
                    case 'dringend': priorityInt = 4; break;
                    default: priorityInt = 2;
                }
                console.log('üéØ Priority conversion:', todoData.priority, '‚Üí', priorityInt);
                
                const todo = {
                    text: todoData.title,
                    category: todoData.category,
                    priority: priorityInt,
                    date: todoData.deadline,
                    time: todoData.time,
                    // Remove due_date field to avoid timezone issues
                    completed: false,
                    user_id: supabase?.user?.id || 'anonymous'
                };
                
                if (supabase?.isAuthenticated()) {
                    try {
                        const result = await supabase.insert('todos', todo);
                        console.log('üíæ Supabase insert result:', result);
                        if (result && Array.isArray(result) && result.length > 0) {
                            // Transform the database result to match UI expectations
                            const dbTodo = result[0];
                            console.log('Database returned todo with ID:', dbTodo.id, dbTodo);
                            const uiTodo = {
                                ...dbTodo,
                                title: dbTodo.text,
                                deadline: dbTodo.date, // Use date field only
                                priority: this.priorityIntToString(dbTodo.priority || 1)
                            };
                            this.todos.push(uiTodo);
                        } else {
                            // If insert doesn't return data, add with generated id
                            todo.id = Date.now().toString();
                            todo.title = todo.text;
                            todo.deadline = todo.date;
                            todo.priority = this.priorityIntToString(todo.priority);
                            this.todos.push(todo);
                        }
                    } catch (error) {
                        console.error('Error saving todo:', error);
                        // Fall back to local storage
                        todo.id = Date.now().toString();
                        todo.title = todo.text;
                        todo.deadline = todo.due_date || todo.date;
                        todo.priority = this.priorityIntToString(todo.priority);
                        this.todos.push(todo);
                    }
                } else {
                    // Local storage fallback
                    todo.id = Date.now().toString();
                    todo.title = todo.text;
                    todo.deadline = todo.due_date || todo.date;
                    todo.priority = this.priorityIntToString(todo.priority);
                    this.todos.push(todo);
                }
                
                console.log('Todo added:', todo);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.category-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-category') : 'heute';
                
                console.log('üîÑ Refreshing view for category:', activeCategory);
                console.log('üîÑ All todos (completed status):', this.todos.map(t => ({title: t.title, completed: t.completed})));
                
                this.displayTodosForCategory(activeCategory);
                
                // Also update home todos
                this.updateHomeTodos();
            },
            
            displayTodosForCategory(category) {
                const container = document.getElementById(category);
                if (!container) return;
                
                let filteredTodos = [];
                
                switch(category) {
                    case 'heute':
                        // Get today without timezone conversion
                        const today = new Date();
                        const todayStr = today.getFullYear() + '-' + 
                                       String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                                       String(today.getDate()).padStart(2, '0');
                        
                        filteredTodos = this.todos.filter(todo => 
                            todo.date === todayStr && !todo.completed
                        );
                        break;
                    case 'alle':
                        filteredTodos = this.todos.filter(todo => !todo.completed);
                        break;
                    case 'archiv':
                        filteredTodos = this.todos.filter(todo => todo.completed);
                        break;
                    default:
                        filteredTodos = this.todos.filter(todo => 
                            todo.category === category && !todo.completed
                        );
                }
                // Sort by date first, then by time
                filteredTodos.sort((a, b) => {
                    // First by date
                    const dateA = a.date || '9999-12-31';
                    const dateB = b.date || '9999-12-31';
                    const dateComparison = dateA.localeCompare(dateB);
                    
                    if (dateComparison !== 0) {
                        return dateComparison;
                    }
                    
                    // Then by time
                    const timeA = a.time || '23:59';
                    const timeB = b.time || '23:59';
                    return timeA.localeCompare(timeB);
                });
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredTodos.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Todos vorhanden</p>';
                    return;
                }
                
                // Create grid for todos
                const grid = document.createElement('div');
                grid.className = 'grid-3'; // 3-spaltig f√ºr kompaktere Todo-Kacheln
                
                // Display todos
                filteredTodos.forEach(todo => {
                    const todoElement = this.createTodoElement(todo);
                    grid.appendChild(todoElement);
                });
                
                container.appendChild(grid);
            },
            
            createTodoElement(todo) {
                const todoCard = document.createElement('div');
                todoCard.className = `ziel-card${todo.completed ? ' completed' : ''}`;
                todoCard.dataset.todoId = todo.id;
                
                // COMPLETELY AVOID DATE PARSING - just use raw strings
                let deadlineClass = '';
                let deadlineText = '';
                
                if (todo.date && todo.time) {
                    // Get today as YYYY-MM-DD string (no timezone conversion)
                    const today = new Date();
                    const todayStr = today.getFullYear() + '-' + 
                                   String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                                   String(today.getDate()).padStart(2, '0');
                    
                    const isToday = todo.date === todayStr;
                    
                    if (isToday) {
                        deadlineClass = 'today';
                        deadlineText = `Heute ${todo.time}`; // Use stored time directly
                    } else {
                        // Format date manually to avoid parsing issues
                        const [year, month, day] = todo.date.split('-');
                        const germanDate = `${day}.${month}.${year}`;
                        deadlineText = `${germanDate} ${todo.time}`;
                        deadlineClass = 'soon';
                    }
                } else {
                    deadlineText = 'Kein Termin';
                    deadlineClass = 'none';
                }
                
                todoCard.innerHTML = `
                    <div class="ziel-kategorie">${todo.category}</div>
                    <div class="ziel-header">
                        <div class="ziel-name">${todo.title}</div>
                        <div class="ziel-beschreibung">
                            <span class="todo-deadline ${deadlineClass}">${deadlineText}</span>
                        </div>
                    </div>
                    <div class="ziel-progress-section">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <input type="checkbox" class="todo-checkbox" ${todo.completed ? 'checked' : ''} 
                                   onchange="TodoManager.toggleTodo('${todo.id}')"
                                   style="width: 20px; height: 20px; border: 2px solid #000; appearance: none; cursor: pointer;">
                            <span class="todo-tag ${TodoManager.getPriorityString(todo.priority)}" style="margin-left: auto;">${TodoManager.getPriorityDisplay(todo.priority)}</span>
                        </div>
                    </div>
                `;
                
                // Add checkbox styling
                const checkbox = todoCard.querySelector('.todo-checkbox');
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        this.style.backgroundColor = '#000';
                        this.innerHTML = '<span style="color: white; position: absolute; top: -2px; left: 2px; font-size: 12px;">‚úì</span>';
                    } else {
                        this.style.backgroundColor = 'transparent';
                        this.innerHTML = '';
                    }
                });
                
                // Set initial checkbox state
                if (todo.completed) {
                    checkbox.style.backgroundColor = '#000';
                    checkbox.innerHTML = '<span style="color: white; position: absolute; top: -2px; left: 2px; font-size: 12px;">‚úì</span>';
                }
                
                return todoCard;
            },
            
            async toggleTodo(todoId) {
                console.log('üîç Looking for todo with ID:', todoId, 'Type:', typeof todoId);
                console.log('üîç Available todos:', this.todos.map(t => ({id: t.id, type: typeof t.id, title: t.title})));
                
                const todo = this.todos.find(t => String(t.id) === String(todoId));
                if (todo) {
                    const wasCompleted = todo.completed;
                    todo.completed = !todo.completed;
                    console.log(`‚úÖ Todo "${todo.title}" ${todo.completed ? 'completed' : 'uncompleted'}`);
                    console.log(`üîç DEBUG: wasCompleted = ${wasCompleted}, todo.completed = ${todo.completed}`);
                    
                    // Track todo completion for monthly count ONLY when completing (not uncompleting)
                    if (todo.completed && !wasCompleted) {
                        console.log('üîç DEBUG: Todo completed, tracking...');
                        // Only track when going from uncompleted to completed
                        try {
                            const now = new Date();
                            const monthKey = `${now.getFullYear()}-${now.getMonth()}`;
                            
                            const monthlyData = JSON.parse(localStorage.getItem('monthlyTodoCompletions') || '{}');
                            monthlyData[monthKey] = (monthlyData[monthKey] || 0) + 1;
                            
                            localStorage.setItem('monthlyTodoCompletions', JSON.stringify(monthlyData));
                            console.log(`üîç DEBUG: Todo completion tracked for ${['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
                                     'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()]} ${now.getFullYear()}, total: ${monthlyData[monthKey]}`);
                            
                            // Update streak displays immediately
                            const streakTiles = document.querySelectorAll('.streak-tile');
                            const todoTile = streakTiles[2]; // Third tile is todos
                            if (todoTile) {
                                const numberElement = todoTile.querySelector('.streak-number');
                                if (numberElement) {
                                    numberElement.textContent = monthlyData[monthKey];
                                    console.log(`üîç DEBUG: Updated todo counter to ${monthlyData[monthKey]}`);
                                }
                            }
                        } catch (error) {
                            console.error('Error tracking todo completion:', error);
                        }
                    } else if (!todo.completed && wasCompleted) {
                        console.log('üîç DEBUG: Todo uncompleted - counter stays the same (once completed todos stay in monthly count)');
                    }
                    
                    if (supabase?.isAuthenticated()) {
                        try {
                            console.log('üíæ Updating in database - ID:', todo.id, 'Type:', typeof todo.id, 'Completed:', todo.completed);
                            
                            // Make sure we use the right ID type
                            const updateId = Number.isInteger(Number(todo.id)) ? Number(todo.id) : todo.id;
                            const result = await supabase.update('todos', { completed: todo.completed }, updateId);
                            
                            console.log('üíæ Database update result:', result);
                            
                            console.log('‚úÖ Database update successful');
                            
                        } catch (error) {
                            console.error('‚ùå Database update failed:', error);
                            alert('Fehler: ' + error.message + '\nTodo wird nicht gespeichert!');
                            // Revert on error
                            todo.completed = wasCompleted;
                            return; // Don't refresh if update failed
                        }
                    }
                    
                    this.refreshCurrentView();
                    this.updateHomeTodos();
                } else {
                    console.error('‚ùå Todo not found for ID:', todoId);
                    alert('Todo nicht gefunden! ID: ' + todoId);
                }
            },
            
            async clearArchive() {
                console.log('üîç DEBUG: clearArchive() called');
                if (!confirm('Wirklich alle erledigten Todos dauerhaft l√∂schen?\n\nDiese Aktion kann nicht r√ºckg√§ngig gemacht werden!')) {
                    console.log('üîç DEBUG: Archive clear cancelled by user');
                    return;
                }
                
                const completedTodos = this.todos.filter(todo => todo.completed);
                console.log('üóëÔ∏è Deleting', completedTodos.length, 'completed todos from archive');
                
                if (supabase?.isAuthenticated()) {
                    try {
                        // Delete from database
                        for (const todo of completedTodos) {
                            console.log(`üóëÔ∏è Deleting todo from database: ID ${todo.id}, Title: "${todo.title}"`);
                            const result = await supabase.delete('todos', todo.id);
                            console.log(`üóëÔ∏è Delete result for ${todo.id}:`, result);
                        }
                        console.log('‚úÖ All completed todos deleted from database');
                    } catch (error) {
                        console.error('‚ùå Error deleting todos from database:', error);
                        alert('Fehler beim L√∂schen aus der Datenbank: ' + error.message);
                        return;
                    }
                }
                
                // Remove from local array
                this.todos = this.todos.filter(todo => !todo.completed);
                
                // Update localStorage cache
                try {
                    localStorage.setItem('todos_cache', JSON.stringify(this.todos));
                    console.log('üîÑ Updated local todos cache');
                } catch (error) {
                    console.error('Error updating local todos cache:', error);
                }
                
                // Refresh current view
                this.refreshCurrentView();
                
                alert(`‚úÖ ${completedTodos.length} erledigte Todos wurden gel√∂scht!`);
            },
            
            updateHomeTodos() {
                const homeContainer = document.getElementById('home-todos');
                if (!homeContainer) return;
                
                // Show today's uncompleted todos on home
                const today = new Date();
                const todayStr = today.getFullYear() + '-' + 
                               String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(today.getDate()).padStart(2, '0');
                
                const todayTodos = this.todos.filter(todo => 
                    todo.date === todayStr && !todo.completed
                ).sort((a, b) => {
                    const timeA = a.time || '23:59';
                    const timeB = b.time || '23:59';
                    return timeA.localeCompare(timeB);
                });
                
                homeContainer.innerHTML = '';
                
                if (todayTodos.length === 0) {
                    homeContainer.innerHTML = '<p style="text-align: center; color: #666; padding: 1rem;">Keine Todos f√ºr heute</p>';
                    return;
                }
                
                todayTodos.forEach(todo => {
                    const todoItem = document.createElement('div');
                    todoItem.className = 'checkbox-item todo-item';
                    todoItem.innerHTML = `
                        <div class="todo-left">
                            <input type="checkbox" id="home-todo-${todo.id}" onchange="TodoManager.toggleTodo('${todo.id}')">
                            <label for="home-todo-${todo.id}">
                                ${todo.title} 
                                <span class="todo-tag ${TodoManager.getPriorityString(todo.priority)}" style="margin-left: 0.5rem;">${TodoManager.getPriorityDisplay(todo.priority)}</span>
                            </label>
                        </div>
                        <span class="todo-time">${todo.time || '21:00'}</span>
                    `;
                    homeContainer.appendChild(todoItem);
                });
            }
        };

        // === GOAL MANAGEMENT ===
        const GoalManager = {
            goals: [], // In-memory storage for demo
            
            async loadGoals() {
                if (!supabase?.isAuthenticated()) return;
                try {
                    const data = await supabase.select('goals', '*');
                    console.log('üíæ Raw goals from database:', data);
                    if (data && Array.isArray(data)) {
                        // Transform database data to match UI expectations
                        this.goals = data.map(goal => {
                            console.log('üîÑ Transforming goal:', goal);
                            return {
                                ...goal,
                                name: goal.title, // Map title to name for UI
                                deadline: goal.target_date, // Map target_date to deadline for UI
                                progress: goal.progress || 0, // Use DB progress field
                                timeframe: goal.timeframe || 'monat', // Use DB timeframe field
                                completed: goal.completed // Use DB completed field
                            };
                        });
                        console.log('üîÑ Transformed goals:', this.goals);
                        this.refreshCurrentView();
                    }
                } catch (error) {
                    console.error('Error loading goals:', error);
                }
            },
            
            // Calculate automatic deadlines based on timeframe
            calculateDeadline(timeframe) {
                const now = new Date();
                
                switch(timeframe) {
                    case 'monat': {
                        // Last day of current month - use day 0 of next month
                        const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                        // Format manually to avoid timezone issues
                        const year = endOfMonth.getFullYear();
                        const month = String(endOfMonth.getMonth() + 1).padStart(2, '0');
                        const day = String(endOfMonth.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    case 'quartal': {
                        // Last day of current quarter
                        const currentQuarter = Math.floor(now.getMonth() / 3);
                        const quarterEndMonth = (currentQuarter + 1) * 3; // 3, 6, 9, 12
                        const endOfQuarter = new Date(now.getFullYear(), quarterEndMonth, 0);
                        // Format manually to avoid timezone issues
                        const year = endOfQuarter.getFullYear();
                        const month = String(endOfQuarter.getMonth() + 1).padStart(2, '0');
                        const day = String(endOfQuarter.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    case 'jahr': {
                        // December 31st of current year
                        const year = now.getFullYear();
                        return `${year}-12-31`;
                    }
                    default:
                        return now.toISOString().split('T')[0];
                }
            },
            
            showAddGoalModal() {
                const modal = document.getElementById('add-goal-modal');
                modal.classList.remove('hide');
                
                // Set default deadline based on current timeframe selection
                const timeframeSelect = document.getElementById('goal-timeframe');
                const deadlineInput = document.getElementById('goal-deadline');
                if (timeframeSelect && deadlineInput) {
                    deadlineInput.value = this.calculateDeadline(timeframeSelect.value);
                }
            },
            
            hideAddGoalModal() {
                const modal = document.getElementById('add-goal-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-goal-form').reset();
                document.getElementById('goal-progress').value = '0';
            },
            
            async addGoal(goalData) {
                const progressPercent = parseInt(goalData.progress);
                // TEMPORARY: Skip database, just use local storage until schema is fixed
                const goal = {
                    id: Date.now().toString(),
                    name: goalData.name,
                    description: goalData.description,
                    category: goalData.category,
                    timeframe: goalData.timeframe, // WICHTIG: timeframe f√ºr Filterung
                    deadline: goalData.deadline,
                    progress: progressPercent,
                    completed: progressPercent >= 100,
                    createdAt: new Date().toISOString()
                };
                
                if (supabase?.isAuthenticated()) {
                    try {
                        // Map UI fields to database schema (with new progress/timeframe fields)
                        const dbGoal = {
                            title: goal.name,
                            description: goal.description,
                            category: goal.category,
                            target_date: goal.deadline,
                            progress: goal.progress,
                            timeframe: goal.timeframe,
                            completed: goal.completed,
                            user_id: supabase?.user?.id
                        };
                        
                        console.log('üíæ Attempting to save goal to database:', dbGoal);
                        const result = await supabase.insert('goals', dbGoal);
                        console.log('üíæ Database result:', result);
                        
                        if (result && result.length > 0) {
                            // Use database result and transform back to UI format
                            const savedGoal = {
                                ...result[0],
                                name: result[0].title,
                                deadline: result[0].target_date,
                                timeframe: result[0].timeframe,
                                progress: result[0].progress,
                                completed: result[0].completed
                            };
                            this.goals.push(savedGoal);
                        } else {
                            // Fallback to local storage
                            this.goals.push(goal);
                        }
                    } catch (error) {
                        console.error('‚ùå Error saving goal to database:', error);
                        console.log('üíæ Falling back to local storage');
                        this.goals.push(goal);
                    }
                } else {
                    // Not authenticated, use local storage
                    this.goals.push(goal);
                }
                
                console.log('Goal added:', goal);
                console.log('All goals after adding:', this.goals);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.ziel-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-ziel-category') : 'monat';
                
                console.log('üéØ Goals refresh - active category:', activeCategory);
                console.log('üéØ All goals:', this.goals.map(g => ({name: g.name, category: g.category, timeframe: g.timeframe})));
                
                this.displayGoalsForCategory(activeCategory);
            },
            
            displayGoalsForCategory(category) {
                const container = document.getElementById(`ziel-${category}`);
                if (!container) return;
                
                let filteredGoals = [];
                
                switch(category) {
                    case 'monat':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'monat' && !goal.completed
                        );
                        break;
                    case 'quartal':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'quartal' && !goal.completed
                        );
                        break;
                    case 'jahr':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'jahr' && !goal.completed
                        );
                        break;
                    case 'alle':
                        filteredGoals = this.goals.filter(goal => !goal.completed);
                        break;
                    case 'archiv':
                        filteredGoals = this.goals.filter(goal => goal.completed);
                        break;
                }
                
                // Sort by deadline
                filteredGoals.sort((a, b) => new Date(a.deadline) - new Date(b.deadline));
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredGoals.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Ziele vorhanden</p>';
                    return;
                }
                
                // Create grid for goals
                const grid = document.createElement('div');
                grid.className = 'grid-2';
                
                // Display goals
                filteredGoals.forEach(goal => {
                    const goalElement = this.createGoalElement(goal);
                    grid.appendChild(goalElement);
                });
                
                container.appendChild(grid);
            },
            
            createGoalElement(goal) {
                const goalCard = document.createElement('div');
                goalCard.className = `ziel-card${goal.completed ? ' completed' : ''}`;
                goalCard.dataset.goalId = goal.id;
                
                goalCard.innerHTML = `
                    <div class="ziel-kategorie">${goal.category}</div>
                    <div class="ziel-edit-icon" onclick="GoalManager.editGoalProgress('${goal.id}')" style="position: absolute; top: 1rem; left: 1rem; cursor: pointer; color: #666; font-size: 0.9rem; opacity: 0.7; transition: opacity 0.2s ease;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">‚úé</div>
                    <div class="ziel-header">
                        <div class="ziel-name">${goal.name}</div>
                        <div class="ziel-beschreibung">${goal.description}</div>
                    </div>
                    <div class="ziel-progress-section">
                        <div class="ziel-progress-header">
                            <span class="ziel-progress-label">Fortschritt</span>
                            <span class="ziel-percentage">${goal.progress}%</span>
                        </div>
                        <div class="progress-container">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${goal.progress}%;"></div>
                            </div>
                        </div>
                    </div>
                `;
                
                return goalCard;
            },
            
            async updateGoalProgress(goalId, newProgress) {
                const goal = this.goals.find(g => g.id == goalId); // Use == for flexible ID matching
                if (goal) {
                    const oldProgress = goal.progress;
                    goal.progress = parseInt(newProgress);
                    goal.completed = goal.progress >= 100;
                    
                    console.log('üéØ Updating goal:', goal.name, 'to progress:', goal.progress);
                    
                    // Only try database update if goal has database ID (not timestamp)
                    const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                    
                    if (supabase?.isAuthenticated() && hasDbId) {
                        try {
                            console.log('üíæ Updating goal in database with ID:', goal.id);
                            await supabase.update('goals', { 
                                progress: goal.progress,
                                completed: goal.completed
                            }, goal.id);
                            console.log('‚úÖ Goal progress updated in database');
                        } catch (error) {
                            console.error('‚ùå Error updating goal progress:', error);
                            // Don't revert - keep local change even if DB fails
                            console.warn('‚ö†Ô∏è Goal updated locally only (database update failed)');
                        }
                    } else {
                        console.warn('‚ö†Ô∏è Goal updated locally only (no database ID or not authenticated)');
                    }
                    
                    console.log('‚úÖ Goal progress updated locally:', goal);
                    this.refreshCurrentView();
                } else {
                    console.error('‚ùå Goal not found for ID:', goalId);
                }
            },
            
            async clearGoalArchive() {
                if (!confirm('Wirklich alle erledigten Ziele dauerhaft l√∂schen?\n\nDiese Aktion kann nicht r√ºckg√§ngig gemacht werden!')) {
                    return;
                }
                
                const completedGoals = this.goals.filter(goal => goal.completed);
                console.log('üóëÔ∏è Deleting', completedGoals.length, 'completed goals from archive');
                
                if (supabase?.isAuthenticated()) {
                    try {
                        // Delete from database (only goals with database IDs)
                        for (const goal of completedGoals) {
                            const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                            if (hasDbId) {
                                await supabase.delete('goals', goal.id);
                                console.log('üíæ Deleted goal from database:', goal.name);
                            } else {
                                console.log('üíæ Skipped local-only goal:', goal.name);
                            }
                        }
                        console.log('‚úÖ All database goals deleted');
                    } catch (error) {
                        console.error('‚ùå Error deleting goals from database:', error);
                        alert('Fehler beim L√∂schen aus der Datenbank: ' + error.message);
                        return;
                    }
                }
                
                // Remove from local array
                this.goals = this.goals.filter(goal => !goal.completed);
                
                // Refresh current view
                this.refreshCurrentView();
                
                alert(`‚úÖ ${completedGoals.length} erledigte Ziele wurden gel√∂scht!`);
            },
            
            clearLocalGoals() {
                if (confirm('Alle lokalen Ziele l√∂schen? (Nur Ziele die nicht in der Datenbank sind)\n\nDas kann alte/kaputte Ziele entfernen.')) {
                    const before = this.goals.length;
                    // Keep only goals that look like they have database IDs
                    this.goals = this.goals.filter(goal => {
                        const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                        return hasDbId;
                    });
                    const after = this.goals.length;
                    console.log(`üóëÔ∏è Removed ${before - after} local-only goals`);
                    this.refreshCurrentView();
                    alert(`${before - after} lokale Ziele gel√∂scht!`);
                }
            },
            
            editGoalProgress(goalId) {
                console.log('‚úèÔ∏è Edit goal progress - ID:', goalId, 'Type:', typeof goalId);
                const goal = this.goals.find(g => g.id == goalId); // Flexible matching
                if (!goal) {
                    console.error('‚ùå Goal not found for edit. ID:', goalId);
                    console.log('‚ùå Available goals:', this.goals.map(g => ({id: g.id, name: g.name})));
                    return;
                }
                console.log('‚úèÔ∏è Editing goal:', goal.name, 'Current progress:', goal.progress);
                
                // Find the goal card and progress percentage element
                const goalCard = document.querySelector(`[data-goal-id="${goalId}"]`);
                const percentageElement = goalCard.querySelector('.ziel-percentage');
                const progressFill = goalCard.querySelector('.progress-fill');
                
                // Create inline edit container
                const editContainer = document.createElement('div');
                editContainer.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; background: #f9f9f9; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px;';
                
                // Create progress input
                const input = document.createElement('input');
                input.type = 'number';
                input.min = '0';
                input.max = '100';
                input.value = goal.progress;
                input.style.cssText = 'width: 50px; padding: 2px 4px; border: 1px solid #ccc; font-size: 0.9rem; text-align: center;';
                
                // Create complete button
                const completeBtn = document.createElement('button');
                completeBtn.textContent = '‚úì Erledigt';
                completeBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; border: 1px solid #28a745; background: #28a745; color: white; border-radius: 3px; cursor: pointer;';
                
                // Create cancel button
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = '√ó';
                cancelBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; border: 1px solid #ccc; background: #f8f9fa; border-radius: 3px; cursor: pointer;';
                
                editContainer.appendChild(input);
                editContainer.appendChild(completeBtn);
                editContainer.appendChild(cancelBtn);
                
                // Replace percentage display with edit container
                const originalText = percentageElement.textContent;
                percentageElement.replaceWith(editContainer);
                input.focus();
                input.select();
                
                // Prevent double execution
                let isHandled = false;
                
                // Handle save/cancel
                const saveProgress = async () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    const newValue = parseInt(input.value);
                    if (!isNaN(newValue) && newValue >= 0 && newValue <= 100) {
                        await this.updateGoalProgress(goalId, newValue);
                        
                        // Update UI
                        const newPercentageElement = document.createElement('span');
                        newPercentageElement.className = 'ziel-percentage';
                        newPercentageElement.textContent = `${newValue}%`;
                        editContainer.replaceWith(newPercentageElement);
                        
                        // Update progress bar
                        progressFill.style.width = `${newValue}%`;
                        
                        // Refresh view if goal completed
                        if (newValue >= 100) {
                            this.refreshCurrentView();
                        }
                    } else {
                        cancelEdit();
                    }
                };
                
                const markComplete = async () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    await this.updateGoalProgress(goalId, 100);
                    
                    // Update UI
                    const newPercentageElement = document.createElement('span');
                    newPercentageElement.className = 'ziel-percentage';
                    newPercentageElement.textContent = '100%';
                    editContainer.replaceWith(newPercentageElement);
                    
                    // Update progress bar
                    progressFill.style.width = '100%';
                    
                    // Refresh view to move to archive
                    this.refreshCurrentView();
                };
                
                const cancelEdit = () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    const newPercentageElement = document.createElement('span');
                    newPercentageElement.className = 'ziel-percentage';
                    newPercentageElement.textContent = originalText;
                    editContainer.replaceWith(newPercentageElement);
                };
                
                // Event listeners
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveProgress();
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
                
                completeBtn.addEventListener('click', markComplete);
                cancelBtn.addEventListener('click', cancelEdit);
                
                // Auto-save on blur for input
                input.addEventListener('blur', (e) => {
                    // Only if user didn't click on buttons
                    setTimeout(() => {
                        if (!isHandled && document.contains(editContainer)) {
                            saveProgress();
                        }
                    }, 100);
                });
            }
        };

        // === JOURNAL MANAGEMENT ===
        const JournalManager = {
            entries: [], // In-memory storage for demo
            
            async loadEntries() {
                if (!supabase?.isAuthenticated()) return;
                try {
                    const data = await supabase.select('journal_entries', '*');
                    if (data && Array.isArray(data)) {
                        // Transform database data to ensure tags is always an array
                        this.entries = data.map(entry => {
                            let tags = [];
                            if (Array.isArray(entry.tags)) {
                                tags = entry.tags;
                            } else if (entry.tags) {
                                if (typeof entry.tags === 'string') {
                                    try {
                                        // Try to parse as JSON first
                                        tags = JSON.parse(entry.tags);
                                        if (!Array.isArray(tags)) {
                                            // If it's not an array, treat as single tag
                                            tags = [entry.tags];
                                        }
                                    } catch (e) {
                                        // If JSON.parse fails, treat as single tag
                                        tags = [entry.tags];
                                    }
                                } else {
                                    tags = [entry.tags];
                                }
                            }
                            return {
                                ...entry,
                                tags: tags
                            };
                        });
                        this.refreshCurrentView();
                    }
                } catch (error) {
                    console.error('Error loading journal entries:', error);
                }
            },
            
            showAddJournalModal() {
                const modal = document.getElementById('add-journal-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('journal-date').value = today;
            },
            
            hideAddJournalModal() {
                const modal = document.getElementById('add-journal-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-journal-form').reset();
                // Reset date back to today
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('journal-date').value = today;
            },
            
            async addEntry(entryData) {
                const entry = {
                    title: entryData.title,
                    content: entryData.content,
                    tags: entryData.tags || [], // Array of tags
                    date: entryData.date,
                    user_id: supabase?.user?.id,
                    created_at: new Date().toISOString()
                };
                
                if (supabase?.isAuthenticated()) {
                    try {
                        const result = await supabase.insert('journal_entries', entry);
                        if (result && result.length > 0) {
                            this.entries.push(result[0]);
                        } else {
                            entry.id = Date.now().toString();
                            this.entries.push(entry);
                        }
                    } catch (error) {
                        console.error('Error saving journal entry:', error);
                        entry.id = Date.now().toString();
                        this.entries.push(entry);
                    }
                } else {
                    entry.id = Date.now().toString();
                    this.entries.push(entry);
                }
                
                console.log('Journal entry added:', entry);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.journal-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-journal-category') : 'alle';
                
                this.displayEntriesForCategory(activeCategory);
            },
            
            displayEntriesForCategory(category) {
                const container = document.getElementById(`journal-${category}`);
                if (!container) return;
                
                let filteredEntries = [];
                
                switch(category) {
                    case 'alle':
                        filteredEntries = this.entries;
                        break;
                    default:
                        // Filter entries that have the selected tag
                        filteredEntries = this.entries.filter(entry => 
                            entry.tags && entry.tags.includes(category)
                        );
                }
                
                // Sort by date (newest first)
                filteredEntries.sort((a, b) => new Date(b.date) - new Date(a.date));
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredEntries.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Journal-Eintr√§ge vorhanden</p>';
                    return;
                }
                
                // Create grid for entries
                const grid = document.createElement('div');
                grid.className = 'grid-2'; // 2-spaltig f√ºr Journal-Eintr√§ge
                
                // Display entries
                filteredEntries.forEach(entry => {
                    const entryElement = this.createEntryElement(entry);
                    grid.appendChild(entryElement);
                });
                
                container.appendChild(grid);
            },
            
            createEntryElement(entry) {
                const entryCard = document.createElement('div');
                entryCard.className = 'ziel-card';
                entryCard.dataset.entryId = entry.id;
                
                const entryDate = new Date(entry.date);
                const formattedDate = entryDate.toLocaleDateString('de-DE', {
                    day: '2-digit',
                    month: '2-digit', 
                    year: 'numeric'
                });
                
                // Ensure tags is always an array before mapping
                const tags = Array.isArray(entry.tags) ? entry.tags : 
                           (entry.tags ? (typeof entry.tags === 'string' ? JSON.parse(entry.tags) : []) : []);
                const tagsHtml = tags.length > 0 
                    ? tags.map(tag => `<span class="todo-tag normal" style="margin-right: 0.5rem;">${tag}</span>`).join('')
                    : '';
                
                entryCard.innerHTML = `
                    <div class="ziel-header">
                        <div class="ziel-name">${entry.title}</div>
                        <div class="ziel-beschreibung">${entry.content}</div>
                    </div>
                    <div class="ziel-progress-section">
                        <div class="ziel-progress-header">
                            <span class="ziel-progress-label">${formattedDate}</span>
                        </div>
                        <div style="margin-top: 0.5rem;">
                            ${tagsHtml}
                        </div>
                    </div>
                `;
                
                return entryCard;
            }
        };

        // === TERMIN MANAGEMENT ===
        const TerminManager = {
            termine: [], // In-memory storage for demo
            
            async loadTermine() {
                if (!supabase?.isAuthenticated()) return;
                try {
                    const data = await supabase.select('termine', '*');
                    if (data && Array.isArray(data)) {
                        this.termine = data;
                        this.displayTermine();
                    }
                } catch (error) {
                    console.error('Error loading termine:', error);
                }
            },
            
            showAddTerminModal() {
                const modal = document.getElementById('add-termin-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('termin-date').value = today;
                
                // Leave time field empty - user can fill if needed
                document.getElementById('termin-time').value = '';
            },
            
            hideAddTerminModal() {
                const modal = document.getElementById('add-termin-modal');
                const form = document.getElementById('add-termin-form');
                const submitBtn = form.querySelector('button[type="submit"]');
                
                modal.classList.add('hide');
                form.reset();
                delete form.dataset.editId; // Clear edit mode
                if (submitBtn) {
                    submitBtn.textContent = 'Hinzuf√ºgen'; // Reset button text
                }
            },
            
            async addTermin(terminData) {
                const termin = {
                    title: terminData.title,
                    description: terminData.description,
                    date: terminData.date,
                    time: terminData.time,
                    user_id: supabase?.user?.id,
                    created_at: new Date().toISOString()
                };
                
                if (supabase?.isAuthenticated()) {
                    try {
                        const result = await supabase.insert('termine', termin);
                        if (result && result.length > 0) {
                            this.termine.push(result[0]);
                        } else {
                            termin.id = Date.now().toString();
                            this.termine.push(termin);
                        }
                    } catch (error) {
                        console.error('Error saving termin:', error);
                        termin.id = Date.now().toString();
                        this.termine.push(termin);
                    }
                } else {
                    termin.id = Date.now().toString();
                    this.termine.push(termin);
                }
                
                console.log('Termin added:', termin);
                
                // Refresh display
                this.displayTermine();
            },
            
            async updateTermin(terminId, terminData) {
                const terminIndex = this.termine.findIndex(t => t.id == terminId);
                if (terminIndex === -1) {
                    console.error('Termin not found for update:', terminId);
                    return;
                }
                
                const updatedTermin = {
                    ...this.termine[terminIndex],
                    title: terminData.title,
                    description: terminData.description,
                    date: terminData.date,
                    time: terminData.time,
                    updated_at: new Date().toISOString()
                };
                
                if (supabase?.isAuthenticated()) {
                    try {
                        await supabase.update('termine', updatedTermin, terminId);
                        this.termine[terminIndex] = updatedTermin;
                    } catch (error) {
                        console.error('Error updating termin:', error);
                        this.termine[terminIndex] = updatedTermin;
                    }
                } else {
                    this.termine[terminIndex] = updatedTermin;
                }
                
                console.log('Termin updated:', updatedTermin);
                
                // Refresh display
                this.displayTermine();
            },
            
            displayTermine() {
                console.log('üìÖ Displaying termine:', this.termine);
                const container = document.getElementById('termine-container');
                if (!container) {
                    console.error('‚ùå Termine container not found');
                    return;
                }
                
                // Clear container
                container.innerHTML = '';
                
                if (this.termine.length === 0) {
                    console.log('‚ÑπÔ∏è No termine to display');
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem; grid-column: 1 / -1;">Keine Termine vorhanden</p>';
                    return;
                }
                
                console.log(`üìä Displaying ${this.termine.length} termine`);
                
                // Sort by date/time (earliest first)
                const sortedTermine = this.termine.sort((a, b) => {
                    const dateTimeA = new Date(`${a.date}T${a.time || '00:00'}`);
                    const dateTimeB = new Date(`${b.date}T${b.time || '00:00'}`);
                    return dateTimeA - dateTimeB;
                });
                
                // Add termine
                sortedTermine.forEach(termin => {
                    const terminElement = this.createTerminElement(termin);
                    container.appendChild(terminElement);
                });
            },
            
            createTerminElement(termin) {
                const terminCard = document.createElement('div');
                terminCard.className = 'termin-card';
                terminCard.dataset.terminId = termin.id;
                
                const terminDate = new Date(termin.date);
                const formattedDate = terminDate.toLocaleDateString('de-DE', {
                    weekday: 'long',
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                });
                
                let displayDate = formattedDate;
                if (termin.time) {
                    const timeDate = new Date(`${termin.date}T${termin.time}`);
                    const formattedTime = timeDate.toLocaleTimeString('de-DE', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    displayDate += `, ${formattedTime}`;
                }
                
                terminCard.innerHTML = `
                    <div class="termin-edit-icon" onclick="TerminManager.editTermin('${termin.id}')" style="position: absolute; top: 1rem; right: 1rem; cursor: pointer; color: #666; font-size: 0.9rem; opacity: 0.7; transition: opacity 0.2s ease;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">‚úé</div>
                    <div class="termin-delete-icon" onclick="TerminManager.deleteTermin('${termin.id}')" style="position: absolute; top: 1rem; right: 2.5rem; cursor: pointer; color: #dc2626; font-size: 0.9rem; opacity: 0.7; transition: opacity 0.2s ease;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">üóë</div>
                    <div class="termin-date">${displayDate}</div>
                    <div class="termin-title">${termin.title}</div>
                    <div class="termin-description">${termin.description}</div>
                `;
                
                return terminCard;
            },
            
            async editTermin(terminId) {
                console.log('üñäÔ∏è Edit termin clicked:', terminId);
                console.log('üìã Available termine:', this.termine);
                
                const termin = this.termine.find(t => t.id == terminId);
                if (!termin) {
                    console.error('‚ùå Termin not found:', terminId);
                    alert('Termin nicht gefunden!');
                    return;
                }
                
                console.log('‚úÖ Found termin for editing:', termin);
                
                // Pre-fill the form with existing values
                document.getElementById('termin-title').value = termin.title;
                document.getElementById('termin-description').value = termin.description;
                document.getElementById('termin-date').value = termin.date;
                document.getElementById('termin-time').value = termin.time || '';
                
                // Store the ID for updating
                const form = document.getElementById('add-termin-form');
                form.dataset.editId = terminId;
                
                // Change button text
                const submitBtn = form.querySelector('button[type="submit"]');
                submitBtn.textContent = 'Termin aktualisieren';
                
                console.log('üìù Form prepared for editing, opening modal...');
                
                // Show modal
                this.showAddTerminModal();
            },
            
            async deleteTermin(terminId) {
                if (!confirm('M√∂chtest du diesen Termin wirklich l√∂schen?')) {
                    return;
                }
                
                console.log('üóëÔ∏è Deleting termin:', terminId);
                
                if (supabase?.isAuthenticated()) {
                    try {
                        await supabase.delete('termine', terminId);
                        console.log('‚úÖ Termin deleted from database');
                    } catch (error) {
                        console.error('‚ùå Error deleting termin from database:', error);
                        alert('Fehler beim L√∂schen: ' + error.message);
                        return;
                    }
                }
                
                // Remove from local array
                this.termine = this.termine.filter(t => t.id != terminId);
                
                // Update localStorage cache
                try {
                    localStorage.setItem('termine_cache', JSON.stringify(this.termine));
                    console.log('üîÑ Updated local termine cache');
                } catch (error) {
                    console.error('Error updating local termine cache:', error);
                }
                
                // Refresh view
                this.displayTermine();
                
                console.log('‚úÖ Termin deleted successfully');
            }
        };

        // === INITIALIZE ===
        document.addEventListener('DOMContentLoaded', async () => {
            updateRoutineProgress();
            
            // Initialize Supabase first
            if (window.initializeSupabase) {
                window.initializeSupabase();
            }
            
            // Then initialize authentication
            await Auth.init();
            
            // Load all data from database if authenticated
            if (supabase?.isAuthenticated()) {
                await Promise.all([
                    TodoManager.loadTodos(),
                    GoalManager.loadGoals(),
                    JournalManager.loadEntries(),
                    TerminManager.loadTermine(),
                    loadRoutineCompletions()
                ]);
            } else {
                // Initialize displays for local storage mode
                TodoManager.updateHomeTodos();
                TerminManager.displayTermine();
            }
            
            // Logout button is already handled by Auth.setupEventListeners()
            
            // Journal form submission
            const journalForm = document.querySelector('.journal-form');
            if (journalForm) {
                journalForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const input = this.querySelector('.journal-input');
                    if (input.value.trim()) {
                        console.log('Journal entry:', input.value);
                        input.value = '';
                    }
                });
            }
            
            // Add Todo Button
            const addTodoBtn = document.getElementById('add-todo-btn');
            if (addTodoBtn) {
                addTodoBtn.addEventListener('click', () => {
                    TodoManager.showAddTodoModal();
                });
            }
            
            // Clear Archive Button
            const clearArchiveBtn = document.getElementById('clear-archive-btn');
            if (clearArchiveBtn) {
                clearArchiveBtn.addEventListener('click', () => {
                    TodoManager.clearArchive();
                });
            }
            
            // Cancel Todo Button
            const cancelTodoBtn = document.getElementById('cancel-todo-btn');
            if (cancelTodoBtn) {
                cancelTodoBtn.addEventListener('click', () => {
                    TodoManager.hideAddTodoModal();
                });
            }
            
            // Add Todo Form Submission
            const addTodoForm = document.getElementById('add-todo-form');
            if (addTodoForm) {
                addTodoForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const todoData = {
                        title: document.getElementById('todo-title').value,
                        category: document.getElementById('todo-category').value,
                        priority: document.getElementById('todo-priority').value,
                        deadline: document.getElementById('todo-deadline').value,
                        time: document.getElementById('todo-time').value
                    };
                    
                    console.log('üìù Form data being sent:', todoData);
                    console.log('üìù Priority element value:', document.getElementById('todo-priority').value);
                    console.log('üìù Priority element selectedIndex:', document.getElementById('todo-priority').selectedIndex);
                    
                    await TodoManager.addTodo(todoData);
                    TodoManager.hideAddTodoModal();
                });
            }
            
            // Close modal when clicking outside
            const addTodoModal = document.getElementById('add-todo-modal');
            if (addTodoModal) {
                addTodoModal.addEventListener('click', (e) => {
                    if (e.target === addTodoModal) {
                        TodoManager.hideAddTodoModal();
                    }
                });
            }
            
            // === GOAL EVENT LISTENERS ===
            
            // Add Goal Button
            const addGoalBtn = document.getElementById('add-goal-btn');
            if (addGoalBtn) {
                addGoalBtn.addEventListener('click', () => {
                    GoalManager.showAddGoalModal();
                });
            }
            
            // Cancel Goal Button
            const cancelGoalBtn = document.getElementById('cancel-goal-btn');
            if (cancelGoalBtn) {
                cancelGoalBtn.addEventListener('click', () => {
                    GoalManager.hideAddGoalModal();
                });
            }
            
            // Add Goal Form Submission
            const addGoalForm = document.getElementById('add-goal-form');
            if (addGoalForm) {
                addGoalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const goalData = {
                        name: document.getElementById('goal-name').value,
                        description: document.getElementById('goal-description').value,
                        category: document.getElementById('goal-category').value,
                        timeframe: document.getElementById('goal-timeframe').value,
                        deadline: document.getElementById('goal-deadline').value,
                        progress: document.getElementById('goal-progress').value
                    };
                    
                    await GoalManager.addGoal(goalData);
                    GoalManager.hideAddGoalModal();
                });
            }
            
            // Timeframe change listener - automatically update deadline
            const goalTimeframeSelect = document.getElementById('goal-timeframe');
            if (goalTimeframeSelect) {
                goalTimeframeSelect.addEventListener('change', (e) => {
                    const deadlineInput = document.getElementById('goal-deadline');
                    if (deadlineInput) {
                        deadlineInput.value = GoalManager.calculateDeadline(e.target.value);
                    }
                });
            }
            
            // Close goal modal when clicking outside
            const addGoalModal = document.getElementById('add-goal-modal');
            if (addGoalModal) {
                addGoalModal.addEventListener('click', (e) => {
                    if (e.target === addGoalModal) {
                        GoalManager.hideAddGoalModal();
                    }
                });
            }
            
            // Clear Goal Archive Button
            const clearGoalArchiveBtn = document.getElementById('clear-goal-archive-btn');
            if (clearGoalArchiveBtn) {
                clearGoalArchiveBtn.addEventListener('click', () => {
                    GoalManager.clearGoalArchive();
                });
            }
            
            // === JOURNAL EVENT LISTENERS ===
            
            // Add Journal Button
            const addJournalBtn = document.getElementById('add-journal-btn');
            if (addJournalBtn) {
                addJournalBtn.addEventListener('click', () => {
                    JournalManager.showAddJournalModal();
                });
            }
            
            // Cancel Journal Button
            const cancelJournalBtn = document.getElementById('cancel-journal-btn');
            if (cancelJournalBtn) {
                cancelJournalBtn.addEventListener('click', () => {
                    JournalManager.hideAddJournalModal();
                });
            }
            
            // Tag selection functionality
            let selectedTags = [];
            
            function updateTagsDisplay() {
                const hiddenInput = document.getElementById('journal-category');
                
                // Update hidden input (use first tag or 'allgemein' as fallback for compatibility)
                hiddenInput.value = selectedTags.length > 0 ? selectedTags[0] : 'allgemein';
                
                // Update tag option buttons
                document.querySelectorAll('.tag-option').forEach(btn => {
                    const tag = btn.getAttribute('data-tag');
                    btn.classList.toggle('selected', selectedTags.includes(tag));
                });
            }
            
            // Tag option click handlers
            document.querySelectorAll('.tag-option').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    
                    // If clicking on the X, remove the tag
                    if (e.target.classList.contains('remove-tag')) {
                        const tag = btn.getAttribute('data-tag');
                        selectedTags = selectedTags.filter(t => t !== tag);
                        updateTagsDisplay();
                        return;
                    }
                    
                    const tag = btn.getAttribute('data-tag');
                    
                    if (selectedTags.includes(tag)) {
                        // Already selected, remove it
                        selectedTags = selectedTags.filter(t => t !== tag);
                    } else {
                        // Not selected, add it
                        selectedTags.push(tag);
                    }
                    
                    updateTagsDisplay();
                });
            });
            
            // Add Journal Form Submission
            const addJournalForm = document.getElementById('add-journal-form');
            if (addJournalForm) {
                addJournalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    if (selectedTags.length === 0) {
                        alert('Bitte w√§hle mindestens einen Tag aus.');
                        return;
                    }
                    
                    const entryData = {
                        title: document.getElementById('journal-title').value,
                        content: document.getElementById('journal-content').value,
                        tags: [...selectedTags], // Copy array
                        date: document.getElementById('journal-date').value
                    };
                    
                    await JournalManager.addEntry(entryData);
                    JournalManager.hideAddJournalModal();
                    
                    // Reset tags
                    selectedTags = [];
                    updateTagsDisplay();
                });
            }
            
            // Close journal modal when clicking outside
            const addJournalModal = document.getElementById('add-journal-modal');
            if (addJournalModal) {
                addJournalModal.addEventListener('click', (e) => {
                    if (e.target === addJournalModal) {
                        JournalManager.hideAddJournalModal();
                    }
                });
            }
            
            // === TERMIN EVENT LISTENERS ===
            
            // Add Termin Button
            const addTerminBtn = document.getElementById('add-termin-btn');
            if (addTerminBtn) {
                addTerminBtn.addEventListener('click', () => {
                    TerminManager.showAddTerminModal();
                });
            }
            
            // Cancel Termin Button
            const cancelTerminBtn = document.getElementById('cancel-termin-btn');
            if (cancelTerminBtn) {
                cancelTerminBtn.addEventListener('click', () => {
                    TerminManager.hideAddTerminModal();
                });
            }
            
            // Add Termin Form Submission
            const addTerminForm = document.getElementById('add-termin-form');
            if (addTerminForm) {
                addTerminForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const terminData = {
                        title: document.getElementById('termin-title').value,
                        description: document.getElementById('termin-description').value,
                        date: document.getElementById('termin-date').value,
                        time: document.getElementById('termin-time').value
                    };
                    
                    // Check if we're editing an existing termin
                    const editId = addTerminForm.dataset.editId;
                    if (editId) {
                        await TerminManager.updateTermin(editId, terminData);
                    } else {
                        await TerminManager.addTermin(terminData);
                    }
                    
                    TerminManager.hideAddTerminModal();
                });
            }
            
            // Close termin modal when clicking outside
            const addTerminModal = document.getElementById('add-termin-modal');
            if (addTerminModal) {
                addTerminModal.addEventListener('click', (e) => {
                    if (e.target === addTerminModal) {
                        TerminManager.hideAddTerminModal();
                    }
                });
            }
            
            // Load routine states on page load
            loadRoutineStates();
            
            // Update routine progress to reflect loaded states
            updateRoutineProgress();
            
            // Initialize settings functionality
            initializeSettings();
            
            // Initialize todo counter display
            initializeTodoCounter();
        });
    </script>
</body>
</html>