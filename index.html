<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DASHBOARD v2.3</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22 font-family=%22-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif%22 font-weight=%22700%22 fill=%22%23000000%22>A</text></svg>">
    <style>
        /* === RESET & BASE === */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #000000;
            line-height: 1.6;
            padding-top: 80px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* === STICKY NAVIGATION === */
        .sticky-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #ffffff;
            border-bottom: 1px solid #e0e0e0;
            z-index: 1000;
            padding: 1rem 0;
        }
        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 3rem;
            position: relative;
        }
        .nav-tab {
            text-decoration: none;
            color: #666666;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.5rem 1rem;
            border: 1px solid transparent;
            transition: all 0.2s ease;
            cursor: pointer;
            background: none;
            font-family: inherit;
        }
        .nav-tab:hover { border-color: #000000; color: #000000; }
        .nav-tab.active {
            color: #000000;
            font-weight: 700;
            border: 1px solid transparent;
            background: transparent;
        }
        
        /* === LOGOUT & SETTINGS BUTTONS === */
        .nav-actions {
            position: absolute;
            right: 0;
            display: flex;
            gap: 0.25rem;
            align-items: center;
        }
        
        .logout-btn, .settings-btn {
            color: #666666 !important;
            font-weight: 400 !important;
            background: transparent !important;
            border: none !important;
            border-color: transparent !important;
            outline: none !important;
            cursor: pointer !important;
            pointer-events: auto !important;
            position: relative !important;
            z-index: 1000 !important;
            box-shadow: none !important;
            text-transform: none !important;
            letter-spacing: normal !important;
            padding: 0.5rem 1rem !important;
        }
        
        /* Mobile-safe hover states - override nav-tab hover */
        .logout-btn:hover, .settings-btn:hover,
        .logout-btn:active, .settings-btn:active,
        .logout-btn:focus, .settings-btn:focus {
            background: transparent !important;
            border: none !important;
            border-color: transparent !important;
        }
        
        /* Specific override for nav-tab hover border */
        .nav-tab.logout-btn:hover, .nav-tab.settings-btn:hover {
            border: none !important;
            border-color: transparent !important;
            background: transparent !important;
        }
        
        .logout-btn:hover span, .logout-btn:active span, .logout-btn:focus span,
        .logout-btn:hover svg, .logout-btn:active svg, .logout-btn:focus svg {
            color: #dc2626 !important;
            stroke: #dc2626 !important;
        }
        
        .settings-btn:hover span, .settings-btn:active span, .settings-btn:focus span {
            color: #22c55e !important;
        }
        
        /* Force reset any stuck hover states on mobile */
        @media (max-width: 768px) {
            .logout-btn span {
                color: #666666 !important;
            }
            .logout-btn:hover span {
                color: #dc2626 !important;
            }
        }
        
        .logout-btn span, .settings-btn span {
            font-size: 1.2rem;
            pointer-events: none !important;
        }

        /* === SETTINGS PAGE === */
        .settings-container {
            max-width: 600px;
            margin: 0 auto;
        }
        
        .setting-group {
            background: #f8f9fa;
            padding: 2rem;
            margin-bottom: 2rem;
            border-radius: 12px;
            border: 1px solid #e0e0e0;
        }
        
        .setting-group h3 {
            margin: 0 0 1.5rem 0;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .setting-item:last-child {
            margin-bottom: 0;
        }
        
        .setting-item label {
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .setting-item input[type="time"] {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            max-width: 200px;
        }
        
        .setting-description {
            font-size: 0.85rem;
            color: #666666;
            margin-top: 0.25rem;
        }
        
        .btn-secondary {
            background: #6b7280 !important;
        }
        
        .btn-secondary:hover {
            background: #4b5563 !important;
        }

        /* === MAIN CONTENT === */
        .main-content { padding: 0 20px 40px 20px; }
        .tab-section { display: none; }
        .tab-section.active { display: block; }

        /* === SHARED COMPONENTS === */
        .section-title {
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 3rem;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 1rem;
        }
        .card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            transition: border-color 0.2s ease;
        }
        .card:hover { border-color: #000000; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 3rem; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2rem; }
        .btn {
            padding: 0.75rem 1.5rem;
            border: 1px solid #000000;
            background: #ffffff;
            color: #000000;
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-block;
        }
        .btn:hover { background: #000000; color: #ffffff; }
        .btn.secondary { border-color: #e0e0e0; color: #666666; }
        .btn.secondary:hover { border-color: #000000; background: #f0f0f0; color: #000000; }

        /* === CHECKBOX COMPONENT === */
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .checkbox-item.todo-item {
            justify-content: space-between;
            width: 100%;
        }
        .checkbox-item.todo-item .todo-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
            min-width: 0; /* Allow shrinking */
        }
        .checkbox-item.todo-item .todo-time {
            font-size: 0.85rem;
            color: #666;
            font-weight: 500;
            flex-shrink: 0;
            margin-left: 1rem;
            text-align: right;
        }
        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            border: 2px solid #000000;
            appearance: none;
            cursor: pointer;
            flex-shrink: 0;
        }
        .checkbox-item input[type="checkbox"]:checked {
            background-color: #000000;
            position: relative;
        }
        .checkbox-item input[type="checkbox"]:checked::after {
            content: '‚úì';
            color: white;
            position: absolute;
            top: -2px;
            left: 2px;
            font-size: 12px;
        }
        .checkbox-item label {
            font-size: 0.95rem;
            cursor: pointer;
            line-height: 1.4;
        }

        /* === PROGRESS BAR === */
        .progress-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .progress-bar {
            flex: 1;
            height: 8px;
            background-color: #f0f0f0;
            border: 1px solid #e0e0e0;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: #000000;
            transition: width 0.3s ease;
        }

        /* === STREAK TILES === */
        .streak-overview {
            margin-bottom: 3rem;
        }
        .streak-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
        }
        .streak-tile {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            text-align: center;
            transition: border-color 0.2s ease;
        }
        .streak-tile:hover {
            border-color: #000000;
        }
        .streak-number {
            font-size: 3rem;
            font-weight: 300;
            color: #000000;
            margin-bottom: 0.5rem;
            line-height: 1;
        }
        .streak-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }
        .streak-date {
            font-size: 0.8rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* === ROUTINE SPECIFIC === */
        .routine-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
            margin-bottom: 4rem;
            height: auto;
            min-height: 300px;
        }
        .routine-section {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            min-height: 250px;
        }
        .routine-section h2 {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .routine-section .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex: 1;
            margin-bottom: 1rem;
        }

        /* === TODO SPECIFIC === */
        .category-tabs {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 3rem;
        }
        .category-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .category-tab:hover { border-color: #000000; color: #000000; }
        .category-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .category-content { display: none; }
        .category-content.active { display: block; }
        
        /* === ZIELE SPECIFIC TABS === */
        .ziel-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .ziel-tab:hover { border-color: #000000; color: #000000; }
        .ziel-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .ziel-content { display: none; }
        
        /* === RESOURCE TABS === */
        .resource-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .resource-tab:hover { border-color: #000000; color: #000000; }
        .resource-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .resource-content { display: none; }
        .resource-content.active { display: block; }
        .ziel-content.active { display: block; }
        
        /* === JOURNAL SPECIFIC TABS === */
        .journal-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .journal-tab:hover { border-color: #000000; color: #000000; }
        .journal-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .journal-content { display: none; }
        .journal-content.active { display: block; }
        
        /* === TAG SELECTION === */
        .tag-option {
            padding: 0.5rem 1rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            color: #666666;
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .tag-option:hover { border-color: #000000; color: #000000; }
        .tag-option.selected {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .tag-option .remove-tag {
            cursor: pointer;
            font-size: 1rem;
            opacity: 0.8;
            display: none;
        }
        .tag-option.selected .remove-tag {
            display: inline;
        }
        .tag-option .remove-tag:hover {
            opacity: 1;
        }
        .todo-section {
            margin-bottom: 2rem;
        }
        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .section-header h3 {
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #444444;
        }
        .section-divider {
            flex: 1;
            height: 1px;
            background: #e0e0e0;
        }
        .section-count {
            font-size: 0.8rem;
            color: #666666;
            background: #f0f0f0;
            padding: 0.25rem 0.75rem;
            border: 1px solid #e0e0e0;
        }
        .todo-item {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: border-color 0.2s ease;
        }
        .todo-item:hover { border-color: #000000; }
        .todo-item.completed { opacity: 0.6; background: #fafafa; }
        .todo-item.completed .todo-title { text-decoration: line-through; }
        .todo-header {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }
        .todo-content { flex: 1; }
        .todo-title {
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }
        .todo-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .todo-deadline {
            font-size: 0.8rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .todo-deadline.today { color: #000000; font-weight: 500; }
        .todo-deadline.overdue { color: #cc0000; font-weight: 500; }
        .todo-deadline.soon { color: #ff6600; font-weight: 500; }
        
        /* Days until badge (similar to termine) */
        .days-until-badge {
            display: inline-block;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-left: 0.5rem;
        }
        .days-until-badge.heute {
            background: #000000;
            color: #ffffff;
        }
        .days-until-badge.morgen {
            background: #ff6600;
            color: #ffffff;
        }
        .days-until-badge.future {
            background: #3b82f6;
            color: #ffffff;
        }
        .days-until-badge.overdue {
            background: #cc0000;
            color: #ffffff;
        }
        
        .todo-tag {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.25rem 0.75rem;
            border: 1px solid;
            color: #ffffff;
            font-weight: 500;
        }
        .todo-tag.wichtig { background-color: #ff6600; border-color: #ff6600; }
        .todo-tag.dringend { background-color: #cc0000; border-color: #cc0000; }
        .todo-tag.normal { background-color: #666666; border-color: #666666; }

        /* === ZIELE SPECIFIC === */
        .ziel-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 200px;
        }
        .ziel-kategorie {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666666;
            border: 1px solid #e0e0e0;
            padding: 0.2rem 0.5rem;
            background: #fafafa;
            white-space: nowrap;
        }
        .ziel-header {
            margin-bottom: 1rem;
            margin-right: 6rem;
        }
        .ziel-name {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }
        .ziel-beschreibung {
            font-size: 0.9rem;
            color: #666666;
            line-height: 1.5;
            margin-bottom: 2rem;
        }
        .ziel-progress-section { margin-top: auto; }
        .ziel-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .ziel-progress-label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #444444;
        }
        .ziel-percentage {
            font-size: 1rem;
            font-weight: 500;
        }

        /* === JOURNAL SPECIFIC === */
        .quick-journal {
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            margin-bottom: 3rem;
        }
        .quick-journal h2 {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .journal-form {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        .journal-input {
            flex: 1;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .journal-input:focus { outline: none; border-color: #000000; }
        .journal-entry {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            margin-bottom: 2rem;
        }
        .journal-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1.5rem;
            gap: 1rem;
        }
        .journal-date {
            font-size: 1rem;
            font-weight: 500;
            color: #000000;
        }
        .journal-kategorie {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666666;
            border: 1px solid #e0e0e0;
            padding: 0.4rem 1rem;
            background: #fafafa;
        }
        .journal-content {
            font-size: 0.95rem;
            line-height: 1.7;
            color: #333333;
        }

        /* === TERMINE SPECIFIC === */
        .termin-card {
            position: relative;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 0;
            padding: 1.5rem;
            box-shadow: none;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .termin-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        }
        
        /* Base styling for days badges - dezent und rechteckig wie Kategorien */
        .termin-days-until, .ziel-days-until {
            position: absolute !important;
            top: 0.5rem !important;
            background: #fafafa !important;
            color: #666666 !important;
            padding: 0.2rem 0.5rem !important;
            border: 1px solid #e0e0e0 !important;
            font-size: 0.65rem !important;
            font-weight: 500 !important;
            text-transform: uppercase !important;
            letter-spacing: 0.1em !important;
            white-space: nowrap !important;
        }
        
        /* Termine: Rechtsb√ºndig */
        .termin-days-until {
            right: 0.5rem !important;
        }
        
        /* Ziele: Mittig */
        .ziel-days-until {
            left: 50% !important;
            transform: translateX(-50%) !important;
        }
        
        /* === RESSOURCEN GRID === */
        .resource-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 200px));
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: start;
        }
        
        .resource-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 0.75rem;
            position: relative;
            transition: all 0.2s ease;
            height: 50px;
            display: flex;
            align-items: center;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .resource-card:hover {
            border-color: #000000;
            background: #f8f8f8;
        }
        
        .resource-icon {
            font-size: 1rem;
            margin-right: 0.5rem;
            flex-shrink: 0;
        }
        
        .resource-title {
            font-size: 0.85rem;
            font-weight: 500;
            color: #000000;
            margin: 0;
            flex: 1;
            line-height: 1.2;
        }
        
        
        /* === EMOJI PALETTE === */
        .emoji-palette {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 0.25rem;
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            position: relative;
            z-index: 1;
        }
        
        .emoji-btn {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 0.25rem;
            cursor: pointer;
            font-size: 1rem;
            border-radius: 2px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 28px;
            width: 28px;
        }
        
        .emoji-btn:hover {
            background: #000000;
            border-color: #000000;
            transform: scale(1.1);
        }
        
        .btn-link {
            background: none;
            border: none;
            color: #666666;
            cursor: pointer;
            text-decoration: underline;
            font-family: inherit;
        }
        
        .btn-link:hover {
            color: #000000;
        }
        
        .resource-footer {
            margin-top: auto;
            padding-top: 1rem;
            border-top: 1px solid #f0f0f0;
        }
        
        .resource-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #000000;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            padding: 0.5rem 1rem;
            border: 1px solid #e0e0e0;
            transition: all 0.2s ease;
        }
        
        .resource-link:hover {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
        }
        
        .resource-actions {
            display: flex;
            gap: 0.25rem;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .resource-edit-btn,
        .resource-delete-btn {
            background: none;
            border: none;
            color: #666666;
            cursor: pointer;
            padding: 0.2rem;
            font-size: 0.7rem;
            transition: all 0.2s ease;
            border-radius: 2px;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .resource-card:hover .resource-edit-btn,
        .resource-card:hover .resource-delete-btn {
            opacity: 1;
        }
        
        .resource-delete-btn:hover {
            color: #cc0000;
        }
        
        .resource-edit-btn:hover {
            color: #000000;
        }
        
        /* === RESOURCE CATEGORIES (bsp1.jpg style) === */
        .resource-category-section {
            margin-bottom: 3rem;
        }
        
        .resource-category-title {
            font-size: 1.8rem;
            font-weight: 300;
            color: #000000;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .resource-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
        }
        
        .resource-button {
            background: #333333;
            border: 1px solid #555555;
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            text-decoration: none;
            min-width: 140px;
            justify-content: flex-start;
        }
        
        .resource-button:hover {
            background: #444444;
            border-color: #666666;
            transform: translateY(-1px);
        }
        
        .resource-icon {
            font-size: 1rem;
            margin-right: 0.25rem;
        }
        
        .resource-name {
            flex: 1;
            text-align: left;
        }
        
        .resource-button .resource-actions {
            position: absolute;
            top: -0.25rem;
            right: -0.25rem;
            display: flex;
            gap: 0.125rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .resource-button:hover .resource-actions {
            opacity: 1;
        }
        
        .resource-button .resource-edit-btn,
        .resource-button .resource-delete-btn {
            background: rgba(0, 0, 0, 0.8);
            border: none;
            color: #ffffff;
            padding: 0.25rem;
            font-size: 0.7rem;
            border-radius: 2px;
            cursor: pointer;
            opacity: 1;
        }
        
        .resource-button .resource-delete-btn:hover {
            background: #cc0000;
        }
        
        .resource-button .resource-edit-btn:hover {
            background: #007acc;
        }
        
        .termin-date {
            font-size: 0.8rem;
            color: #64748b;
            font-weight: 500;
            margin-bottom: 0.75rem;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .termin-date::before {
            content: 'üìÖ';
            font-size: 0.9rem;
        }
        
        .termin-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #1e293b;
            line-height: 1.3;
        }
        
        .termin-description {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #64748b;
            margin-bottom: 1rem;
        }
        
        .termin-edit-icon, .termin-delete-icon {
            position: absolute !important;
            bottom: 1rem !important;
            width: 32px !important;
            height: 32px !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 0.85rem !important;
            transition: all 0.2s ease !important;
            cursor: pointer !important;
        }
        
        .termin-edit-icon {
            right: 3.5rem !important;
            background: rgba(59, 130, 246, 0.1) !important;
            color: #3b82f6 !important;
            top: auto !important;
        }
        
        .termin-edit-icon:hover {
            background: #3b82f6 !important;
            color: white !important;
            transform: scale(1.1) !important;
        }
        
        .termin-delete-icon {
            right: 1rem !important;
            background: rgba(239, 68, 68, 0.1) !important;
            color: #ef4444 !important;
            top: auto !important;
        }
        
        .termin-delete-icon:hover {
            background: #ef4444 !important;
            color: white !important;
            transform: scale(1.1) !important;
        }

        /* === ADD TODO MODAL === */
        .add-todo-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            padding: 1rem;
        }
        .add-todo-modal.hide { display: none; }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            padding: 1rem;
        }
        .modal.hide { display: none; }
        .modal-content {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 500px;
            position: relative;
            z-index: 4001;
        }
        .modal-content .close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            cursor: pointer;
            font-size: 1.5rem;
            color: #666;
        }
        .modal-content .close:hover {
            color: #000;
        }
        .add-todo-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 500px;
        }
        .add-todo-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .add-todo-header h2 {
            font-size: 1.5rem;
            font-weight: 500;
            color: #000000;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .form-row .form-group {
            flex: 1;
        }
        .form-group select {
            width: 100%;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .form-group select:focus { outline: none; border-color: #000000; }
        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        /* === AUTH SCREEN === */
        .auth-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 1rem;
        }
        .auth-screen.hide { display: none; }
        .auth-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 400px;
        }
        .auth-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .auth-header h2 {
            font-size: 1.5rem;
            font-weight: 500;
            color: #000000;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-group {
            margin-bottom: 1.5rem;
        }
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #000000;
            font-weight: 500;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-group input {
            width: 100%;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .form-group input:focus { outline: none; border-color: #000000; }
        .auth-btn {
            width: 100%;
            padding: 1rem;
            border: 1px solid #000000;
            background: #ffffff;
            color: #000000;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .auth-btn:hover {
            background: #000000;
            color: #ffffff;
        }
        .auth-error {
            color: #cc0000;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            display: none;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .auth-error.show { display: block; }

        /* === RESPONSIVE === */
        @media (max-width: 768px) {
            .grid-2, .grid-3, .routine-grid, .streak-grid { grid-template-columns: 1fr; gap: 2rem; }
            .routine-grid { height: auto; }
            .routine-section { height: auto; min-height: 350px; }
            .main-content { padding: 0 15px 40px 15px; }
            .nav-container { flex-wrap: wrap; gap: 1rem; }
            .nav-tab { font-size: 0.8rem; padding: 0.4rem 0.8rem; }
            .ziel-kategorie { position: static; align-self: flex-start; margin-bottom: 1rem; }
            .ziel-header { margin-right: 0; }
            .journal-form { flex-direction: column; align-items: stretch; }
            .journal-entry-header { flex-direction: column; align-items: flex-start; }
            
            /* Resource mobile optimization */
            .resource-grid { 
                grid-template-columns: repeat(auto-fill, minmax(170px, 170px)); 
                gap: 0.4rem;
            }
            .resource-card { 
                height: 46px;
                padding: 0.6rem;
            }
            .resource-title { 
                font-size: 0.8rem; 
            }
            .resource-icon {
                font-size: 0.95rem;
                margin-right: 0.4rem;
            }
            .emoji-palette { 
                grid-template-columns: repeat(8, 1fr); 
                gap: 0.2rem;
                padding: 0.3rem;
            }
            .emoji-btn {
                min-height: 24px;
                width: 24px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <!-- === ADD TODO MODAL === -->
    <div id="add-todo-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Todo hinzuf√ºgen</h2>
            </div>
            
            <form id="add-todo-form" autocomplete="off">
                <div class="form-group">
                    <label for="todo-title">Aufgabe</label>
                    <input type="text" id="todo-title" placeholder="Was m√∂chtest du erledigen?" required autocomplete="off">
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="todo-category">Kategorie</label>
                        <select id="todo-category" required autocomplete="off">
                            <option value="">Kategorie w√§hlen</option>
                            <option value="alle">Alle</option>
                            <option value="privat">Privat</option>
                            <option value="uni">Uni</option>
                            <option value="arbeit">Arbeit</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="todo-priority">Priorit√§t</label>
                        <select id="todo-priority" required autocomplete="off">
                            <option value="mittel" selected>Normal</option>
                            <option value="wichtig">Wichtig</option>
                            <option value="dringend">Dringend</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="todo-deadline">Deadline</label>
                        <input type="date" id="todo-deadline" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="todo-time">Uhrzeit</label>
                        <input type="time" id="todo-time" value="21:00" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-todo-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Todo erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD GOAL MODAL === -->
    <div id="add-goal-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Ziel hinzuf√ºgen</h2>
            </div>
            
            <form id="add-goal-form" autocomplete="off">
                <div class="form-group">
                    <label for="goal-name">Ziel-Name</label>
                    <input type="text" id="goal-name" placeholder="Was m√∂chtest du erreichen?" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="goal-description">Beschreibung</label>
                    <textarea id="goal-description" placeholder="Detaillierte Beschreibung des Ziels..." rows="3" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-category">Kategorie</label>
                        <input type="text" id="goal-category" placeholder="z.B. Fitness, Karriere, Finanzen..." required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-timeframe">Zeitrahmen</label>
                        <select id="goal-timeframe" required autocomplete="off">
                            <option value="monat">Monat</option>
                            <option value="quartal">Quartal</option>
                            <option value="jahr">Jahr</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-deadline">Deadline</label>
                        <input type="date" id="goal-deadline" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-unit">Einheit</label>
                        <input type="text" id="goal-unit" placeholder="z.B. kg, ‚Ç¨, B√ºcher, Stunden..." autocomplete="off">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-start-value">Startwert</label>
                        <input type="number" id="goal-start-value" placeholder="z.B. 80" step="0.01" autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-target-value">Zielwert</label>
                        <input type="number" id="goal-target-value" placeholder="z.B. 70" step="0.01" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-goal-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Ziel erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD JOURNAL MODAL === -->
    <div id="add-journal-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Journal Eintrag hinzuf√ºgen</h2>
            </div>
            
            <form id="add-journal-form" autocomplete="off">
                <div class="form-group">
                    <label for="journal-title">Titel</label>
                    <input type="text" id="journal-title" placeholder="Titel f√ºr den Eintrag..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="journal-content">Inhalt</label>
                    <textarea id="journal-content" placeholder="Was besch√§ftigt dich heute...?" rows="6" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="journal-tags">Tags (mehrere m√∂glich)</label>
                        <div id="journal-tag-options" style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                            <button type="button" class="tag-option" data-tag="allgemein">
                                Allgemein
                                <span class="remove-tag">√ó</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="fitness">
                                Fitness
                                <span class="remove-tag">√ó</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="uni">
                                Uni
                                <span class="remove-tag">√ó</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="crypto">
                                Crypto
                                <span class="remove-tag">√ó</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="lesen">
                                Lesen
                                <span class="remove-tag">√ó</span>
                            </button>
                        </div>
                        <input type="hidden" id="journal-category" required>
                    </div>
                    <div class="form-group">
                        <label for="journal-date">Datum</label>
                        <input type="date" id="journal-date" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-journal-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Journal erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD TERMIN MODAL === -->
    <div id="add-termin-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Termin hinzuf√ºgen</h2>
            </div>
            
            <form id="add-termin-form" autocomplete="off">
                <div class="form-group">
                    <label for="termin-title">Titel</label>
                    <input type="text" id="termin-title" placeholder="z.B. Zahnarzt Termin..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="termin-description">Beschreibung</label>
                    <textarea id="termin-description" placeholder="Weitere Details zum Termin..." rows="3" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="termin-date">Datum</label>
                        <input type="date" id="termin-date" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="termin-time">Uhrzeit (optional)</label>
                        <input type="time" id="termin-time" autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-termin-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Termin erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === EDIT GOAL VALUE MODAL === -->
    <div id="edit-goal-value-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2 id="edit-goal-modal-title">Fortschritt aktualisieren</h2>
            </div>
            
            <div id="edit-goal-current-status" style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; font-size: 0.9rem; color: #666;">
                <!-- Current goal status will be inserted here -->
            </div>
            
            <form id="edit-goal-value-form" autocomplete="off">
                <div class="form-group">
                    <label for="new-goal-value">Neuer aktueller Wert</label>
                    <input type="number" id="new-goal-value" step="0.01" required autocomplete="off" style="font-size: 1.1rem; padding: 0.75rem;">
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-edit-goal-value-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Wert aktualisieren</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === AUTH SCREEN === -->
    <div id="auth-screen" class="auth-screen hide">
        <div class="auth-container">
            <div class="auth-header">
                <h2>DASHBOARD</h2>
            </div>
            
            <div class="form-group">
                <label for="login-email">Email</label>
                <input type="email" id="login-email" placeholder="your@email.com" required>
            </div>
            <div class="form-group">
                <label for="login-password">Password</label>
                <input type="password" id="login-password" placeholder="Your password" required>
            </div>
            <button id="login-btn" class="auth-btn">Login</button>
            <div id="login-error" class="auth-error"></div>
        </div>
    </div>

    <!-- === STICKY NAVIGATION === -->
    <nav class="sticky-nav">
        <div class="nav-container">
            <button class="nav-tab active" data-tab="tab-home">Home</button>
            <button class="nav-tab" data-tab="tab-todos">ToDos</button>
            <button class="nav-tab" data-tab="tab-ziele">Ziele</button>
            <button class="nav-tab" data-tab="tab-journal">Journal</button>
            <button class="nav-tab" data-tab="tab-ressourcen">Ressourcen</button>
            <button class="nav-tab" data-tab="tab-motivation">Motivation</button>
            <button class="nav-tab" data-tab="tab-settings" style="display: none;">Settings</button>
            <div class="nav-actions">
                <button id="settings-btn" class="nav-tab settings-btn">
                    <span>‚öô</span>
                </button>
                <button id="logout-btn" class="nav-tab logout-btn" style="display:flex;align-items:center;justify-content:center;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 2v10"></path>
                        <circle cx="12" cy="12" r="10"></circle>
                    </svg>
                </button>
            </div>
        </div>
    </nav>

    <div class="main-content">
        <!-- === HOME TAB === -->
        <section id="tab-home" class="tab-section active">
            <!-- Streak Kacheln -->
            <section class="streak-overview">
                <div class="streak-grid">
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Morgenroutine</div>
                        <div class="streak-date">August 2025</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Abendroutine</div>
                        <div class="streak-date">August 2025</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Todos Erledigt</div>
                        <div class="streak-date">August 2025</div>
                    </div>
                </div>
            </section>

            <!-- Routinen Section -->
            <div class="routine-grid">
                <div id="morning-routine" class="routine-section">
                    <h2>Morgenroutine</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="wasser-kreatin">
                            <label for="wasser-kreatin">Wasser und Kreatin</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="bbue-sport">
                            <label for="bbue-sport">BB√ú und Sport</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="tag-planen">
                            <label for="tag-planen">Tag planen</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="todos-checken">
                            <label for="todos-checken">Todos checken</label>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <div id="evening-routine" class="routine-section">
                    <h2>Abendroutine</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="journal-reflexion">
                            <label for="journal-reflexion">Tag reflektieren per Journal</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="lesen-lessons">
                            <label for="lesen-lessons">Lesen und Lessons nachhalten</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="trades-evaluieren">
                            <label for="trades-evaluieren">Trades evaluieren und Lessons nachhalten</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="naechsten-tag-planen">
                            <label for="naechsten-tag-planen">N√§chsten Tag planen</label>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Anstehende Termine -->
            <section style="margin-bottom: 3rem;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 2rem; margin-bottom: 1.5rem;">
                    <h2 style="font-size: 1.2rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.1em; margin: 0;">Anstehende Termine</h2>
                    <button id="add-termin-btn" class="btn" style="font-size: 0.7rem; padding: 0.5rem 1rem;">Add New</button>
                </div>
                <div class="grid-3" id="termine-container">
                    <!-- Termine will be loaded from TerminManager -->
                </div>
            </section>

            <!-- Heutige Aufgaben -->
            <section class="card">
                <h2 style="font-size: 1.2rem; font-weight: 500; margin-bottom: 1.5rem; text-transform: uppercase; letter-spacing: 0.1em;">Heutige Aufgaben</h2>
                <div class="checkbox-group" id="home-todos">
                    <!-- Todos will be loaded from database -->
                </div>
            </section>
        </section>

        <!-- === TODOS TAB === -->
        <section id="tab-todos" class="tab-section">
            
            <div class="category-tabs">
                <button class="category-tab active" data-category="alle">Alle</button>
                <button class="category-tab" data-category="heute">Heute</button>
                <button class="category-tab" data-category="privat">Privat</button>
                <button class="category-tab" data-category="uni">Uni</button>
                <button class="category-tab" data-category="arbeit">Arbeit</button>
                <button class="category-tab" data-category="archiv">Archiv</button>
                <button id="add-todo-btn" class="btn" style="margin-left: 2rem;">+ Add Todo</button>
                <button id="clear-archive-btn" class="btn secondary" style="margin-left: 1rem; display: none;">üóëÔ∏è Archiv leeren</button>
            </div>

            <!-- HEUTE KATEGORIE -->
            <div class="category-content" id="heute">
                <!-- Todos for today will be loaded from database -->
            </div>

            <!-- PRIVAT KATEGORIE -->
            <div class="category-content" id="privat">
                <!-- Private todos will be loaded from database -->
            </div>

            <!-- UNI KATEGORIE -->
            <div class="category-content" id="uni">
                <!-- Uni todos will be loaded from database -->
            </div>

            <!-- ARBEIT KATEGORIE -->
            <div class="category-content" id="arbeit">
                <!-- Work todos will be loaded from database -->
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="category-content active" id="alle">
                <!-- All todos will be loaded from database -->
            </div>

            <!-- ARCHIV KATEGORIE -->
            <div class="category-content" id="archiv">
                <!-- Completed/archived todos will be loaded from database -->
            </div>
        </section>

        <!-- === ZIELE TAB === -->
        <section id="tab-ziele" class="tab-section">
            
            <div class="category-tabs">
                <button class="ziel-tab active" data-ziel-category="alle">Alle</button>
                <button class="ziel-tab" data-ziel-category="monat">Monat</button>
                <button class="ziel-tab" data-ziel-category="quartal">Quartal</button>
                <button class="ziel-tab" data-ziel-category="jahr">Jahr</button>
                <button class="ziel-tab" data-ziel-category="archiv">Archiv</button>
                <button id="add-goal-btn" class="btn" style="margin-left: 2rem;">+ Add Goal</button>
                <button id="clear-goal-archive-btn" class="btn secondary" style="margin-left: 1rem; display: none;">üóëÔ∏è Archiv leeren</button>
            </div>

            <!-- MONAT KATEGORIE -->
            <div class="ziel-content" id="ziel-monat">
                <!-- Monatsziele will be loaded from database -->
            </div>

            <!-- QUARTAL KATEGORIE -->
            <div class="ziel-content" id="ziel-quartal">
                <!-- Quartalsziele will be loaded from database -->
            </div>

            <!-- JAHR KATEGORIE -->
            <div class="ziel-content" id="ziel-jahr">
                <!-- Jahresziele will be loaded from database -->
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="ziel-content active" id="ziel-alle">
                <!-- All ziele will be loaded from database -->
            </div>

            <!-- ARCHIV KATEGORIE -->
            <div class="ziel-content" id="ziel-archiv">
                <!-- Completed/archived ziele will be loaded from database -->
            </div>

        </section>

        <!-- === JOURNAL TAB === -->
        <section id="tab-journal" class="tab-section">
            
            <div class="category-tabs">
                <button class="journal-tab active" data-journal-category="alle">Alle</button>
                <button class="journal-tab" data-journal-category="allgemein">Allgemein</button>
                <button class="journal-tab" data-journal-category="fitness">Fitness</button>
                <button class="journal-tab" data-journal-category="uni">Uni</button>
                <button class="journal-tab" data-journal-category="crypto">Crypto</button>
                <button class="journal-tab" data-journal-category="lesen">Lesen</button>
                <button id="add-journal-btn" class="btn" style="margin-left: 2rem;">+ Add Journal</button>
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="journal-content active" id="journal-alle">
                <!-- All journal entries will be loaded from database -->
            </div>

            <!-- ALLGEMEIN KATEGORIE -->
            <div class="journal-content" id="journal-allgemein">
                <!-- Allgemein entries will be loaded from database -->
            </div>

            <!-- FITNESS KATEGORIE -->
            <div class="journal-content" id="journal-fitness">
                <!-- Fitness entries will be loaded from database -->
            </div>

            <!-- UNI KATEGORIE -->
            <div class="journal-content" id="journal-uni">
                <!-- Uni entries will be loaded from database -->
            </div>

            <!-- CRYPTO KATEGORIE -->
            <div class="journal-content" id="journal-crypto">
                <!-- Crypto entries will be loaded from database -->
            </div>

            <!-- LESEN KATEGORIE -->
            <div class="journal-content" id="journal-lesen">
                <!-- Lesen entries will be loaded from database -->
            </div>

        </section>

        <!-- === RESSOURCEN TAB === -->
        <section id="tab-ressourcen" class="tab-section">
            
            <div class="category-tabs">
                <button class="resource-tab active" data-resource-category="alle">Alle</button>
                <button class="resource-tab" data-resource-category="privat">Privat</button>
                <button class="resource-tab" data-resource-category="arbeit">Arbeit</button>
                <button class="resource-tab" data-resource-category="uni">Uni</button>
                <button class="resource-tab" data-resource-category="crypto">Crypto</button>
                <button id="add-resource-btn" class="btn" style="margin-left: 2rem;">+ Add Resource</button>
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="resource-content active" id="resource-alle">
                <!-- All resources will be loaded from database -->
            </div>

            <!-- PRIVAT KATEGORIE -->
            <div class="resource-content" id="resource-privat">
                <!-- Private resources will be loaded from database -->
            </div>

            <!-- ARBEIT KATEGORIE -->
            <div class="resource-content" id="resource-arbeit">
                <!-- Work resources will be loaded from database -->
            </div>

            <!-- UNI KATEGORIE -->
            <div class="resource-content" id="resource-uni">
                <!-- Uni resources will be loaded from database -->
            </div>

            <!-- CRYPTO KATEGORIE -->
            <div class="resource-content" id="resource-crypto">
                <!-- Crypto resources will be loaded from database -->
            </div>
            
        </section>

        <!-- === MOTIVATION TAB === -->
        <section id="tab-motivation" class="tab-section">
            <div class="section-header">
                <button id="add-motivation-btn" class="btn">+ Add Motivation</button>
            </div>
            
            <div class="motivation-grid" id="motivation-container">
                <!-- Motivation cards will be dynamically added here -->
            </div>
        </section>

        <!-- === ADD MOTIVATION MODAL === -->
        <div id="add-motivation-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Neue Motivation erstellen</h2>
                    <span class="close-btn" id="close-motivation-modal">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="motivation-title-input">Titel</label>
                        <input type="text" id="motivation-title-input" placeholder="z.B. Mein Traumhaus, Fitness-Ziel, etc.">
                    </div>
                    
                    <div class="form-group">
                        <label for="motivation-quote-input">Motivationsspruch (optional)</label>
                        <textarea id="motivation-quote-input" placeholder="z.B. 'Der Weg ist das Ziel' oder 'Tr√§ume werden wahr'"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="motivation-image-input">Bild</label>
                        <div class="file-upload-area" id="motivation-upload-area">
                            <div class="upload-placeholder">
                                <span class="upload-icon">üì∏</span>
                                <p>Klicken oder Bild hierher ziehen</p>
                                <p class="upload-hint">JPG, PNG, GIF oder WebP (max. 5MB)</p>
                            </div>
                            <img id="motivation-preview" style="display: none;">
                        </div>
                        <input type="file" id="motivation-image-input" accept="image/*" style="display: none;">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancel-motivation-btn">Abbrechen</button>
                    <button type="button" class="btn btn-primary" id="save-motivation-btn">Motivation erstellen</button>
                </div>
            </div>
        </div>

        <!-- === SETTINGS TAB === -->
        <section id="tab-settings" class="tab-section">
            <h1 class="section-title">Einstellungen</h1>
            
            <div class="settings-container">
                <div class="setting-group">
                    <h3>Routinen</h3>
                    <div class="setting-item">
                        <label for="routine-reset-time">Routine Reset Zeit:</label>
                        <input type="time" id="routine-reset-time" value="06:00">
                        <span class="setting-description">Zeit, zu der die Routinen t√§glich zur√ºckgesetzt werden</span>
                    </div>
                    <button id="save-routine-settings" class="btn">Speichern</button>
                </div>
                
                <div class="setting-group">
                    <h3>Routines Reset</h3>
                    <div class="setting-item">
                        <label>Routine-Datenbank komplett zur√ºcksetzen:</label>
                        <button id="reset-routines-btn" class="btn btn-danger" style="background: #cc0000; border-color: #cc0000; color: white;" onclick="handleRoutineReset()">Routines komplett zur√ºcksetzen</button>
                        <button onclick="debugRoutineSystem()" class="btn btn-secondary" style="margin-left: 1rem;">üîç Debug Routines</button>
                        <span class="setting-description">‚ö†Ô∏è L√∂scht ALLE Routine-Daten und Counter. Synchronisiert zwischen allen Ger√§ten.</span>
                    </div>
                </div>
                
                <div class="setting-group">
                    <h3>Daten</h3>
                    <div class="setting-item">
                        <button id="reset-routines-today" class="btn btn-secondary">Routinen heute zur√ºcksetzen</button>
                        <span class="setting-description">Setzt alle Routine-Checkboxes f√ºr heute zur√ºck</span>
                    </div>
                    <div class="setting-item">
                        <button id="reset-monthly-todos" class="btn btn-secondary">Todo-Z√§hler f√ºr aktuellen Monat zur√ºcksetzen</button>
                        <span class="setting-description">Setzt den monatlichen Todo-Counter auf 0 zur√ºck</span>
                    </div>
                </div>
            </div>
        </section>

    </div>

    <!-- Add Resource Modal -->
    <div id="add-resource-modal" class="modal hide">
        <div class="modal-content">
            <span class="close" onclick="ResourceManager.hideAddResourceModal()">&times;</span>
            <h2>Add Resource</h2>
            <form id="add-resource-form">
                <div class="form-group">
                    <label for="resource-title">Title *</label>
                    <input type="text" id="resource-title" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="resource-category">Category *</label>
                    <select id="resource-category" required autocomplete="off">
                        <option value="">Choose category...</option>
                        <option value="Privat">Privat</option>
                        <option value="Arbeit">Arbeit</option>
                        <option value="Uni">Uni</option>
                        <option value="Crypto">Crypto</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="resource-url">URL *</label>
                    <input type="url" id="resource-url" placeholder="https://example.com" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="resource-description">Description</label>
                    <textarea id="resource-description" rows="3" placeholder="Optional description..." autocomplete="off"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="resource-icon">Icon (optional)</label>
                    <input type="text" id="resource-icon" placeholder="Click emoji below or type manually" maxlength="4" readonly>
                    <div class="emoji-palette">
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üìß')">üìß</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üíº')">üíº</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üìö')">üìö</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üè†')">üè†</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üí¨')">üí¨</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üè¶')">üè¶</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üîß')">üîß</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üìä')">üìä</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üìù')">üìù</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üë•')">üë•</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üåê')">üåê</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üí∞')">üí∞</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üéØ')">üéØ</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('‚ö°')">‚ö°</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üîê')">üîê</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üîó')">üîó</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üöÄ')">üöÄ</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üé®')">üé®</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('üèÉ')">üèÉ</button>
                        <button type="button" class="emoji-btn" onclick="ResourceManager.selectEmoji('ü§ñ')">ü§ñ</button>
                    </div>
                    <small style="margin-top: 0.5rem; display: block;">Click an emoji above or make input editable to type manually</small>
                    <button type="button" class="btn-link" onclick="ResourceManager.toggleEmojiInput()" style="font-size: 0.8rem; margin-top: 0.25rem;">Enable manual typing</button>
                </div>
                
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="ResourceManager.hideAddResourceModal()">Cancel</button>
                    <button type="submit" class="btn">Add Resource</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Scripts -->
    <script src="supabase-config.js"></script>
    <script src="cloud-storage.js"></script>
    <script src="simple-routine-system.js"></script>
    <script>
        // Debug: Check if basic JavaScript works
        console.log('üîß JavaScript loading started...');
        
        window.addEventListener('error', function(e) {
            console.error('‚ùå JavaScript Error:', e.error);
            alert('JavaScript Error: ' + e.message + ' at line ' + e.lineno);
        });
        
        window.addEventListener('DOMContentLoaded', function() {
            console.log('‚úÖ DOM loaded');
        });
        // === AUTHENTICATION ===
        const Auth = {
            isAuthenticated: false,
            currentUser: null,
            
            async init() {
                window.Auth = this;
                
                if (!supabase) {
                    console.log('‚ö†Ô∏è Demo mode - no authentication');
                    await this.showDashboard();
                    return;
                }
                
                this.currentUser = supabase.getCurrentUser();
                if (supabase.isAuthenticated()) {
                    console.log('‚úÖ User authenticated:', this.currentUser.email);
                    this.isAuthenticated = true;
                    await this.showDashboard();
                } else {
                    this.showAuthScreen();
                }
                
                this.setupEventListeners();
            },
            
            setupEventListeners() {
                const loginBtn = document.getElementById('login-btn');
                const logoutBtn = document.getElementById('logout-btn');
                
                if (loginBtn) {
                    loginBtn.addEventListener('click', () => this.handleLogin());
                }
                
                if (logoutBtn) {
                    logoutBtn.addEventListener('click', () => this.handleLogout());
                }
            },
            
            async handleLogin() {
                const email = document.getElementById('login-email').value;
                const password = document.getElementById('login-password').value;
                const errorEl = document.getElementById('login-error');
                
                if (!email || !password) {
                    this.showError('Please enter email and password');
                    return;
                }
                
                try {
                    const { user, error } = await supabase.signIn(email, password);
                    
                    if (error) {
                        this.showError(error);
                        return;
                    }
                    
                    if (user) {
                        this.currentUser = user;
                        this.isAuthenticated = true;
                        await this.showDashboard();
                    }
                } catch (error) {
                    this.showError(error.message);
                }
            },
            
            async handleLogout() {
                console.log('üö™ Logout clicked');
                try {
                    if (supabase && typeof supabase.signOut === 'function') {
                        await supabase.signOut();
                    }
                    // Only clear auth-related data, preserve routine/todo data
                    localStorage.removeItem('supabase.auth.token');
                    sessionStorage.clear();
                    console.log('‚úÖ Logout successful, reloading...');
                    window.location.reload();
                } catch (error) {
                    console.error('‚ùå Logout error:', error);
                    localStorage.clear();
                    sessionStorage.clear();
                    window.location.reload();
                }
            },
            
            showError(message) {
                const errorEl = document.getElementById('login-error');
                if (errorEl) {
                    errorEl.textContent = message;
                    errorEl.classList.add('show');
                    setTimeout(() => errorEl.classList.remove('show'), 5000);
                }
            },
            
            showAuthScreen() {
                document.getElementById('auth-screen').classList.remove('hide');
            },
            
            async showDashboard() {
                document.getElementById('auth-screen').classList.add('hide');
                
                // Load all data after successful login
                if (supabase?.isAuthenticated()) {
                    await Promise.all([
                        TodoManager.loadTodos(),
                        GoalManager.loadGoals(),
                        JournalManager.loadEntries(),
                        TerminManager.loadTermine(),
                        loadRoutineCompletions()
                    ]);
                    
                    // Load ResourceManager separately after all other managers
                    if (window.ResourceManager && window.ResourceManager.loadResources) {
                        console.log('üîÑ Loading ResourceManager after login...');
                        await window.ResourceManager.loadResources();
                        console.log('‚úÖ ResourceManager loaded after login');
                        
                        // CRITICAL: Force todo counter update after ResourceManager loads
                        console.log('üö® CRITICAL: Forcing todo counter update after ResourceManager...');
                        if (window.initializeTodoCounter) {
                            // Reset running flag and force update
                            window.initializeTodoCounter.running = false;
                            await window.initializeTodoCounter();
                            console.log('‚úÖ CRITICAL: Todo counter updated after ResourceManager');
                        } else {
                            console.error('‚ùå initializeTodoCounter not available after ResourceManager');
                        }
                    }
                } else {
                    // Initialize displays for local storage mode
                    TodoManager.updateHomeTodos();
                    TerminManager.displayTermine();
                }
            }
        };

        // === TAB SYSTEM ===
        function switchTab(tabId) {
            document.querySelectorAll('.tab-section').forEach(section => {
                section.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
            
            // If switching to todos tab, load the active category
            if (tabId === 'tab-todos') {
                const activeTab = document.querySelector('.category-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-category') : 'heute';
                TodoManager.displayTodosForCategory(activeCategory);
            }
            
            // If switching to home tab, update home todos
            if (tabId === 'tab-home') {
                TodoManager.updateHomeTodos();
            }
            
            // If switching to motivation tab, ensure MotivationManager is initialized
            if (tabId === 'tab-motivation') {
                console.log('üéØ Switching to motivation tab, checking MotivationManager...');
                setTimeout(() => {
                    if (window.MotivationManager && !window.MotivationManager.initialized) {
                        console.log('üöÄ Initializing MotivationManager for first time');
                        window.MotivationManager.init();
                        window.MotivationManager.initialized = true;
                    } else if (!window.MotivationManager) {
                        console.error('‚ùå MotivationManager not found when switching to motivation tab');
                    } else {
                        console.log('‚úÖ MotivationManager already initialized');
                    }
                }, 100);
            }
            
            // If switching to ziele tab, load the active category
            if (tabId === 'tab-ziele') {
                const activeTab = document.querySelector('.ziel-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-ziel-category') : 'alle';
                GoalManager.displayGoalsForCategory(activeCategory);
            }
            
            // If switching to journal tab, load the active category
            if (tabId === 'tab-journal') {
                const activeTab = document.querySelector('.journal-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-journal-category') : 'alle';
                JournalManager.displayEntriesForCategory(activeCategory);
            }
        }

        // === ROUTINE PROGRESS ===
        // Load saved checkbox states from database and localStorage
        async function loadRoutineStates() {
            const today = new Date().toISOString().split('T')[0];
            let savedStates = {};
            
            // First load from localStorage (fallback)
            savedStates = JSON.parse(localStorage.getItem(`routineStates_${today}`) || '{}');
            
            // If authenticated, load from database and merge/override localStorage states
            if (supabase?.isAuthenticated()) {
                try {
                    const routineCompletions = getRoutineCompletions();
                    if (routineCompletions && routineCompletions.length > 0) {
                        console.log(`üîÑ Loading ${routineCompletions.length} routine completions from database for ${today}`);
                        
                        // Filter for today's completions
                        const todayCompletions = routineCompletions.filter(c => c.date === today);
                        console.log(`üìÖ Found ${todayCompletions.length} routine completions for today`);
                        
                        // Convert database completions to checkbox states
                        todayCompletions.forEach(completion => {
                            if (completion.checkbox_id) {
                                savedStates[completion.checkbox_id] = completion.completed;
                                console.log(`‚úÖ Restored from database: ${completion.checkbox_id} = ${completion.completed}`);
                            }
                        });
                        
                        // Update localStorage with merged states
                        localStorage.setItem(`routineStates_${today}`, JSON.stringify(savedStates));
                    }
                } catch (error) {
                    console.error('Error loading routine states from database:', error);
                    // Continue with localStorage-only states
                }
            }
            
            // Apply states to checkboxes
            Object.keys(savedStates).forEach(checkboxId => {
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.checked = savedStates[checkboxId];
                    // Apply visual styling
                    const label = checkbox.nextElementSibling;
                    if (label) {
                        if (checkbox.checked) {
                            label.style.textDecoration = 'line-through';
                            label.style.color = '#999';
                        } else {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    }
                }
            });
            
            console.log(`‚úÖ Loaded routine states for ${today}:`, savedStates);
        }
        
        // Save checkbox state to both localStorage and database
        async function saveCheckboxState(checkboxId, isChecked) {
            const today = new Date().toISOString().split('T')[0];
            
            // Save to localStorage (existing functionality)
            const savedStates = JSON.parse(localStorage.getItem(`routineStates_${today}`) || '{}');
            savedStates[checkboxId] = isChecked;
            localStorage.setItem(`routineStates_${today}`, JSON.stringify(savedStates));
            
            // Skip database save for routine checkboxes - handled by routine completion system
            const checkbox = document.getElementById(checkboxId);
            const routineSection = checkbox?.closest('.routine-section');
            
            if (routineSection) {
                console.log(`üìù Routine checkbox ${checkboxId} state saved to localStorage only - database sync handled by routine system`);
                return;
            }
            
            // Save non-routine checkboxes to database if authenticated
            if (supabase?.isAuthenticated()) {
                console.log(`üíæ Saving non-routine checkbox ${checkboxId} to database...`);
                // Only save non-routine checkboxes to database
                // Routine checkboxes are handled by the routine completion system
            }
        }

        function updateRoutineProgress() {
            const routineTab = document.getElementById('tab-home');
            if (!routineTab) return;
            
            const routineSections = routineTab.querySelectorAll('.routine-section');
            
            routineSections.forEach(section => {
                const checkboxes = section.querySelectorAll('input[type="checkbox"]');
                const checkedBoxes = section.querySelectorAll('input[type="checkbox"]:checked');
                
                if (checkboxes.length === 0) return;
                
                const percentage = Math.round((checkedBoxes.length / checkboxes.length) * 100);
                
                const progressFill = section.querySelector('.progress-fill');
                if (progressFill) {
                    progressFill.style.width = percentage + '%';
                }
                
                // Optional: Log progress for debugging
                console.log(`Routine progress: ${percentage}% (${checkedBoxes.length}/${checkboxes.length})`);
                
                // Update monthly streaks based on completion status
                const today = new Date().toISOString().split('T')[0];
                const routineType = section.querySelector('h2').textContent.includes('Morgen') ? 'morning' : 'evening';
                const localData = JSON.parse(localStorage.getItem('routineCompletionData') || '{}');
                if (!localData[today]) localData[today] = {};
                
                if (percentage === 100) {
                    console.log('üîç DEBUG: 100% reached, marking as complete');
                    localData[today][routineType] = true;
                } else {
                    console.log('üîç DEBUG: Less than 100%, marking as incomplete');
                    localData[today][routineType] = false;
                }
                
                localStorage.setItem('routineCompletionData', JSON.stringify(localData));
                console.log(`üîç DEBUG: Saved ${routineType} completion: ${localData[today][routineType]}`);
                
                // Also save to cloud if authenticated (async without blocking)
                if (supabase?.isAuthenticated()) {
                    (async () => {
                        try {
                            console.log(`‚òÅÔ∏è Saving routine completion to cloud: ${routineType} = ${localData[today][routineType]}`);
                            await cloudStorage.saveRoutineCompletion(`${routineType}_routine`, today, localData[today][routineType]);
                            
                            // Refresh cloud-based routine counter after saving
                            setTimeout(() => {
                                updateMonthlyStreakDisplaysFromMemory();
                            }, 100);
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Could not save routine completion to cloud:', error);
                        }
                    })();
                }
                
                // Update streak display directly
                console.log('üîç DEBUG: Updating streak display');
                console.log('üîç DEBUG: localData:', localData);
                
                // Calculate monthly count from both legacy localStorage and new cloud cache
                const currentDate = new Date();
                const currentYear = currentDate.getFullYear();
                const currentMonth = currentDate.getMonth() + 1; // getMonth() is 0-indexed
                const currentMonthPrefix = `${currentYear}-${currentMonth.toString().padStart(2, '0')}`;
                
                console.log(`üîç DEBUG: Current month prefix: ${currentMonthPrefix}`);
                
                // First try legacy format (mobile compatibility)
                const currentMonthDates = Object.keys(localData).filter(date => date.startsWith(currentMonthPrefix));
                let monthlyCount = currentMonthDates.filter(date => localData[date][routineType] === true).length;
                console.log(`üîç DEBUG: Legacy format count for ${routineType}: ${monthlyCount}`);
                
                // Also check cloud completions - first try cache, then direct Supabase query
                let cloudCompletions = [];
                try {
                    const cloudCompletionsCache = localStorage.getItem('routine_completions_cache');
                    console.log(`üîç DEBUG: Cloud completions cache raw:`, cloudCompletionsCache);
                    
                    if (cloudCompletionsCache) {
                        cloudCompletions = JSON.parse(cloudCompletionsCache);
                        console.log(`üîç DEBUG: Found cloud completions cache with ${cloudCompletions.length} entries`);
                        
                        // Filter for current month and routine type
                        const currentMonthCloudCompletions = cloudCompletions.filter(completion => {
                            if (!completion.date || !completion.template_id) return false;
                            const completionMonth = completion.date.substring(0, 7); // "2025-08-13" -> "2025-08"
                            const expectedPrefix = currentMonthPrefix.substring(0, 7); // "2025-08-13" -> "2025-08" 
                            return completionMonth === expectedPrefix && 
                                   completion.template_id.includes(routineType) && 
                                   completion.completed === true;
                        });
                        
                        console.log(`üîç DEBUG: Current month cloud completions for ${routineType}:`, currentMonthCloudCompletions.length);
                        
                        // Count days with completed routines (group by date)
                        const completionDates = new Set(currentMonthCloudCompletions.map(c => c.date));
                        const cloudMonthlyCount = completionDates.size;
                        console.log(`üîç DEBUG: Cloud format count for ${routineType}: ${cloudMonthlyCount}`);
                        
                        // Use the higher count (in case data exists in both formats)
                        monthlyCount = Math.max(monthlyCount, cloudMonthlyCount);
                    } else {
                        console.log(`üîç DEBUG: No cloud completions cache found, trying direct Supabase query...`);
                        
                        // Try direct Supabase query if authenticated and cache is empty
                        if (supabase?.isAuthenticated()) {
                            try {
                                // Query routine completions directly from Supabase
                                const currentMonthStart = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-01`;
                                const nextMonth = currentMonth === 12 ? 1 : currentMonth + 1;
                                const nextYear = currentMonth === 12 ? currentYear + 1 : currentYear;
                                const nextMonthStart = `${nextYear}-${nextMonth.toString().padStart(2, '0')}-01`;
                                
                                console.log(`üîç DEBUG: Querying Supabase for routine completions from ${currentMonthStart} to ${nextMonthStart}`);
                                
                                // Direct Supabase query not needed here - data should be loaded via loadRoutineCompletions()
                                console.log(`üîç DEBUG: Cache is empty - data should be loaded by loadRoutineCompletions() on login`);
                            } catch (error) {
                                console.warn(`‚ö†Ô∏è Error querying Supabase directly:`, error);
                            }
                        } else {
                            console.log(`üîç DEBUG: Not authenticated for direct Supabase query`);
                        }
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Error checking cloud completions:`, error);
                }
                console.log(`üîç DEBUG: monthlyCount for ${routineType}:`, monthlyCount);
                const streakTiles = document.querySelectorAll('.streak-tile');
                console.log(`üîç DEBUG: Found ${streakTiles.length} streak tiles`);
                const tileIndex = routineType === 'morning' ? 0 : 1;
                const targetTile = streakTiles[tileIndex];
                console.log(`üîç DEBUG: targetTile at index ${tileIndex}:`, targetTile);
                if (targetTile) {
                    const numberElement = targetTile.querySelector('.streak-number');
                    console.log(`üîç DEBUG: numberElement:`, numberElement);
                    if (numberElement) {
                        numberElement.textContent = monthlyCount;
                        console.log(`üîç DEBUG: Set ${routineType} counter to ${monthlyCount}`);
                    }
                }
            });
        }

        // === CATEGORY SYSTEM (for todos) ===
        function switchCategory(categoryId) {
            const parentTab = document.querySelector('#tab-todos');
            // Hide all category contents within todos
            parentTab.querySelectorAll('.category-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all category tabs
            parentTab.querySelectorAll('.category-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-category="${categoryId}"]`).classList.add('active');
            
            // Show/hide clear archive button
            const clearArchiveBtn = document.getElementById('clear-archive-btn');
            if (clearArchiveBtn) {
                if (categoryId === 'archiv') {
                    clearArchiveBtn.style.display = 'inline-block';
                } else {
                    clearArchiveBtn.style.display = 'none';
                }
            }
            
            // Load todos for this category
            TodoManager.displayTodosForCategory(categoryId);
        }

        // === ZIELE CATEGORY SYSTEM ===
        function switchZielCategory(categoryId) {
            const parentTab = document.querySelector('#tab-ziele');
            // Hide all ziel contents
            parentTab.querySelectorAll('.ziel-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all ziel tabs
            parentTab.querySelectorAll('.ziel-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#ziel-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-ziel-category="${categoryId}"]`).classList.add('active');
            
            // Show/hide clear goal archive button
            const clearGoalArchiveBtn = document.getElementById('clear-goal-archive-btn');
            if (clearGoalArchiveBtn) {
                if (categoryId === 'archiv') {
                    clearGoalArchiveBtn.style.display = 'inline-block';
                } else {
                    clearGoalArchiveBtn.style.display = 'none';
                }
            }
            
            // Load goals for this category
            GoalManager.displayGoalsForCategory(categoryId);
        }

        // === RESOURCE CATEGORY SYSTEM ===
        function switchResourceCategory(categoryId) {
            const parentTab = document.querySelector('#tab-ressourcen');
            // Hide all resource contents
            parentTab.querySelectorAll('.resource-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all resource tabs
            parentTab.querySelectorAll('.resource-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#resource-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-resource-category="${categoryId}"]`).classList.add('active');
            
            // Load resources for this category
            ResourceManager.displayResourcesForCategory(categoryId);
        }

        // === JOURNAL CATEGORY SYSTEM ===
        function switchJournalCategory(categoryId) {
            const parentTab = document.querySelector('#tab-journal');
            // Hide all journal contents
            parentTab.querySelectorAll('.journal-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all journal tabs
            parentTab.querySelectorAll('.journal-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#journal-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-journal-category="${categoryId}"]`).classList.add('active');
            
            // Load journal entries for this category
            JournalManager.displayEntriesForCategory(categoryId);
        }

        // === SETTINGS FUNCTIONALITY ===
        function initializeSettings() {
            // Load saved routine reset time
            const savedResetTime = localStorage.getItem('routineResetTime') || '06:00';
            const timeInput = document.getElementById('routine-reset-time');
            if (timeInput) {
                timeInput.value = savedResetTime;
            }
            
            // Save routine settings button
            const saveBtn = document.getElementById('save-routine-settings');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    const resetTime = timeInput.value;
                    localStorage.setItem('routineResetTime', resetTime);
                    alert(`Routine Reset Zeit auf ${resetTime} gesetzt!`);
                    console.log(`Routine reset time saved: ${resetTime}`);
                });
            }
            
            // Reset routines today button
            const resetBtn = document.getElementById('reset-routines-today');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    if (confirm('M√∂chtest du wirklich alle Routinen f√ºr heute zur√ºcksetzen?')) {
                        resetRoutinesToday();
                    }
                });
            }
            
            // Reset monthly todos button
            const resetTodosBtn = document.getElementById('reset-monthly-todos');
            if (resetTodosBtn) {
                resetTodosBtn.addEventListener('click', () => {
                    const now = new Date();
                    const monthName = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
                                     'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
                    if (confirm(`M√∂chtest du wirklich den Todo-Z√§hler f√ºr ${monthName} ${now.getFullYear()} zur√ºcksetzen?`)) {
                        resetMonthlyTodos();
                    }
                });
            }
        }
        
        function resetRoutinesToday() {
            const today = new Date().toISOString().split('T')[0];
            
            // Clear routine states for today
            localStorage.removeItem(`routineStates_${today}`);
            
            // Clear routine completion data for today
            const completionData = JSON.parse(localStorage.getItem('routineCompletionData') || '{}');
            if (completionData[today]) {
                delete completionData[today];
                localStorage.setItem('routineCompletionData', JSON.stringify(completionData));
            }
            
            // Uncheck all routine checkboxes
            document.querySelectorAll('.routine-section input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
                const label = checkbox.nextElementSibling;
                if (label) {
                    label.style.textDecoration = 'none';
                    label.style.color = 'inherit';
                }
            });
            
            // Update progress and streak displays
            updateRoutineProgress();
            if (window.updateMonthlyStreakDisplays) {
                updateMonthlyStreakDisplays();
            }
            
            alert('Routinen f√ºr heute wurden zur√ºckgesetzt!');
            console.log('Routines reset for today');
        }
        
        function resetMonthlyTodos() {
            const now = new Date();
            const monthKey = `${now.getFullYear()}-${now.getMonth()}`;
            
            // Reset monthly todo completions
            const monthlyData = JSON.parse(localStorage.getItem('monthlyTodoCompletions') || '{}');
            monthlyData[monthKey] = 0;
            localStorage.setItem('monthlyTodoCompletions', JSON.stringify(monthlyData));
            
            // Update streak displays
            if (window.updateMonthlyStreakDisplays) {
                updateMonthlyStreakDisplays();
            }
            
            const monthName = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
                             'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
            alert(`Todo-Z√§hler f√ºr ${monthName} ${now.getFullYear()} wurde auf 0 zur√ºckgesetzt!`);
            console.log(`Monthly todos reset for ${monthKey}`);
        }
        
        // === CLOUD-BASED TODO COUNTER ===
        async function initializeTodoCounter() {
            try {
                // Prevent multiple concurrent calls
                if (initializeTodoCounter.running) {
                    console.log('‚ö†Ô∏è Todo counter initialization already in progress, skipping...');
                    return;
                }
                initializeTodoCounter.running = true;
                
                console.log('‚òÅÔ∏è Initializing todo counter from cloud data...');
                
                if (!supabase?.isAuthenticated()) {
                    console.log('‚ö†Ô∏è Not authenticated, using local fallback for todo counter');
                    initializeTodoCounterLocal();
                    return;
                }
                
                const now = new Date();
                const currentMonth = now.getMonth() + 1; // 1-12
                const currentYear = now.getFullYear();
                const monthName = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
                                 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
                
                // Query completed todos for current month from cloud
                const startOfMonth = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-01`;
                const endOfMonth = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-31`;
                
                const completedTodos = await supabase.query(`todos?completed=eq.true&created_at=gte.${startOfMonth}&created_at=lt.${endOfMonth}&select=*`);
                const todoCount = completedTodos ? completedTodos.length : 0;
                
                console.log(`‚òÅÔ∏è Found ${todoCount} completed todos in ${monthName} ${currentYear} from cloud`);
                
                // Update the third streak tile (todos)
                const streakTiles = document.querySelectorAll('.streak-tile');
                const todoTile = streakTiles[2]; // Third tile is todos
                if (todoTile) {
                    const numberElement = todoTile.querySelector('.streak-number');
                    const dateElement = todoTile.querySelector('.streak-date');
                    if (numberElement && dateElement) {
                        numberElement.textContent = todoCount;
                        dateElement.textContent = `${monthName} ${currentYear}`;
                        console.log(`‚òÅÔ∏è Todo counter set to ${todoCount} from cloud data`);
                        
                        // Additional verification
                        setTimeout(() => {
                            const verifyElement = document.querySelectorAll('.streak-tile')[2]?.querySelector('.streak-number');
                            if (verifyElement && verifyElement.textContent !== todoCount.toString()) {
                                console.warn(`‚ö†Ô∏è Todo counter was overwritten! Setting back to ${todoCount}`);
                                verifyElement.textContent = todoCount;
                            } else {
                                console.log(`‚úÖ Todo counter verified: ${verifyElement?.textContent}`);
                            }
                        }, 1000);
                    }
                } else {
                    console.error('Todo tile not found');
                }
            } catch (error) {
                console.error('‚ùå Error loading cloud todo counter, falling back to local:', error);
                initializeTodoCounterLocal();
            } finally {
                initializeTodoCounter.running = false;
            }
        }
        
        // === LOCAL FALLBACK FOR TODO COUNTER ===
        function initializeTodoCounterLocal() {
            try {
                const now = new Date();
                const currentMonth = now.getMonth() + 1;
                const currentYear = now.getFullYear();
                const monthName = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
                                 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
                
                // Try to count from cached todos first
                let todoCount = 0;
                try {
                    const cachedTodos = localStorage.getItem('todos_cache');
                    if (cachedTodos) {
                        const todos = JSON.parse(cachedTodos);
                        console.log(`üì± Found ${todos.length} todos in cache`);
                        
                        // Count completed todos from current month
                        todoCount = todos.filter(todo => {
                            if (!todo.completed) return false;
                            
                            const completedDate = new Date(todo.completed_at || todo.created_at);
                            return completedDate.getMonth() + 1 === currentMonth && 
                                   completedDate.getFullYear() === currentYear;
                        }).length;
                        
                        console.log(`üì± Counted ${todoCount} completed todos from current month`);
                    } else {
                        console.log(`üì± No todos cache found`);
                    }
                } catch (e) {
                    console.warn('üì± Error counting from todos cache:', e);
                    
                    // Fallback to old method
                    const monthKey = `${currentYear}-${now.getMonth()}`;
                    const monthlyData = JSON.parse(localStorage.getItem('monthlyTodoCompletions') || '{}');
                    todoCount = monthlyData[monthKey] || 0;
                    console.log(`üì± Fallback to monthly counter: ${todoCount}`);
                }
                
                console.log(`üì± Local fallback: Todo counter for ${monthName} ${currentYear}: ${todoCount}`);
                
                // Update the third streak tile (todos)
                const streakTiles = document.querySelectorAll('.streak-tile');
                const todoTile = streakTiles[2]; // Third tile is todos
                if (todoTile) {
                    const numberElement = todoTile.querySelector('.streak-number');
                    const dateElement = todoTile.querySelector('.streak-date');
                    if (numberElement && dateElement) {
                        numberElement.textContent = todoCount;
                        dateElement.textContent = `${monthName} ${currentYear}`;
                        console.log(`üì± Local todo counter set to ${todoCount}`);
                    }
                } else {
                    console.error('üì± Todo tile not found');
                }
            } catch (error) {
                console.error('Error in local todo counter fallback:', error);
            }
        }
        
        // === MOBILE-FIRST ROUTINE COMPLETIONS ===
        let globalRoutineCompletions = []; // Always keep in memory for mobile
        
        async function loadRoutineCompletions() {
            try {
                console.log('üîÑ Loading routine completions (Cloud-First with Migration)...');
                
                // STEP 1: If not authenticated, use local data only
                if (!supabase?.isAuthenticated()) {
                    console.log('‚ö†Ô∏è Not authenticated, using local data only');
                    try {
                        const localData = localStorage.getItem('routine_completions_cache');
                        if (localData) {
                            globalRoutineCompletions = JSON.parse(localData);
                            updateMonthlyStreakDisplaysFromMemory();
                        }
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Could not read local data:', e);
                        globalRoutineCompletions = [];
                    }
                    return;
                }
                
                // STEP 2: Load cloud data
                const cloudCompletions = await supabase.query('routine_completions?select=*');
                console.log(`‚òÅÔ∏è Loaded ${cloudCompletions?.length || 0} routine completions from cloud`);
                
                // STEP 3: Cloud-first with improved migration
                if (cloudCompletions && cloudCompletions.length > 0) {
                    // Use cloud data if available
                    globalRoutineCompletions = cloudCompletions;
                    console.log(`‚òÅÔ∏è Using ${cloudCompletions.length} completions from cloud`);
                } else {
                    // Cloud is empty - try migration with new improved approach
                    console.log('üîç Cloud is empty, attempting migration with new schema...');
                    const migrationSuccess = await migrateLocalDataToCloudV2();
                    
                    if (migrationSuccess) {
                        // Reload after successful migration
                        const newCloudCompletions = await supabase.query('routine_completions?select=*');
                        console.log(`üîÑ After migration: ${newCloudCompletions?.length || 0} completions in cloud`);
                        globalRoutineCompletions = newCloudCompletions || [];
                    } else {
                        // Migration failed - use local data as fallback
                        console.log('‚ö†Ô∏è Migration failed, using local data as fallback');
                        globalRoutineCompletions = [];
                        
                        // Load from all local sources
                        const localSources = ['routine_completions_cache', 'routineCompletionData'];
                        for (const source of localSources) {
                            try {
                                const localData = localStorage.getItem(source);
                                if (localData) {
                                    const parsed = JSON.parse(localData);
                                    
                                    if (source === 'routineCompletionData') {
                                        // Convert old format
                                        Object.keys(parsed).forEach(date => {
                                            const dayData = parsed[date];
                                            if (dayData.morning !== undefined) {
                                                globalRoutineCompletions.push({
                                                    template_id: 'morning_routine',
                                                    date: date,
                                                    completed: dayData.morning
                                                });
                                            }
                                            if (dayData.evening !== undefined) {
                                                globalRoutineCompletions.push({
                                                    template_id: 'evening_routine',
                                                    date: date,
                                                    completed: dayData.evening
                                                });
                                            }
                                        });
                                    } else if (Array.isArray(parsed)) {
                                        globalRoutineCompletions.push(...parsed);
                                    }
                                }
                            } catch (e) {
                                console.warn(`‚ö†Ô∏è Could not load fallback from ${source}:`, e);
                            }
                        }
                        console.log(`üì± Using ${globalRoutineCompletions.length} local completions as fallback`);
                    }
                }
                
                // STEP 4: Cache locally for offline access
                try {
                    localStorage.setItem('routine_completions_cache', JSON.stringify(globalRoutineCompletions));
                    console.log('üíæ Cached cloud data locally');
                } catch (storageError) {
                    console.warn('‚ö†Ô∏è localStorage save failed:', storageError);
                }
                
                // STEP 5: Update displays
                updateMonthlyStreakDisplaysFromMemory();
                
            } catch (error) {
                console.error('‚ùå Error loading routine completions:', error);
                // Fallback to local data on error
                try {
                    const localData = localStorage.getItem('routine_completions_cache');
                    if (localData) {
                        globalRoutineCompletions = JSON.parse(localData);
                        console.log('üîÑ Fallback to local data due to error');
                    } else {
                        globalRoutineCompletions = [];
                    }
                } catch (e) {
                    globalRoutineCompletions = [];
                }
            }
        }
        
        // === IMPROVED MIGRATION FUNCTION V2 ===
        async function migrateLocalDataToCloudV2() {
            try {
                console.log('üöÄ Starting IMPROVED migration (V2) of local routine data to cloud...');
                
                // Get current user
                const currentUser = supabase.getCurrentUser();
                if (!currentUser || !currentUser.id) {
                    console.error('‚ùå No authenticated user found for migration');
                    return false;
                }
                
                console.log(`üë§ Migrating data for user: ${currentUser.email}`);
                
                // Collect all local data
                const localCompletions = [];
                
                // Source 1: routineCompletionData (legacy format)
                try {
                    const legacyData = localStorage.getItem('routineCompletionData');
                    if (legacyData) {
                        const parsed = JSON.parse(legacyData);
                        console.log(`üìÅ Found legacy data for ${Object.keys(parsed).length} dates`);
                        
                        Object.keys(parsed).forEach(date => {
                            const dayData = parsed[date];
                            if (dayData.morning !== undefined) {
                                localCompletions.push({
                                    template_id: 'morning_routine',
                                    date: date,
                                    completed: Boolean(dayData.morning),
                                    user_id: currentUser.id
                                });
                            }
                            if (dayData.evening !== undefined) {
                                localCompletions.push({
                                    template_id: 'evening_routine',
                                    date: date,
                                    completed: Boolean(dayData.evening),
                                    user_id: currentUser.id
                                });
                            }
                        });
                    }
                } catch (e) {
                    console.warn('‚ö†Ô∏è Could not parse legacy routine data:', e);
                }
                
                console.log(`üìä Prepared ${localCompletions.length} completions for migration`);
                
                if (localCompletions.length === 0) {
                    console.log('üì≠ No local data found to migrate');
                    return true;
                }
                
                // Remove duplicates based on user_id + template_id + date
                const uniqueCompletions = [];
                const seen = new Set();
                
                localCompletions.forEach(completion => {
                    const key = `${completion.user_id}_${completion.template_id}_${completion.date}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueCompletions.push(completion);
                    }
                });
                
                console.log(`üîç After deduplication: ${uniqueCompletions.length} unique completions`);
                
                // Upload to cloud
                let uploadedCount = 0;
                
                for (const completion of uniqueCompletions) {
                    try {
                        console.log(`‚¨ÜÔ∏è Uploading: ${completion.template_id} for ${completion.date} (${completion.completed})`);
                        
                        const result = await supabase.insert('routine_completions', [completion]);
                        if (result && result.length > 0) {
                            uploadedCount++;
                            console.log(`‚úÖ Uploaded successfully`);
                        } else {
                            console.warn(`‚ö†Ô∏è Upload returned no result`);
                        }
                    } catch (uploadError) {
                        console.error(`‚ùå Failed to upload completion:`, uploadError);
                        
                        // Check if it's a duplicate key error (which is OK)
                        if (uploadError.message && uploadError.message.includes('unique constraint')) {
                            console.log(`‚ÑπÔ∏è Duplicate entry (already exists) - skipping`);
                            uploadedCount++; // Count as success since data exists
                        } else {
                            console.error(`‚ùå Real upload error:`, uploadError.message);
                        }
                    }
                }
                
                console.log(`üéâ Migration V2 complete! Successfully processed ${uploadedCount}/${uniqueCompletions.length} completions`);
                return uploadedCount > 0;
                
            } catch (error) {
                console.error('‚ùå Migration V2 failed:', error);
                return false;
            }
        }
        
        // === OLD MIGRATION FUNCTION (DEPRECATED) ===
        async function migrateLocalDataToCloud() {
            try {
                console.log('üöÄ Starting migration of local routine data to cloud...');
                
                // Get all local routine data sources
                const sources = [
                    'routine_completions_cache',
                    'routineCompletionData',
                    'monthlyRoutineCompletions'
                ];
                
                let allLocalCompletions = [];
                
                for (const source of sources) {
                    try {
                        const data = localStorage.getItem(source);
                        if (data) {
                            let parsed = JSON.parse(data);
                            console.log(`üìÅ Found data in ${source}:`, parsed);
                            
                            if (source === 'routineCompletionData') {
                                // Convert old format to new format
                                Object.keys(parsed).forEach(date => {
                                    const dayData = parsed[date];
                                    if (dayData.morning !== undefined) {
                                        allLocalCompletions.push({
                                            template_id: 'morning_routine',
                                            date: date,
                                            completed: dayData.morning,
                                            user_id: supabase.getCurrentUser()?.id
                                            // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                        });
                                    }
                                    if (dayData.evening !== undefined) {
                                        allLocalCompletions.push({
                                            template_id: 'evening_routine', 
                                            date: date,
                                            completed: dayData.evening,
                                            user_id: supabase.getCurrentUser()?.id
                                            // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                        });
                                    }
                                });
                            } else if (Array.isArray(parsed)) {
                                // Add user_id to existing completions and remove any existing id
                                parsed.forEach(completion => {
                                    const cleanCompletion = {
                                        template_id: completion.template_id,
                                        date: completion.date,
                                        completed: completion.completed,
                                        user_id: supabase.getCurrentUser()?.id
                                        // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                    };
                                    allLocalCompletions.push(cleanCompletion);
                                });
                            }
                        }
                    } catch (e) {
                        console.warn(`‚ö†Ô∏è Could not parse ${source}:`, e);
                    }
                }
                
                console.log(`üìä Found ${allLocalCompletions.length} local completions to migrate`);
                
                if (allLocalCompletions.length === 0) {
                    console.log('üì≠ No local data found to migrate');
                    return true; // No data to migrate is considered success
                }
                
                // Clean all completions: remove any existing IDs and ensure clean data
                const cleanedCompletions = allLocalCompletions.map(completion => ({
                    template_id: completion.template_id,
                    date: completion.date,
                    completed: completion.completed,
                    user_id: completion.user_id || supabase.getCurrentUser()?.id
                    // Explicitly exclude: id, created_at, updated_at - these will be auto-generated
                }));
                
                console.log(`üßπ Cleaned data, removing ${allLocalCompletions.length - cleanedCompletions.length} invalid entries`);
                
                // Upload to cloud in batches
                const batchSize = 50;
                let uploaded = 0;
                let hasErrors = false;
                
                for (let i = 0; i < cleanedCompletions.length; i += batchSize) {
                    const batch = cleanedCompletions.slice(i, i + batchSize);
                    try {
                        const result = await supabase.insert('routine_completions', batch);
                        if (result) {
                            uploaded += batch.length;
                            console.log(`‚úÖ Uploaded batch: ${uploaded}/${cleanedCompletions.length}`);
                        } else {
                            console.error('‚ùå Batch upload returned no result');
                            hasErrors = true;
                        }
                    } catch (batchError) {
                        console.error('‚ùå Batch upload failed:', batchError);
                        hasErrors = true;
                        
                        // Check if it's an RLS error
                        if (batchError.message && batchError.message.includes('row-level security')) {
                            console.error('üîí RLS Error: Please run the fix-routine-completions-rls.sql file in Supabase');
                            return false; // Stop migration on RLS error
                        }
                    }
                }
                
                if (hasErrors && uploaded === 0) {
                    console.log('‚ùå Migration failed completely');
                    return false;
                } else if (hasErrors) {
                    console.log(`‚ö†Ô∏è Migration partially successful: ${uploaded}/${cleanedCompletions.length} uploaded`);
                    return uploaded > 0; // Partial success
                } else {
                    console.log(`üéâ Migration complete! Uploaded ${uploaded} routine completions to cloud`);
                    return true;
                }
                
            } catch (error) {
                console.error('‚ùå Migration failed:', error);
                return false;
            }
        }
        
        // Mobile-safe function that uses memory first, localStorage as fallback
        function getRoutineCompletions() {
            if (globalRoutineCompletions && globalRoutineCompletions.length > 0) {
                console.log('üì± Using routine completions from memory (Mobile-safe)');
                return globalRoutineCompletions;
            }
            
            // Fallback to localStorage if available
            try {
                const cached = localStorage.getItem('routine_completions_cache');
                if (cached) {
                    const parsed = JSON.parse(cached);
                    console.log('üíæ Using routine completions from localStorage fallback');
                    return parsed;
                }
            } catch (e) {
                console.warn('‚ö†Ô∏è localStorage read failed, using empty array');
            }
            
            return [];
        }
        
        // === CLOUD-BASED ROUTINE STREAK UPDATER ===
        async function updateMonthlyStreakDisplaysFromMemory() {
            try {
                console.log('‚òÅÔ∏è Updating routine streak displays from cloud data...');
                
                if (!supabase?.isAuthenticated()) {
                    console.log('‚ö†Ô∏è Not authenticated, using local routine data');
                    updateRoutineStreakLocal();
                    return;
                }
                
                const currentDate = new Date();
                const currentYear = currentDate.getFullYear();
                const currentMonth = currentDate.getMonth() + 1; // 1-12
                const monthName = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
                                 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][currentDate.getMonth()];
                
                // Query routine completions for current month from cloud
                const startOfMonth = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-01`;
                const endOfMonth = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-31`;
                
                const routineCompletions = await supabase.query(`routine_completions?date=gte.${startOfMonth}&date=lte.${endOfMonth}&completed=eq.true&select=*`);
                
                console.log(`‚òÅÔ∏è Found ${routineCompletions?.length || 0} completed routines in ${monthName} ${currentYear} from cloud`);
                
                // Count morning and evening completions
                let morningCount = 0;
                let eveningCount = 0;
                
                if (routineCompletions) {
                    const morningDates = new Set();
                    const eveningDates = new Set();
                    
                    routineCompletions.forEach(completion => {
                        if (completion.template_id.includes('morning')) {
                            morningDates.add(completion.date);
                        } else if (completion.template_id.includes('evening')) {
                            eveningDates.add(completion.date);
                        }
                    });
                    
                    morningCount = morningDates.size;
                    eveningCount = eveningDates.size;
                }
                
                console.log(`‚òÅÔ∏è Cloud routine counts: Morning=${morningCount}, Evening=${eveningCount}`);
                
                // Update streak tiles
                const streakTiles = document.querySelectorAll('.streak-tile');
                if (streakTiles.length >= 2) {
                    // Morning (tile 0)
                    const morningTile = streakTiles[0];
                    const morningNumber = morningTile?.querySelector('.streak-number');
                    const morningDate = morningTile?.querySelector('.streak-date');
                    if (morningNumber && morningDate) {
                        morningNumber.textContent = morningCount;
                        morningDate.textContent = `${monthName} ${currentYear}`;
                        console.log(`‚òÅÔ∏è Updated morning counter to ${morningCount} from cloud`);
                    }
                    
                    // Evening (tile 1)  
                    const eveningTile = streakTiles[1];
                    const eveningNumber = eveningTile?.querySelector('.streak-number');
                    const eveningDate = eveningTile?.querySelector('.streak-date');
                    if (eveningNumber && eveningDate) {
                        eveningNumber.textContent = eveningCount;
                        eveningDate.textContent = `${monthName} ${currentYear}`;
                        console.log(`‚òÅÔ∏è Updated evening counter to ${eveningCount} from cloud`);
                    }
                } else {
                    console.warn('‚ö†Ô∏è Streak tiles not found');
                }
                
            } catch (error) {
                console.error('‚ùå Error updating cloud routine streaks, falling back to local:', error);
                updateRoutineStreakLocal();
            }
        }
        
        // === LOCAL FALLBACK FOR ROUTINE STREAKS ===
        function updateRoutineStreakLocal() {
            try {
                console.log('üì± Updating routine streaks from local data...');
                const routineCompletions = getRoutineCompletions();
                const currentDate = new Date();
                const currentMonthPrefix = `${currentDate.getFullYear()}-${(currentDate.getMonth() + 1).toString().padStart(2, '0')}`;
                
                console.log(`üì± Checking ${routineCompletions.length} local routine completions for ${currentMonthPrefix}`);
                
                // Count morning routine completions this month
                const morningCompletions = routineCompletions.filter(c => 
                    c.date && c.date.startsWith(currentMonthPrefix) && 
                    c.template_id && c.template_id.includes('morning') && 
                    c.completed === true
                );
                const morningDates = new Set(morningCompletions.map(c => c.date));
                const morningCount = morningDates.size;
                
                // Count evening routine completions this month  
                const eveningCompletions = routineCompletions.filter(c =>
                    c.date && c.date.startsWith(currentMonthPrefix) && 
                    c.template_id && c.template_id.includes('evening') && 
                    c.completed === true
                );
                const eveningDates = new Set(eveningCompletions.map(c => c.date));
                const eveningCount = eveningDates.size;
                
                console.log(`üì± Local routine counts: Morning=${morningCount}, Evening=${eveningCount}`);
                
                // Update streak tiles
                const streakTiles = document.querySelectorAll('.streak-tile');
                if (streakTiles.length >= 2) {
                    // Morning (tile 0)
                    const morningTile = streakTiles[0];
                    const morningNumber = morningTile?.querySelector('.streak-number');
                    if (morningNumber) {
                        morningNumber.textContent = morningCount;
                        console.log(`üì± Updated morning counter to ${morningCount} from local`);
                    }
                    
                    // Evening (tile 1)  
                    const eveningTile = streakTiles[1];
                    const eveningNumber = eveningTile?.querySelector('.streak-number');
                    if (eveningNumber) {
                        eveningNumber.textContent = eveningCount;
                        console.log(`üì± Updated evening counter to ${eveningCount} from local`);
                    }
                } else {
                    console.warn('‚ö†Ô∏è Streak tiles not found');
                }
                
            } catch (error) {
                console.error('‚ùå Error updating local routine streaks:', error);
            }
        }
        
        // === MONTHLY STREAK DISPLAY FUNCTION (FIXED) ===
        function updateMonthlyStreakDisplays() {
            console.log('üîÑ Updating monthly streak displays...');
            // Simple implementation for now
            const now = new Date();
            const monthName = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni',
                             'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
            
            // Update streak tiles with current month
            const streakTiles = document.querySelectorAll('.streak-tile');
            streakTiles.forEach((tile, index) => {
                const dateElement = tile.querySelector('.streak-date');
                if (dateElement) {
                    dateElement.textContent = `${monthName} ${now.getFullYear()}`;
                }
            });
        }
        
        function updateMonthlyStreakDisplaysFromMemory() {
            // Fallback to basic function for now
            updateMonthlyStreakDisplays();
        }
        
        function getRoutineCompletions() {
            // Return empty array for now
            return [];
        }
        
        // === MAKE FUNCTIONS GLOBALLY AVAILABLE ===
        window.updateMonthlyStreakDisplays = updateMonthlyStreakDisplays;
        window.updateMonthlyStreakDisplaysFromMemory = updateMonthlyStreakDisplaysFromMemory;
        window.getRoutineCompletions = getRoutineCompletions;
        window.initializeTodoCounter = initializeTodoCounter;
        window.loadRoutineCompletions = loadRoutineCompletions;
        window.loadRoutineStates = loadRoutineStates;
        window.updateRoutineProgress = updateRoutineProgress;

        // === EVENT LISTENERS ===
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Skip logout and settings buttons - they have their own handlers
                if (tab.id === 'logout-btn' || tab.id === 'settings-btn') return;
                
                const tabId = tab.getAttribute('data-tab');
                if (tabId) switchTab(tabId);
            });
        });
        
        // Settings button event listener
        const settingsBtn = document.getElementById('settings-btn');
        if (settingsBtn) {
            settingsBtn.addEventListener('click', () => {
                console.log('Settings clicked');
                switchTab('tab-settings');
            });
        }

        // Todo category tabs
        document.querySelectorAll('.category-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-category');
                switchCategory(categoryId);
            });
        });

        // Ziele category tabs
        document.querySelectorAll('.ziel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-ziel-category');
                switchZielCategory(categoryId);
            });
        });

        // Resource category tabs
        document.querySelectorAll('.resource-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-resource-category');
                switchResourceCategory(categoryId);
            });
        });

        // Journal category tabs
        document.querySelectorAll('.journal-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-journal-category');
                switchJournalCategory(categoryId);
            });
        });

        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', async function() {
                // ToDo-Items als completed markieren
                const todoItem = this.closest('.todo-item');
                if (todoItem) {
                    todoItem.classList.toggle('completed', this.checked);
                }
                
                // Routine-Progress aktualisieren (nur bei Routine-Checkboxen)
                const routineSection = this.closest('.routine-section');
                if (routineSection) {
                    // Apply visual styling immediately
                    const label = this.nextElementSibling;
                    if (label) {
                        if (this.checked) {
                            label.style.textDecoration = 'line-through';
                            label.style.color = '#999';
                        } else {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    }
                    
                    // Save checkbox state (now async)
                    await saveCheckboxState(this.id, this.checked);
                    updateRoutineProgress();
                }
            });
        });

        // === TODO MANAGEMENT ===
        const TodoManager = {
            todos: [], // In-memory storage for demo
            
            priorityIntToString(priorityInt) {
                switch(priorityInt) {
                    case 1: return 'mittel'; // Map old niedrig to mittel
                    case 2: return 'mittel';
                    case 3: return 'wichtig';
                    case 4: return 'dringend';
                    default: return 'mittel';
                }
            },
            
            getPriorityString(priority) {
                if (typeof priority === 'string') {
                    return priority;
                }
                return this.priorityIntToString(priority);
            },
            
            getPriorityDisplay(priority) {
                const priorityStr = this.getPriorityString(priority);
                return priorityStr.charAt(0).toUpperCase() + priorityStr.slice(1);
            },
            
            async loadTodos() {
                if (!supabase?.isAuthenticated()) return;
                try {
                    const data = await supabase.select('todos', '*');
                    if (data && Array.isArray(data)) {
                        // Transform database data to match UI expectations
                        this.todos = data.map(todo => {
                            // Convert priority integer back to string
                            let priorityString = 'mittel';
                            switch(todo.priority) {
                                case 1: priorityString = 'mittel'; break; // Map old niedrig to mittel
                                case 2: priorityString = 'mittel'; break;
                                case 3: priorityString = 'wichtig'; break;
                                case 4: priorityString = 'dringend'; break;
                                default: priorityString = 'mittel';
                            }
                            
                            return {
                                ...todo,
                                title: todo.text, // Map text to title for UI
                                deadline: todo.date, // Use date field only (no due_date)
                                priority: priorityString // Convert integer to string
                            };
                        });
                        this.refreshCurrentView();
                        this.updateHomeTodos();
                    }
                } catch (error) {
                    console.error('Error loading todos:', error);
                }
            },
            
            showAddTodoModal() {
                const modal = document.getElementById('add-todo-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('todo-deadline').value = today;
            },
            
            hideAddTodoModal() {
                const modal = document.getElementById('add-todo-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-todo-form').reset();
                // Reset to default values
                document.getElementById('todo-time').value = '21:00';
                document.getElementById('todo-priority').value = 'mittel';
            },
            
            async addTodo(todoData) {
                // DON'T create due_date with timezone - it causes issues
                // Just store date and time separately
                
                // Convert priority string to integer
                let priorityInt = 2; // Default to mittel
                switch(todoData.priority) {
                    case 'niedrig': priorityInt = 1; break; // Keep for backwards compatibility
                    case 'mittel': priorityInt = 2; break;
                    case 'wichtig': priorityInt = 3; break;
                    case 'dringend': priorityInt = 4; break;
                    default: priorityInt = 2;
                }
                console.log('üéØ Priority conversion:', todoData.priority, '‚Üí', priorityInt);
                
                const todo = {
                    text: todoData.title,
                    category: todoData.category,
                    priority: priorityInt,
                    date: todoData.deadline,
                    time: todoData.time,
                    // Remove due_date field to avoid timezone issues
                    completed: false,
                    user_id: supabase?.user?.id || 'anonymous'
                };
                
                if (supabase?.isAuthenticated()) {
                    try {
                        const result = await supabase.insert('todos', todo);
                        console.log('üíæ Supabase insert result:', result);
                        if (result && Array.isArray(result) && result.length > 0) {
                            // Transform the database result to match UI expectations
                            const dbTodo = result[0];
                            console.log('Database returned todo with ID:', dbTodo.id, dbTodo);
                            const uiTodo = {
                                ...dbTodo,
                                title: dbTodo.text,
                                deadline: dbTodo.date, // Use date field only
                                priority: this.priorityIntToString(dbTodo.priority || 1)
                            };
                            this.todos.push(uiTodo);
                        } else {
                            // If insert doesn't return data, add with generated id
                            todo.id = Date.now().toString();
                            todo.title = todo.text;
                            todo.deadline = todo.date;
                            todo.priority = this.priorityIntToString(todo.priority);
                            this.todos.push(todo);
                        }
                    } catch (error) {
                        console.error('Error saving todo:', error);
                        // Fall back to local storage
                        todo.id = Date.now().toString();
                        todo.title = todo.text;
                        todo.deadline = todo.due_date || todo.date;
                        todo.priority = this.priorityIntToString(todo.priority);
                        this.todos.push(todo);
                    }
                } else {
                    // Local storage fallback
                    todo.id = Date.now().toString();
                    todo.title = todo.text;
                    todo.deadline = todo.due_date || todo.date;
                    todo.priority = this.priorityIntToString(todo.priority);
                    this.todos.push(todo);
                }
                
                console.log('Todo added:', todo);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.category-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-category') : 'heute';
                
                console.log('üîÑ Refreshing view for category:', activeCategory);
                console.log('üîÑ All todos (completed status):', this.todos.map(t => ({title: t.title, completed: t.completed})));
                
                this.displayTodosForCategory(activeCategory);
                
                // Also update home todos
                this.updateHomeTodos();
            },
            
            displayTodosForCategory(category) {
                const container = document.getElementById(category);
                if (!container) return;
                
                let filteredTodos = [];
                
                switch(category) {
                    case 'heute':
                        // Get today without timezone conversion
                        const today = new Date();
                        const todayStr = today.getFullYear() + '-' + 
                                       String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                                       String(today.getDate()).padStart(2, '0');
                        
                        filteredTodos = this.todos.filter(todo => 
                            todo.date === todayStr && !todo.completed
                        );
                        break;
                    case 'alle':
                        filteredTodos = this.todos.filter(todo => !todo.completed);
                        break;
                    case 'archiv':
                        filteredTodos = this.todos.filter(todo => todo.completed);
                        break;
                    default:
                        filteredTodos = this.todos.filter(todo => 
                            todo.category === category && !todo.completed
                        );
                }
                // Sort by date first, then by time
                filteredTodos.sort((a, b) => {
                    // First by date
                    const dateA = a.date || '9999-12-31';
                    const dateB = b.date || '9999-12-31';
                    const dateComparison = dateA.localeCompare(dateB);
                    
                    if (dateComparison !== 0) {
                        return dateComparison;
                    }
                    
                    // Then by time
                    const timeA = a.time || '23:59';
                    const timeB = b.time || '23:59';
                    return timeA.localeCompare(timeB);
                });
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredTodos.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Todos vorhanden</p>';
                    return;
                }
                
                // Create grid for todos
                const grid = document.createElement('div');
                grid.className = 'grid-3'; // 3-spaltig f√ºr kompaktere Todo-Kacheln
                
                // Display todos
                filteredTodos.forEach(todo => {
                    const todoElement = this.createTodoElement(todo);
                    grid.appendChild(todoElement);
                });
                
                container.appendChild(grid);
            },
            
            createTodoElement(todo) {
                const todoCard = document.createElement('div');
                todoCard.className = `ziel-card${todo.completed ? ' completed' : ''}`;
                todoCard.dataset.todoId = todo.id;
                
                // COMPLETELY AVOID DATE PARSING - just use raw strings
                let deadlineClass = '';
                let deadlineText = '';
                
                if (todo.date) {
                    // Get today as YYYY-MM-DD string (no timezone conversion)
                    const today = new Date();
                    const todayStr = today.getFullYear() + '-' + 
                                   String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                                   String(today.getDate()).padStart(2, '0');
                    
                    const isToday = todo.date === todayStr;
                    
                    if (todo.time) {
                        // Todo has both date and time
                        const todoDate = new Date(todo.date + 'T' + todo.time);
                        const now = new Date();
                        
                        if (isToday) {
                            // Check if time has passed for today
                            if (todoDate < now) {
                                deadlineClass = 'overdue';
                                deadlineText = `√úberf√§llig ${todo.time}`;
                            } else {
                                deadlineClass = 'today';
                                deadlineText = `Heute ${todo.time}`;
                            }
                        } else if (todo.date < todayStr) {
                            // Past date - definitely overdue
                            deadlineClass = 'overdue';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = `√úberf√§llig ${germanDate} ${todo.time}`;
                        } else {
                            // Future date
                            deadlineClass = 'soon';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = `${germanDate} ${todo.time}`;
                        }
                    } else {
                        // Todo has only date, no time
                        if (isToday) {
                            deadlineClass = 'today';
                            deadlineText = 'Heute';
                        } else if (todo.date < todayStr) {
                            // Past date - overdue
                            deadlineClass = 'overdue';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = `√úberf√§llig ${germanDate}`;
                        } else {
                            // Future date
                            deadlineClass = 'soon';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = germanDate;
                        }
                    }
                } else {
                    deadlineText = 'Kein Termin';
                    deadlineClass = 'none';
                }
                
                // Calculate days until deadline (similar to termine)
                let daysUntilText = '';
                let daysUntilBadge = '';
                if (todo.date) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const todoDateObj = new Date(todo.date);
                    todoDateObj.setHours(0, 0, 0, 0);
                    const daysDifference = Math.ceil((todoDateObj - today) / (1000 * 60 * 60 * 24));
                    
                    if (daysDifference === 0) {
                        daysUntilText = 'Heute';
                        daysUntilBadge = `<span class="days-until-badge heute">Heute</span>`;
                    } else if (daysDifference === 1) {
                        daysUntilText = 'Morgen';
                        daysUntilBadge = `<span class="days-until-badge morgen">Morgen</span>`;
                    } else if (daysDifference === -1) {
                        daysUntilText = 'Gestern';
                        daysUntilBadge = `<span class="days-until-badge overdue">1 Tag √ºberf√§llig</span>`;
                    } else if (daysDifference > 1) {
                        daysUntilText = `in ${daysDifference} Tagen`;
                        daysUntilBadge = `<span class="days-until-badge future">${daysDifference} Tage</span>`;
                    } else if (daysDifference < -1) {
                        daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                        daysUntilBadge = `<span class="days-until-badge overdue">${Math.abs(daysDifference)} Tage √ºberf√§llig</span>`;
                    }
                }

                todoCard.innerHTML = `
                    <div class="ziel-kategorie">${todo.category}</div>
                    <div class="ziel-header">
                        <div class="ziel-name">${todo.title}</div>
                        <div class="ziel-beschreibung">
                            <span class="todo-deadline ${deadlineClass}">${deadlineText}</span>
                            ${daysUntilBadge}
                        </div>
                    </div>
                    <div class="ziel-progress-section">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <input type="checkbox" class="todo-checkbox" ${todo.completed ? 'checked' : ''} 
                                   onchange="TodoManager.toggleTodo('${todo.id}')"
                                   style="width: 20px; height: 20px; border: 2px solid #000; appearance: none; cursor: pointer;">
                            <span class="todo-tag ${TodoManager.getPriorityString(todo.priority)}" style="margin-left: auto;">${TodoManager.getPriorityDisplay(todo.priority)}</span>
                        </div>
                    </div>
                `;
                
                // Add checkbox styling
                const checkbox = todoCard.querySelector('.todo-checkbox');
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        this.style.backgroundColor = '#000';
                        this.innerHTML = '<span style="color: white; position: absolute; top: -2px; left: 2px; font-size: 12px;">‚úì</span>';
                    } else {
                        this.style.backgroundColor = 'transparent';
                        this.innerHTML = '';
                    }
                });
                
                // Set initial checkbox state
                if (todo.completed) {
                    checkbox.style.backgroundColor = '#000';
                    checkbox.innerHTML = '<span style="color: white; position: absolute; top: -2px; left: 2px; font-size: 12px;">‚úì</span>';
                }
                
                return todoCard;
            },
            
            async toggleTodo(todoId) {
                console.log('üîç Looking for todo with ID:', todoId, 'Type:', typeof todoId);
                console.log('üîç Available todos:', this.todos.map(t => ({id: t.id, type: typeof t.id, title: t.title})));
                
                const todo = this.todos.find(t => String(t.id) === String(todoId));
                if (todo) {
                    const wasCompleted = todo.completed;
                    todo.completed = !todo.completed;
                    console.log(`‚úÖ Todo "${todo.title}" ${todo.completed ? 'completed' : 'uncompleted'}`);
                    console.log(`üîç DEBUG: wasCompleted = ${wasCompleted}, todo.completed = ${todo.completed}`);
                    
                    // Update counter display when todo status changes (now cloud-based)
                    if (todo.completed !== wasCompleted) {
                        console.log('‚òÅÔ∏è Todo status changed, will refresh cloud counter after database update...');
                    }
                    
                    if (supabase?.isAuthenticated()) {
                        try {
                            console.log('üíæ Updating in database - ID:', todo.id, 'Type:', typeof todo.id, 'Completed:', todo.completed);
                            
                            // Make sure we use the right ID type
                            const updateId = Number.isInteger(Number(todo.id)) ? Number(todo.id) : todo.id;
                            const result = await supabase.update('todos', { completed: todo.completed }, updateId);
                            
                            console.log('üíæ Database update result:', result);
                            
                            console.log('‚úÖ Database update successful');
                            
                            // Refresh cloud-based counter after successful database update
                            if (todo.completed !== wasCompleted) {
                                console.log('‚òÅÔ∏è Refreshing todo counter from cloud...');
                                setTimeout(() => {
                                    initializeTodoCounter(); // This now uses cloud data
                                }, 100);
                            }
                            
                        } catch (error) {
                            console.error('‚ùå Database update failed:', error);
                            alert('Fehler: ' + error.message + '\nTodo wird nicht gespeichert!');
                            // Revert on error
                            todo.completed = wasCompleted;
                            return; // Don't refresh if update failed
                        }
                    }
                    
                    this.refreshCurrentView();
                    this.updateHomeTodos();
                } else {
                    console.error('‚ùå Todo not found for ID:', todoId);
                    alert('Todo nicht gefunden! ID: ' + todoId);
                }
            },
            
            async clearArchive() {
                console.log('üîç DEBUG: clearArchive() called');
                if (!confirm('Wirklich alle erledigten Todos dauerhaft l√∂schen?\n\nDiese Aktion kann nicht r√ºckg√§ngig gemacht werden!')) {
                    console.log('üîç DEBUG: Archive clear cancelled by user');
                    return;
                }
                
                const completedTodos = this.todos.filter(todo => todo.completed);
                console.log('üóëÔ∏è Deleting', completedTodos.length, 'completed todos from archive');
                
                if (supabase?.isAuthenticated()) {
                    try {
                        // Delete from database
                        for (const todo of completedTodos) {
                            console.log(`üóëÔ∏è Deleting todo from database: ID ${todo.id}, Title: "${todo.title}"`);
                            const result = await supabase.delete('todos', todo.id);
                            console.log(`üóëÔ∏è Delete result for ${todo.id}:`, result);
                        }
                        console.log('‚úÖ All completed todos deleted from database');
                    } catch (error) {
                        console.error('‚ùå Error deleting todos from database:', error);
                        alert('Fehler beim L√∂schen aus der Datenbank: ' + error.message);
                        return;
                    }
                }
                
                // Remove from local array
                this.todos = this.todos.filter(todo => !todo.completed);
                
                // Update localStorage cache
                try {
                    localStorage.setItem('todos_cache', JSON.stringify(this.todos));
                    console.log('üîÑ Updated local todos cache');
                } catch (error) {
                    console.error('Error updating local todos cache:', error);
                }
                
                // Refresh current view
                this.refreshCurrentView();
                
                alert(`‚úÖ ${completedTodos.length} erledigte Todos wurden gel√∂scht!`);
            },
            
            updateHomeTodos() {
                const homeContainer = document.getElementById('home-todos');
                if (!homeContainer) return;
                
                // Show today's uncompleted todos on home
                const today = new Date();
                const todayStr = today.getFullYear() + '-' + 
                               String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(today.getDate()).padStart(2, '0');
                
                const todayTodos = this.todos.filter(todo => 
                    todo.date === todayStr && !todo.completed
                ).sort((a, b) => {
                    const timeA = a.time || '23:59';
                    const timeB = b.time || '23:59';
                    return timeA.localeCompare(timeB);
                });
                
                homeContainer.innerHTML = '';
                
                if (todayTodos.length === 0) {
                    homeContainer.innerHTML = '<p style="text-align: center; color: #666; padding: 1rem;">Keine Todos f√ºr heute</p>';
                    return;
                }
                
                todayTodos.forEach(todo => {
                    const todoItem = document.createElement('div');
                    todoItem.className = 'checkbox-item todo-item';
                    todoItem.innerHTML = `
                        <div class="todo-left">
                            <input type="checkbox" id="home-todo-${todo.id}" onchange="TodoManager.toggleTodo('${todo.id}')">
                            <label for="home-todo-${todo.id}">
                                ${todo.title} 
                                <span class="todo-tag ${TodoManager.getPriorityString(todo.priority)}" style="margin-left: 0.5rem;">${TodoManager.getPriorityDisplay(todo.priority)}</span>
                            </label>
                        </div>
                        <span class="todo-time">${todo.time || '21:00'}</span>
                    `;
                    homeContainer.appendChild(todoItem);
                });
            }
        };

        // === GOAL MANAGEMENT ===
        const GoalManager = {
            goals: [], // In-memory storage for demo
            
            async loadGoals() {
                if (!supabase?.isAuthenticated()) return;
                try {
                    const data = await supabase.select('goals', '*');
                    console.log('üíæ Raw goals from database:', data);
                    if (data && Array.isArray(data)) {
                        // Transform database data to match UI expectations
                        this.goals = data.map(goal => {
                            console.log('üîÑ Transforming goal:', goal);
                            return {
                                ...goal,
                                name: goal.title, // Map title to name for UI
                                deadline: goal.target_date, // Map target_date to deadline for UI
                                progress: goal.progress || 0, // Use DB progress field
                                timeframe: goal.timeframe || 'monat', // Use DB timeframe field
                                completed: goal.completed, // Use DB completed field
                                // Map new progress fields
                                startValue: goal.start_value,
                                targetValue: goal.target_value, 
                                currentValue: goal.current_value,
                                unit: goal.unit
                            };
                        });
                        console.log('üîÑ Transformed goals:', this.goals);
                        this.refreshCurrentView();
                    }
                } catch (error) {
                    console.error('Error loading goals:', error);
                }
            },
            
            // Calculate automatic deadlines based on timeframe
            calculateDeadline(timeframe) {
                const now = new Date();
                
                switch(timeframe) {
                    case 'monat': {
                        // Last day of current month - use day 0 of next month
                        const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                        // Format manually to avoid timezone issues
                        const year = endOfMonth.getFullYear();
                        const month = String(endOfMonth.getMonth() + 1).padStart(2, '0');
                        const day = String(endOfMonth.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    case 'quartal': {
                        // Last day of current quarter
                        const currentQuarter = Math.floor(now.getMonth() / 3);
                        const quarterEndMonth = (currentQuarter + 1) * 3; // 3, 6, 9, 12
                        const endOfQuarter = new Date(now.getFullYear(), quarterEndMonth, 0);
                        // Format manually to avoid timezone issues
                        const year = endOfQuarter.getFullYear();
                        const month = String(endOfQuarter.getMonth() + 1).padStart(2, '0');
                        const day = String(endOfQuarter.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    case 'jahr': {
                        // December 31st of current year
                        const year = now.getFullYear();
                        return `${year}-12-31`;
                    }
                    default:
                        return now.toISOString().split('T')[0];
                }
            },
            
            showAddGoalModal() {
                const modal = document.getElementById('add-goal-modal');
                modal.classList.remove('hide');
                
                // Set default deadline based on current timeframe selection
                const timeframeSelect = document.getElementById('goal-timeframe');
                const deadlineInput = document.getElementById('goal-deadline');
                if (timeframeSelect && deadlineInput) {
                    deadlineInput.value = this.calculateDeadline(timeframeSelect.value);
                }
            },
            
            hideAddGoalModal() {
                const modal = document.getElementById('add-goal-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-goal-form').reset();
            },
            
            calculateProgress(startValue, targetValue, currentValue) {
                if (startValue === targetValue) return 100; // Edge case
                const progress = ((currentValue - startValue) / (targetValue - startValue)) * 100;
                return Math.max(0, Math.min(100, Math.round(progress))); // Clamp between 0-100
            },
            
            async addGoal(goalData) {
                const goal = {
                    id: Date.now().toString(),
                    name: goalData.name,
                    description: goalData.description,
                    category: goalData.category,
                    timeframe: goalData.timeframe, // WICHTIG: timeframe f√ºr Filterung
                    deadline: goalData.deadline,
                    unit: goalData.unit || '',
                    startValue: goalData.startValue || 0,
                    targetValue: goalData.targetValue,
                    currentValue: goalData.startValue || 0, // Start with start value
                    progress: 0, // Will be calculated
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                // Calculate initial progress
                goal.progress = this.calculateProgress(goal.startValue, goal.targetValue, goal.currentValue);
                
                console.log('üéØ Created goal with progress data:', {
                    name: goal.name,
                    startValue: goal.startValue,
                    targetValue: goal.targetValue,
                    currentValue: goal.currentValue,
                    unit: goal.unit,
                    progress: goal.progress
                });
                
                if (supabase?.isAuthenticated()) {
                    try {
                        // Map UI fields to database schema - all progress fields now supported
                        const dbGoal = {
                            title: goal.name,
                            description: goal.description,
                            category: goal.category,
                            target_date: goal.deadline,
                            progress: goal.progress,
                            timeframe: goal.timeframe,
                            completed: goal.completed,
                            start_value: goal.startValue,
                            target_value: goal.targetValue, 
                            current_value: goal.currentValue,
                            unit: goal.unit,
                            user_id: supabase?.user?.id
                        };
                        
                        console.log('üíæ Attempting to save goal to database:', dbGoal);
                        const result = await supabase.insert('goals', dbGoal);
                        console.log('üíæ Database result:', result);
                        console.log('üíæ Database result type:', typeof result, 'Array?', Array.isArray(result));
                        
                        if (result && Array.isArray(result) && result.length > 0) {
                            // Use database result and transform back to UI format
                            const savedGoal = {
                                ...result[0],
                                name: result[0].title,
                                deadline: result[0].target_date,
                                timeframe: result[0].timeframe,
                                progress: result[0].progress,
                                completed: result[0].completed,
                                startValue: result[0].start_value,
                                targetValue: result[0].target_value,
                                currentValue: result[0].current_value,
                                unit: result[0].unit,
                                database_id: result[0].id // Store real DB ID for updates
                            };
                            this.goals.push(savedGoal);
                            console.log('‚úÖ Goal saved to cloud with database_id:', result[0].id);
                        } else {
                            // Fallback to local storage
                            this.goals.push(goal);
                        }
                    } catch (error) {
                        console.error('‚ùå Error saving goal to database:', error);
                        console.log('üíæ Falling back to local storage');
                        this.goals.push(goal);
                    }
                } else {
                    // Not authenticated, use local storage
                    this.goals.push(goal);
                }
                
                console.log('Goal added:', goal);
                console.log('All goals after adding:', this.goals);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.ziel-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-ziel-category') : 'alle';
                
                console.log('üéØ Goals refresh - active category:', activeCategory);
                console.log('üéØ All goals:', this.goals.map(g => ({name: g.name, category: g.category, timeframe: g.timeframe})));
                
                this.displayGoalsForCategory(activeCategory);
            },
            
            displayGoalsForCategory(category) {
                const container = document.getElementById(`ziel-${category}`);
                if (!container) return;
                
                let filteredGoals = [];
                
                switch(category) {
                    case 'monat':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'monat' && !goal.completed
                        );
                        break;
                    case 'quartal':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'quartal' && !goal.completed
                        );
                        break;
                    case 'jahr':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'jahr' && !goal.completed
                        );
                        break;
                    case 'alle':
                        filteredGoals = this.goals.filter(goal => !goal.completed);
                        break;
                    case 'archiv':
                        filteredGoals = this.goals.filter(goal => goal.completed);
                        break;
                }
                
                // Sort by deadline
                filteredGoals.sort((a, b) => new Date(a.deadline) - new Date(b.deadline));
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredGoals.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Ziele vorhanden</p>';
                    return;
                }
                
                // Create grid for goals
                const grid = document.createElement('div');
                grid.className = 'grid-2';
                
                // Display goals
                filteredGoals.forEach(goal => {
                    const goalElement = this.createGoalElement(goal);
                    grid.appendChild(goalElement);
                });
                
                container.appendChild(grid);
            },
            
            createGoalElement(goal) {
                const goalCard = document.createElement('div');
                goalCard.className = `termin-card${goal.completed ? ' completed' : ''}`;
                goalCard.dataset.goalId = goal.id;
                
                // Calculate days until deadline (exactly like termine)
                let daysUntilText = '';
                let badgeColor1 = '';
                let badgeColor2 = '';
                let formattedDeadline = '';
                
                if (goal.deadline) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const goalDate = new Date(goal.deadline);
                    goalDate.setHours(0, 0, 0, 0);
                    const daysDifference = Math.ceil((goalDate - today) / (1000 * 60 * 60 * 24));
                    
                    // Format deadline like termine
                    formattedDeadline = goalDate.toLocaleDateString('de-DE', {
                        weekday: 'long',
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric'
                    });
                    
                    // Badge styling (exactly like termine)
                    if (daysDifference === 0) {
                        daysUntilText = 'Heute';
                        badgeColor1 = '#ef4444';
                        badgeColor2 = '#dc2626';
                    } else if (daysDifference === 1) {
                        daysUntilText = 'Morgen';
                        badgeColor1 = '#f97316';
                        badgeColor2 = '#ea580c';
                    } else if (daysDifference === -1) {
                        daysUntilText = 'Gestern';
                        badgeColor1 = '#6b7280';
                        badgeColor2 = '#4b5563';
                    } else if (daysDifference > 1) {
                        daysUntilText = `in ${daysDifference} Tagen`;
                        badgeColor1 = '#3b82f6';
                        badgeColor2 = '#2563eb';
                    } else if (daysDifference < -1) {
                        daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                        badgeColor1 = '#6b7280';
                        badgeColor2 = '#4b5563';
                    }
                }
                
                // Set CSS custom properties for badge colors (like terme)
                const badgeColorVars = `--badge-color-1: ${badgeColor1}; --badge-color-2: ${badgeColor2};`;
                goalCard.style.cssText += badgeColorVars;
                
                // Prepare progress display  
                const hasProgressData = goal.hasOwnProperty('startValue') && goal.hasOwnProperty('targetValue');
                console.log('üîç Goal progress check for:', goal.name);
                console.log('üîç hasProgressData:', hasProgressData);
                console.log('üîç startValue:', goal.startValue, typeof goal.startValue);
                console.log('üîç targetValue:', goal.targetValue, typeof goal.targetValue);
                console.log('üîç currentValue:', goal.currentValue, typeof goal.currentValue);
                console.log('üîç progress:', goal.progress);
                const progressSection = hasProgressData ? `
                    <div class="goal-progress-section" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0;">
                        <div class="goal-values" style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem; color: #666;">
                            <span>${goal.startValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                            <span style="font-weight: 600; color: #000;">${goal.currentValue || goal.startValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                            <span>${goal.targetValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                        </div>
                        <div class="progress-container" style="background: #f0f0f0; height: 6px; border-radius: 3px; overflow: hidden;">
                            <div class="progress-fill" style="background: linear-gradient(90deg, #3b82f6, #1d4ed8); height: 100%; width: ${goal.progress || 0}%; transition: width 0.3s ease;"></div>
                        </div>
                        <div style="text-align: center; margin-top: 0.5rem; font-size: 0.9rem; font-weight: 600; color: #1d4ed8;">
                            ${goal.progress || 0}%
                        </div>
                    </div>
                ` : '';
                
                console.log('üîç progressSection generated:', hasProgressData ? 'YES' : 'NO');
                console.log('üîç progressSection length:', progressSection.length);

                goalCard.innerHTML = `
                    ${daysUntilText ? `<div class="ziel-days-until">${daysUntilText}</div>` : ''}
                    <div class="ziel-kategorie">${goal.category}</div>
                    ${formattedDeadline ? `<div class="termin-date">üéØ ${formattedDeadline}</div>` : ''}
                    <div class="termin-title">${goal.name}</div>
                    <div class="termin-description">${goal.description}</div>
                    ${progressSection}
                    <div class="termin-edit-icon" onclick="GoalManager.showEditGoalValueModal('${goal.id}')">‚úé</div>
                    <div class="termin-delete-icon" onclick="GoalManager.deleteGoal('${goal.id}')">üóë</div>
                `;
                
                return goalCard;
            },
            
            async updateGoalProgress(goalId, newProgress) {
                const goal = this.goals.find(g => g.id == goalId); // Use == for flexible ID matching
                if (goal) {
                    const oldProgress = goal.progress;
                    goal.progress = parseInt(newProgress);
                    goal.completed = goal.progress >= 100;
                    
                    console.log('üéØ Updating goal:', goal.name, 'to progress:', goal.progress);
                    
                    // Check if goal has real database ID or use database_id field
                    const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                    
                    if (supabase?.isAuthenticated() && dbId) {
                        try {
                            console.log('üíæ Updating goal in database with ID:', dbId);
                            const result = await supabase.update('goals', { 
                                progress: goal.progress,
                                completed: goal.completed
                            }, dbId);
                            console.log('‚úÖ Goal progress updated in cloud database:', result);
                        } catch (error) {
                            console.error('‚ùå Error updating goal progress:', error);
                            // Don't revert - keep local change even if DB fails
                            console.warn('‚ö†Ô∏è Goal updated locally only (database update failed)');
                        }
                    } else {
                        console.warn('‚ö†Ô∏è Goal updated locally only (no database ID or not authenticated)');
                    }
                    
                    console.log('‚úÖ Goal progress updated locally:', goal);
                    this.refreshCurrentView();
                } else {
                    console.error('‚ùå Goal not found for ID:', goalId);
                }
            },
            
            showEditGoalValueModal(goalId) {
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                const currentValue = goal.currentValue || goal.startValue || 0;
                const unit = goal.unit ? ` ${goal.unit}` : '';
                
                // Set modal title and current status
                document.getElementById('edit-goal-modal-title').textContent = `Fortschritt f√ºr "${goal.name}"`;
                document.getElementById('edit-goal-current-status').innerHTML = `
                    <strong>Aktueller Status:</strong><br>
                    Start: <strong>${goal.startValue}${unit}</strong> ‚Üí 
                    Ziel: <strong>${goal.targetValue}${unit}</strong><br>
                    Aktuell: <strong>${currentValue}${unit}</strong> 
                    (${goal.progress || 0}% erreicht)
                `;
                
                // Pre-fill current value
                document.getElementById('new-goal-value').value = currentValue;
                
                // Store goal ID for form submission
                document.getElementById('edit-goal-value-form').dataset.goalId = goalId;
                
                // Show modal
                document.getElementById('edit-goal-value-modal').classList.remove('hide');
                
                // Focus input
                setTimeout(() => {
                    document.getElementById('new-goal-value').focus();
                    document.getElementById('new-goal-value').select();
                }, 100);
            },
            
            hideEditGoalValueModal() {
                document.getElementById('edit-goal-value-modal').classList.add('hide');
                document.getElementById('edit-goal-value-form').reset();
                delete document.getElementById('edit-goal-value-form').dataset.goalId;
            },
            
            async editGoalValue(goalId) {
                // This method is now called by the modal form submission
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                const newValue = parseFloat(document.getElementById('new-goal-value').value);
                if (isNaN(newValue)) {
                    alert('Bitte eine g√ºltige Zahl eingeben!');
                    return;
                }
                
                const unit = goal.unit ? ` ${goal.unit}` : '';
                
                // Update values
                goal.currentValue = newValue;
                goal.progress = this.calculateProgress(goal.startValue, goal.targetValue, goal.currentValue);
                goal.completed = goal.progress >= 100;
                
                // Update in database if authenticated
                const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                
                if (supabase?.isAuthenticated() && dbId) {
                    try {
                        await supabase.update('goals', { 
                            current_value: goal.currentValue, // Use DB field name
                            progress: goal.progress,
                            completed: goal.completed
                        }, dbId);
                        console.log('‚úÖ Goal value updated in database');
                    } catch (error) {
                        console.error('‚ùå Error updating goal value:', error);
                        alert('Fehler beim Speichern: ' + error.message);
                        return;
                    }
                }
                
                // Hide modal and refresh view
                this.hideEditGoalValueModal();
                this.refreshCurrentView();
                
                console.log('‚úÖ Goal value updated:', goal.name, `${goal.currentValue}${unit}`, `${goal.progress}%`);
            },
            
            async deleteGoal(goalId) {
                if (!confirm('Dieses Ziel ins Archiv verschieben?\n\n(Es wird als abgeschlossen markiert und ins Archiv verschoben)')) {
                    return;
                }
                
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    console.error('‚ùå Goal not found for archiving:', goalId);
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                console.log('üì¶ Archiving goal:', goal.name);
                
                // Mark as completed (move to archive)
                const oldCompleted = goal.completed;
                goal.completed = true;
                goal.progress = 100; // Set to 100% when archived
                
                // Update in database if authenticated and has real DB ID
                const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                
                if (supabase?.isAuthenticated() && dbId) {
                    try {
                        console.log('üíæ Updating goal in database with ID:', dbId);
                        await supabase.update('goals', { 
                            completed: true,
                            progress: 100
                        }, dbId);
                        console.log('‚úÖ Goal archived in database');
                    } catch (error) {
                        console.error('‚ùå Error archiving goal in database:', error);
                        alert('Fehler beim Archivieren: ' + error.message);
                        // Revert on error
                        goal.completed = oldCompleted;
                        return;
                    }
                }
                
                // Refresh current view
                this.refreshCurrentView();
                
                console.log('‚úÖ Goal archived successfully:', goal.name);
            },
            
            async clearGoalArchive() {
                if (!confirm('Wirklich alle erledigten Ziele dauerhaft l√∂schen?\n\nDiese Aktion kann nicht r√ºckg√§ngig gemacht werden!')) {
                    return;
                }
                
                const completedGoals = this.goals.filter(goal => goal.completed);
                console.log('üóëÔ∏è Deleting', completedGoals.length, 'completed goals from archive');
                
                if (supabase?.isAuthenticated()) {
                    try {
                        // Delete from database (only goals with database IDs)
                        for (const goal of completedGoals) {
                            const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                            if (hasDbId) {
                                await supabase.delete('goals', goal.id);
                                console.log('üíæ Deleted goal from database:', goal.name);
                            } else {
                                console.log('üíæ Skipped local-only goal:', goal.name);
                            }
                        }
                        console.log('‚úÖ All database goals deleted');
                    } catch (error) {
                        console.error('‚ùå Error deleting goals from database:', error);
                        alert('Fehler beim L√∂schen aus der Datenbank: ' + error.message);
                        return;
                    }
                }
                
                // Remove from local array
                this.goals = this.goals.filter(goal => !goal.completed);
                
                // Refresh current view
                this.refreshCurrentView();
                
                alert(`‚úÖ ${completedGoals.length} erledigte Ziele wurden gel√∂scht!`);
            },
            
            clearLocalGoals() {
                if (confirm('Alle lokalen Ziele l√∂schen? (Nur Ziele die nicht in der Datenbank sind)\n\nDas kann alte/kaputte Ziele entfernen.')) {
                    const before = this.goals.length;
                    // Keep only goals that look like they have database IDs
                    this.goals = this.goals.filter(goal => {
                        const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                        return hasDbId;
                    });
                    const after = this.goals.length;
                    console.log(`üóëÔ∏è Removed ${before - after} local-only goals`);
                    this.refreshCurrentView();
                    alert(`${before - after} lokale Ziele gel√∂scht!`);
                }
            },
            
            editGoalProgress(goalId) {
                console.log('‚úèÔ∏è Edit goal progress - ID:', goalId, 'Type:', typeof goalId);
                const goal = this.goals.find(g => g.id == goalId); // Flexible matching
                if (!goal) {
                    console.error('‚ùå Goal not found for edit. ID:', goalId);
                    console.log('‚ùå Available goals:', this.goals.map(g => ({id: g.id, name: g.name})));
                    return;
                }
                console.log('‚úèÔ∏è Editing goal:', goal.name, 'Current progress:', goal.progress);
                
                // Find the goal card and progress percentage element
                const goalCard = document.querySelector(`[data-goal-id="${goalId}"]`);
                const percentageElement = goalCard.querySelector('.ziel-percentage');
                const progressFill = goalCard.querySelector('.progress-fill');
                
                // Create inline edit container
                const editContainer = document.createElement('div');
                editContainer.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; background: #f9f9f9; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px;';
                
                // Create progress input
                const input = document.createElement('input');
                input.type = 'number';
                input.min = '0';
                input.max = '100';
                input.value = goal.progress;
                input.style.cssText = 'width: 50px; padding: 2px 4px; border: 1px solid #ccc; font-size: 0.9rem; text-align: center;';
                
                // Create complete button
                const completeBtn = document.createElement('button');
                completeBtn.textContent = '‚úì Erledigt';
                completeBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; border: 1px solid #28a745; background: #28a745; color: white; border-radius: 3px; cursor: pointer;';
                
                // Create cancel button
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = '√ó';
                cancelBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; border: 1px solid #ccc; background: #f8f9fa; border-radius: 3px; cursor: pointer;';
                
                editContainer.appendChild(input);
                editContainer.appendChild(completeBtn);
                editContainer.appendChild(cancelBtn);
                
                // Replace percentage display with edit container
                const originalText = percentageElement.textContent;
                percentageElement.replaceWith(editContainer);
                input.focus();
                input.select();
                
                // Prevent double execution
                let isHandled = false;
                
                // Handle save/cancel
                const saveProgress = async () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    const newValue = parseInt(input.value);
                    if (!isNaN(newValue) && newValue >= 0 && newValue <= 100) {
                        await this.updateGoalProgress(goalId, newValue);
                        
                        // Update UI
                        const newPercentageElement = document.createElement('span');
                        newPercentageElement.className = 'ziel-percentage';
                        newPercentageElement.textContent = `${newValue}%`;
                        editContainer.replaceWith(newPercentageElement);
                        
                        // Update progress bar
                        progressFill.style.width = `${newValue}%`;
                        
                        // Refresh view if goal completed
                        if (newValue >= 100) {
                            this.refreshCurrentView();
                        }
                    } else {
                        cancelEdit();
                    }
                };
                
                const markComplete = async () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    await this.updateGoalProgress(goalId, 100);
                    
                    // Update UI
                    const newPercentageElement = document.createElement('span');
                    newPercentageElement.className = 'ziel-percentage';
                    newPercentageElement.textContent = '100%';
                    editContainer.replaceWith(newPercentageElement);
                    
                    // Update progress bar
                    progressFill.style.width = '100%';
                    
                    // Refresh view to move to archive
                    this.refreshCurrentView();
                };
                
                const cancelEdit = () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    const newPercentageElement = document.createElement('span');
                    newPercentageElement.className = 'ziel-percentage';
                    newPercentageElement.textContent = originalText;
                    editContainer.replaceWith(newPercentageElement);
                };
                
                // Event listeners
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveProgress();
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
                
                completeBtn.addEventListener('click', markComplete);
                cancelBtn.addEventListener('click', cancelEdit);
                
                // Auto-save on blur for input
                input.addEventListener('blur', (e) => {
                    // Only if user didn't click on buttons
                    setTimeout(() => {
                        if (!isHandled && document.contains(editContainer)) {
                            saveProgress();
                        }
                    }, 100);
                });
            }
        };

        // === JOURNAL MANAGEMENT ===
        const JournalManager = {
            entries: [], // In-memory storage for demo
            
            async loadEntries() {
                if (!supabase?.isAuthenticated()) return;
                try {
                    const data = await supabase.select('journal_entries', '*');
                    if (data && Array.isArray(data)) {
                        // Transform database data to ensure tags is always an array
                        this.entries = data.map(entry => {
                            let tags = [];
                            if (Array.isArray(entry.tags)) {
                                tags = entry.tags;
                            } else if (entry.tags) {
                                if (typeof entry.tags === 'string') {
                                    try {
                                        // Try to parse as JSON first
                                        tags = JSON.parse(entry.tags);
                                        if (!Array.isArray(tags)) {
                                            // If it's not an array, treat as single tag
                                            tags = [entry.tags];
                                        }
                                    } catch (e) {
                                        // If JSON.parse fails, treat as single tag
                                        tags = [entry.tags];
                                    }
                                } else {
                                    tags = [entry.tags];
                                }
                            }
                            return {
                                ...entry,
                                tags: tags
                            };
                        });
                        this.refreshCurrentView();
                    }
                } catch (error) {
                    console.error('Error loading journal entries:', error);
                }
            },
            
            showAddJournalModal() {
                const modal = document.getElementById('add-journal-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('journal-date').value = today;
            },
            
            hideAddJournalModal() {
                const modal = document.getElementById('add-journal-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-journal-form').reset();
                // Reset date back to today
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('journal-date').value = today;
            },
            
            async addEntry(entryData) {
                const entry = {
                    title: entryData.title,
                    content: entryData.content,
                    tags: entryData.tags || [], // Array of tags
                    date: entryData.date, // Keep date for local use
                    entry_date: entryData.date, // Use entry_date for database
                    user_id: supabase?.user?.id,
                    created_at: new Date().toISOString()
                };
                
                if (supabase?.isAuthenticated()) {
                    try {
                        // Create database entry without 'date' and 'created_at' fields (auto-generated)
                        const dbEntry = { ...entry };
                        delete dbEntry.date;
                        delete dbEntry.created_at;
                        console.log('üíæ Sending to database:', dbEntry);
                        const result = await supabase.insert('journal_entries', dbEntry);
                        if (result && result.length > 0) {
                            this.entries.push(result[0]);
                        } else {
                            entry.id = Date.now().toString();
                            this.entries.push(entry);
                        }
                    } catch (error) {
                        console.error('Error saving journal entry:', error);
                        entry.id = Date.now().toString();
                        this.entries.push(entry);
                    }
                } else {
                    entry.id = Date.now().toString();
                    this.entries.push(entry);
                }
                
                console.log('Journal entry added:', entry);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.journal-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-journal-category') : 'alle';
                
                this.displayEntriesForCategory(activeCategory);
            },
            
            displayEntriesForCategory(category) {
                const container = document.getElementById(`journal-${category}`);
                if (!container) return;
                
                let filteredEntries = [];
                
                switch(category) {
                    case 'alle':
                        filteredEntries = this.entries;
                        break;
                    default:
                        // Filter entries that have the selected tag
                        filteredEntries = this.entries.filter(entry => 
                            entry.tags && entry.tags.includes(category)
                        );
                }
                
                // Sort by date (newest first)
                filteredEntries.sort((a, b) => new Date(b.entry_date || b.date) - new Date(a.entry_date || a.date));
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredEntries.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Journal-Eintr√§ge vorhanden</p>';
                    return;
                }
                
                // Create grid for entries
                const grid = document.createElement('div');
                grid.className = 'grid-2'; // 2-spaltig f√ºr Journal-Eintr√§ge
                
                // Display entries
                filteredEntries.forEach(entry => {
                    const entryElement = this.createEntryElement(entry);
                    grid.appendChild(entryElement);
                });
                
                container.appendChild(grid);
            },
            
            createEntryElement(entry) {
                const entryCard = document.createElement('div');
                entryCard.className = 'ziel-card';
                entryCard.dataset.entryId = entry.id;
                
                const entryDate = new Date(entry.entry_date || entry.date);
                const formattedDate = entryDate.toLocaleDateString('de-DE', {
                    day: '2-digit',
                    month: '2-digit', 
                    year: 'numeric'
                });
                
                // Ensure tags is always an array before mapping
                const tags = Array.isArray(entry.tags) ? entry.tags : 
                           (entry.tags ? (typeof entry.tags === 'string' ? JSON.parse(entry.tags) : []) : []);
                const tagsHtml = tags.length > 0 
                    ? tags.map(tag => `<span class="todo-tag normal" style="margin-right: 0.5rem;">${tag}</span>`).join('')
                    : '';
                
                entryCard.innerHTML = `
                    <div class="ziel-header">
                        <div class="ziel-name">${entry.title}</div>
                        <div class="ziel-beschreibung">${entry.content}</div>
                    </div>
                    <div class="ziel-progress-section">
                        <div class="ziel-progress-header">
                            <span class="ziel-progress-label">${formattedDate}</span>
                            <button class="delete-entry-btn" data-entry-id="${entry.id}" style="background: none; border: none; color: #cc0000; cursor: pointer; padding: 0.25rem; font-size: 0.9rem;" title="Eintrag l√∂schen">
                                üóëÔ∏è
                            </button>
                        </div>
                        <div style="margin-top: 0.5rem;">
                            ${tagsHtml}
                        </div>
                    </div>
                `;
                
                return entryCard;
            },
            
            async deleteEntry(entryId) {
                if (!confirm('Diesen Journal-Eintrag wirklich l√∂schen?')) {
                    return;
                }
                
                try {
                    // Delete from database if authenticated
                    if (supabase?.isAuthenticated()) {
                        await supabase.delete('journal_entries', entryId);
                        console.log('‚úÖ Journal entry deleted from database:', entryId);
                    }
                    
                    // Remove from local entries array
                    this.entries = this.entries.filter(entry => entry.id != entryId);
                    
                    // Refresh current view
                    this.refreshCurrentView();
                    
                    console.log('‚úÖ Journal entry deleted:', entryId);
                } catch (error) {
                    console.error('‚ùå Error deleting journal entry:', error);
                    alert('Fehler beim L√∂schen des Eintrags: ' + error.message);
                }
            }
        };

        // === TERMIN MANAGEMENT ===
        const TerminManager = {
            termine: [], // In-memory storage for demo
            
            async loadTermine(forceReload = false) {
                console.log('üîÑ TerminManager.loadTermine() called, forceReload:', forceReload);
                console.log('üîç Auth check:', supabase ? 'supabase exists' : 'no supabase', supabase?.isAuthenticated() ? 'authenticated' : 'not authenticated');
                
                // Enhanced authentication check with retry
                if (!supabase?.isAuthenticated()) {
                    console.log('‚ùå Not authenticated, checking again in 500ms...');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    if (!supabase?.isAuthenticated()) {
                        console.log('‚ùå Still not authenticated after retry, aborting loadTermine');
                        return;
                    }
                }
                
                try {
                    console.log('üì° Fetching termine from database...');
                    const data = await supabase.select('termine', '*');
                    console.log('üì• Raw termine data received:', data);
                    
                    if (data && Array.isArray(data)) {
                        this.termine = data;
                        console.log('‚úÖ Termine loaded to memory:', this.termine.length, 'items');
                        this.displayTermine();
                    } else {
                        console.warn('‚ö†Ô∏è Invalid termine data format:', data);
                        this.termine = [];
                        this.displayTermine();
                    }
                } catch (error) {
                    console.error('‚ùå Error loading termine:', error);
                    
                    // If error but we had termine before, keep them
                    if (this.termine.length > 0 && !forceReload) {
                        console.log('‚ÑπÔ∏è Keeping existing termine after error');
                    } else {
                        this.termine = [];
                        this.displayTermine();
                    }
                }
            },
            
            showAddTerminModal() {
                const modal = document.getElementById('add-termin-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('termin-date').value = today;
                
                // Leave time field empty - user can fill if needed
                document.getElementById('termin-time').value = '';
            },
            
            hideAddTerminModal() {
                const modal = document.getElementById('add-termin-modal');
                const form = document.getElementById('add-termin-form');
                const submitBtn = form.querySelector('button[type="submit"]');
                
                modal.classList.add('hide');
                form.reset();
                delete form.dataset.editId; // Clear edit mode
                if (submitBtn) {
                    submitBtn.textContent = 'Hinzuf√ºgen'; // Reset button text
                }
            },
            
            async addTermin(terminData) {
                const termin = {
                    title: terminData.title,
                    description: terminData.description,
                    date: terminData.date,
                    time: terminData.time,
                    user_id: supabase?.user?.id,
                    created_at: new Date().toISOString()
                };
                
                if (supabase?.isAuthenticated()) {
                    try {
                        const result = await supabase.insert('termine', termin);
                        if (result && result.length > 0) {
                            this.termine.push(result[0]);
                        } else {
                            termin.id = Date.now().toString();
                            this.termine.push(termin);
                        }
                    } catch (error) {
                        console.error('Error saving termin:', error);
                        termin.id = Date.now().toString();
                        this.termine.push(termin);
                    }
                } else {
                    termin.id = Date.now().toString();
                    this.termine.push(termin);
                }
                
                console.log('Termin added:', termin);
                
                // Refresh display
                this.displayTermine();
            },
            
            async updateTermin(terminId, terminData) {
                const terminIndex = this.termine.findIndex(t => t.id == terminId);
                if (terminIndex === -1) {
                    console.error('Termin not found for update:', terminId);
                    return;
                }
                
                const updatedTermin = {
                    ...this.termine[terminIndex],
                    title: terminData.title,
                    description: terminData.description,
                    date: terminData.date,
                    time: terminData.time,
                    updated_at: new Date().toISOString()
                };
                
                if (supabase?.isAuthenticated()) {
                    try {
                        await supabase.update('termine', updatedTermin, terminId);
                        this.termine[terminIndex] = updatedTermin;
                    } catch (error) {
                        console.error('Error updating termin:', error);
                        this.termine[terminIndex] = updatedTermin;
                    }
                } else {
                    this.termine[terminIndex] = updatedTermin;
                }
                
                console.log('Termin updated:', updatedTermin);
                
                // Refresh display
                this.displayTermine();
            },
            
            displayTermine() {
                console.log('üìÖ TerminManager.displayTermine() called');
                console.log('üìä Current termine in memory:', this.termine);
                console.log('üìà Termine count:', this.termine.length);
                
                const container = document.getElementById('termine-container');
                if (!container) {
                    console.error('‚ùå Termine container DOM element not found - check if #termine-container exists');
                    return;
                }
                
                console.log('‚úÖ Termine container found:', container);
                
                // Clear container
                container.innerHTML = '';
                
                if (this.termine.length === 0) {
                    console.log('‚ÑπÔ∏è No termine to display - showing empty state message');
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem; grid-column: 1 / -1;">Keine Termine vorhanden</p>';
                    return;
                }
                
                console.log(`üìä Rendering ${this.termine.length} termine to DOM...`);
                
                // Sort by date/time (earliest first)
                const sortedTermine = this.termine.sort((a, b) => {
                    const dateTimeA = new Date(`${a.date}T${a.time || '00:00'}`);
                    const dateTimeB = new Date(`${b.date}T${b.time || '00:00'}`);
                    return dateTimeA - dateTimeB;
                });
                
                console.log('üîÑ Termine sorted by date:', sortedTermine.map(t => `${t.title} - ${t.date}`));
                
                // Add termine
                sortedTermine.forEach((termin, index) => {
                    console.log(`üîÑ Creating element for termin ${index + 1}:`, termin.title);
                    const terminElement = this.createTerminElement(termin);
                    container.appendChild(terminElement);
                });
                
                console.log('‚úÖ All termine rendered to DOM');
            },
            
            createTerminElement(termin) {
                const terminCard = document.createElement('div');
                terminCard.className = 'termin-card';
                terminCard.dataset.terminId = termin.id;
                
                const terminDate = new Date(termin.date);
                const formattedDate = terminDate.toLocaleDateString('de-DE', {
                    weekday: 'long',
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                });
                
                let displayDate = formattedDate;
                if (termin.time) {
                    const timeDate = new Date(`${termin.date}T${termin.time}`);
                    const formattedTime = timeDate.toLocaleTimeString('de-DE', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    displayDate += `, ${formattedTime}`;
                }
                
                // Calculate days until appointment
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const appointmentDate = new Date(termin.date);
                appointmentDate.setHours(0, 0, 0, 0);
                const daysDifference = Math.ceil((appointmentDate - today) / (1000 * 60 * 60 * 24));
                
                let daysUntilText = '';
                let badgeColor1 = '';
                let badgeColor2 = '';
                
                if (daysDifference === 0) {
                    daysUntilText = 'Heute';
                    badgeColor1 = '#ef4444';
                    badgeColor2 = '#dc2626';
                } else if (daysDifference === 1) {
                    daysUntilText = 'Morgen';
                    badgeColor1 = '#f97316';
                    badgeColor2 = '#ea580c';
                } else if (daysDifference === -1) {
                    daysUntilText = 'Gestern';
                    badgeColor1 = '#6b7280';
                    badgeColor2 = '#4b5563';
                } else if (daysDifference > 1) {
                    daysUntilText = `in ${daysDifference} Tagen`;
                    badgeColor1 = '#3b82f6';
                    badgeColor2 = '#2563eb';
                } else if (daysDifference < -1) {
                    daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                    badgeColor1 = '#6b7280';
                    badgeColor2 = '#4b5563';
                }
                
                // Set CSS custom properties for badge colors
                const badgeColorVars = `--badge-color-1: ${badgeColor1}; --badge-color-2: ${badgeColor2};`;
                
                terminCard.style.cssText += badgeColorVars;
                
                terminCard.innerHTML = `
                    <div class="termin-days-until">${daysUntilText}</div>
                    <div class="termin-date">${displayDate}</div>
                    <div class="termin-title">${termin.title}</div>
                    <div class="termin-description">${termin.description}</div>
                    <div class="termin-edit-icon" onclick="TerminManager.editTermin('${termin.id}')">‚úé</div>
                    <div class="termin-delete-icon" onclick="TerminManager.deleteTermin('${termin.id}')">üóë</div>
                `;
                
                return terminCard;
            },
            
            async editTermin(terminId) {
                console.log('üñäÔ∏è Edit termin clicked:', terminId);
                console.log('üìã Available termine:', this.termine);
                
                const termin = this.termine.find(t => t.id == terminId);
                if (!termin) {
                    console.error('‚ùå Termin not found:', terminId);
                    alert('Termin nicht gefunden!');
                    return;
                }
                
                console.log('‚úÖ Found termin for editing:', termin);
                
                // Pre-fill the form with existing values
                document.getElementById('termin-title').value = termin.title;
                document.getElementById('termin-description').value = termin.description;
                document.getElementById('termin-date').value = termin.date;
                document.getElementById('termin-time').value = termin.time || '';
                
                // Store the ID for updating
                const form = document.getElementById('add-termin-form');
                form.dataset.editId = terminId;
                
                // Change button text
                const submitBtn = form.querySelector('button[type="submit"]');
                submitBtn.textContent = 'Termin aktualisieren';
                
                console.log('üìù Form prepared for editing, opening modal...');
                
                // Show modal
                this.showAddTerminModal();
            },
            
            async deleteTermin(terminId) {
                if (!confirm('M√∂chtest du diesen Termin wirklich l√∂schen?')) {
                    return;
                }
                
                console.log('üóëÔ∏è Deleting termin:', terminId);
                
                if (supabase?.isAuthenticated()) {
                    try {
                        await supabase.delete('termine', terminId);
                        console.log('‚úÖ Termin deleted from database');
                    } catch (error) {
                        console.error('‚ùå Error deleting termin from database:', error);
                        alert('Fehler beim L√∂schen: ' + error.message);
                        return;
                    }
                }
                
                // Remove from local array
                this.termine = this.termine.filter(t => t.id != terminId);
                
                // Update localStorage cache
                try {
                    localStorage.setItem('termine_cache', JSON.stringify(this.termine));
                    console.log('üîÑ Updated local termine cache');
                } catch (error) {
                    console.error('Error updating local termine cache:', error);
                }
                
                // Refresh view
                this.displayTermine();
                
                console.log('‚úÖ Termin deleted successfully');
            }
        };

        // Make TerminManager globally available
        window.TerminManager = TerminManager;

        // === INITIALIZE ===
        document.addEventListener('DOMContentLoaded', async () => {
            // Logout is now handled by separate logout.html page
            
            // Initialize Supabase first
            if (window.initializeSupabase) {
                window.initializeSupabase();
            }
            
            // Then initialize authentication
            await Auth.init();
            
            // Load all data from database if authenticated
            if (supabase?.isAuthenticated()) {
                await Promise.all([
                    TodoManager.loadTodos(),
                    GoalManager.loadGoals(),
                    JournalManager.loadEntries(),
                    TerminManager.loadTermine(),
                    loadRoutineCompletions()
                ]);
                
                // Load ResourceManager separately after it's defined
                setTimeout(async () => {
                    if (window.ResourceManager && window.ResourceManager.loadResources) {
                        console.log('üîÑ Loading ResourceManager after initialization...');
                        await window.ResourceManager.loadResources();
                        console.log('‚úÖ ResourceManager loaded successfully');
                    } else {
                        console.warn('‚ö†Ô∏è ResourceManager still not available');
                    }
                }, 100);
            } else {
                // Initialize displays for local storage mode
                TodoManager.updateHomeTodos();
                // Don't call TerminManager.displayTermine() here - it will show empty termine
                // Let it be handled by authentication flow
            }
            
            // Logout button is already handled by Auth.setupEventListeners()
            
            // Journal form submission
            const journalForm = document.querySelector('.journal-form');
            if (journalForm) {
                journalForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const input = this.querySelector('.journal-input');
                    if (input.value.trim()) {
                        console.log('Journal entry:', input.value);
                        input.value = '';
                    }
                });
            }
            
            // Add Todo Button
            const addTodoBtn = document.getElementById('add-todo-btn');
            if (addTodoBtn) {
                addTodoBtn.addEventListener('click', () => {
                    TodoManager.showAddTodoModal();
                });
            }
            
            // Clear Archive Button
            const clearArchiveBtn = document.getElementById('clear-archive-btn');
            if (clearArchiveBtn) {
                clearArchiveBtn.addEventListener('click', () => {
                    TodoManager.clearArchive();
                });
            }
            
            // Cancel Todo Button
            const cancelTodoBtn = document.getElementById('cancel-todo-btn');
            if (cancelTodoBtn) {
                cancelTodoBtn.addEventListener('click', () => {
                    TodoManager.hideAddTodoModal();
                });
            }
            
            // Add Todo Form Submission
            const addTodoForm = document.getElementById('add-todo-form');
            if (addTodoForm) {
                addTodoForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const todoData = {
                        title: document.getElementById('todo-title').value,
                        category: document.getElementById('todo-category').value,
                        priority: document.getElementById('todo-priority').value,
                        deadline: document.getElementById('todo-deadline').value,
                        time: document.getElementById('todo-time').value
                    };
                    
                    console.log('üìù Form data being sent:', todoData);
                    console.log('üìù Priority element value:', document.getElementById('todo-priority').value);
                    console.log('üìù Priority element selectedIndex:', document.getElementById('todo-priority').selectedIndex);
                    
                    await TodoManager.addTodo(todoData);
                    TodoManager.hideAddTodoModal();
                });
            }
            
            // Close modal when clicking outside
            const addTodoModal = document.getElementById('add-todo-modal');
            if (addTodoModal) {
                addTodoModal.addEventListener('click', (e) => {
                    if (e.target === addTodoModal) {
                        TodoManager.hideAddTodoModal();
                    }
                });
            }
            
            // === GOAL EVENT LISTENERS ===
            
            // Add Goal Button
            const addGoalBtn = document.getElementById('add-goal-btn');
            if (addGoalBtn) {
                addGoalBtn.addEventListener('click', () => {
                    GoalManager.showAddGoalModal();
                });
            }
            
            // Cancel Goal Button
            const cancelGoalBtn = document.getElementById('cancel-goal-btn');
            if (cancelGoalBtn) {
                cancelGoalBtn.addEventListener('click', () => {
                    GoalManager.hideAddGoalModal();
                });
            }
            
            // Add Goal Form Submission
            const addGoalForm = document.getElementById('add-goal-form');
            if (addGoalForm) {
                addGoalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const goalData = {
                        name: document.getElementById('goal-name').value,
                        description: document.getElementById('goal-description').value,
                        category: document.getElementById('goal-category').value,
                        timeframe: document.getElementById('goal-timeframe').value,
                        deadline: document.getElementById('goal-deadline').value,
                        unit: document.getElementById('goal-unit').value,
                        startValue: parseFloat(document.getElementById('goal-start-value').value) || 0,
                        targetValue: parseFloat(document.getElementById('goal-target-value').value)
                    };
                    
                    await GoalManager.addGoal(goalData);
                    GoalManager.hideAddGoalModal();
                });
            }
            
            // Timeframe change listener - automatically update deadline
            const goalTimeframeSelect = document.getElementById('goal-timeframe');
            if (goalTimeframeSelect) {
                goalTimeframeSelect.addEventListener('change', (e) => {
                    const deadlineInput = document.getElementById('goal-deadline');
                    if (deadlineInput) {
                        deadlineInput.value = GoalManager.calculateDeadline(e.target.value);
                    }
                });
            }
            
            // Close goal modal when clicking outside
            const addGoalModal = document.getElementById('add-goal-modal');
            if (addGoalModal) {
                addGoalModal.addEventListener('click', (e) => {
                    if (e.target === addGoalModal) {
                        GoalManager.hideAddGoalModal();
                    }
                });
            }
            
            // Clear Goal Archive Button
            const clearGoalArchiveBtn = document.getElementById('clear-goal-archive-btn');
            if (clearGoalArchiveBtn) {
                clearGoalArchiveBtn.addEventListener('click', () => {
                    GoalManager.clearGoalArchive();
                });
            }
            
            // === JOURNAL EVENT LISTENERS ===
            
            // Add Journal Button
            const addJournalBtn = document.getElementById('add-journal-btn');
            if (addJournalBtn) {
                addJournalBtn.addEventListener('click', () => {
                    JournalManager.showAddJournalModal();
                });
            }
            
            // Cancel Journal Button
            const cancelJournalBtn = document.getElementById('cancel-journal-btn');
            if (cancelJournalBtn) {
                cancelJournalBtn.addEventListener('click', () => {
                    JournalManager.hideAddJournalModal();
                });
            }
            
            // Tag selection functionality
            let selectedTags = [];
            
            function updateTagsDisplay() {
                const hiddenInput = document.getElementById('journal-category');
                
                // Update hidden input (use first tag or 'allgemein' as fallback for compatibility)
                hiddenInput.value = selectedTags.length > 0 ? selectedTags[0] : 'allgemein';
                
                // Update tag option buttons
                document.querySelectorAll('.tag-option').forEach(btn => {
                    const tag = btn.getAttribute('data-tag');
                    btn.classList.toggle('selected', selectedTags.includes(tag));
                });
            }
            
            // Tag option click handlers
            document.querySelectorAll('.tag-option').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    
                    // If clicking on the X, remove the tag
                    if (e.target.classList.contains('remove-tag')) {
                        const tag = btn.getAttribute('data-tag');
                        selectedTags = selectedTags.filter(t => t !== tag);
                        updateTagsDisplay();
                        return;
                    }
                    
                    const tag = btn.getAttribute('data-tag');
                    
                    if (selectedTags.includes(tag)) {
                        // Already selected, remove it
                        selectedTags = selectedTags.filter(t => t !== tag);
                    } else {
                        // Not selected, add it
                        selectedTags.push(tag);
                    }
                    
                    updateTagsDisplay();
                });
            });
            
            // Add Journal Form Submission
            const addJournalForm = document.getElementById('add-journal-form');
            if (addJournalForm) {
                addJournalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    if (selectedTags.length === 0) {
                        alert('Bitte w√§hle mindestens einen Tag aus.');
                        return;
                    }
                    
                    const entryData = {
                        title: document.getElementById('journal-title').value,
                        content: document.getElementById('journal-content').value,
                        tags: [...selectedTags], // Copy array
                        date: document.getElementById('journal-date').value
                    };
                    
                    await JournalManager.addEntry(entryData);
                    JournalManager.hideAddJournalModal();
                    
                    // Reset tags
                    selectedTags = [];
                    updateTagsDisplay();
                });
            }
            
            // Close journal modal when clicking outside
            const addJournalModal = document.getElementById('add-journal-modal');
            if (addJournalModal) {
                addJournalModal.addEventListener('click', (e) => {
                    if (e.target === addJournalModal) {
                        JournalManager.hideAddJournalModal();
                    }
                });
            }
            
            // === TERMIN EVENT LISTENERS ===
            
            // Add Termin Button
            const addTerminBtn = document.getElementById('add-termin-btn');
            if (addTerminBtn) {
                addTerminBtn.addEventListener('click', () => {
                    TerminManager.showAddTerminModal();
                });
            }
            
            // Cancel Termin Button
            const cancelTerminBtn = document.getElementById('cancel-termin-btn');
            if (cancelTerminBtn) {
                cancelTerminBtn.addEventListener('click', () => {
                    TerminManager.hideAddTerminModal();
                });
            }
            
            // Add Termin Form Submission
            const addTerminForm = document.getElementById('add-termin-form');
            if (addTerminForm) {
                addTerminForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const terminData = {
                        title: document.getElementById('termin-title').value,
                        description: document.getElementById('termin-description').value,
                        date: document.getElementById('termin-date').value,
                        time: document.getElementById('termin-time').value
                    };
                    
                    // Check if we're editing an existing termin
                    const editId = addTerminForm.dataset.editId;
                    if (editId) {
                        await TerminManager.updateTermin(editId, terminData);
                    } else {
                        await TerminManager.addTermin(terminData);
                    }
                    
                    TerminManager.hideAddTerminModal();
                });
            }
            
            // Close termin modal when clicking outside
            const addTerminModal = document.getElementById('add-termin-modal');
            if (addTerminModal) {
                addTerminModal.addEventListener('click', (e) => {
                    if (e.target === addTerminModal) {
                        TerminManager.hideAddTerminModal();
                    }
                });
            }
            
            // Load routine states on page load
            loadRoutineStates();
            
            // Update routine progress to reflect loaded states
            updateRoutineProgress();
            
            // Initialize settings functionality
            initializeSettings();
            
            // Initialize todo counter after short delay to allow auth to complete
            setTimeout(() => {
                if (window.initializeTodoCounter) {
                    console.log('üîÑ Initial todo counter setup...');
                    window.initializeTodoCounter();
                }
            }, 1000);
            
            // === EDIT GOAL VALUE MODAL EVENT LISTENERS ===
            document.getElementById('cancel-edit-goal-value-btn').addEventListener('click', () => {
                GoalManager.hideEditGoalValueModal();
            });

            document.getElementById('edit-goal-value-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const goalId = e.target.dataset.goalId;
                if (goalId) {
                    await GoalManager.editGoalValue(goalId);
                }
            });
            
            // === RESOURCE MANAGER ===
            const ResourceManager = {
                resources: [],
                
                async loadResources() {
                    try {
                        console.log('üîÑ ResourceManager.loadResources() called');
                        console.log('üîç Auth status:', supabase?.isAuthenticated());
                        console.log('üîç CloudStorage available:', !!cloudStorage);
                        
                        if (cloudStorage && supabase?.isAuthenticated()) {
                            console.log('‚òÅÔ∏è Attempting to load resources from cloud...');
                            this.resources = await cloudStorage.getResources() || [];
                            console.log(`‚òÅÔ∏è Loaded ${this.resources.length} resources from cloud`);
                            if (this.resources.length > 0) {
                                console.log('üìã Sample resource IDs:', this.resources.slice(0, 3).map(r => `${r.id} (${typeof r.id})`));
                            }
                        } else {
                            console.log('üì± Loading resources from localStorage...');
                            const cached = localStorage.getItem('resources');
                            this.resources = cached ? JSON.parse(cached) : [];
                            console.log(`üì± Loaded ${this.resources.length} resources from localStorage`);
                            if (this.resources.length > 0) {
                                console.log('üìã Sample local resource IDs:', this.resources.slice(0, 3).map(r => `${r.id} (${typeof r.id})`));
                            }
                        }
                        this.renderResources();
                        console.log('‚úÖ ResourceManager.loadResources() completed');
                    } catch (error) {
                        console.error('‚ùå Error loading resources:', error);
                        console.log('üì± Falling back to localStorage...');
                        const cached = localStorage.getItem('resources');
                        this.resources = cached ? JSON.parse(cached) : [];
                        console.log(`üì± Fallback loaded ${this.resources.length} resources`);
                    }
                },
                
                renderResources() {
                    console.log('üé® ResourceManager.renderResources() called with', this.resources.length, 'resources');
                    // Refresh current view
                    this.refreshCurrentView();
                },
                
                refreshCurrentView() {
                    // Get current active category
                    const activeTab = document.querySelector('.resource-tab.active');
                    const activeCategory = activeTab ? activeTab.getAttribute('data-resource-category') : 'alle';
                    
                    console.log('üîÑ Refreshing view for category:', activeCategory);
                    this.displayResourcesForCategory(activeCategory);
                },
                
                displayResourcesForCategory(category) {
                    const container = document.getElementById(`resource-${category}`);
                    if (!container) return;
                    
                    let filteredResources = [];
                    
                    switch(category) {
                        case 'privat':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Privat'
                            );
                            break;
                        case 'arbeit':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Arbeit'
                            );
                            break;
                        case 'uni':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Uni'
                            );
                            break;
                        case 'crypto':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Crypto'
                            );
                            break;
                        case 'alle':
                        default:
                            filteredResources = this.resources;
                            break;
                    }
                    
                    let html = '';
                    
                    if (filteredResources.length === 0) {
                        html = '<p style="text-align: center; color: #666; padding: 3rem;">Keine Resources vorhanden</p>';
                    } else {
                        // Todo-style grid layout for all categories
                        html += '<div class="resource-grid">';
                        
                        filteredResources.forEach(resource => {
                            const icon = resource.icon || 'üîó';
                            const description = resource.description || '';
                            const truncatedTitle = resource.title.length > 25 ? resource.title.substring(0, 25) + '...' : resource.title;
                            const fullTitle = `${resource.title}${description ? ` - ${description}` : ''}`;
                            html += `
                                <div class="resource-card" onclick="window.open('${resource.url}', '_blank')" 
                                     title="${fullTitle}">
                                    <span class="resource-icon">${icon}</span>
                                    <span class="resource-title">${truncatedTitle}</span>
                                    <div class="resource-actions">
                                        <button class="resource-edit-btn" onclick="event.stopPropagation(); ResourceManager.editResource('${resource.id}')" title="Edit">‚úèÔ∏è</button>
                                        <button class="resource-delete-btn" onclick="event.stopPropagation(); ResourceManager.deleteResource('${resource.id}')" title="Delete">üóëÔ∏è</button>
                                    </div>
                                </div>
                            `;
                        });
                        
                        html += '</div>';
                    }
                    
                    container.innerHTML = html;
                },
                
                showAddResourceModal() {
                    const modal = document.getElementById('add-resource-modal');
                    modal.classList.remove('hide');
                    document.getElementById('resource-title').focus();
                },
                
                hideAddResourceModal() {
                    const modal = document.getElementById('add-resource-modal');
                    modal.classList.add('hide');
                    document.getElementById('add-resource-form').reset();
                },
                
                async addResource(resourceData) {
                    console.log('üîÑ ResourceManager.addResource() called for:', resourceData.title);
                    
                    const resource = {
                        // Remove manual ID - let database auto-generate BIGSERIAL id
                        title: resourceData.title,
                        category: resourceData.category,
                        url: resourceData.url,
                        description: resourceData.description || '',
                        icon: resourceData.icon || 'üîó',
                        created_at: new Date().toISOString()
                    };
                    
                    console.log('üìù Created resource object:', { title: resource.title, category: resource.category });
                    
                    try {
                        if (cloudStorage && supabase?.isAuthenticated()) {
                            console.log('‚òÅÔ∏è Attempting to save resource to cloud...');
                            await cloudStorage.saveResource(resource);
                            console.log('‚úÖ Resource saved to cloud successfully');
                            
                            // Reload resources from cloud to get updated data with proper IDs
                            console.log('üîÑ Reloading resources to get updated list...');
                            await this.loadResources();
                            
                        } else {
                            console.log('üì± No cloudStorage/auth, generating temp ID and saving locally');
                            // Generate temporary ID for offline use
                            resource.id = 'temp_' + Date.now().toString();
                            this.resources.push(resource);
                            localStorage.setItem('resources', JSON.stringify(this.resources));
                            this.renderResources();
                        }
                        console.log('‚úÖ Resource added:', resource.title);
                    } catch (error) {
                        console.error('‚ùå Error saving resource:', error);
                        console.error('‚ùå Resource save error details:', error.message, error.stack);
                        
                        // Fallback: add with temp ID and let sync queue handle it
                        console.log('‚ö†Ô∏è Adding resource with temp ID for sync queue');
                        resource.id = 'temp_' + Date.now().toString();
                        this.resources.push(resource);
                        this.renderResources();
                    }
                },
                
                async deleteResource(resourceId) {
                    if (!confirm('Are you sure you want to delete this resource?')) {
                        return;
                    }
                    
                    this.resources = this.resources.filter(r => r.id !== resourceId);
                    
                    try {
                        if (cloudStorage) {
                            await cloudStorage.deleteResource(resourceId);
                        } else {
                            localStorage.setItem('resources', JSON.stringify(this.resources));
                        }
                        this.renderResources();
                        console.log('‚úÖ Resource deleted');
                    } catch (error) {
                        console.error('Error deleting resource:', error);
                    }
                },
                
                editResource(resourceId) {
                    const resource = this.resources.find(r => r.id === resourceId);
                    if (!resource) return;
                    
                    // Populate form with existing data
                    document.getElementById('resource-title').value = resource.title;
                    document.getElementById('resource-category').value = resource.category;
                    document.getElementById('resource-url').value = resource.url;
                    document.getElementById('resource-description').value = resource.description || '';
                    document.getElementById('resource-icon').value = resource.icon || '';
                    
                    // Mark form as editing
                    const form = document.getElementById('add-resource-form');
                    form.dataset.editId = resourceId;
                    
                    this.showAddResourceModal();
                },
                
                selectEmoji(emoji) {
                    const iconInput = document.getElementById('resource-icon');
                    if (iconInput) {
                        iconInput.value = emoji;
                    }
                },
                
                toggleEmojiInput() {
                    const iconInput = document.getElementById('resource-icon');
                    const toggleBtn = event.target;
                    
                    if (iconInput.readOnly) {
                        iconInput.readOnly = false;
                        iconInput.placeholder = 'Type emoji manually...';
                        iconInput.focus();
                        toggleBtn.textContent = 'Use emoji palette';
                    } else {
                        iconInput.readOnly = true;
                        iconInput.placeholder = 'Click emoji below or type manually';
                        toggleBtn.textContent = 'Enable manual typing';
                    }
                }
            };
            
            // Make ResourceManager global
            window.ResourceManager = ResourceManager;
            
            // === JOURNAL DELETE BUTTONS ===
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-entry-btn')) {
                    const entryId = e.target.dataset.entryId;
                    if (entryId) {
                        JournalManager.deleteEntry(entryId);
                    }
                }
            });

            // === RESOURCE EVENT LISTENERS ===
            
            // Add Resource Button
            const addResourceBtn = document.getElementById('add-resource-btn');
            if (addResourceBtn) {
                addResourceBtn.addEventListener('click', () => {
                    ResourceManager.showAddResourceModal();
                });
            }
            
            // Add Resource Form Submission
            const addResourceForm = document.getElementById('add-resource-form');
            if (addResourceForm) {
                addResourceForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const resourceData = {
                        title: document.getElementById('resource-title').value,
                        category: document.getElementById('resource-category').value,
                        url: document.getElementById('resource-url').value,
                        description: document.getElementById('resource-description').value,
                        icon: document.getElementById('resource-icon').value
                    };
                    
                    // Check if we're editing an existing resource
                    const editId = addResourceForm.dataset.editId;
                    if (editId) {
                        // Update existing resource
                        const resource = ResourceManager.resources.find(r => r.id === editId);
                        if (resource) {
                            Object.assign(resource, resourceData);
                            try {
                                if (cloudStorage) {
                                    await cloudStorage.saveResource(resource);
                                } else {
                                    localStorage.setItem('resources', JSON.stringify(ResourceManager.resources));
                                }
                                ResourceManager.renderResources();
                                console.log('‚úÖ Resource updated:', resource.title);
                            } catch (error) {
                                console.error('Error updating resource:', error);
                            }
                        }
                        // Clear edit mode
                        delete addResourceForm.dataset.editId;
                    } else {
                        // Add new resource
                        await ResourceManager.addResource(resourceData);
                    }
                    
                    ResourceManager.hideAddResourceModal();
                });
            }
            
            // Close resource modal when clicking outside
            const addResourceModal = document.getElementById('add-resource-modal');
            if (addResourceModal) {
                addResourceModal.addEventListener('click', (e) => {
                    if (e.target === addResourceModal) {
                        ResourceManager.hideAddResourceModal();
                    }
                });
            }
            
            // Load resources when Resources tab is selected  
            const ressourcenTab = document.querySelector('[data-tab="ressourcen"]');
            if (ressourcenTab) {
                ressourcenTab.addEventListener('click', () => {
                    ResourceManager.loadResources();
                });
            }
            
            // Initialize resources with sample data if empty
            document.addEventListener('DOMContentLoaded', () => {
                ResourceManager.loadResources();
                
                // Add sample resources if none exist
                setTimeout(() => {
                    if (ResourceManager.resources.length === 0) {
                        console.log('üå± Adding sample resources...');
                        const sampleResources = [
                            { title: 'Mail', category: 'Privat', url: 'https://gmail.com', icon: 'üìß', description: 'Personal email access' },
                            { title: 'MyFitnessPal', category: 'Privat', url: 'https://myfitnesspal.com', icon: 'üèÉ', description: 'Fitness tracking app' },
                            { title: 'Telegram', category: 'Privat', url: 'https://web.telegram.org', icon: 'üí¨', description: 'Telegram web client' },
                            { title: 'ChatGPT', category: 'Privat', url: 'https://chat.openai.com', icon: 'ü§ñ', description: 'AI assistant' },
                            { title: 'Sparkasse', category: 'Privat', url: 'https://sparkasse.de', icon: 'üè¶', description: 'Online banking' },
                            { title: 'Mail', category: 'Work', url: 'https://outlook.com', icon: 'üìß', description: 'Work email access' },
                            { title: 'Gartenpflege Lose', category: 'Work', url: 'https://example.com', icon: 'üå±', description: 'Garden maintenance system' },
                            { title: 'Techem', category: 'Work', url: 'https://techem.de', icon: 'üîß', description: 'Heating service portal' },
                            { title: 'BGWeb', category: 'Work', url: 'https://example.com', icon: 'üè†', description: 'Building management' },
                            { title: 'CO2', category: 'Work', url: 'https://example.com', icon: 'üìä', description: 'CO2 monitoring' },
                            { title: 'DAML Notes', category: 'Studium', url: 'https://example.com', icon: 'üìù', description: 'DAML study notes' },
                            { title: 'Teams', category: 'Studium', url: 'https://teams.microsoft.com', icon: 'üë•', description: 'Microsoft Teams' }
                        ];
                        
                        sampleResources.forEach((resourceData, index) => {
                            const resource = {
                                id: `sample_${Date.now()}_${index}`,
                                ...resourceData,
                                created_at: new Date().toISOString()
                            };
                            ResourceManager.resources.push(resource);
                        });
                        
                        localStorage.setItem('resources', JSON.stringify(ResourceManager.resources));
                        ResourceManager.renderResources();
                    }
                }, 500);
            });
            
            // === MOTIVATION MANAGER ===
            const MotivationManager = {
                cards: [],
                nextId: 1,
                initialized: false,
                currentImage: null,
                
                init() {
                    console.log('üí™ MotivationManager.init() called');
                    if (this.initialized) {
                        console.log('‚ö†Ô∏è MotivationManager already initialized, skipping...');
                        return;
                    }
                    
                    this.loadData();
                    this.setupEventListeners();
                    this.renderCards();
                    this.initialized = true;
                    console.log('‚úÖ MotivationManager initialization complete');
                },
                
                setupEventListeners() {
                    console.log('üéß Setting up MotivationManager event listeners...');
                    
                    // Add motivation button
                    const addBtn = document.getElementById('add-motivation-btn');
                    if (addBtn) {
                        addBtn.addEventListener('click', () => this.showAddModal());
                    }
                    
                    // Modal event listeners
                    this.setupModalListeners();
                    
                    // Card delete listeners (event delegation)
                    document.addEventListener('click', (e) => {
                        if (e.target.matches('.motivation-delete-btn')) {
                            e.stopPropagation();
                            const card = e.target.closest('.motivation-card');
                            if (card) {
                                const cardId = parseInt(card.getAttribute('data-id'));
                                this.deleteCard(cardId);
                            }
                        }
                    });
                },
                
                setupModalListeners() {
                    const modal = document.getElementById('add-motivation-modal');
                    const closeBtn = document.getElementById('close-motivation-modal');
                    const cancelBtn = document.getElementById('cancel-motivation-btn');
                    const saveBtn = document.getElementById('save-motivation-btn');
                    const uploadArea = document.getElementById('motivation-upload-area');
                    const fileInput = document.getElementById('motivation-image-input');
                    
                    // Close modal events
                    if (closeBtn) {
                        closeBtn.addEventListener('click', () => {
                            console.log('üñ±Ô∏è Close button clicked');
                            this.hideAddModal();
                        });
                    }
                    
                    if (cancelBtn) {
                        cancelBtn.addEventListener('click', () => {
                            console.log('üñ±Ô∏è Cancel button clicked');
                            this.hideAddModal();
                        });
                    }
                    
                    // Close on background click
                    modal?.addEventListener('click', (e) => {
                        if (e.target === modal) this.hideAddModal();
                    });
                    
                    // Save button
                    saveBtn?.addEventListener('click', () => this.saveCard());
                    
                    // File upload area
                    uploadArea?.addEventListener('click', () => fileInput?.click());
                    
                    // File input change
                    fileInput?.addEventListener('change', (e) => this.handleModalImageUpload(e));
                    
                    // Drag and drop
                    uploadArea?.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        uploadArea.classList.add('dragover');
                    });
                    
                    uploadArea?.addEventListener('dragleave', () => {
                        uploadArea.classList.remove('dragover');
                    });
                    
                    uploadArea?.addEventListener('drop', (e) => {
                        e.preventDefault();
                        uploadArea.classList.remove('dragover');
                        const file = e.dataTransfer.files[0];
                        if (file && file.type.startsWith('image/')) {
                            this.processImage(file);
                        }
                    });
                },
                
                showAddModal() {
                    console.log('üñ±Ô∏è showAddModal called');
                    const modal = document.getElementById('add-motivation-modal');
                    if (modal) {
                        modal.style.display = 'flex';
                        modal.style.alignItems = 'center';
                        modal.style.justifyContent = 'center';
                        this.resetModalForm();
                        console.log('‚úÖ Modal should now be visible');
                    } else {
                        console.error('‚ùå Modal element not found!');
                    }
                },
                
                hideAddModal() {
                    console.log('üñ±Ô∏è hideAddModal called');
                    const modal = document.getElementById('add-motivation-modal');
                    if (modal) {
                        modal.style.display = 'none';
                        this.resetModalForm();
                        console.log('‚úÖ Modal should now be hidden');
                    } else {
                        console.error('‚ùå Modal element not found!');
                    }
                },
                
                resetModalForm() {
                    document.getElementById('motivation-title-input').value = '';
                    document.getElementById('motivation-quote-input').value = '';
                    document.getElementById('motivation-preview').style.display = 'none';
                    document.querySelector('.upload-placeholder').style.display = 'flex';
                    this.currentImage = null;
                },
                
                saveCard() {
                    const title = document.getElementById('motivation-title-input').value.trim();
                    const quote = document.getElementById('motivation-quote-input').value.trim();
                    
                    if (!title) {
                        alert('Bitte gib einen Titel ein');
                        return;
                    }
                    
                    if (!this.currentImage) {
                        alert('Bitte w√§hle ein Bild aus');
                        return;
                    }
                    
                    const newCard = {
                        id: this.nextId++,
                        title: title,
                        quote: quote,
                        image: this.currentImage,
                        created: new Date().toISOString()
                    };
                    
                    this.cards.push(newCard);
                    this.renderCards();
                    this.saveData();
                    this.hideAddModal();
                    
                    console.log('‚úÖ Created new motivation card:', newCard.id);
                },
                
                deleteCard(cardId) {
                    const card = this.cards.find(c => c.id === cardId);
                    if (card && confirm(`"${card.title}" l√∂schen?`)) {
                        this.cards = this.cards.filter(c => c.id !== cardId);
                        this.renderCards();
                        this.saveData();
                        console.log('üóëÔ∏è Deleted motivation card:', cardId);
                    }
                },
                
                handleModalImageUpload(event) {
                    const file = event.target.files[0];
                    if (file) {
                        this.processImage(file);
                    }
                },
                
                processImage(file) {
                    console.log(`üìÅ Processing file: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                    
                    // Validate file type
                    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
                    if (!allowedTypes.includes(file.type)) {
                        alert('Bitte w√§hle ein Bild (JPG, PNG, GIF oder WebP)');
                        return;
                    }
                    
                    // Check file size (max 5MB)
                    if (file.size > 5 * 1024 * 1024) {
                        alert('Bild zu gro√ü! Maximum 5MB erlaubt.');
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.currentImage = e.target.result;
                        this.showImagePreview(e.target.result);
                        console.log('üì∏ Image processed successfully');
                    };
                    reader.onerror = () => {
                        console.error('‚ùå Error reading file');
                        alert('Fehler beim Laden des Bildes');
                    };
                    reader.readAsDataURL(file);
                },
                
                showImagePreview(imageSrc) {
                    const preview = document.getElementById('motivation-preview');
                    const placeholder = document.querySelector('.upload-placeholder');
                    
                    preview.src = imageSrc;
                    preview.style.display = 'block';
                    placeholder.style.display = 'none';
                },
                
                renderCards() {
                    const container = document.getElementById('motivation-container');
                    if (!container) return;
                    
                    container.innerHTML = '';
                    
                    if (this.cards.length === 0) {
                        container.innerHTML = `
                            <div style="grid-column: 1 / -1; text-align: center; padding: 3rem; color: #666666;">
                                <span style="font-size: 3rem; display: block; margin-bottom: 1rem;">üí™</span>
                                <p>Noch keine Motivationen erstellt</p>
                                <p style="font-size: 0.9rem;">Klicke auf "Add Motivation" um zu beginnen</p>
                            </div>
                        `;
                        return;
                    }
                    
                    this.cards.forEach(card => {
                        const cardElement = this.createCardElement(card);
                        container.appendChild(cardElement);
                    });
                    
                    console.log(`üé® Rendered ${this.cards.length} motivation cards`);
                },
                
                createCardElement(card) {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'motivation-card';
                    cardDiv.setAttribute('data-id', card.id);
                    
                    cardDiv.innerHTML = `
                        <div class="motivation-image-container">
                            <img class="motivation-image" src="${card.image}" alt="${card.title}">
                            <button class="motivation-delete-btn" title="L√∂schen">√ó</button>
                        </div>
                        <div class="motivation-content">
                            <h3 class="motivation-title">${card.title}</h3>
                            ${card.quote ? `<p class="motivation-quote">"${card.quote}"</p>` : ''}
                        </div>
                    `;
                    
                    return cardDiv;
                },
                
                
                loadData() {
                    try {
                        const cached = localStorage.getItem('motivation_cards');
                        if (cached) {
                            const data = JSON.parse(cached);
                            this.cards = data.cards || [];
                            this.nextId = data.nextId || 1;
                            console.log('üìã Loaded', this.cards.length, 'motivation cards');
                        } else {
                            this.cards = [];
                            this.nextId = 1;
                            console.log('üìã Starting with empty motivation cards');
                        }
                    } catch (error) {
                        console.error('‚ùå Error loading motivation data:', error);
                        this.cards = [];
                        this.nextId = 1;
                    }
                },
                
                saveData() {
                    try {
                        const data = {
                            cards: this.cards,
                            nextId: this.nextId
                        };
                        const dataString = JSON.stringify(data);
                        const sizeInKB = (dataString.length / 1024).toFixed(2);
                        const sizeInMB = (dataString.length / (1024 * 1024)).toFixed(2);
                        
                        localStorage.setItem('motivation_cards', dataString);
                        console.log(`üíæ Motivation cards saved (${sizeInKB}KB / ${sizeInMB}MB, ${this.cards.length} cards)`);
                        
                        // Check total storage usage
                        let totalSize = 0;
                        let itemCount = 0;
                        for (let key in localStorage) {
                            if (localStorage.hasOwnProperty(key)) {
                                totalSize += localStorage[key].length;
                                itemCount++;
                            }
                        }
                        const totalKB = (totalSize / 1024).toFixed(2);
                        const totalMB = (totalSize / (1024 * 1024)).toFixed(2);
                        console.log(`üìä Total localStorage: ${itemCount} items, ${totalKB}KB / ${totalMB}MB`);
                        
                        // Warn if approaching 5MB localStorage limit
                        if (totalSize > 4 * 1024 * 1024) {
                            console.warn('‚ö†Ô∏è Approaching localStorage limit (5MB)');
                        }
                        
                    } catch (error) {
                        console.error('‚ùå Error saving motivation data:', error);
                        if (error.name === 'QuotaExceededError') {
                            alert('Speicher voll! Bitte l√∂sche einige Bilder um Platz zu schaffen.');
                        }
                    }
                },
                
                autoSave() {
                    clearTimeout(this.saveTimeout);
                    this.saveTimeout = setTimeout(() => {
                        this.saveData();
                        console.log('üîÑ Motivation cards auto-saved');
                    }, 1000);
                }
            };
            
            // Make MotivationManager globally available
            window.MotivationManager = MotivationManager;
            
            // MotivationManager will be initialized when switching to motivation tab
            
            // Fallback: Direct event listener for add button
            setTimeout(() => {
                const fallbackBtn = document.getElementById('add-motivation-btn');
                if (fallbackBtn && !fallbackBtn.hasAttribute('data-listener-added')) {
                    console.log('üîß Adding fallback event listener to add button');
                    fallbackBtn.setAttribute('data-listener-added', 'true');
                    fallbackBtn.addEventListener('click', function() {
                        console.log('üñ±Ô∏è Fallback: Add motivation button clicked!');
                        if (window.MotivationManager && window.MotivationManager.addCard) {
                            window.MotivationManager.addCard();
                        } else {
                            console.error('‚ùå MotivationManager or addCard method not available');
                        }
                    });
                }
            }, 500);
            
            // === SIMPLE LOGOUT (URL-based) ===
            console.log('‚úÖ Logout is now URL-based, no JavaScript needed');
            
            // === EMERGENCY MODAL CLOSE ===
            // Add global event listeners to force-close any visible modals
            document.addEventListener('DOMContentLoaded', function() {
                console.log('üö® Emergency modal close system activated');
                
                // Force hide modal on page load
                const modal = document.getElementById('add-motivation-modal');
                if (modal) {
                    modal.style.display = 'none';
                    console.log('üîí Modal force-hidden on page load');
                }
                
                // Global ESC key listener
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape') {
                        const modal = document.getElementById('add-motivation-modal');
                        if (modal && modal.style.display !== 'none') {
                            modal.style.display = 'none';
                            console.log('üîë Modal closed via ESC key');
                        }
                    }
                });
                
                // Global click listener for modal close buttons
                document.addEventListener('click', function(e) {
                    // Close button or cancel button
                    if (e.target.id === 'close-motivation-modal' || 
                        e.target.id === 'cancel-motivation-btn') {
                        const modal = document.getElementById('add-motivation-modal');
                        if (modal) {
                            modal.style.display = 'none';
                            console.log('üñ±Ô∏è Modal closed via button click');
                        }
                    }
                    
                    // Background click
                    if (e.target.id === 'add-motivation-modal') {
                        e.target.style.display = 'none';
                        console.log('üñ±Ô∏è Modal closed via background click');
                    }
                });
            });
            
            // === ROUTINE RESET FUNCTIONALITY ===
            // Use event delegation to catch button clicks even if tab is loaded later
            document.addEventListener('click', async function(e) {
                if (e.target && e.target.id === 'reset-routines-btn') {
                    console.log('üñ±Ô∏è Reset routines button clicked');
                    
                    const confirmed = confirm(
                        '‚ö†Ô∏è ACHTUNG: Routine-Datenbank komplett zur√ºcksetzen?\n\n' +
                        '‚Ä¢ L√∂scht ALLE Routine-Daten (lokal und cloud)\n' +
                        '‚Ä¢ Setzt alle Counter auf 0\n' +
                        '‚Ä¢ Betrifft alle Ger√§te\n' +
                        '‚Ä¢ Kann nicht r√ºckg√§ngig gemacht werden\n\n' +
                        'Fortfahren?'
                    );
                    
                    if (confirmed) {
                        console.log('‚úÖ User confirmed reset');
                        const success = await resetRoutineDatabase();
                        if (success) {
                            alert('‚úÖ Routine-Datenbank wurde komplett zur√ºckgesetzt!\n\nBitte refreshe die Seite auf allen Ger√§ten.');
                            window.location.reload();
                        } else {
                            alert('‚ùå Fehler beim Zur√ºcksetzen. Bitte Console pr√ºfen.');
                        }
                    } else {
                        console.log('‚ùå User cancelled reset');
                    }
                }
            });
            
            // Complete Routine Database Reset Function
            async function resetRoutineDatabase() {
                console.log('üîÑ Starting complete routine database reset...');
                
                try {
                    // 1. Clear all localStorage routine data (old and new)
                    const keysToRemove = [
                        'routineCompletionData',
                        'routine_completions_cache', 
                        'monthlyRoutineCompletions',
                        'routineData',
                        'lastRoutineResetDate',
                        'routineResetTime',
                        'morningRoutineStreak',
                        'eveningRoutineStreak',
                        'simple_routine_data' // New system
                    ];
                    
                    keysToRemove.forEach(key => {
                        if (localStorage.getItem(key)) {
                            localStorage.removeItem(key);
                            console.log(`üóëÔ∏è Removed localStorage: ${key}`);
                        }
                    });
                    
                    // 2. Clear Supabase tables if authenticated
                    if (window.supabase && window.supabase.isAuthenticated()) {
                        const user = window.supabase.getCurrentUser();
                        console.log('üîÑ Clearing cloud routine data for user:', user.email);
                        
                        try {
                            // Delete old system data
                            await window.supabase.delete('routine_completions', `user_id=eq.${user.id}`);
                            console.log('‚úÖ Cleared old routine_completions table');
                            
                            // Delete new system data
                            await window.supabase.delete('simple_routines', `user_id=eq.${user.id}`);
                            console.log('‚úÖ Cleared new simple_routines table');
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Could not clear cloud data:', error);
                        }
                    }
                    
                    // 3. Reset routine checkboxes on page
                    const morningCheckboxes = document.querySelectorAll('#morning-routine input[type="checkbox"]');
                    const eveningCheckboxes = document.querySelectorAll('#evening-routine input[type="checkbox"]');
                    
                    [...morningCheckboxes, ...eveningCheckboxes].forEach(checkbox => {
                        checkbox.checked = false;
                        const label = checkbox.nextElementSibling;
                        if (label) {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    });
                    console.log('‚úÖ Reset all routine checkboxes');
                    
                    // 4. Reset routine counters to 0
                    const streakTiles = document.querySelectorAll('.streak-tile');
                    if (streakTiles.length >= 2) {
                        const morningTile = streakTiles[0];
                        const eveningTile = streakTiles[1];
                        
                        const morningNumber = morningTile?.querySelector('.streak-number');
                        const eveningNumber = eveningTile?.querySelector('.streak-number');
                        
                        if (morningNumber) morningNumber.textContent = '0';
                        if (eveningNumber) eveningNumber.textContent = '0';
                        
                        console.log('‚úÖ Reset routine counters to 0');
                    }
                    
                    // 5. Reset new simple routine manager if available
                    if (window.simpleRoutineManager) {
                        await window.simpleRoutineManager.reset();
                        console.log('‚úÖ Reset SimpleRoutineManager');
                    }
                    
                    console.log('üéâ Routine database reset complete!');
                    console.log('üìù All routine data has been cleared and counters reset');
                    console.log('üîÑ Refresh the page to ensure clean state across devices');
                    
                    return true;
                    
                } catch (error) {
                    console.error('‚ùå Error during routine reset:', error);
                    return false;
                }
            }
            
            // === DEBUG ROUTINE SYSTEM ===
            window.debugRoutineSystem = function() {
                console.log('üîç ROUTINE SYSTEM DEBUG');
                console.log('======================');
                
                // Check localStorage
                const simpleData = localStorage.getItem('simple_routine_data');
                console.log('üì± simple_routine_data:', simpleData ? JSON.parse(simpleData) : 'NOT FOUND');
                
                const oldData = localStorage.getItem('routineCompletionData');
                console.log('üì± routineCompletionData (old):', oldData ? JSON.parse(oldData) : 'NOT FOUND');
                
                // Check SimpleRoutineManager
                if (window.simpleRoutineManager) {
                    console.log('‚úÖ SimpleRoutineManager exists');
                    console.log('üìä Current data:', window.simpleRoutineManager.routineData);
                    console.log('üìÖ Today:', window.simpleRoutineManager.today);
                } else {
                    console.log('‚ùå SimpleRoutineManager NOT FOUND');
                }
                
                // Check checkboxes
                const morningCheckboxes = document.querySelectorAll('#morning-routine input[type="checkbox"]');
                const eveningCheckboxes = document.querySelectorAll('#evening-routine input[type="checkbox"]');
                
                console.log('üåÖ Morning checkboxes:');
                morningCheckboxes.forEach(cb => {
                    const label = cb.nextElementSibling;
                    console.log(`- ${cb.id}: checked=${cb.checked}, strikethrough=${label?.style?.textDecoration || 'none'}`);
                });
                
                console.log('üåô Evening checkboxes:');
                eveningCheckboxes.forEach(cb => {
                    const label = cb.nextElementSibling;
                    console.log(`- ${cb.id}: checked=${cb.checked}, strikethrough=${label?.style?.textDecoration || 'none'}`);
                });
                
                // Check counters
                const streakTiles = document.querySelectorAll('.streak-tile');
                console.log('üìä Counter tiles:');
                streakTiles.forEach((tile, index) => {
                    const number = tile.querySelector('.streak-number');
                    const label = tile.querySelector('.streak-label');
                    console.log(`- Tile ${index}: ${label?.textContent} = ${number?.textContent}`);
                });
                
                alert('Debug info logged to console - press F12 to see details');
            };
            
            // === GLOBAL ROUTINE RESET HANDLER ===
            window.handleRoutineReset = async function() {
                console.log('üñ±Ô∏è handleRoutineReset called via onclick');
                
                const confirmed = confirm(
                    '‚ö†Ô∏è ACHTUNG: Routine-Datenbank komplett zur√ºcksetzen?\n\n' +
                    '‚Ä¢ L√∂scht ALLE Routine-Daten (lokal und cloud)\n' +
                    '‚Ä¢ Setzt alle Counter auf 0\n' +
                    '‚Ä¢ Betrifft alle Ger√§te\n' +
                    '‚Ä¢ Kann nicht r√ºckg√§ngig gemacht werden\n\n' +
                    'Fortfahren?'
                );
                
                if (confirmed) {
                    console.log('‚úÖ User confirmed reset');
                    const success = await resetRoutineDatabase();
                    if (success) {
                        alert('‚úÖ Routine-Datenbank wurde komplett zur√ºckgesetzt!\n\nBitte refreshe die Seite auf allen Ger√§ten.');
                        window.location.reload();
                    } else {
                        alert('‚ùå Fehler beim Zur√ºcksetzen. Bitte Console pr√ºfen.');
                    }
                } else {
                    console.log('‚ùå User cancelled reset');
                }
            };
            
            // Mobile debug removed for cleaner console output
        });
    </script>
</body>
</html>