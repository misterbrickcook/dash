<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-eval' 'unsafe-inline' https://unpkg.com https://cdn.jsdelivr.net; object-src 'none'; base-uri 'self';">
    <title>DASHBOARD v2.3</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22 font-family=%22-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif%22 font-weight=%22700%22 fill=%22%23000000%22>A</text></svg>">
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        /* === RESET & BASE === */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #000000;
            line-height: 1.6;
            padding-top: 80px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* === STICKY NAVIGATION === */
        .sticky-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #ffffff;
            border-bottom: 1px solid #e0e0e0;
            z-index: 1000;
            padding: 1rem 0;
        }
        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 3rem;
            position: relative;
        }
        .nav-tab {
            text-decoration: none;
            color: #666666;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.5rem 1rem;
            border: 1px solid transparent;
            transition: all 0.2s ease;
            cursor: pointer;
            background: none;
            font-family: inherit;
        }
        .nav-tab:hover { border-color: #000000; color: #000000; }
        .nav-tab.active {
            color: #000000;
            font-weight: 700;
            border: 1px solid transparent;
            background: transparent;
        }
        
        /* === LOGOUT & SETTINGS BUTTONS === */
        .nav-actions {
            position: absolute;
            right: 0;
            display: flex;
            gap: 0.25rem;
            align-items: center;
        }
        
        .logout-btn, .settings-btn, .timer-btn, .quick-add-btn {
            color: #666666 !important;
            font-weight: 400 !important;
            background: transparent !important;
            border: none !important;
            border-color: transparent !important;
            outline: none !important;
            cursor: pointer !important;
            pointer-events: auto !important;
            position: relative !important;
            z-index: 1000 !important;
            box-shadow: none !important;
            text-transform: none !important;
            letter-spacing: normal !important;
            padding: 0.5rem 1rem !important;
        }
        
        /* Mobile-safe hover states - override nav-tab hover */
        .logout-btn:hover, .settings-btn:hover, .timer-btn:hover, .quick-add-btn:hover,
        .logout-btn:active, .settings-btn:active, .timer-btn:active, .quick-add-btn:active,
        .logout-btn:focus, .settings-btn:focus, .timer-btn:focus, .quick-add-btn:focus {
            background: transparent !important;
            border: none !important;
            border-color: transparent !important;
        }
        
        /* Specific override for nav-tab hover border */
        .nav-tab.logout-btn:hover, .nav-tab.settings-btn:hover, .nav-tab.timer-btn:hover, .nav-tab.quick-add-btn:hover {
            border: none !important;
            border-color: transparent !important;
            background: transparent !important;
        }
        
        /* Override conflicting nav-tab hover rules for quick-add */
        .nav-tab.quick-add-btn:hover {
            border-color: transparent !important;
        }
        
        .logout-btn:hover span, .logout-btn:active span, .logout-btn:focus span,
        .logout-btn:hover svg, .logout-btn:active svg, .logout-btn:focus svg {
            color: #dc2626 !important;
            stroke: #dc2626 !important;
        }
        
        /* Timer button specific styles */
        .timer-btn.timer-running {
            color: #059669 !important;
        }
        .timer-btn.timer-running i {
            stroke: #059669 !important;
            animation: pulse 2s infinite;
        }
        .timer-btn.timer-paused {
            color: #d97706 !important;
        }
        .timer-btn.timer-paused i {
            stroke: #d97706 !important;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Quick-add button - JavaScript only approach */
        .nav-tab.quick-add-btn i {
            transition: transform 0.3s ease !important;
            will-change: transform !important;
        }
        
        .settings-btn:hover span, .settings-btn:active span, .settings-btn:focus span,
        .settings-btn:hover i, .settings-btn:active i, .settings-btn:focus i {
            color: #059669 !important;
            stroke: #059669 !important;
        }
        
        .timer-btn:hover i, .timer-btn:active i, .timer-btn:focus i {
            stroke: #059669 !important;
            color: #059669 !important;
        }
        
        /* Force reset any stuck hover states on mobile */
        @media (max-width: 768px) {
            .logout-btn span {
                color: #666666 !important;
            }
            .logout-btn:hover span {
                color: #dc2626 !important;
            }
        }
        
        .logout-btn span, .settings-btn span {
            font-size: 1.2rem;
            pointer-events: none !important;
        }

        /* === SETTINGS PAGE === */
        .settings-container {
            max-width: 600px;
            margin: 0 auto;
        }
        
        .setting-group {
            background: #f8f9fa;
            padding: 2rem;
            margin-bottom: 2rem;
            border-radius: 12px;
            border: 1px solid #e0e0e0;
        }
        
        .setting-group h3 {
            margin: 0 0 1.5rem 0;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .setting-item:last-child {
            margin-bottom: 0;
        }
        
        .setting-item label {
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .setting-item input[type="time"] {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            max-width: 200px;
        }
        
        .setting-description {
            font-size: 0.85rem;
            color: #666666;
            margin-top: 0.25rem;
        }
        
        .btn-secondary {
            background: #6b7280 !important;
        }
        
        .btn-secondary:hover {
            background: #4b5563 !important;
        }

        /* === MAIN CONTENT === */
        .main-content { padding: 0 20px 40px 20px; }
        .tab-section { display: none; }
        .tab-section.active { display: block; }

        /* === SHARED COMPONENTS === */
        .section-title {
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 3rem;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 1rem;
        }
        .card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            transition: border-color 0.2s ease;
        }
        .card:hover { border-color: #000000; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 3rem; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2rem; }
        .btn {
            padding: 0.75rem 1.5rem;
            border: 1px solid #000000;
            background: #ffffff;
            color: #000000;
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-block;
        }
        .btn:hover { background: #000000; color: #ffffff; }
        .btn.secondary { border-color: #e0e0e0; color: #666666; }
        .btn.secondary:hover { border-color: #000000; background: #f0f0f0; color: #000000; }

        /* === CHECKBOX COMPONENT === */
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .checkbox-item.todo-item {
            justify-content: space-between;
            width: 100%;
        }
        .checkbox-item.todo-item .todo-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
            min-width: 0; /* Allow shrinking */
        }
        .checkbox-item.todo-item .todo-time {
            font-size: 0.85rem;
            color: #666;
            font-weight: 500;
            flex-shrink: 0;
            margin-left: 1rem;
            text-align: right;
        }
        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            border: 2px solid #000000;
            appearance: none;
            cursor: pointer;
            flex-shrink: 0;
        }
        .checkbox-item input[type="checkbox"]:checked {
            background-color: #000000;
            position: relative;
        }
        .checkbox-item input[type="checkbox"]:checked::after {
            content: '✓';
            color: white;
            position: absolute;
            top: -2px;
            left: 2px;
            font-size: 12px;
        }
        .checkbox-item label {
            font-size: 0.95rem;
            cursor: pointer;
            line-height: 1.4;
        }

        /* === PROGRESS BAR === */
        .progress-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .progress-bar {
            flex: 1;
            height: 8px;
            background-color: #f0f0f0;
            border: 1px solid #e0e0e0;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: #000000;
            transition: width 0.3s ease;
        }

        /* === STREAK TILES === */
        .streak-overview {
            margin-bottom: 3rem;
        }
        .streak-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2rem;
        }
        .streak-tile {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            text-align: center;
            transition: border-color 0.2s ease;
        }
        .streak-tile:hover {
            border-color: #000000;
        }
        .streak-number {
            font-size: 3rem;
            font-weight: 300;
            color: #000000;
            margin-bottom: 0.5rem;
            line-height: 1;
        }
        .streak-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }
        .streak-date {
            font-size: 0.8rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* === ROUTINE SPECIFIC === */
        .routine-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
            margin-bottom: 4rem;
            height: auto;
            min-height: 300px;
        }
        .routine-section {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            min-height: 250px;
        }
        .routine-section h2 {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .routine-section .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex: 1;
            margin-bottom: 1rem;
        }

        /* === TODO SPECIFIC === */
        .category-tabs {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 3rem;
        }
        .category-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .category-tab:hover { border-color: #000000; color: #000000; }
        .category-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        
        .badge {
            background: #dc2626;
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 4px;
            min-width: 16px;
            text-align: center;
        }
        .category-content { display: none; }
        .category-content.active { display: block; }
        
        /* === ZIELE SPECIFIC TABS === */
        .ziel-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .ziel-tab:hover { border-color: #000000; color: #000000; }
        .ziel-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .ziel-content { display: none; }
        
        /* === RESOURCE TABS === */
        .resource-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .resource-tab:hover { border-color: #000000; color: #000000; }
        .resource-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .resource-content { display: none; }
        .resource-content.active { display: block; }
        .ziel-content.active { display: block; }
        
        /* === JOURNAL SPECIFIC TABS === */
        .journal-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .journal-tab:hover { border-color: #000000; color: #000000; }
        .journal-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .journal-content { display: none; }
        .journal-content.active { display: block; }
        
        /* === TAG SELECTION === */
        .tag-option {
            padding: 0.5rem 1rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            color: #666666;
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .tag-option:hover { border-color: #000000; color: #000000; }
        .tag-option.selected {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .tag-option .remove-tag {
            cursor: pointer;
            font-size: 1rem;
            opacity: 0.8;
            display: none;
        }
        .tag-option.selected .remove-tag {
            display: inline;
        }
        .tag-option .remove-tag:hover {
            opacity: 1;
        }
        .todo-section {
            margin-bottom: 2rem;
        }
        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .section-header h3 {
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #444444;
        }
        .section-divider {
            flex: 1;
            height: 1px;
            background: #e0e0e0;
        }
        .section-count {
            font-size: 0.8rem;
            color: #666666;
            background: #f0f0f0;
            padding: 0.25rem 0.75rem;
            border: 1px solid #e0e0e0;
        }
        .todo-item {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: border-color 0.2s ease;
        }
        .todo-item:hover { border-color: #000000; }
        .todo-item.completed { opacity: 0.6; background: #fafafa; }
        .todo-item.completed .todo-title { text-decoration: line-through; }
        .todo-header {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }
        .todo-content { flex: 1; }
        .todo-title {
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }
        .todo-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .todo-deadline {
            font-size: 0.8rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .todo-deadline.today { color: #000000; font-weight: 500; }
        .todo-deadline.overdue { color: #cc0000; font-weight: 500; }
        .todo-deadline.soon { color: #ff6600; font-weight: 500; }
        
        /* Days until badge (similar to termine) */
        .days-until-badge {
            display: inline-block;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-left: 0.5rem;
        }
        .days-until-badge.heute {
            background: #000000;
            color: #ffffff;
        }
        .days-until-badge.morgen {
            background: #ff6600;
            color: #ffffff;
        }
        .days-until-badge.future {
            background: #3b82f6;
            color: #ffffff;
        }
        .days-until-badge.overdue {
            background: #cc0000;
            color: #ffffff;
        }
        
        .todo-tag {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.25rem 0.75rem;
            border: 1px solid;
            color: #ffffff;
            font-weight: 500;
        }
        .todo-tag.wichtig { background-color: #ff6600; border-color: #ff6600; }
        .todo-tag.dringend { background-color: #cc0000; border-color: #cc0000; }
        .todo-tag.normal { background-color: #666666; border-color: #666666; }

        /* === ZIELE SPECIFIC === */
        .ziel-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 200px;
        }
        .ziel-kategorie {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666666;
            border: 1px solid #e0e0e0;
            padding: 0.2rem 0.5rem;
            background: #fafafa;
            white-space: nowrap;
        }
        .ziel-header {
            margin-bottom: 1rem;
            margin-right: 6rem;
        }
        .ziel-name {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }
        .ziel-beschreibung {
            font-size: 0.9rem;
            color: #666666;
            line-height: 1.5;
            margin-bottom: 2rem;
        }
        .ziel-progress-section { margin-top: auto; }
        .ziel-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .ziel-progress-label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #444444;
        }
        .ziel-percentage {
            font-size: 1rem;
            font-weight: 500;
        }

        /* === JOURNAL SPECIFIC === */
        .quick-journal {
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            margin-bottom: 3rem;
        }
        .quick-journal h2 {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .journal-form {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        .journal-input {
            flex: 1;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .journal-input:focus { outline: none; border-color: #000000; }
        .journal-entry {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            margin-bottom: 2rem;
        }
        .journal-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1.5rem;
            gap: 1rem;
        }
        .journal-date {
            font-size: 1rem;
            font-weight: 500;
            color: #000000;
        }
        .journal-kategorie {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666666;
            border: 1px solid #e0e0e0;
            padding: 0.4rem 1rem;
            background: #fafafa;
        }
        .journal-content {
            font-size: 0.95rem;
            line-height: 1.7;
            color: #333333;
        }

        /* === TERMINE SPECIFIC === */
        .termin-card {
            position: relative;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 0;
            padding: 1.5rem;
            box-shadow: none;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .termin-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        }
        
        /* Base styling for days badges - dezent und rechteckig wie Kategorien */
        .termin-days-until, .ziel-days-until {
            position: absolute !important;
            top: 0.5rem !important;
            background: #fafafa !important;
            color: #666666 !important;
            padding: 0.2rem 0.5rem !important;
            border: 1px solid #e0e0e0 !important;
            font-size: 0.65rem !important;
            font-weight: 500 !important;
            text-transform: uppercase !important;
            letter-spacing: 0.1em !important;
            white-space: nowrap !important;
        }
        
        /* Termine: Rechtsbündig */
        .termin-days-until {
            right: 0.5rem !important;
        }
        
        /* Ziele: Mittig */
        .ziel-days-until {
            left: 50% !important;
            transform: translateX(-50%) !important;
        }
        
        /* === RESSOURCEN GRID === */
        .resource-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 200px));
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: start;
        }
        
        .resource-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 0.75rem;
            position: relative;
            transition: all 0.2s ease;
            height: 50px;
            display: flex;
            align-items: center;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .resource-card:hover {
            border-color: #000000;
            background: #f8f8f8;
        }
        
        .resource-icon {
            margin-right: 0.5rem;
            flex-shrink: 0;
            display: flex;
            align-items: center;
        }
        
        .resource-title {
            font-size: 0.85rem;
            font-weight: 500;
            color: #000000;
            margin: 0;
            flex: 1;
            line-height: 1.2;
        }
        
        
        /* === EMOJI PALETTE === */
        .emoji-palette {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 0.25rem;
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            position: relative;
            z-index: 1;
        }
        
        .emoji-btn {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 0.25rem;
            cursor: pointer;
            font-size: 1rem;
            border-radius: 2px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 28px;
            width: 28px;
        }
        
        .emoji-btn:hover {
            background: #000000;
            border-color: #000000;
            transform: scale(1.1);
        }
        
        .btn-link {
            background: none;
            border: none;
            color: #666666;
            cursor: pointer;
            text-decoration: underline;
            font-family: inherit;
        }
        
        .btn-link:hover {
            color: #000000;
        }
        
        .resource-footer {
            margin-top: auto;
            padding-top: 1rem;
            border-top: 1px solid #f0f0f0;
        }
        
        .resource-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #000000;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            padding: 0.5rem 1rem;
            border: 1px solid #e0e0e0;
            transition: all 0.2s ease;
        }
        
        .resource-link:hover {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
        }
        
        .resource-actions {
            position: absolute;
            top: 0.4rem;
            right: 0.4rem;
            display: flex;
            gap: 0.2rem;
            opacity: 1;
            transition: opacity 0.2s ease;
            z-index: 10;
        }
        
        .resource-card:hover .resource-actions {
            opacity: 1;
        }
        
        .resource-edit-btn,
        .resource-delete-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #333333;
            cursor: pointer;
            padding: 0.25rem;
            transition: all 0.2s ease;
            border-radius: 4px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        
        
        .resource-delete-btn:hover {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }
        
        .resource-edit-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.3);
            color: #3b82f6;
        }
        
        .resource-edit-btn:hover i,
        .resource-delete-btn:hover i {
            stroke: currentColor;
        }
        
        /* === RESOURCE CATEGORIES (bsp1.jpg style) === */
        .resource-category-section {
            margin-bottom: 3rem;
        }
        
        .resource-category-title {
            font-size: 1.8rem;
            font-weight: 300;
            color: #000000;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .resource-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
        }
        
        .resource-button {
            background: #333333;
            border: 1px solid #555555;
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            text-decoration: none;
            min-width: 140px;
            justify-content: flex-start;
        }
        
        .resource-button:hover {
            background: #444444;
            border-color: #666666;
            transform: translateY(-1px);
        }
        
        .resource-icon {
            font-size: 1rem;
            margin-right: 0.25rem;
        }
        
        .resource-name {
            flex: 1;
            text-align: left;
        }
        
        .resource-button .resource-actions {
            position: absolute;
            top: -0.25rem;
            right: -0.25rem;
            display: flex;
            gap: 0.125rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .resource-button:hover .resource-actions {
            opacity: 1;
        }
        
        .resource-button .resource-edit-btn,
        .resource-button .resource-delete-btn {
            background: rgba(0, 0, 0, 0.8);
            border: none;
            color: #ffffff;
            padding: 0.25rem;
            font-size: 0.7rem;
            border-radius: 2px;
            cursor: pointer;
            opacity: 1;
        }
        
        .resource-button .resource-delete-btn:hover {
            background: #cc0000;
        }
        
        .resource-button .resource-edit-btn:hover {
            background: #007acc;
        }
        
        .termin-date {
            font-size: 0.8rem;
            color: #64748b;
            font-weight: 500;
            margin-bottom: 0.75rem;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .termin-date::before {
            content: '📅';
            font-size: 0.9rem;
        }
        
        .termin-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #1e293b;
            line-height: 1.3;
        }
        
        .termin-description {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #64748b;
            margin-bottom: 1rem;
        }
        
        .termin-edit-icon, .termin-delete-icon {
            position: absolute !important;
            bottom: 1rem !important;
            width: 32px !important;
            height: 32px !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 0.85rem !important;
            transition: all 0.2s ease !important;
            cursor: pointer !important;
        }
        
        .termin-edit-icon {
            right: 3.5rem !important;
            background: rgba(59, 130, 246, 0.1) !important;
            color: #3b82f6 !important;
            top: auto !important;
        }
        
        .termin-edit-icon:hover {
            background: #3b82f6 !important;
            color: white !important;
            transform: scale(1.1) !important;
        }
        
        .termin-delete-icon {
            right: 1rem !important;
            background: rgba(239, 68, 68, 0.1) !important;
            color: #ef4444 !important;
            top: auto !important;
        }
        
        .termin-delete-icon:hover {
            background: #ef4444 !important;
            color: white !important;
            transform: scale(1.1) !important;
        }

        /* === ADD TODO MODAL === */
        .add-todo-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            padding: 1rem;
        }
        .add-todo-modal.hide { display: none; }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            padding: 1rem;
        }
        .modal.hide { display: none; }
        .modal-content {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 500px;
            position: relative;
            z-index: 4001;
        }
        .modal-content .close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            cursor: pointer;
            font-size: 1.5rem;
            color: #666;
        }
        .modal-content .close:hover {
            color: #000;
        }
        .add-todo-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 500px;
        }
        .add-todo-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .add-todo-header h2 {
            font-size: 1.5rem;
            font-weight: 500;
            color: #000000;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .form-row .form-group {
            flex: 1;
        }
        .form-group select {
            width: 100%;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .form-group select:focus { outline: none; border-color: #000000; }
        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        /* === AUTH SCREEN === */
        .auth-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 1rem;
        }
        .auth-screen.hide { display: none; }
        .auth-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 400px;
        }
        .auth-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .auth-header h2 {
            font-size: 1.5rem;
            font-weight: 500;
            color: #000000;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-group {
            margin-bottom: 1.5rem;
        }
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #000000;
            font-weight: 500;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-group input {
            width: 100%;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .form-group input:focus { outline: none; border-color: #000000; }
        .auth-btn {
            width: 100%;
            padding: 1rem;
            border: 1px solid #000000;
            background: #ffffff;
            color: #000000;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .auth-btn:hover {
            background: #000000;
            color: #ffffff;
        }
        .auth-error {
            color: #cc0000;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            display: none;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .auth-error.show { display: block; }

        /* === RESPONSIVE === */
        /* === CRYPTO WIKI STYLES === */
        .wiki-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .search-container {
            display: flex;
            flex: 1;
            min-width: 300px;
        }
        
        .search-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-right: none;
            border-radius: 0;
            font-size: 0.95rem;
        }
        
        .search-btn {
            padding: 0.75rem 1rem;
            border: 1px solid #d1d5db;
            border-left: none;
            border-radius: 0;
            background: #f8f9fa;
            cursor: pointer;
        }
        
        .filter-container {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex: 1;
            min-width: 250px;
        }
        
        .filter-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.95rem;
            background: #ffffff;
        }
        
        .filter-input:focus {
            outline: none;
            border-color: #000000;
            box-shadow: 0 0 0 1px #000000;
        }
        
        .filter-container select {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0;
            font-size: 0.95rem;
            background: #ffffff;
        }
        
        .wiki-content {
            display: grid;
            gap: 1.5rem;
        }
        
        .wiki-entry {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 1.5rem;
        }
        
        .wiki-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }
        
        .wiki-entry-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #000000;
            margin: 0;
        }
        
        .wiki-entry-content {
            color: #333333;
            line-height: 1.6;
            margin-bottom: 1rem;
            white-space: pre-wrap;
        }
        
        .wiki-entry-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 1rem;
            border-top: 1px solid #e0e0e0;
            font-size: 0.85rem;
            color: #666666;
        }
        
        .wiki-entry-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .wiki-tag {
            background: #e5e7eb;
            color: #374151;
            padding: 0.25rem 0.5rem;
            border-radius: 0;
            font-size: 0.75rem;
        }
        
        .wiki-entry-source {
            font-style: italic;
        }
        
        .wiki-entry-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .wiki-entry-actions button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
        }
        
        .empty-wiki {
            text-align: center;
            color: #666666;
            padding: 3rem;
        }

        /* === TRADING TAB STYLES === */
        .add-trade-section {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .add-trade-section h3 {
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .trade-form .form-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .trade-form .form-group {
            display: flex;
            flex-direction: column;
        }

        .trade-form .form-group label {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #333333;
        }

        .trade-form .form-group input {
            padding: 0.75rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            font-size: 0.9rem;
        }

        .trade-form .form-group input:focus {
            outline: none;
            border-color: #000000;
        }

        .trade-form .form-actions {
            display: flex;
            gap: 0.5rem;
        }

        .portfolio-overview {
            margin-bottom: 2rem;
        }

        .portfolio-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
        }

        .portfolio-stat {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            text-align: center;
        }

        .stat-number {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .stat-number.positive { color: #059669; }
        .stat-number.negative { color: #dc2626; }

        .stat-label {
            font-size: 0.9rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .open-trades, .closed-trades {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .section-header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .trades-table {
            overflow-x: auto;
        }

        .trade-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr auto;
            gap: 1rem;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f0f0f0;
            align-items: center;
        }

        .open-trades .trade-row {
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr auto;
        }

        .trade-row:last-child {
            border-bottom: none;
        }

        .trade-header {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr auto;
            gap: 1rem;
            padding: 0.5rem 0;
            border-bottom: 2px solid #e0e0e0;
            font-weight: 600;
            font-size: 0.85rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .open-trades .trade-header {
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr auto;
        }

        .trade-token {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .trade-amount {
            font-size: 0.9rem;
        }

        .trade-entry-price {
            font-size: 0.9rem;
            color: #666666;
        }

        .trade-current-price {
            font-size: 0.9rem;
        }

        .trade-pnl {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .trade-pnl.positive { color: #059669; }
        .trade-pnl.negative { color: #dc2626; }

        .trade-actions {
            display: flex;
            gap: 0.5rem;
        }

        .trade-actions button {
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
        }

        .empty-trades {
            text-align: center;
            color: #666666;
            padding: 2rem;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .trade-form .form-row {
                grid-template-columns: 1fr;
            }
            
            .portfolio-stats {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .trade-row, .trade-header {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }

            .trade-row > div::before {
                content: attr(data-label) ": ";
                font-weight: 600;
                display: inline-block;
                width: 80px;
            }
        }

        /* === LUCIDE ICON STYLES === */
        .icon-palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .icon-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            background: #ffffff;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .icon-btn:hover {
            background: #f3f4f6;
            border-color: #000000;
        }
        
        .icon-btn:active {
            background: #e5e7eb;
        }

        @media (max-width: 768px) {
            .grid-2, .grid-3, .routine-grid, .streak-grid { grid-template-columns: 1fr; gap: 2rem; }
            .routine-grid { height: auto; }
            .routine-section { height: auto; min-height: 350px; }
            .main-content { padding: 0 15px 40px 15px; }
            .nav-container { flex-wrap: wrap; gap: 1rem; }
            .nav-tab { font-size: 0.8rem; padding: 0.4rem 0.8rem; }
            .ziel-kategorie { position: static; align-self: flex-start; margin-bottom: 1rem; }
            .ziel-header { margin-right: 0; }
            .journal-form { flex-direction: column; align-items: stretch; }
            .journal-entry-header { flex-direction: column; align-items: flex-start; }
            
            /* Resource mobile optimization */
            .resource-grid { 
                grid-template-columns: repeat(auto-fill, minmax(170px, 170px)); 
                gap: 0.4rem;
            }
            .resource-card { 
                height: 46px;
                padding: 0.6rem;
            }
            .resource-title { 
                font-size: 0.8rem; 
            }
            .resource-icon {
                font-size: 0.95rem;
                margin-right: 0.4rem;
            }
            .emoji-palette { 
                grid-template-columns: repeat(8, 1fr); 
                gap: 0.2rem;
                padding: 0.3rem;
            }
            .emoji-btn {
                min-height: 24px;
                width: 24px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <!-- === ADD TODO MODAL === -->
    <div id="add-todo-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Todo hinzufügen</h2>
            </div>
            
            <form id="add-todo-form" autocomplete="off">
                <div class="form-group">
                    <label for="todo-title">Aufgabe</label>
                    <input type="text" id="todo-title" name="todo-title" placeholder="Was möchtest du erledigen?" required autocomplete="off">
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="todo-category">Kategorie</label>
                        <select id="todo-category" name="todo-category" required autocomplete="off">
                            <option value="">Kategorie wählen</option>
                            <option value="privat">Privat</option>
                            <option value="uni">Uni</option>
                            <option value="arbeit">Arbeit</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="todo-priority">Priorität</label>
                        <select id="todo-priority" name="todo-priority" required autocomplete="off">
                            <option value="mittel" selected>Normal</option>
                            <option value="wichtig">Wichtig</option>
                            <option value="dringend">Dringend</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="todo-deadline">Deadline</label>
                        <input type="date" id="todo-deadline" name="todo-deadline" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="todo-time">Uhrzeit</label>
                        <input type="time" id="todo-time" name="todo-time" value="21:00" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-todo-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Todo erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD GOAL MODAL === -->
    <div id="add-goal-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Ziel hinzufügen</h2>
            </div>
            
            <form id="add-goal-form" autocomplete="off">
                <div class="form-group">
                    <label for="goal-name">Ziel-Name</label>
                    <input type="text" id="goal-name" name="goal-name" placeholder="Was möchtest du erreichen?" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="goal-description">Beschreibung</label>
                    <textarea id="goal-description" placeholder="Detaillierte Beschreibung des Ziels..." rows="3" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-category">Kategorie</label>
                        <input type="text" id="goal-category" placeholder="z.B. Fitness, Karriere, Finanzen..." required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-timeframe">Zeitrahmen</label>
                        <select id="goal-timeframe" required autocomplete="off">
                            <option value="monat">Monat</option>
                            <option value="quartal">Quartal</option>
                            <option value="jahr">Jahr</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-deadline">Deadline</label>
                        <input type="date" id="goal-deadline" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-unit">Einheit</label>
                        <input type="text" id="goal-unit" placeholder="z.B. kg, €, Bücher, Stunden..." autocomplete="off">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-start-value">Startwert</label>
                        <input type="number" id="goal-start-value" placeholder="z.B. 80" step="0.01" autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-target-value">Zielwert</label>
                        <input type="number" id="goal-target-value" placeholder="z.B. 70" step="0.01" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-goal-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Ziel erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD JOURNAL MODAL === -->
    <div id="add-journal-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Journal Eintrag hinzufügen</h2>
            </div>
            
            <form id="add-journal-form" autocomplete="off">
                <div class="form-group">
                    <label for="journal-title">Titel</label>
                    <input type="text" id="journal-title" placeholder="Titel für den Eintrag..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="journal-content">Inhalt</label>
                    <textarea id="journal-content" placeholder="Was beschäftigt dich heute...?" rows="6" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="journal-tags">Tags (mehrere möglich)</label>
                        <div id="journal-tag-options" style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                            <button type="button" class="tag-option" data-tag="allgemein">
                                Allgemein
                                <span class="remove-tag">×</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="fitness">
                                Fitness
                                <span class="remove-tag">×</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="uni">
                                Uni
                                <span class="remove-tag">×</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="crypto">
                                Crypto
                                <span class="remove-tag">×</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="lesen">
                                Lesen
                                <span class="remove-tag">×</span>
                            </button>
                        </div>
                        <input type="hidden" id="journal-category" required>
                    </div>
                    <div class="form-group">
                        <label for="journal-date">Datum</label>
                        <input type="date" id="journal-date" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-journal-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Journal erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD TERMIN MODAL === -->
    <div id="add-termin-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Termin hinzufügen</h2>
            </div>
            
            <form id="add-termin-form" autocomplete="off">
                <div class="form-group">
                    <label for="termin-title">Titel</label>
                    <input type="text" id="termin-title" placeholder="z.B. Zahnarzt Termin..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="termin-description">Beschreibung</label>
                    <textarea id="termin-description" placeholder="Weitere Details zum Termin..." rows="3" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="termin-date">Datum</label>
                        <input type="date" id="termin-date" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="termin-time">Uhrzeit (optional)</label>
                        <input type="time" id="termin-time" autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-termin-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Termin erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === EDIT GOAL VALUE MODAL === -->
    <div id="edit-goal-value-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2 id="edit-goal-modal-title">Fortschritt aktualisieren</h2>
            </div>
            
            <div id="edit-goal-current-status" style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; font-size: 0.9rem; color: #666;">
                <!-- Current goal status will be inserted here -->
            </div>
            
            <form id="edit-goal-value-form" autocomplete="off">
                <div class="form-group">
                    <label for="new-goal-value">Neuer aktueller Wert</label>
                    <input type="number" id="new-goal-value" name="new-goal-value" step="0.01" required autocomplete="off" style="font-size: 1.1rem; padding: 0.75rem;">
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-edit-goal-value-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Wert aktualisieren</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === AUTH SCREEN === -->
    <div id="auth-screen" class="auth-screen hide">
        <div class="auth-container">
            <div class="auth-header">
                <h2>DASHBOARD</h2>
            </div>
            
            <div class="form-group">
                <label for="login-email">Email</label>
                <input type="email" id="login-email" name="email" placeholder="your@email.com" required autocomplete="email">
            </div>
            <div class="form-group">
                <label for="login-password">Password</label>
                <input type="password" id="login-password" name="password" placeholder="Your password" required autocomplete="current-password">
            </div>
            <button id="login-btn" class="auth-btn">Login</button>
            <div id="login-error" class="auth-error"></div>
        </div>
    </div>

    <!-- === STICKY NAVIGATION === -->
    <nav class="sticky-nav">
        <div class="nav-container">
            <button class="nav-tab active" data-tab="tab-home">Home</button>
            <button class="nav-tab" data-tab="tab-todos">ToDos</button>
            <button class="nav-tab" data-tab="tab-ziele">Ziele</button>
            <button class="nav-tab" data-tab="tab-journal">Journal</button>
            <button class="nav-tab" data-tab="tab-trading">Trading</button>
            <button class="nav-tab" data-tab="tab-ressourcen">Ressourcen</button>
            <button class="nav-tab" data-tab="tab-wiki">Wiki</button>
            <button class="nav-tab" data-tab="tab-settings" style="display: none;">Settings</button>
            <div class="nav-actions">
                <button id="quick-add-btn" class="nav-tab quick-add-btn" title="Quick Add Todo">
                    <i data-lucide="plus" style="width: 18px; height: 18px;"></i>
                </button>
                <button id="timer-btn" class="nav-tab timer-btn" title="Pomodoro Timer (25 min) | Right-click to reset">
                    <i data-lucide="timer" style="width: 18px; height: 18px;"></i>
                </button>
                <button id="settings-btn" class="nav-tab settings-btn">
                    <i data-lucide="settings" style="width: 18px; height: 18px;"></i>
                </button>
                <button id="logout-btn" class="nav-tab logout-btn" style="display:flex;align-items:center;justify-content:center;">
                    <i data-lucide="log-out" style="width: 18px; height: 18px;"></i>
                </button>
            </div>
        </div>
    </nav>

    <div class="main-content">
        <!-- === HOME TAB === -->
        <section id="tab-home" class="tab-section active">
            <!-- Streak Kacheln -->
            <section class="streak-overview">
                <div class="streak-grid">
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Morgenroutine</div>
                        <div class="streak-date">August 2025</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Abendroutine</div>
                        <div class="streak-date">August 2025</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Todos Erledigt</div>
                        <div class="streak-date">August 2025</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0.00</div>
                        <div class="streak-label">SOL Balance</div>
                        <div class="streak-date">Live</div>
                    </div>
                </div>
            </section>

            <!-- Routinen Section -->
            <div class="routine-grid">
                <div id="morning-routine" class="routine-section">
                    <h2>Morgenroutine</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="wasser-kreatin">
                            <label for="wasser-kreatin">Wasser und Kreatin</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="bbue-sport">
                            <label for="bbue-sport">BBÜ und Sport</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="tag-planen">
                            <label for="tag-planen">Tag planen</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="todos-checken">
                            <label for="todos-checken">Todos checken</label>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <div id="evening-routine" class="routine-section">
                    <h2>Abendroutine</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="journal-reflexion">
                            <label for="journal-reflexion">Tag reflektieren per Journal</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="lesen-lessons">
                            <label for="lesen-lessons">Lesen und Lessons nachhalten</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="trades-evaluieren">
                            <label for="trades-evaluieren">Trades evaluieren und Lessons nachhalten</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="naechsten-tag-planen">
                            <label for="naechsten-tag-planen">Nächsten Tag planen</label>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Anstehende Termine -->
            <section style="margin-bottom: 3rem;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 2rem; margin-bottom: 1.5rem;">
                    <h2 style="font-size: 1.2rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.1em; margin: 0;">Anstehende Termine</h2>
                    <button id="add-termin-btn" class="btn" style="font-size: 0.7rem; padding: 0.5rem 1rem;">Add New</button>
                </div>
                <div class="grid-3" id="termine-container">
                    <!-- Termine will be loaded from TerminManager -->
                </div>
            </section>

            <!-- Heutige Aufgaben -->
            <section class="card">
                <h2 style="font-size: 1.2rem; font-weight: 500; margin-bottom: 1.5rem; text-transform: uppercase; letter-spacing: 0.1em;">Heutige Aufgaben</h2>
                <div class="checkbox-group" id="home-todos">
                    <!-- Todos will be loaded from database -->
                </div>
            </section>
        </section>

        <!-- === TODOS TAB === -->
        <section id="tab-todos" class="tab-section">
            
            <div class="category-tabs">
                <button class="category-tab active" data-category="alle">Alle <span id="overdue-count" class="badge" style="display: none;"></span></button>
                <button class="category-tab" data-category="heute">Heute</button>
                <button class="category-tab" data-category="privat">Privat</button>
                <button class="category-tab" data-category="uni">Uni</button>
                <button class="category-tab" data-category="arbeit">Arbeit</button>
                <button class="category-tab" data-category="archiv">Archiv</button>
                <button id="add-todo-btn" class="btn" style="margin-left: 2rem;">+ Add Todo</button>
                <button id="clear-archive-btn" class="btn secondary" style="margin-left: 1rem; display: none;">🗑️ Archiv leeren</button>
            </div>

            <!-- HEUTE KATEGORIE -->
            <div class="category-content" id="heute">
                <!-- Todos for today and overdue will be loaded from database -->
            </div>

            <!-- PRIVAT KATEGORIE -->
            <div class="category-content" id="privat">
                <!-- Private todos will be loaded from database -->
            </div>

            <!-- UNI KATEGORIE -->
            <div class="category-content" id="uni">
                <!-- Uni todos will be loaded from database -->
            </div>

            <!-- ARBEIT KATEGORIE -->
            <div class="category-content" id="arbeit">
                <!-- Work todos will be loaded from database -->
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="category-content active" id="alle">
                <!-- All todos will be loaded from database -->
            </div>

            <!-- ARCHIV KATEGORIE -->
            <div class="category-content" id="archiv">
                <!-- Completed/archived todos will be loaded from database -->
            </div>
        </section>

        <!-- === ZIELE TAB === -->
        <section id="tab-ziele" class="tab-section">
            
            <div class="category-tabs">
                <button class="ziel-tab active" data-ziel-category="alle">Alle</button>
                <button class="ziel-tab" data-ziel-category="monat">Monat</button>
                <button class="ziel-tab" data-ziel-category="quartal">Quartal</button>
                <button class="ziel-tab" data-ziel-category="jahr">Jahr</button>
                <button class="ziel-tab" data-ziel-category="archiv">Archiv</button>
                <button id="add-goal-btn" class="btn" style="margin-left: 2rem;">+ Add Goal</button>
                <button id="clear-goal-archive-btn" class="btn secondary" style="margin-left: 1rem; display: none;">🗑️ Archiv leeren</button>
            </div>

            <!-- MONAT KATEGORIE -->
            <div class="ziel-content" id="ziel-monat">
                <!-- Monatsziele will be loaded from database -->
            </div>

            <!-- QUARTAL KATEGORIE -->
            <div class="ziel-content" id="ziel-quartal">
                <!-- Quartalsziele will be loaded from database -->
            </div>

            <!-- JAHR KATEGORIE -->
            <div class="ziel-content" id="ziel-jahr">
                <!-- Jahresziele will be loaded from database -->
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="ziel-content active" id="ziel-alle">
                <!-- All ziele will be loaded from database -->
            </div>

            <!-- ARCHIV KATEGORIE -->
            <div class="ziel-content" id="ziel-archiv">
                <!-- Completed/archived ziele will be loaded from database -->
            </div>

        </section>

        <!-- === JOURNAL TAB === -->
        <section id="tab-journal" class="tab-section">
            
            <div class="category-tabs">
                <button class="journal-tab active" data-journal-category="alle">Alle</button>
                <button class="journal-tab" data-journal-category="allgemein">Allgemein</button>
                <button class="journal-tab" data-journal-category="fitness">Fitness</button>
                <button class="journal-tab" data-journal-category="uni">Uni</button>
                <button class="journal-tab" data-journal-category="crypto">Crypto</button>
                <button class="journal-tab" data-journal-category="lesen">Lesen</button>
                <button id="add-journal-btn" class="btn" style="margin-left: 2rem;">+ Add Journal</button>
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="journal-content active" id="journal-alle">
                <!-- All journal entries will be loaded from database -->
            </div>

            <!-- ALLGEMEIN KATEGORIE -->
            <div class="journal-content" id="journal-allgemein">
                <!-- Allgemein entries will be loaded from database -->
            </div>

            <!-- FITNESS KATEGORIE -->
            <div class="journal-content" id="journal-fitness">
                <!-- Fitness entries will be loaded from database -->
            </div>

            <!-- UNI KATEGORIE -->
            <div class="journal-content" id="journal-uni">
                <!-- Uni entries will be loaded from database -->
            </div>

            <!-- CRYPTO KATEGORIE -->
            <div class="journal-content" id="journal-crypto">
                <!-- Crypto entries will be loaded from database -->
            </div>

            <!-- LESEN KATEGORIE -->
            <div class="journal-content" id="journal-lesen">
                <!-- Lesen entries will be loaded from database -->
            </div>

        </section>

        <!-- === TRADING TAB === -->
        <section id="tab-trading" class="tab-section">
            
            <!-- Add New Trade -->
            <div class="add-trade-section">
                <h3>Add New Trade</h3>
                <div class="trade-form">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="trade-token">Token Symbol</label>
                            <input type="text" id="trade-token" placeholder="BONK" autocomplete="off">
                        </div>
                        <div class="form-group">
                            <label for="trade-sol-amount">SOL Amount</label>
                            <input type="number" id="trade-sol-amount" placeholder="0.5" step="0.001" autocomplete="off">
                        </div>
                        <div class="form-group">
                            <label for="trade-mcap">Market Cap</label>
                            <input type="text" id="trade-mcap" placeholder="2.1B" autocomplete="off">
                        </div>
                    </div>
                    <div class="form-actions">
                        <button id="add-trade-btn" class="btn">Add Trade</button>
                    </div>
                </div>
            </div>

            <!-- Portfolio Overview -->
            <div class="portfolio-overview">
                <div class="portfolio-stats">
                    <div class="portfolio-stat">
                        <div class="stat-number" id="total-pnl">+0.00 SOL</div>
                        <div class="stat-label">Total P&L</div>
                    </div>
                    <div class="portfolio-stat">
                        <div class="stat-number" id="open-trades">0</div>
                        <div class="stat-label">Open Positions</div>
                    </div>
                    <div class="portfolio-stat">
                        <div class="stat-number" id="win-rate">0%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                </div>
            </div>

            <!-- Open Trades -->
            <div class="open-trades">
                <div class="section-header">
                    <h3>Open Positions</h3>
                    <button id="refresh-prices-btn" class="btn secondary">🔄 Update Prices</button>
                </div>
                <div class="trades-table" id="open-trades-list">
                    <div class="empty-trades">No open trades yet</div>
                </div>
            </div>

            <!-- Closed Trades -->
            <div class="closed-trades">
                <div class="section-header">
                    <h3>Closed Trades</h3>
                </div>
                <div class="trades-table" id="closed-trades-list">
                    <div class="empty-trades">No closed trades yet</div>
                </div>
            </div>

        </section>

        <!-- === RESSOURCEN TAB === -->
        <section id="tab-ressourcen" class="tab-section">
            
            <div class="category-tabs">
                <button class="resource-tab active" data-resource-category="alle">Alle</button>
                <button class="resource-tab" data-resource-category="privat">Privat</button>
                <button class="resource-tab" data-resource-category="arbeit">Arbeit</button>
                <button class="resource-tab" data-resource-category="uni">Uni</button>
                <button class="resource-tab" data-resource-category="crypto">Crypto</button>
                <button id="add-resource-btn" class="btn" style="margin-left: 2rem;">+ Add Resource</button>
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="resource-content active" id="resource-alle">
                <!-- All resources will be loaded from database -->
            </div>

            <!-- PRIVAT KATEGORIE -->
            <div class="resource-content" id="resource-privat">
                <!-- Private resources will be loaded from database -->
            </div>

            <!-- ARBEIT KATEGORIE -->
            <div class="resource-content" id="resource-arbeit">
                <!-- Work resources will be loaded from database -->
            </div>

            <!-- UNI KATEGORIE -->
            <div class="resource-content" id="resource-uni">
                <!-- Uni resources will be loaded from database -->
            </div>

            <!-- CRYPTO KATEGORIE -->
            <div class="resource-content" id="resource-crypto">
                <!-- Crypto resources will be loaded from database -->
            </div>
            
        </section>


        <!-- === SETTINGS TAB === -->
        <section id="tab-settings" class="tab-section">
            <h1 class="section-title">Einstellungen</h1>
            
            <div class="settings-container">
                <div class="setting-group">
                    <h3>Routinen</h3>
                    <div class="setting-item">
                        <label for="routine-reset-time">Routine Reset Zeit:</label>
                        <input type="time" id="routine-reset-time" value="06:00">
                        <span class="setting-description">Zeit, zu der die Routinen täglich zurückgesetzt werden</span>
                    </div>
                    <button id="save-routine-settings" class="btn">Speichern</button>
                </div>
                
                <div class="setting-group">
                    <h3>Routines Reset</h3>
                    <div class="setting-item">
                        <label>Routine-Datenbank komplett zurücksetzen:</label>
                        <button id="reset-routines-btn" class="btn btn-danger" style="background: #cc0000; border-color: #cc0000; color: white;" onclick="handleRoutineReset()">Routines komplett zurücksetzen</button>
                        <button onclick="debugRoutineSystem()" class="btn btn-secondary" style="margin-left: 1rem;">🔍 Debug Routines</button>
                        <span class="setting-description">⚠️ Löscht ALLE Routine-Daten und Counter. Synchronisiert zwischen allen Geräten.</span>
                    </div>
                </div>
                
                <div class="setting-group">
                    <h3>Daten</h3>
                    <div class="setting-item">
                        <button id="reset-routines-today" class="btn btn-secondary">Routinen heute zurücksetzen</button>
                        <span class="setting-description">Setzt alle Routine-Checkboxes für heute zurück</span>
                    </div>
                    <div class="setting-item">
                        <button id="reset-monthly-todos" class="btn btn-secondary">Todo-Zähler für aktuellen Monat zurücksetzen</button>
                        <span class="setting-description">Setzt den monatlichen Todo-Counter auf 0 zurück</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- === WIKI TAB === -->
        <section id="tab-wiki" class="tab-section">
            <!-- Search and Filter Bar -->
            <div class="wiki-controls">
                <div class="search-container">
                    <input type="text" id="wiki-search" placeholder="Search wiki entries..." class="search-input">
                    <button class="search-btn" onclick="Wiki.search()">
                        <i data-lucide="search" style="width: 16px; height: 16px;"></i>
                    </button>
                </div>
                <div class="filter-container">
                    <input type="text" id="wiki-tag-filter" placeholder="Filter by tags..." class="filter-input" oninput="Wiki.filterByTags()">
                    <button class="btn" onclick="Wiki.showAddModal()">+ Add Entry</button>
                </div>
            </div>

            <!-- Wiki Content -->
            <div class="wiki-content" id="wiki-entries">
                <!-- Wiki entries will be loaded here -->
            </div>
        </section>

    </div>

    <!-- Add Resource Modal -->
    <div id="add-resource-modal" class="modal hide">
        <div class="modal-content">
            <span class="close" onclick="ResourceManager.hideAddResourceModal()">&times;</span>
            <h2>Add Resource</h2>
            <form id="add-resource-form">
                <div class="form-group">
                    <label for="resource-title">Title *</label>
                    <input type="text" id="resource-title" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="resource-category">Category *</label>
                    <select id="resource-category" required autocomplete="off">
                        <option value="">Choose category...</option>
                        <option value="Privat">Privat</option>
                        <option value="Arbeit">Arbeit</option>
                        <option value="Uni">Uni</option>
                        <option value="Crypto">Crypto</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="resource-url">URL *</label>
                    <input type="url" id="resource-url" placeholder="https://example.com" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="resource-description">Description</label>
                    <textarea id="resource-description" rows="3" placeholder="Optional description..." autocomplete="off"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="resource-icon">Icon (optional)</label>
                    <input type="text" id="resource-icon" placeholder="Click icon below or type lucide icon name" readonly>
                    <div class="icon-palette">
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('mail')"><i data-lucide="mail" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('briefcase')"><i data-lucide="briefcase" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('book')"><i data-lucide="book" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('home')"><i data-lucide="home" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('message-circle')"><i data-lucide="message-circle" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('building')"><i data-lucide="building" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('wrench')"><i data-lucide="wrench" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('bar-chart-3')"><i data-lucide="bar-chart-3" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('file-text')"><i data-lucide="file-text" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('users')"><i data-lucide="users" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('globe')"><i data-lucide="globe" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('dollar-sign')"><i data-lucide="dollar-sign" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('target')"><i data-lucide="target" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('zap')"><i data-lucide="zap" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('lock')"><i data-lucide="lock" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('link')"><i data-lucide="link" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('rocket')"><i data-lucide="rocket" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('palette')"><i data-lucide="palette" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('activity')"><i data-lucide="activity" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('bot')"><i data-lucide="bot" style="width: 16px; height: 16px;"></i></button>
                    </div>
                    <small style="margin-top: 0.5rem; display: block;">Click an icon above or make input editable to type manually</small>
                    <button type="button" class="btn-link" onclick="ResourceManager.toggleIconInput()" style="font-size: 0.8rem; margin-top: 0.25rem;">Enable manual typing</button>
                </div>
                
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="ResourceManager.hideAddResourceModal()">Cancel</button>
                    <button type="submit" class="btn">Add Resource</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Add Wiki Entry Modal -->
    <div id="add-wiki-modal" class="modal hide">
        <div class="modal-content">
            <span class="close" onclick="Wiki.hideAddModal()">
                <i data-lucide="x" style="width: 20px; height: 20px;"></i>
            </span>
            <h2>Add Wiki Entry</h2>
            <form id="add-wiki-form">
                <div class="form-group">
                    <label for="wiki-title">Title *</label>
                    <input type="text" id="wiki-title" required autocomplete="off" placeholder="e.g. CME Gap Trading Strategy">
                </div>
                
                <div class="form-group">
                    <label for="wiki-tags">Tags *</label>
                    <input type="text" id="wiki-tags" required placeholder="e.g. crypto, trading, analysis, finance" autocomplete="off">
                    <small>Separate tags with commas for better filtering.</small>
                </div>
                
                <div class="form-group">
                    <label for="wiki-content">Content *</label>
                    <textarea id="wiki-content" rows="15" required autocomplete="off" placeholder="Enter detailed explanation, rules, or learnings..." style="resize: vertical; min-height: 300px; width: 100%;"></textarea>
                </div>
                
                
                <div class="form-group">
                    <label for="wiki-source">Source (optional)</label>
                    <input type="text" id="wiki-source" placeholder="Video title, book, website..." autocomplete="off">
                </div>
                
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="Wiki.hideAddModal()">Cancel</button>
                    <button type="submit" class="btn">Add Entry</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Scripts -->
    <script src="supabase-config.js"></script>
    <script src="cloud-storage.js"></script>
    <script src="simple-counters.js"></script>
    <script src="simple-routine-system.js"></script>
    <script src="debug-routine-data.js"></script>
    <script>
        // Debug: Check if basic JavaScript works
        console.log('🔧 JavaScript loading started...');
        
        window.addEventListener('error', function(e) {
            console.error('❌ JavaScript Error:', e.error);
            alert('JavaScript Error: ' + e.message + ' at line ' + e.lineno);
        });
        
        // === AUTHENTICATION ===
        const Auth = {
            isAuthenticated: false,
            currentUser: null,
            
            async init() {
                window.Auth = this;
                
                if (!supabase) {
                    console.log('⚠️ Demo mode - no authentication');
                    await this.showDashboard();
                    return;
                }
                
                this.currentUser = supabase.getCurrentUser();
                if (supabase.isAuthenticated()) {
                    console.log('✅ User authenticated:', this.currentUser.email);
                    this.isAuthenticated = true;
                    await this.showDashboard();
                } else {
                    this.showAuthScreen();
                }
                
                this.setupEventListeners();
            },
            
            setupEventListeners() {
                const loginBtn = document.getElementById('login-btn');
                const logoutBtn = document.getElementById('logout-btn');
                
                if (loginBtn) {
                    loginBtn.addEventListener('click', () => this.handleLogin());
                }
                
                if (logoutBtn) {
                    logoutBtn.addEventListener('click', () => this.handleLogout());
                }
            },
            
            async handleLogin() {
                const email = document.getElementById('login-email').value;
                const password = document.getElementById('login-password').value;
                const errorEl = document.getElementById('login-error');
                
                if (!email || !password) {
                    this.showError('Please enter email and password');
                    return;
                }
                
                try {
                    const { user, error } = await supabase.signIn(email, password);
                    
                    if (error) {
                        this.showError(error);
                        return;
                    }
                    
                    if (user) {
                        this.currentUser = user;
                        this.isAuthenticated = true;
                        await this.showDashboard();
                    }
                } catch (error) {
                    this.showError(error.message);
                }
            },
            
            async handleLogout() {
                console.log('🚪 Logout clicked');
                try {
                    if (supabase && typeof supabase.signOut === 'function') {
                        await supabase.signOut();
                    }
                    // Only clear auth-related data, preserve routine/todo data
                    localStorage.removeItem('supabase.auth.token');
                    sessionStorage.clear();
                    console.log('✅ Logout successful, redirecting to login...');
                    
                    // Clear URL hash and redirect to clean login page
                    window.history.replaceState(null, null, window.location.pathname);
                    window.location.reload();
                } catch (error) {
                    console.error('❌ Logout error:', error);
                    // Only clear auth-related data, preserve user data
                    localStorage.removeItem('supabase.auth.token');
                    sessionStorage.clear();
                    window.location.reload();
                }
            },
            
            showError(message) {
                const errorEl = document.getElementById('login-error');
                if (errorEl) {
                    errorEl.textContent = message;
                    errorEl.classList.add('show');
                    setTimeout(() => errorEl.classList.remove('show'), 5000);
                }
            },
            
            showAuthScreen() {
                document.getElementById('auth-screen').classList.remove('hide');
            },
            
            async refreshRoutineUI() {
                // Simple refresh for routine UI without retries
                console.log('🔄 Refreshing routine UI...');
                
                try {
                    // Note: Counter updates now handled by SimpleCounters
                    
                    // Dispatch update event for routine elements
                    const routineSections = document.querySelectorAll('.routine-item, .habit-item');
                    if (routineSections.length > 0) {
                        routineSections.forEach(section => {
                            const event = new Event('routineUpdate', { bubbles: true });
                            section.dispatchEvent(event);
                        });
                    }
                    
                    console.log('✅ Routine UI refreshed');
                } catch (error) {
                    console.error('❌ Error refreshing routine UI:', error);
                }
            },
            
            async showDashboard() {
                document.getElementById('auth-screen').classList.add('hide');
                
                // Load all data after successful login
                if (supabase?.isAuthenticated()) {
                    console.log('🔄 Loading dashboard data...');
                    
                    // Load all data in parallel for better performance
                    await Promise.all([
                        TodoManager.loadTodos(),
                        GoalManager.loadGoals(),
                        JournalManager.loadEntries(),
                        TerminManager.loadTermine(),
                        // Load Wiki data if available
                        window.Wiki ? window.Wiki.loadEntries() : Promise.resolve(),
                        // Load ResourceManager data if it exists (after login)
                        window.ResourceManager ? window.ResourceManager.loadResources() : Promise.resolve()
                    ]);
                    
                    // Initialize routine system FIRST, then counters to avoid race condition
                    if (window.simpleRoutineManager) {
                        console.log('🔄 Re-initializing routine manager after login...');
                        await window.simpleRoutineManager.loadTodaysData();
                        window.simpleRoutineManager.restoreCheckboxes();
                        window.simpleRoutineManager.updateProgressBarsOnly();
                    }
                    
                    // Initialize counters AFTER routine system is ready
                    if (window.SimpleCounters) {
                        await window.SimpleCounters.init();
                    }
                    
                    // Render Wiki after data is loaded
                    if (window.Wiki) {
                        window.Wiki.render();
                    }
                    
                    console.log('✅ Dashboard data loaded');
                    
                    // After login, always go to home tab for clean UX
                    console.log('🏠 After login, redirecting to home tab');
                    switchTab('tab-home', true); // Update URL to #home
                } else {
                    // Initialize displays for local storage mode
                    TodoManager.updateHomeTodos();
                    TerminManager.displayTermine();
                }
            }
        };

        // === TAB SYSTEM ===
        // Mapping between tab IDs and URL hashes
        const tabHashMapping = {
            'tab-home': 'home',
            'tab-todos': 'todos',
            'tab-ziele': 'goals', 
            'tab-journal': 'journal',
            'tab-trading': 'trading',
            'tab-ressourcen': 'resources',
            'tab-wiki': 'wiki',
            'tab-settings': 'settings'
        };

        // Reverse mapping for hash to tab ID
        const hashTabMapping = Object.fromEntries(
            Object.entries(tabHashMapping).map(([key, value]) => [value, key])
        );

        function switchTab(tabId, updateHash = true) {
            document.querySelectorAll('.tab-section').forEach(section => {
                section.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            const targetSection = document.getElementById(tabId);
            const targetTab = document.querySelector(`[data-tab="${tabId}"]`);
            
            if (targetSection && targetTab) {
                targetSection.classList.add('active');
                targetTab.classList.add('active');
                
                // Update URL hash
                if (updateHash && tabHashMapping[tabId]) {
                    const hash = tabHashMapping[tabId];
                    
                    window.history.replaceState(null, null, `#${hash}`);
                    console.log(`🔗 Tab switched to ${tabId}, URL updated to #${hash}`);
                } else if (updateHash) {
                    // Fallback: if no hash mapping, clear hash
                    window.history.replaceState(null, null, window.location.pathname);
                }
            }
            
            // If switching to todos tab, load the active category
            if (tabId === 'tab-todos') {
                const activeTab = document.querySelector('.category-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-category') : 'heute';
                TodoManager.displayTodosForCategory(activeCategory);
            }
            
            // If switching to home tab, update home todos
            if (tabId === 'tab-home') {
                TodoManager.updateHomeTodos();
            }
            
            // If switching to ziele tab, load the active category
            if (tabId === 'tab-ziele') {
                const activeTab = document.querySelector('.ziel-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-ziel-category') : 'alle';
                GoalManager.displayGoalsForCategory(activeCategory);
            }
            
            // If switching to journal tab, load the active category
            if (tabId === 'tab-journal') {
                const activeTab = document.querySelector('.journal-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-journal-category') : 'alle';
                JournalManager.displayEntriesForCategory(activeCategory);
            }
            
            // If switching to resources tab, load the active category
            if (tabId === 'tab-ressourcen') {
                if (window.ResourceManager) {
                    const activeTab = document.querySelector('.resource-tab.active');
                    const activeCategory = activeTab ? activeTab.getAttribute('data-resource-category') : 'alle';
                    ResourceManager.displayResourcesForCategory(activeCategory);
                }
            }
        }

        // Handle hash changes for direct URL navigation
        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove the '#'
            if (hash && hashTabMapping[hash]) {
                console.log(`🔗 Hash changed to #${hash}, switching to ${hashTabMapping[hash]}`);
                switchTab(hashTabMapping[hash], false); // Don't update hash again
            } else if (!hash && supabase?.isAuthenticated()) {
                // Only default to home if authenticated (not on login screen)
                console.log('🔗 No hash found, defaulting to home (authenticated user)');
                switchTab('tab-home', false);
            }
            // If not authenticated and no hash, do nothing (stay on login screen)
        }

        // Initialize tab from URL hash on page load
        function initializeFromHash() {
            const hash = window.location.hash.slice(1);
            if (hash && hashTabMapping[hash]) {
                switchTab(hashTabMapping[hash], false);
            } else if (!hash && supabase?.isAuthenticated()) {
                // Only default to home if authenticated
                switchTab('tab-home', false);
            }
            // If not authenticated and no hash, do nothing (stay on login screen)
        }

        // === ROUTINE PROGRESS ===
        // Load saved checkbox states from cloud only (pure cloud mode)
        async function loadRoutineStates() {
            const today = new Date().toISOString().split('T')[0];
            let savedStates = {};
            
            // Pure cloud mode - no localStorage fallback needed
            console.log('☁️ Pure cloud mode - loading routine states from cloud only');
            
            // If authenticated, load from database
            if (supabase?.isAuthenticated()) {
                try {
                    const routineCompletions = getRoutineCompletions();
                    if (routineCompletions && routineCompletions.length > 0) {
                        console.log(`🔄 Loading ${routineCompletions.length} routine completions from database for ${today}`);
                        
                        // Filter for today's completions
                        const todayCompletions = routineCompletions.filter(c => c.date === today);
                        console.log(`📅 Found ${todayCompletions.length} routine completions for today`);
                        
                        // Convert database completions to checkbox states
                        todayCompletions.forEach(completion => {
                            if (completion.checkbox_id) {
                                savedStates[completion.checkbox_id] = completion.completed;
                                console.log(`✅ Restored from database: ${completion.checkbox_id} = ${completion.completed}`);
                            }
                        });
                        
                        // Pure cloud mode - no localStorage updates needed
                        console.log('☁️ Routine states loaded from cloud');
                    }
                } catch (error) {
                    console.error('Error loading routine states from database:', error);
                    // Continue with localStorage-only states
                }
            }
            
            // Apply states to checkboxes
            Object.keys(savedStates).forEach(checkboxId => {
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.checked = savedStates[checkboxId];
                    // Apply visual styling
                    const label = checkbox.nextElementSibling;
                    if (label) {
                        if (checkbox.checked) {
                            label.style.textDecoration = 'line-through';
                            label.style.color = '#999';
                        } else {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    }
                }
            });
            
            console.log(`✅ Loaded routine states for ${today}:`, savedStates);
        }
        
        // Save checkbox state to both localStorage and database
        async function saveCheckboxState(checkboxId, isChecked) {
            const today = new Date().toISOString().split('T')[0];
            
            // Pure cloud mode - no localStorage saving needed
            console.log(`☁️ Pure cloud mode: Checkbox state ${checkboxId} = ${isChecked} (not saved to localStorage)`);
            
            // Skip database save for routine checkboxes - handled by routine completion system
            const checkbox = document.getElementById(checkboxId);
            const routineSection = checkbox?.closest('.routine-section');
            
            if (routineSection) {
                console.log(`📝 Routine checkbox ${checkboxId} state saved to localStorage only - database sync handled by routine system`);
                return;
            }
            
            // Save non-routine checkboxes to database if authenticated
            if (supabase?.isAuthenticated()) {
                console.log(`💾 Saving non-routine checkbox ${checkboxId} to database...`);
                // Only save non-routine checkboxes to database
                // Routine checkboxes are handled by the routine completion system
            }
        }

        function updateRoutineProgress() {
            // DISABLED - conflicts with SimpleRoutineManager
            return;
            const routineTab = document.getElementById('tab-home');
            if (!routineTab) return;
            
            const routineSections = routineTab.querySelectorAll('.routine-section');
            
            routineSections.forEach(section => {
                const checkboxes = section.querySelectorAll('input[type="checkbox"]');
                const checkedBoxes = section.querySelectorAll('input[type="checkbox"]:checked');
                
                if (checkboxes.length === 0) return;
                
                const percentage = Math.round((checkedBoxes.length / checkboxes.length) * 100);
                
                const progressFill = section.querySelector('.progress-fill');
                if (progressFill) {
                    progressFill.style.width = percentage + '%';
                }
                
                // Optional: Log progress for debugging
                console.log(`Routine progress: ${percentage}% (${checkedBoxes.length}/${checkboxes.length})`);
                
                // Update monthly streaks based on completion status (pure cloud mode)
                const today = new Date().toISOString().split('T')[0];
                const routineType = section.querySelector('h2').textContent.includes('Morgen') ? 'morning' : 'evening';
                
                let completionStatus;
                if (percentage === 100) {
                    console.log('🔍 DEBUG: 100% reached, marking as complete');
                    completionStatus = true;
                } else {
                    console.log('🔍 DEBUG: Less than 100%, marking as incomplete');
                    completionStatus = false;
                }
                
                console.log(`☁️ Pure cloud mode: ${routineType} completion: ${completionStatus}`);
                
                // Save to cloud if authenticated (async without blocking)
                if (supabase?.isAuthenticated()) {
                    (async () => {
                        try {
                            console.log(`☁️ Saving routine completion to cloud: ${routineType} = ${completionStatus}`);
                            await cloudStorage.saveRoutineCompletion(`${routineType}_routine`, today, completionStatus);
                            
                            // Note: Counter updates now handled by SimpleCounters
                        } catch (error) {
                            console.warn('⚠️ Could not save routine completion to cloud:', error);
                        }
                    })();
                }
                
                // Note: Counter updates now handled by SimpleCounters
            });
        }

        // === CATEGORY SYSTEM (for todos) ===
        function switchCategory(categoryId) {
            const parentTab = document.querySelector('#tab-todos');
            // Hide all category contents within todos
            parentTab.querySelectorAll('.category-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all category tabs
            parentTab.querySelectorAll('.category-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-category="${categoryId}"]`).classList.add('active');
            
            // Show/hide clear archive button
            const clearArchiveBtn = document.getElementById('clear-archive-btn');
            if (clearArchiveBtn) {
                if (categoryId === 'archiv') {
                    clearArchiveBtn.style.display = 'inline-block';
                } else {
                    clearArchiveBtn.style.display = 'none';
                }
            }
            
            // Load todos for this category
            TodoManager.displayTodosForCategory(categoryId);
        }

        // === ZIELE CATEGORY SYSTEM ===
        function switchZielCategory(categoryId) {
            const parentTab = document.querySelector('#tab-ziele');
            // Hide all ziel contents
            parentTab.querySelectorAll('.ziel-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all ziel tabs
            parentTab.querySelectorAll('.ziel-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#ziel-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-ziel-category="${categoryId}"]`).classList.add('active');
            
            // Show/hide clear goal archive button
            const clearGoalArchiveBtn = document.getElementById('clear-goal-archive-btn');
            if (clearGoalArchiveBtn) {
                if (categoryId === 'archiv') {
                    clearGoalArchiveBtn.style.display = 'inline-block';
                } else {
                    clearGoalArchiveBtn.style.display = 'none';
                }
            }
            
            // Load goals for this category
            GoalManager.displayGoalsForCategory(categoryId);
        }

        // === RESOURCE CATEGORY SYSTEM ===
        function switchResourceCategory(categoryId) {
            const parentTab = document.querySelector('#tab-ressourcen');
            // Hide all resource contents
            parentTab.querySelectorAll('.resource-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all resource tabs
            parentTab.querySelectorAll('.resource-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#resource-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-resource-category="${categoryId}"]`).classList.add('active');
            
            // Load resources for this category
            ResourceManager.displayResourcesForCategory(categoryId);
        }

        // === JOURNAL CATEGORY SYSTEM ===
        function switchJournalCategory(categoryId) {
            const parentTab = document.querySelector('#tab-journal');
            // Hide all journal contents
            parentTab.querySelectorAll('.journal-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all journal tabs
            parentTab.querySelectorAll('.journal-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#journal-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-journal-category="${categoryId}"]`).classList.add('active');
            
            // Load journal entries for this category
            JournalManager.displayEntriesForCategory(categoryId);
        }

        // === SETTINGS FUNCTIONALITY ===
        function initializeSettings() {
            // Pure cloud mode - use default reset time (settings could be moved to cloud later)
            console.log('☁️ Pure cloud mode: Using default routine reset time');
            const savedResetTime = '06:00'; // Default time, no localStorage needed
            const timeInput = document.getElementById('routine-reset-time');
            if (timeInput) {
                timeInput.value = savedResetTime;
            }
            
            // Save routine settings button
            const saveBtn = document.getElementById('save-routine-settings');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    const resetTime = timeInput.value;
                    console.log('☁️ Pure cloud mode: Settings change noted but not persisted');
                    alert(`Routine Reset Zeit auf ${resetTime} temporär gesetzt! (Pure Cloud Mode - nicht dauerhaft gespeichert)`);
                    console.log(`Routine reset time noted: ${resetTime} (not persisted in pure cloud mode)`);
                });
            }
            
            // Reset routines today button
            const resetBtn = document.getElementById('reset-routines-today');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    if (confirm('Möchtest du wirklich alle Routinen für heute zurücksetzen?')) {
                        resetRoutinesToday();
                    }
                });
            }
            
            // Reset monthly todos button
            const resetTodosBtn = document.getElementById('reset-monthly-todos');
            if (resetTodosBtn) {
                resetTodosBtn.addEventListener('click', () => {
                    const now = new Date();
                    const monthName = ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni',
                                     'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
                    if (confirm(`Möchtest du wirklich den Todo-Zähler für ${monthName} ${now.getFullYear()} zurücksetzen?`)) {
                        resetMonthlyTodos();
                    }
                });
            }
        }
        
        function resetRoutinesToday() {
            const today = new Date().toISOString().split('T')[0];
            
            // Pure cloud mode - no localStorage operations needed
            console.log('☁️ Pure cloud mode: Routine reset will only affect UI, not persistent storage');
            console.log(`☁️ Resetting routines for ${today} (UI only)`);
            
            // Note: In pure cloud mode, this only resets the UI
            // The actual cloud data would need to be reset via cloud operations
            
            // Uncheck all routine checkboxes
            document.querySelectorAll('.routine-section input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
                const label = checkbox.nextElementSibling;
                if (label) {
                    label.style.textDecoration = 'none';
                    label.style.color = 'inherit';
                }
            });
            
            // Update progress displays
            updateRoutineProgress();
            // Note: Counter updates now handled by SimpleCounters
            
            alert('Routinen für heute wurden zurückgesetzt!');
            console.log('Routines reset for today');
        }
        
        function resetMonthlyTodos() {
            const now = new Date();
            const monthKey = `${now.getFullYear()}-${now.getMonth()}`;
            
            // Reset monthly todo completions
            const monthlyData = JSON.parse(localStorage.getItem('monthlyTodoCompletions') || '{}');
            monthlyData[monthKey] = 0;
            localStorage.setItem('monthlyTodoCompletions', JSON.stringify(monthlyData));
            
            // Note: Counter updates now handled by SimpleCounters
            
            const monthName = ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni',
                             'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
            alert(`Todo-Zähler für ${monthName} ${now.getFullYear()} wurde auf 0 zurückgesetzt!`);
            console.log(`Monthly todos reset for ${monthKey}`);
        }
        
        // === TODO COUNTER SYSTEMS REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        // === MOBILE-FIRST ROUTINE COMPLETIONS ===
        let globalRoutineCompletions = []; // Always keep in memory for mobile
        
        async function loadRoutineCompletions() {
            try {
                console.log('🔄 Loading routine completions (Cloud-First with Migration)...');
                
                // STEP 1: If not authenticated, use local data only
                if (!supabase?.isAuthenticated()) {
                    console.log('⚠️ Not authenticated, using local data only');
                    try {
                        const localData = localStorage.getItem('routine_completions_cache');
                        if (localData) {
                            globalRoutineCompletions = JSON.parse(localData);
                            // Note: Counter updates now handled by SimpleCounters
                        }
                    } catch (e) {
                        console.warn('⚠️ Could not read local data:', e);
                        globalRoutineCompletions = [];
                    }
                    return;
                }
                
                // STEP 2: Load cloud data
                const cloudCompletions = await supabase.query('routine_completions?select=*');
                console.log(`☁️ Loaded ${cloudCompletions?.length || 0} routine completions from cloud`);
                
                // STEP 3: Cloud-first with improved migration
                if (cloudCompletions && cloudCompletions.length > 0) {
                    // Use cloud data if available
                    globalRoutineCompletions = cloudCompletions;
                    console.log(`☁️ Using ${cloudCompletions.length} completions from cloud`);
                } else {
                    // Cloud is empty - try migration with new improved approach
                    console.log('🔍 Cloud is empty, attempting migration with new schema...');
                    const migrationSuccess = await migrateLocalDataToCloudV2();
                    
                    if (migrationSuccess) {
                        // Reload after successful migration
                        const newCloudCompletions = await supabase.query('routine_completions?select=*');
                        console.log(`🔄 After migration: ${newCloudCompletions?.length || 0} completions in cloud`);
                        globalRoutineCompletions = newCloudCompletions || [];
                    } else {
                        // Migration failed - use local data as fallback
                        console.log('⚠️ Migration failed, using local data as fallback');
                        globalRoutineCompletions = [];
                        
                        // Load from all local sources
                        const localSources = ['routine_completions_cache', 'routineCompletionData'];
                        for (const source of localSources) {
                            try {
                                const localData = localStorage.getItem(source);
                                if (localData) {
                                    const parsed = JSON.parse(localData);
                                    
                                    if (source === 'routineCompletionData') {
                                        // Convert old format
                                        Object.keys(parsed).forEach(date => {
                                            const dayData = parsed[date];
                                            if (dayData.morning !== undefined) {
                                                globalRoutineCompletions.push({
                                                    template_id: 'morning_routine',
                                                    date: date,
                                                    completed: dayData.morning
                                                });
                                            }
                                            if (dayData.evening !== undefined) {
                                                globalRoutineCompletions.push({
                                                    template_id: 'evening_routine',
                                                    date: date,
                                                    completed: dayData.evening
                                                });
                                            }
                                        });
                                    } else if (Array.isArray(parsed)) {
                                        globalRoutineCompletions.push(...parsed);
                                    }
                                }
                            } catch (e) {
                                console.warn(`⚠️ Could not load fallback from ${source}:`, e);
                            }
                        }
                        console.log(`📱 Using ${globalRoutineCompletions.length} local completions as fallback`);
                    }
                }
                
                // STEP 4: Pure cloud mode - no local caching needed
                console.log('☁️ Pure cloud mode - skipping local cache storage');
                
                // STEP 5: Counter updates now handled by SimpleCounters
                
            } catch (error) {
                console.error('❌ Error loading routine completions:', error);
                // Fallback to local data on error
                try {
                    const localData = localStorage.getItem('routine_completions_cache');
                    if (localData) {
                        globalRoutineCompletions = JSON.parse(localData);
                        console.log('🔄 Fallback to local data due to error');
                    } else {
                        globalRoutineCompletions = [];
                    }
                } catch (e) {
                    globalRoutineCompletions = [];
                }
            }
        }
        
        // === IMPROVED MIGRATION FUNCTION V2 ===
        async function migrateLocalDataToCloudV2() {
            try {
                console.log('🚀 Starting IMPROVED migration (V2) of local routine data to cloud...');
                
                // Get current user
                const currentUser = supabase.getCurrentUser();
                if (!currentUser || !currentUser.id) {
                    console.error('❌ No authenticated user found for migration');
                    return false;
                }
                
                console.log(`👤 Migrating data for user: ${currentUser.email}`);
                
                // Collect all local data
                const localCompletions = [];
                
                // Source 1: routineCompletionData (legacy format)
                try {
                    const legacyData = localStorage.getItem('routineCompletionData');
                    if (legacyData) {
                        const parsed = JSON.parse(legacyData);
                        console.log(`📁 Found legacy data for ${Object.keys(parsed).length} dates`);
                        
                        Object.keys(parsed).forEach(date => {
                            const dayData = parsed[date];
                            if (dayData.morning !== undefined) {
                                localCompletions.push({
                                    template_id: 'morning_routine',
                                    date: date,
                                    completed: Boolean(dayData.morning),
                                    user_id: currentUser.id
                                });
                            }
                            if (dayData.evening !== undefined) {
                                localCompletions.push({
                                    template_id: 'evening_routine',
                                    date: date,
                                    completed: Boolean(dayData.evening),
                                    user_id: currentUser.id
                                });
                            }
                        });
                    }
                } catch (e) {
                    console.warn('⚠️ Could not parse legacy routine data:', e);
                }
                
                console.log(`📊 Prepared ${localCompletions.length} completions for migration`);
                
                if (localCompletions.length === 0) {
                    console.log('📭 No local data found to migrate');
                    return true;
                }
                
                // Remove duplicates based on user_id + template_id + date
                const uniqueCompletions = [];
                const seen = new Set();
                
                localCompletions.forEach(completion => {
                    const key = `${completion.user_id}_${completion.template_id}_${completion.date}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueCompletions.push(completion);
                    }
                });
                
                console.log(`🔍 After deduplication: ${uniqueCompletions.length} unique completions`);
                
                // Upload to cloud
                let uploadedCount = 0;
                
                for (const completion of uniqueCompletions) {
                    try {
                        console.log(`⬆️ Uploading: ${completion.template_id} for ${completion.date} (${completion.completed})`);
                        
                        const result = await supabase.insert('routine_completions', [completion]);
                        if (result && result.length > 0) {
                            uploadedCount++;
                            console.log(`✅ Uploaded successfully`);
                        } else {
                            console.warn(`⚠️ Upload returned no result`);
                        }
                    } catch (uploadError) {
                        console.error(`❌ Failed to upload completion:`, uploadError);
                        
                        // Check if it's a duplicate key error (which is OK)
                        if (uploadError.message && uploadError.message.includes('unique constraint')) {
                            console.log(`ℹ️ Duplicate entry (already exists) - skipping`);
                            uploadedCount++; // Count as success since data exists
                        } else {
                            console.error(`❌ Real upload error:`, uploadError.message);
                        }
                    }
                }
                
                console.log(`🎉 Migration V2 complete! Successfully processed ${uploadedCount}/${uniqueCompletions.length} completions`);
                return uploadedCount > 0;
                
            } catch (error) {
                console.error('❌ Migration V2 failed:', error);
                return false;
            }
        }
        
        // === OLD MIGRATION FUNCTION (DEPRECATED) ===
        async function migrateLocalDataToCloud() {
            try {
                console.log('🚀 Starting migration of local routine data to cloud...');
                
                // Get all local routine data sources
                const sources = [
                    'routine_completions_cache',
                    'routineCompletionData',
                    'monthlyRoutineCompletions'
                ];
                
                let allLocalCompletions = [];
                
                for (const source of sources) {
                    try {
                        const data = localStorage.getItem(source);
                        if (data) {
                            let parsed = JSON.parse(data);
                            console.log(`📁 Found data in ${source}:`, parsed);
                            
                            if (source === 'routineCompletionData') {
                                // Convert old format to new format
                                Object.keys(parsed).forEach(date => {
                                    const dayData = parsed[date];
                                    if (dayData.morning !== undefined) {
                                        allLocalCompletions.push({
                                            template_id: 'morning_routine',
                                            date: date,
                                            completed: dayData.morning,
                                            user_id: supabase.getCurrentUser()?.id
                                            // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                        });
                                    }
                                    if (dayData.evening !== undefined) {
                                        allLocalCompletions.push({
                                            template_id: 'evening_routine', 
                                            date: date,
                                            completed: dayData.evening,
                                            user_id: supabase.getCurrentUser()?.id
                                            // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                        });
                                    }
                                });
                            } else if (Array.isArray(parsed)) {
                                // Add user_id to existing completions and remove any existing id
                                parsed.forEach(completion => {
                                    const cleanCompletion = {
                                        template_id: completion.template_id,
                                        date: completion.date,
                                        completed: completion.completed,
                                        user_id: supabase.getCurrentUser()?.id
                                        // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                    };
                                    allLocalCompletions.push(cleanCompletion);
                                });
                            }
                        }
                    } catch (e) {
                        console.warn(`⚠️ Could not parse ${source}:`, e);
                    }
                }
                
                console.log(`📊 Found ${allLocalCompletions.length} local completions to migrate`);
                
                if (allLocalCompletions.length === 0) {
                    console.log('📭 No local data found to migrate');
                    return true; // No data to migrate is considered success
                }
                
                // Clean all completions: remove any existing IDs and ensure clean data
                const cleanedCompletions = allLocalCompletions.map(completion => ({
                    template_id: completion.template_id,
                    date: completion.date,
                    completed: completion.completed,
                    user_id: completion.user_id || supabase.getCurrentUser()?.id
                    // Explicitly exclude: id, created_at, updated_at - these will be auto-generated
                }));
                
                console.log(`🧹 Cleaned data, removing ${allLocalCompletions.length - cleanedCompletions.length} invalid entries`);
                
                // Upload to cloud in batches
                const batchSize = 50;
                let uploaded = 0;
                let hasErrors = false;
                
                for (let i = 0; i < cleanedCompletions.length; i += batchSize) {
                    const batch = cleanedCompletions.slice(i, i + batchSize);
                    try {
                        const result = await supabase.insert('routine_completions', batch);
                        if (result) {
                            uploaded += batch.length;
                            console.log(`✅ Uploaded batch: ${uploaded}/${cleanedCompletions.length}`);
                        } else {
                            console.error('❌ Batch upload returned no result');
                            hasErrors = true;
                        }
                    } catch (batchError) {
                        console.error('❌ Batch upload failed:', batchError);
                        hasErrors = true;
                        
                        // Check if it's an RLS error
                        if (batchError.message && batchError.message.includes('row-level security')) {
                            console.error('🔒 RLS Error: Please run the fix-routine-completions-rls.sql file in Supabase');
                            return false; // Stop migration on RLS error
                        }
                    }
                }
                
                if (hasErrors && uploaded === 0) {
                    console.log('❌ Migration failed completely');
                    return false;
                } else if (hasErrors) {
                    console.log(`⚠️ Migration partially successful: ${uploaded}/${cleanedCompletions.length} uploaded`);
                    return uploaded > 0; // Partial success
                } else {
                    console.log(`🎉 Migration complete! Uploaded ${uploaded} routine completions to cloud`);
                    return true;
                }
                
            } catch (error) {
                console.error('❌ Migration failed:', error);
                return false;
            }
        }
        
        // Mobile-safe function that uses memory first, localStorage as fallback
        function getRoutineCompletions() {
            if (globalRoutineCompletions && globalRoutineCompletions.length > 0) {
                console.log('📱 Using routine completions from memory (Mobile-safe)');
                return globalRoutineCompletions;
            }
            
            // Fallback to localStorage if available
            try {
                const cached = localStorage.getItem('routine_completions_cache');
                if (cached) {
                    const parsed = JSON.parse(cached);
                    console.log('💾 Using routine completions from localStorage fallback');
                    return parsed;
                }
            } catch (e) {
                console.warn('⚠️ localStorage read failed, using empty array');
            }
            
            return [];
        }
        
        // === CLOUD-BASED ROUTINE STREAK UPDATER REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        // === LOCAL FALLBACK FOR ROUTINE STREAKS REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        // === MONTHLY STREAK DISPLAY FUNCTIONS REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        function getRoutineCompletions() {
            // Return empty array for now
            return [];
        }
        
        // === MAKE FUNCTIONS GLOBALLY AVAILABLE ===
        window.getRoutineCompletions = getRoutineCompletions;
        window.loadRoutineCompletions = loadRoutineCompletions;
        window.loadRoutineStates = loadRoutineStates;
        window.updateRoutineProgress = updateRoutineProgress;

        // === EVENT LISTENERS ===
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Skip action buttons - they have their own handlers
                if (tab.id === 'logout-btn' || tab.id === 'settings-btn' || tab.id === 'timer-btn' || tab.id === 'quick-add-btn') return;
                
                const tabId = tab.getAttribute('data-tab');
                if (tabId) switchTab(tabId);
            });
        });
        
        // Settings button event listener
        const settingsBtn = document.getElementById('settings-btn');
        if (settingsBtn) {
            settingsBtn.addEventListener('click', () => {
                console.log('Settings clicked');
                switchTab('tab-settings');
            });
        }

        // Quick-add button event listener
        const quickAddBtn = document.getElementById('quick-add-btn');
        if (quickAddBtn) {
            quickAddBtn.addEventListener('click', () => {
                console.log('Quick-add clicked');
                if (window.QuickAdd) {
                    window.QuickAdd.show();
                }
            });
            
            // Setup Quick-Add animation after Lucide processes icons
            function setupQuickAddAnimation() {
                let quickAddIcon = quickAddBtn.querySelector('svg');
                
                if (quickAddIcon) {
                    quickAddIcon.style.cssText = `
                        transition: all 0.3s ease !important;
                        transform-origin: center !important;
                        display: inline-block !important;
                    `;
                    
                    quickAddBtn.onmouseenter = function() {
                        const svg = quickAddBtn.querySelector('svg');
                        if (svg) {
                            svg.style.transform = 'rotate(90deg)';
                            svg.style.stroke = '#059669';
                        }
                    };
                    
                    quickAddBtn.onmouseleave = function() {
                        const svg = quickAddBtn.querySelector('svg');
                        if (svg) {
                            svg.style.transform = 'rotate(0deg)';
                            svg.style.stroke = '';
                        }
                    };
                    
                    return true;
                }
                return false;
            }
            
            // Retry setup with delays for Lucide
            if (!setupQuickAddAnimation()) {
                setTimeout(() => {
                    if (!setupQuickAddAnimation()) {
                        setTimeout(setupQuickAddAnimation, 1000);
                    }
                }, 500);
            }
            
            // Setup Timer and Settings hover animations
            function setupActionButtonHovers() {
                const timerBtn = document.getElementById('timer-btn');
                const settingsBtn = document.getElementById('settings-btn');
                
                if (timerBtn?.querySelector('svg')) {
                    timerBtn.onmouseenter = function() {
                        const svg = timerBtn.querySelector('svg');
                        if (svg && !timerBtn.classList.contains('timer-running') && !timerBtn.classList.contains('timer-paused')) {
                            svg.style.stroke = '#059669';
                            svg.style.color = '#059669';
                        }
                    };
                    timerBtn.onmouseleave = function() {
                        const svg = timerBtn.querySelector('svg');
                        if (svg && !timerBtn.classList.contains('timer-running') && !timerBtn.classList.contains('timer-paused')) {
                            svg.style.stroke = '';
                            svg.style.color = '';
                        }
                    };
                }
                
                if (settingsBtn?.querySelector('svg')) {
                    settingsBtn.onmouseenter = function() {
                        const svg = settingsBtn.querySelector('svg');
                        if (svg) {
                            svg.style.stroke = '#059669';
                            svg.style.color = '#059669';
                        }
                    };
                    settingsBtn.onmouseleave = function() {
                        const svg = settingsBtn.querySelector('svg');
                        if (svg) {
                            svg.style.stroke = '';
                            svg.style.color = '';
                        }
                    };
                }
            }
            
            // Setup action button hovers after Lucide
            setTimeout(setupActionButtonHovers, 1000);
        }

        // Timer button event listener
        const timerBtn = document.getElementById('timer-btn');
        if (timerBtn) {
            // Left click: start/stop
            timerBtn.addEventListener('click', () => {
                console.log('Timer clicked');
                if (window.PomodoroTimer) {
                    window.PomodoroTimer.toggle();
                }
            });
            
            // Right click: reset to 25:00
            timerBtn.addEventListener('contextmenu', (e) => {
                e.preventDefault(); // Prevent context menu
                console.log('Timer right-clicked - reset');
                if (window.PomodoroTimer) {
                    window.PomodoroTimer.reset();
                }
            });
        }

        // Todo category tabs
        document.querySelectorAll('.category-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-category');
                switchCategory(categoryId);
            });
        });

        // Ziele category tabs
        document.querySelectorAll('.ziel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-ziel-category');
                switchZielCategory(categoryId);
            });
        });

        // Resource category tabs
        document.querySelectorAll('.resource-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-resource-category');
                switchResourceCategory(categoryId);
            });
        });

        // Journal category tabs
        document.querySelectorAll('.journal-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-journal-category');
                switchJournalCategory(categoryId);
            });
        });

        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', async function() {
                // ToDo-Items als completed markieren
                const todoItem = this.closest('.todo-item');
                if (todoItem) {
                    todoItem.classList.toggle('completed', this.checked);
                }
                
                // Routine-Progress aktualisieren (nur bei Routine-Checkboxen)
                const routineSection = this.closest('.routine-section');
                if (routineSection) {
                    // Apply visual styling immediately
                    const label = this.nextElementSibling;
                    if (label) {
                        if (this.checked) {
                            label.style.textDecoration = 'line-through';
                            label.style.color = '#999';
                        } else {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    }
                    
                    // DISABLED - SimpleRoutineManager handles this
                    // await saveCheckboxState(this.id, this.checked);
                    // updateRoutineProgress();
                }
            });
        });

        // === TODO MANAGEMENT ===
        const TodoManager = {
            todos: [], // In-memory storage for demo
            
            priorityIntToString(priorityInt) {
                switch(priorityInt) {
                    case 1: return 'mittel'; // Map old niedrig to mittel
                    case 2: return 'mittel';
                    case 3: return 'wichtig';
                    case 4: return 'dringend';
                    default: return 'mittel';
                }
            },
            
            getPriorityString(priority) {
                if (typeof priority === 'string') {
                    return priority;
                }
                return this.priorityIntToString(priority);
            },
            
            getPriorityDisplay(priority) {
                const priorityStr = this.getPriorityString(priority);
                return priorityStr.charAt(0).toUpperCase() + priorityStr.slice(1);
            },
            
            async loadTodos() {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TodoManager: Not authenticated - pure cloud mode requires authentication');
                    this.todos = [];
                    return;
                }
                
                try {
                    const user = supabase.getCurrentUser();
                    const data = await supabase.query(`todos?user_id=eq.${user.id}&select=*`);
                    if (data && Array.isArray(data)) {
                        // Transform database data to match UI expectations
                        this.todos = data.map(todo => {
                            // Convert priority integer back to string
                            let priorityString = 'mittel';
                            switch(todo.priority) {
                                case 1: priorityString = 'mittel'; break; // Map old niedrig to mittel
                                case 2: priorityString = 'mittel'; break;
                                case 3: priorityString = 'wichtig'; break;
                                case 4: priorityString = 'dringend'; break;
                                default: priorityString = 'mittel';
                            }
                            
                            return {
                                ...todo,
                                title: todo.text, // Map text to title for UI
                                deadline: todo.date, // Use date field only (no due_date)
                                priority: priorityString // Convert integer to string
                            };
                        });
                        console.log(`☁️ TodoManager: Loaded ${this.todos.length} todos from cloud`);
                        this.refreshCurrentView();
                        this.updateHomeTodos();
                    } else {
                        console.log('☁️ TodoManager: No todos found in cloud');
                        this.todos = [];
                    }
                } catch (error) {
                    console.error('❌ TodoManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            showAddTodoModal() {
                const modal = document.getElementById('add-todo-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('todo-deadline').value = today;
            },
            
            hideAddTodoModal() {
                const modal = document.getElementById('add-todo-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-todo-form').reset();
                // Reset to default values
                document.getElementById('todo-time').value = '21:00';
                document.getElementById('todo-priority').value = 'mittel';
            },
            
            async addTodo(todoData) {
                // DON'T create due_date with timezone - it causes issues
                // Just store date and time separately
                
                // Convert priority string to integer
                let priorityInt = 2; // Default to mittel
                switch(todoData.priority) {
                    case 'niedrig': priorityInt = 1; break; // Keep for backwards compatibility
                    case 'mittel': priorityInt = 2; break;
                    case 'wichtig': priorityInt = 3; break;
                    case 'dringend': priorityInt = 4; break;
                    default: priorityInt = 2;
                }
                console.log('🎯 Priority conversion:', todoData.priority, '→', priorityInt);
                
                const todo = {
                    text: todoData.title,
                    category: todoData.category,
                    priority: priorityInt,
                    date: todoData.deadline,
                    time: todoData.time,
                    // Remove due_date field to avoid timezone issues
                    completed: false,
                    user_id: supabase?.user?.id || 'anonymous'
                };
                
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TodoManager: Not authenticated - cannot add todo in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Todo kann nicht gespeichert werden.');
                    return;
                }
                
                try {
                    const result = await supabase.insert('todos', todo);
                    console.log('💾 Supabase insert result:', result);
                    if (result && Array.isArray(result) && result.length > 0) {
                        // Transform the database result to match UI expectations
                        const dbTodo = result[0];
                        console.log('☁️ TodoManager: Todo saved to cloud with ID:', dbTodo.id);
                        const uiTodo = {
                            ...dbTodo,
                            title: dbTodo.text,
                            deadline: dbTodo.date, // Use date field only
                            priority: this.priorityIntToString(dbTodo.priority || 1)
                        };
                        this.todos.push(uiTodo);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ TodoManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Todos: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('Todo added:', todo);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.category-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-category') : 'heute';
                
                console.log('🔄 Refreshing view for category:', activeCategory);
                console.log('🔄 All todos (completed status):', this.todos.map(t => ({title: t.title, completed: t.completed})));
                
                this.displayTodosForCategory(activeCategory);
                
                // Also update home todos
                this.updateHomeTodos();
                
                // Update overdue badge
                this.updateOverdueBadge();
            },
            
            updateOverdueBadge() {
                // Count overdue todos
                const today = new Date();
                const todayStr = today.getFullYear() + '-' + 
                               String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(today.getDate()).padStart(2, '0');
                
                const overdueCount = this.todos.filter(todo => 
                    todo.date && todo.date < todayStr && !todo.completed
                ).length;
                
                const badge = document.getElementById('overdue-count');
                if (badge) {
                    if (overdueCount > 0) {
                        badge.textContent = overdueCount;
                        badge.style.display = 'inline';
                    } else {
                        badge.style.display = 'none';
                    }
                }
            },
            
            displayTodosForCategory(category) {
                const container = document.getElementById(category);
                if (!container) return;
                
                let filteredTodos = [];
                
                switch(category) {
                    case 'heute':
                        // Get today without timezone conversion
                        const today = new Date();
                        const todayStr = today.getFullYear() + '-' + 
                                       String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                                       String(today.getDate()).padStart(2, '0');
                        
                        // Include both today's todos AND overdue todos
                        filteredTodos = this.todos.filter(todo => 
                            todo.date && todo.date <= todayStr && !todo.completed
                        );
                        break;
                    case 'alle':
                        filteredTodos = this.todos.filter(todo => !todo.completed);
                        break;
                    case 'archiv':
                        filteredTodos = this.todos.filter(todo => todo.completed);
                        break;
                    default:
                        filteredTodos = this.todos.filter(todo => 
                            todo.category === category && !todo.completed
                        );
                }
                // Sort by date first, then by time
                filteredTodos.sort((a, b) => {
                    // First by date
                    const dateA = a.date || '9999-12-31';
                    const dateB = b.date || '9999-12-31';
                    const dateComparison = dateA.localeCompare(dateB);
                    
                    if (dateComparison !== 0) {
                        return dateComparison;
                    }
                    
                    // Then by time
                    const timeA = a.time || '23:59';
                    const timeB = b.time || '23:59';
                    return timeA.localeCompare(timeB);
                });
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredTodos.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Todos vorhanden</p>';
                    return;
                }
                
                // Create grid for todos
                const grid = document.createElement('div');
                grid.className = 'grid-3'; // 3-spaltig für kompaktere Todo-Kacheln
                
                // Display todos
                filteredTodos.forEach(todo => {
                    const todoElement = this.createTodoElement(todo);
                    grid.appendChild(todoElement);
                });
                
                container.appendChild(grid);
            },
            
            createTodoElement(todo) {
                const todoCard = document.createElement('div');
                todoCard.className = `ziel-card${todo.completed ? ' completed' : ''}`;
                todoCard.dataset.todoId = todo.id;
                
                // COMPLETELY AVOID DATE PARSING - just use raw strings
                let deadlineClass = '';
                let deadlineText = '';
                
                if (todo.date) {
                    // Get today as YYYY-MM-DD string (no timezone conversion)
                    const today = new Date();
                    const todayStr = today.getFullYear() + '-' + 
                                   String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                                   String(today.getDate()).padStart(2, '0');
                    
                    const isToday = todo.date === todayStr;
                    
                    if (todo.time) {
                        // Todo has both date and time
                        const todoDate = new Date(todo.date + 'T' + todo.time);
                        const now = new Date();
                        
                        if (isToday) {
                            // Check if time has passed for today
                            if (todoDate < now) {
                                deadlineClass = 'overdue';
                                deadlineText = `Überfällig ${todo.time}`;
                            } else {
                                deadlineClass = 'today';
                                deadlineText = `Heute ${todo.time}`;
                            }
                        } else if (todo.date < todayStr) {
                            // Past date - definitely overdue
                            deadlineClass = 'overdue';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = `Überfällig ${germanDate} ${todo.time}`;
                        } else {
                            // Future date
                            deadlineClass = 'soon';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = `${germanDate} ${todo.time}`;
                        }
                    } else {
                        // Todo has only date, no time
                        if (isToday) {
                            deadlineClass = 'today';
                            deadlineText = 'Heute';
                        } else if (todo.date < todayStr) {
                            // Past date - overdue
                            deadlineClass = 'overdue';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = `Überfällig ${germanDate}`;
                        } else {
                            // Future date
                            deadlineClass = 'soon';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = germanDate;
                        }
                    }
                } else {
                    deadlineText = 'Kein Termin';
                    deadlineClass = 'none';
                }
                
                // Calculate days until deadline (similar to termine)
                let daysUntilText = '';
                let daysUntilBadge = '';
                if (todo.date) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const todoDateObj = new Date(todo.date);
                    todoDateObj.setHours(0, 0, 0, 0);
                    const daysDifference = Math.ceil((todoDateObj - today) / (1000 * 60 * 60 * 24));
                    
                    if (daysDifference === 0) {
                        daysUntilText = 'Heute';
                        daysUntilBadge = `<span class="days-until-badge heute">Heute</span>`;
                    } else if (daysDifference === 1) {
                        daysUntilText = 'Morgen';
                        daysUntilBadge = `<span class="days-until-badge morgen">Morgen</span>`;
                    } else if (daysDifference === -1) {
                        daysUntilText = 'Gestern';
                        daysUntilBadge = `<span class="days-until-badge overdue">1 Tag überfällig</span>`;
                    } else if (daysDifference > 1) {
                        daysUntilText = `in ${daysDifference} Tagen`;
                        daysUntilBadge = `<span class="days-until-badge future">${daysDifference} Tage</span>`;
                    } else if (daysDifference < -1) {
                        daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                        daysUntilBadge = `<span class="days-until-badge overdue">${Math.abs(daysDifference)} Tage überfällig</span>`;
                    }
                }

                todoCard.innerHTML = `
                    <div class="ziel-kategorie">${todo.category}</div>
                    <div class="ziel-header">
                        <div class="ziel-name">${todo.title}</div>
                        <div class="ziel-beschreibung">
                            <span class="todo-deadline ${deadlineClass}">${deadlineText}</span>
                            ${daysUntilBadge}
                        </div>
                    </div>
                    <div class="ziel-progress-section">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <input type="checkbox" class="todo-checkbox" ${todo.completed ? 'checked' : ''} 
                                   onchange="TodoManager.toggleTodo('${todo.id}')"
                                   style="width: 20px; height: 20px; border: 2px solid #000; appearance: none; cursor: pointer;">
                            <span class="todo-tag ${TodoManager.getPriorityString(todo.priority)}" style="margin-left: auto;">${TodoManager.getPriorityDisplay(todo.priority)}</span>
                        </div>
                    </div>
                `;
                
                // Add checkbox styling
                const checkbox = todoCard.querySelector('.todo-checkbox');
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        this.style.backgroundColor = '#000';
                        this.innerHTML = '<span style="color: white; position: absolute; top: -2px; left: 2px; font-size: 12px;">✓</span>';
                    } else {
                        this.style.backgroundColor = 'transparent';
                        this.innerHTML = '';
                    }
                });
                
                // Set initial checkbox state
                if (todo.completed) {
                    checkbox.style.backgroundColor = '#000';
                    checkbox.innerHTML = '<span style="color: white; position: absolute; top: -2px; left: 2px; font-size: 12px;">✓</span>';
                }
                
                return todoCard;
            },
            
            async toggleTodo(todoId) {
                console.log('🔍 Looking for todo with ID:', todoId, 'Type:', typeof todoId);
                console.log('🔍 Available todos:', this.todos.map(t => ({id: t.id, type: typeof t.id, title: t.title})));
                
                const todo = this.todos.find(t => String(t.id) === String(todoId));
                if (todo) {
                    const wasCompleted = todo.completed;
                    todo.completed = !todo.completed;
                    console.log(`✅ Todo "${todo.title}" ${todo.completed ? 'completed' : 'uncompleted'}`);
                    console.log(`🔍 DEBUG: wasCompleted = ${wasCompleted}, todo.completed = ${todo.completed}`);
                    
                    // Update counter display when todo status changes (now cloud-based)
                    if (todo.completed !== wasCompleted) {
                        console.log('☁️ Todo status changed, will refresh cloud counter after database update...');
                    }
                    
                    if (supabase?.isAuthenticated()) {
                        try {
                            console.log('💾 Updating in database - ID:', todo.id, 'Type:', typeof todo.id, 'Completed:', todo.completed);
                            
                            // Make sure we use the right ID type
                            const updateId = Number.isInteger(Number(todo.id)) ? Number(todo.id) : todo.id;
                            const result = await supabase.update('todos', { completed: todo.completed }, updateId);
                            
                            console.log('💾 Database update result:', result);
                            
                            console.log('✅ Database update successful');
                            
                            // Refresh simple counter after successful database update
                            if (todo.completed !== wasCompleted) {
                                console.log('☁️ Refreshing todo counter via SimpleCounters...');
                                if (window.SimpleCounters) {
                                    window.SimpleCounters.onTodoChanged();
                                }
                            }
                            
                        } catch (error) {
                            console.error('❌ Database update failed:', error);
                            alert('Fehler: ' + error.message + '\nTodo wird nicht gespeichert!');
                            // Revert on error
                            todo.completed = wasCompleted;
                            return; // Don't refresh if update failed
                        }
                    }
                    
                    this.refreshCurrentView();
                    this.updateHomeTodos();
                } else {
                    console.error('❌ Todo not found for ID:', todoId);
                    alert('Todo nicht gefunden! ID: ' + todoId);
                }
            },
            
            async clearArchive() {
                console.log('☁️ TodoManager: clearArchive() called (pure cloud mode)');
                if (!confirm('Wirklich alle erledigten Todos dauerhaft löschen?\n\nDiese Aktion kann nicht rückgängig gemacht werden!')) {
                    console.log('🔍 Archive clear cancelled by user');
                    return;
                }
                
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TodoManager: Not authenticated - cannot clear archive in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Archive kann nicht geleert werden.');
                    return;
                }
                
                const completedTodos = this.todos.filter(todo => todo.completed);
                console.log('☁️ TodoManager: Deleting', completedTodos.length, 'completed todos from cloud');
                
                try {
                    // Delete from cloud database
                    for (const todo of completedTodos) {
                        console.log(`☁️ Deleting todo from cloud: ID ${todo.id}, Title: "${todo.title}"`);
                        if (!todo.id) {
                            console.warn(`⚠️ Skipping todo without ID: "${todo.title}"`);
                            continue;
                        }
                        const result = await supabase.delete('todos', String(todo.id));
                        console.log(`✅ Delete result for ${todo.id}:`, result);
                    }
                    console.log('☁️ TodoManager: All completed todos deleted from cloud');
                    
                    // Remove from local array
                    this.todos = this.todos.filter(todo => !todo.completed);
                    
                    // Refresh current view
                    this.refreshCurrentView();
                    
                    alert(`✅ ${completedTodos.length} erledigte Todos wurden gelöscht!`);
                } catch (error) {
                    console.error('❌ TodoManager: Error deleting from cloud:', error);
                    alert('Fehler beim Löschen aus der Cloud: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            updateHomeTodos() {
                const homeContainer = document.getElementById('home-todos');
                if (!homeContainer) return;
                
                // Show today's and overdue uncompleted todos on home
                const today = new Date();
                const todayStr = today.getFullYear() + '-' + 
                               String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(today.getDate()).padStart(2, '0');
                
                const todayTodos = this.todos.filter(todo => 
                    todo.date && todo.date <= todayStr && !todo.completed
                ).sort((a, b) => {
                    // First sort by date (overdue first)
                    const dateA = a.date || '9999-12-31';
                    const dateB = b.date || '9999-12-31';
                    const dateComparison = dateA.localeCompare(dateB);
                    
                    if (dateComparison !== 0) {
                        return dateComparison;
                    }
                    
                    // Then by time
                    const timeA = a.time || '23:59';
                    const timeB = b.time || '23:59';
                    return timeA.localeCompare(timeB);
                });
                
                homeContainer.innerHTML = '';
                
                if (todayTodos.length === 0) {
                    homeContainer.innerHTML = '<p style="text-align: center; color: #666; padding: 1rem;">Keine Todos für heute</p>';
                    return;
                }
                
                todayTodos.forEach(todo => {
                    const todoItem = document.createElement('div');
                    todoItem.className = 'checkbox-item todo-item';
                    todoItem.innerHTML = `
                        <div class="todo-left">
                            <input type="checkbox" id="home-todo-${todo.id}" onchange="TodoManager.toggleTodo('${todo.id}')">
                            <label for="home-todo-${todo.id}">
                                ${todo.title} 
                                <span class="todo-tag ${TodoManager.getPriorityString(todo.priority)}" style="margin-left: 0.5rem;">${TodoManager.getPriorityDisplay(todo.priority)}</span>
                            </label>
                        </div>
                        <span class="todo-time">${todo.time || '21:00'}</span>
                    `;
                    homeContainer.appendChild(todoItem);
                });
                
                // Also update overdue badge when updating home
                this.updateOverdueBadge();
            }
        };

        // Make TodoManager globally available
        window.TodoManager = TodoManager;

        // === GOAL MANAGEMENT ===
        const GoalManager = {
            goals: [], // In-memory storage for demo
            
            async loadGoals() {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ GoalManager: Not authenticated - pure cloud mode requires authentication');
                    this.goals = [];
                    return;
                }
                
                try {
                    const user = supabase.getCurrentUser();
                    const data = await supabase.query(`goals?user_id=eq.${user.id}&select=*`);
                    console.log('☁️ GoalManager: Raw goals from cloud:', data);
                    if (data && Array.isArray(data)) {
                        // Transform database data to match UI expectations
                        this.goals = data.map(goal => {
                            console.log('🔄 Transforming goal:', goal);
                            return {
                                ...goal,
                                name: goal.title, // Map title to name for UI
                                deadline: goal.target_date, // Map target_date to deadline for UI
                                progress: goal.progress || 0, // Use DB progress field
                                timeframe: goal.timeframe || 'monat', // Use DB timeframe field
                                completed: goal.completed, // Use DB completed field
                                // Map new progress fields
                                startValue: goal.start_value,
                                targetValue: goal.target_value, 
                                currentValue: goal.current_value,
                                unit: goal.unit
                            };
                        });
                        console.log(`☁️ GoalManager: Loaded ${this.goals.length} goals from cloud`);
                        this.refreshCurrentView();
                    } else {
                        console.log('☁️ GoalManager: No goals found in cloud');
                        this.goals = [];
                    }
                } catch (error) {
                    console.error('❌ GoalManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            // Calculate automatic deadlines based on timeframe
            calculateDeadline(timeframe) {
                const now = new Date();
                
                switch(timeframe) {
                    case 'monat': {
                        // Last day of current month - use day 0 of next month
                        const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                        // Format manually to avoid timezone issues
                        const year = endOfMonth.getFullYear();
                        const month = String(endOfMonth.getMonth() + 1).padStart(2, '0');
                        const day = String(endOfMonth.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    case 'quartal': {
                        // Last day of current quarter
                        const currentQuarter = Math.floor(now.getMonth() / 3);
                        const quarterEndMonth = (currentQuarter + 1) * 3; // 3, 6, 9, 12
                        const endOfQuarter = new Date(now.getFullYear(), quarterEndMonth, 0);
                        // Format manually to avoid timezone issues
                        const year = endOfQuarter.getFullYear();
                        const month = String(endOfQuarter.getMonth() + 1).padStart(2, '0');
                        const day = String(endOfQuarter.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    case 'jahr': {
                        // December 31st of current year
                        const year = now.getFullYear();
                        return `${year}-12-31`;
                    }
                    default:
                        return now.toISOString().split('T')[0];
                }
            },
            
            showAddGoalModal() {
                const modal = document.getElementById('add-goal-modal');
                modal.classList.remove('hide');
                
                // Set default deadline based on current timeframe selection
                const timeframeSelect = document.getElementById('goal-timeframe');
                const deadlineInput = document.getElementById('goal-deadline');
                if (timeframeSelect && deadlineInput) {
                    deadlineInput.value = this.calculateDeadline(timeframeSelect.value);
                }
            },
            
            hideAddGoalModal() {
                const modal = document.getElementById('add-goal-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-goal-form').reset();
            },
            
            calculateProgress(startValue, targetValue, currentValue) {
                if (startValue === targetValue) return 100; // Edge case
                const progress = ((currentValue - startValue) / (targetValue - startValue)) * 100;
                return Math.max(0, Math.min(100, Math.round(progress))); // Clamp between 0-100
            },
            
            async addGoal(goalData) {
                const goal = {
                    id: Date.now().toString(),
                    name: goalData.name,
                    description: goalData.description,
                    category: goalData.category,
                    timeframe: goalData.timeframe, // WICHTIG: timeframe für Filterung
                    deadline: goalData.deadline,
                    unit: goalData.unit || '',
                    startValue: goalData.startValue || 0,
                    targetValue: goalData.targetValue,
                    currentValue: goalData.startValue || 0, // Start with start value
                    progress: 0, // Will be calculated
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                // Calculate initial progress
                goal.progress = this.calculateProgress(goal.startValue, goal.targetValue, goal.currentValue);
                
                console.log('🎯 Created goal with progress data:', {
                    name: goal.name,
                    startValue: goal.startValue,
                    targetValue: goal.targetValue,
                    currentValue: goal.currentValue,
                    unit: goal.unit,
                    progress: goal.progress
                });
                
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ GoalManager: Not authenticated - cannot add goal in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Ziel kann nicht gespeichert werden.');
                    return;
                }
                
                try {
                    // Map UI fields to database schema - all progress fields now supported
                    const dbGoal = {
                        title: goal.name,
                        description: goal.description,
                        category: goal.category,
                        target_date: goal.deadline,
                        progress: goal.progress,
                        timeframe: goal.timeframe,
                        completed: goal.completed,
                        start_value: goal.startValue,
                        target_value: goal.targetValue, 
                        current_value: goal.currentValue,
                        unit: goal.unit,
                        user_id: supabase?.user?.id
                    };
                    
                    console.log('☁️ GoalManager: Saving goal to cloud:', dbGoal);
                    const result = await supabase.insert('goals', dbGoal);
                    console.log('☁️ GoalManager: Cloud result:', result);
                    
                    if (result && Array.isArray(result) && result.length > 0) {
                        // Use database result and transform back to UI format
                        const savedGoal = {
                            ...result[0],
                            name: result[0].title,
                            deadline: result[0].target_date,
                            timeframe: result[0].timeframe,
                            progress: result[0].progress,
                            completed: result[0].completed,
                            startValue: result[0].start_value,
                            targetValue: result[0].target_value,
                            currentValue: result[0].current_value,
                            unit: result[0].unit,
                            database_id: result[0].id // Store real DB ID for updates
                        };
                        this.goals.push(savedGoal);
                        console.log('☁️ GoalManager: Goal saved to cloud with ID:', result[0].id);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ GoalManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Ziels: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('Goal added:', goal);
                console.log('All goals after adding:', this.goals);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.ziel-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-ziel-category') : 'alle';
                
                console.log('🎯 Goals refresh - active category:', activeCategory);
                console.log('🎯 All goals:', this.goals.map(g => ({name: g.name, category: g.category, timeframe: g.timeframe})));
                
                this.displayGoalsForCategory(activeCategory);
            },
            
            displayGoalsForCategory(category) {
                const container = document.getElementById(`ziel-${category}`);
                if (!container) return;
                
                let filteredGoals = [];
                
                switch(category) {
                    case 'monat':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'monat' && !goal.completed
                        );
                        break;
                    case 'quartal':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'quartal' && !goal.completed
                        );
                        break;
                    case 'jahr':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'jahr' && !goal.completed
                        );
                        break;
                    case 'alle':
                        filteredGoals = this.goals.filter(goal => !goal.completed);
                        break;
                    case 'archiv':
                        filteredGoals = this.goals.filter(goal => goal.completed);
                        break;
                }
                
                // Sort by deadline
                filteredGoals.sort((a, b) => new Date(a.deadline) - new Date(b.deadline));
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredGoals.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Ziele vorhanden</p>';
                    return;
                }
                
                // Create grid for goals
                const grid = document.createElement('div');
                grid.className = 'grid-2';
                
                // Display goals
                filteredGoals.forEach(goal => {
                    const goalElement = this.createGoalElement(goal);
                    grid.appendChild(goalElement);
                });
                
                container.appendChild(grid);
            },
            
            createGoalElement(goal) {
                const goalCard = document.createElement('div');
                goalCard.className = `termin-card${goal.completed ? ' completed' : ''}`;
                goalCard.dataset.goalId = goal.id;
                
                // Calculate days until deadline (exactly like termine)
                let daysUntilText = '';
                let badgeColor1 = '';
                let badgeColor2 = '';
                let formattedDeadline = '';
                
                if (goal.deadline) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const goalDate = new Date(goal.deadline);
                    goalDate.setHours(0, 0, 0, 0);
                    const daysDifference = Math.ceil((goalDate - today) / (1000 * 60 * 60 * 24));
                    
                    // Format deadline like termine
                    formattedDeadline = goalDate.toLocaleDateString('de-DE', {
                        weekday: 'long',
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric'
                    });
                    
                    // Badge styling (exactly like termine)
                    if (daysDifference === 0) {
                        daysUntilText = 'Heute';
                        badgeColor1 = '#ef4444';
                        badgeColor2 = '#dc2626';
                    } else if (daysDifference === 1) {
                        daysUntilText = 'Morgen';
                        badgeColor1 = '#f97316';
                        badgeColor2 = '#ea580c';
                    } else if (daysDifference === -1) {
                        daysUntilText = 'Gestern';
                        badgeColor1 = '#6b7280';
                        badgeColor2 = '#4b5563';
                    } else if (daysDifference > 1) {
                        daysUntilText = `in ${daysDifference} Tagen`;
                        badgeColor1 = '#3b82f6';
                        badgeColor2 = '#2563eb';
                    } else if (daysDifference < -1) {
                        daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                        badgeColor1 = '#6b7280';
                        badgeColor2 = '#4b5563';
                    }
                }
                
                // Set CSS custom properties for badge colors (like terme)
                const badgeColorVars = `--badge-color-1: ${badgeColor1}; --badge-color-2: ${badgeColor2};`;
                goalCard.style.cssText += badgeColorVars;
                
                // Prepare progress display  
                const hasProgressData = goal.hasOwnProperty('startValue') && goal.hasOwnProperty('targetValue');
                console.log('🔍 Goal progress check for:', goal.name);
                console.log('🔍 hasProgressData:', hasProgressData);
                console.log('🔍 startValue:', goal.startValue, typeof goal.startValue);
                console.log('🔍 targetValue:', goal.targetValue, typeof goal.targetValue);
                console.log('🔍 currentValue:', goal.currentValue, typeof goal.currentValue);
                console.log('🔍 progress:', goal.progress);
                const progressSection = hasProgressData ? `
                    <div class="goal-progress-section" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0;">
                        <div class="goal-values" style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem; color: #666;">
                            <span>${goal.startValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                            <span style="font-weight: 600; color: #000;">${goal.currentValue || goal.startValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                            <span>${goal.targetValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                        </div>
                        <div class="progress-container" style="background: #f0f0f0; height: 6px; border-radius: 3px; overflow: hidden;">
                            <div class="progress-fill" style="background: linear-gradient(90deg, #3b82f6, #1d4ed8); height: 100%; width: ${goal.progress || 0}%; transition: width 0.3s ease;"></div>
                        </div>
                        <div style="text-align: center; margin-top: 0.5rem; font-size: 0.9rem; font-weight: 600; color: #1d4ed8;">
                            ${goal.progress || 0}%
                        </div>
                    </div>
                ` : '';
                
                console.log('🔍 progressSection generated:', hasProgressData ? 'YES' : 'NO');
                console.log('🔍 progressSection length:', progressSection.length);

                goalCard.innerHTML = `
                    ${daysUntilText ? `<div class="ziel-days-until">${daysUntilText}</div>` : ''}
                    <div class="ziel-kategorie">${goal.category}</div>
                    ${formattedDeadline ? `<div class="termin-date">🎯 ${formattedDeadline}</div>` : ''}
                    <div class="termin-title">${goal.name}</div>
                    <div class="termin-description">${goal.description}</div>
                    ${progressSection}
                    <div class="termin-edit-icon" onclick="GoalManager.showEditGoalValueModal('${goal.id}')">✎</div>
                    <div class="termin-delete-icon" onclick="GoalManager.deleteGoal('${goal.id}')">🗑</div>
                `;
                
                return goalCard;
            },
            
            async updateGoalProgress(goalId, newProgress) {
                const goal = this.goals.find(g => g.id == goalId); // Use == for flexible ID matching
                if (goal) {
                    const oldProgress = goal.progress;
                    goal.progress = parseInt(newProgress);
                    goal.completed = goal.progress >= 100;
                    
                    console.log('🎯 Updating goal:', goal.name, 'to progress:', goal.progress);
                    
                    // Check if goal has real database ID or use database_id field
                    const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                    
                    if (supabase?.isAuthenticated() && dbId) {
                        try {
                            console.log('💾 Updating goal in database with ID:', dbId);
                            const result = await supabase.update('goals', { 
                                progress: goal.progress,
                                completed: goal.completed
                            }, dbId);
                            console.log('✅ Goal progress updated in cloud database:', result);
                        } catch (error) {
                            console.error('❌ Error updating goal progress:', error);
                            // Don't revert - keep local change even if DB fails
                            console.warn('⚠️ Goal updated locally only (database update failed)');
                        }
                    } else {
                        console.warn('⚠️ Goal updated locally only (no database ID or not authenticated)');
                    }
                    
                    console.log('✅ Goal progress updated locally:', goal);
                    this.refreshCurrentView();
                } else {
                    console.error('❌ Goal not found for ID:', goalId);
                }
            },
            
            showEditGoalValueModal(goalId) {
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                const currentValue = goal.currentValue || goal.startValue || 0;
                const unit = goal.unit ? ` ${goal.unit}` : '';
                
                // Set modal title and current status
                document.getElementById('edit-goal-modal-title').textContent = `Fortschritt für "${goal.name}"`;
                document.getElementById('edit-goal-current-status').innerHTML = `
                    <strong>Aktueller Status:</strong><br>
                    Start: <strong>${goal.startValue}${unit}</strong> → 
                    Ziel: <strong>${goal.targetValue}${unit}</strong><br>
                    Aktuell: <strong>${currentValue}${unit}</strong> 
                    (${goal.progress || 0}% erreicht)
                `;
                
                // Pre-fill current value
                document.getElementById('new-goal-value').value = currentValue;
                
                // Store goal ID for form submission
                document.getElementById('edit-goal-value-form').dataset.goalId = goalId;
                
                // Show modal
                document.getElementById('edit-goal-value-modal').classList.remove('hide');
                
                // Ensure event listeners are set up when modal opens
                console.log('🎯 Modal opened, reinitializing event listeners...');
                if (window.initGoalEditModalEventListeners) {
                    window.initGoalEditModalEventListeners();
                }
                
                // Focus input
                setTimeout(() => {
                    document.getElementById('new-goal-value').focus();
                    document.getElementById('new-goal-value').select();
                }, 100);
            },
            
            hideEditGoalValueModal() {
                document.getElementById('edit-goal-value-modal').classList.add('hide');
                document.getElementById('edit-goal-value-form').reset();
                delete document.getElementById('edit-goal-value-form').dataset.goalId;
            },
            
            async editGoalValue(goalId) {
                console.log('🎯 editGoalValue called with goalId:', goalId);
                
                // This method is now called by the modal form submission
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    console.error('❌ Goal not found for ID:', goalId);
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                console.log('🎯 Found goal:', goal.name, 'Current value:', goal.currentValue);
                
                const newValueInput = document.getElementById('new-goal-value').value;
                console.log('🎯 Input value:', newValueInput);
                
                const newValue = parseFloat(newValueInput);
                if (isNaN(newValue)) {
                    console.error('❌ Invalid number:', newValueInput);
                    alert('Bitte eine gültige Zahl eingeben!');
                    return;
                }
                
                console.log('🎯 Parsed new value:', newValue);
                
                // Pure cloud mode - require authentication
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ GoalManager: Not authenticated - cannot update goal value in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Ziel-Wert kann nicht aktualisiert werden.');
                    return;
                }
                
                const unit = goal.unit ? ` ${goal.unit}` : '';
                
                // Update values
                const oldCurrentValue = goal.currentValue;
                const oldProgress = goal.progress;
                
                goal.currentValue = newValue;
                goal.progress = this.calculateProgress(goal.startValue, goal.targetValue, goal.currentValue);
                goal.completed = goal.progress >= 100;
                
                console.log('🎯 Updated values:', {
                    oldCurrentValue,
                    newCurrentValue: goal.currentValue,
                    oldProgress,
                    newProgress: goal.progress,
                    startValue: goal.startValue,
                    targetValue: goal.targetValue
                });
                
                // Update in database - use database ID
                const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                console.log('🎯 Database ID for update:', dbId);
                
                if (dbId) {
                    try {
                        console.log('💾 Updating goal in database...');
                        const updateData = { 
                            current_value: goal.currentValue, // Use DB field name
                            progress: goal.progress,
                            completed: goal.completed
                        };
                        console.log('💾 Update data:', updateData);
                        
                        await supabase.update('goals', updateData, dbId);
                        console.log('✅ Goal value updated in database');
                    } catch (error) {
                        console.error('❌ Error updating goal value:', error);
                        alert('Fehler beim Speichern: ' + error.message);
                        return;
                    }
                } else {
                    console.error('❌ No valid database ID found for goal:', goal);
                    alert('Fehler: Kann Ziel nicht in der Datenbank aktualisieren (keine gültige ID).');
                    return;
                }
                
                // Hide modal and refresh view
                console.log('🎯 Hiding modal and refreshing view...');
                this.hideEditGoalValueModal();
                this.refreshCurrentView();
                
                console.log('✅ Goal value updated:', goal.name, `${goal.currentValue}${unit}`, `${goal.progress}%`);
            },
            
            async deleteGoal(goalId) {
                if (!confirm('Dieses Ziel ins Archiv verschieben?\n\n(Es wird als abgeschlossen markiert und ins Archiv verschoben)')) {
                    return;
                }
                
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    console.error('❌ Goal not found for archiving:', goalId);
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                console.log('📦 Archiving goal:', goal.name);
                
                // Mark as completed (move to archive)
                const oldCompleted = goal.completed;
                goal.completed = true;
                goal.progress = 100; // Set to 100% when archived
                
                // Update in database if authenticated and has real DB ID
                const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                
                if (supabase?.isAuthenticated() && dbId) {
                    try {
                        console.log('💾 Updating goal in database with ID:', dbId);
                        await supabase.update('goals', { 
                            completed: true,
                            progress: 100
                        }, dbId);
                        console.log('✅ Goal archived in database');
                    } catch (error) {
                        console.error('❌ Error archiving goal in database:', error);
                        alert('Fehler beim Archivieren: ' + error.message);
                        // Revert on error
                        goal.completed = oldCompleted;
                        return;
                    }
                }
                
                // Refresh current view
                this.refreshCurrentView();
                
                console.log('✅ Goal archived successfully:', goal.name);
            },
            
            async clearGoalArchive() {
                if (!confirm('Wirklich alle erledigten Ziele dauerhaft löschen?\n\nDiese Aktion kann nicht rückgängig gemacht werden!')) {
                    return;
                }
                
                const completedGoals = this.goals.filter(goal => goal.completed);
                console.log('🗑️ Deleting', completedGoals.length, 'completed goals from archive');
                
                if (supabase?.isAuthenticated()) {
                    try {
                        // Delete from database (only goals with database IDs)
                        for (const goal of completedGoals) {
                            const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                            if (hasDbId) {
                                await supabase.delete('goals', goal.id);
                                console.log('💾 Deleted goal from database:', goal.name);
                            } else {
                                console.log('💾 Skipped local-only goal:', goal.name);
                            }
                        }
                        console.log('✅ All database goals deleted');
                    } catch (error) {
                        console.error('❌ Error deleting goals from database:', error);
                        alert('Fehler beim Löschen aus der Datenbank: ' + error.message);
                        return;
                    }
                }
                
                // Remove from local array
                this.goals = this.goals.filter(goal => !goal.completed);
                
                // Refresh current view
                this.refreshCurrentView();
                
                alert(`✅ ${completedGoals.length} erledigte Ziele wurden gelöscht!`);
            },
            
            clearLocalGoals() {
                if (confirm('Alle lokalen Ziele löschen? (Nur Ziele die nicht in der Datenbank sind)\n\nDas kann alte/kaputte Ziele entfernen.')) {
                    const before = this.goals.length;
                    // Keep only goals that look like they have database IDs
                    this.goals = this.goals.filter(goal => {
                        const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                        return hasDbId;
                    });
                    const after = this.goals.length;
                    console.log(`🗑️ Removed ${before - after} local-only goals`);
                    this.refreshCurrentView();
                    alert(`${before - after} lokale Ziele gelöscht!`);
                }
            },
            
            editGoalProgress(goalId) {
                console.log('✏️ Edit goal progress - ID:', goalId, 'Type:', typeof goalId);
                const goal = this.goals.find(g => g.id == goalId); // Flexible matching
                if (!goal) {
                    console.error('❌ Goal not found for edit. ID:', goalId);
                    console.log('❌ Available goals:', this.goals.map(g => ({id: g.id, name: g.name})));
                    return;
                }
                console.log('✏️ Editing goal:', goal.name, 'Current progress:', goal.progress);
                
                // Find the goal card and progress percentage element
                const goalCard = document.querySelector(`[data-goal-id="${goalId}"]`);
                const percentageElement = goalCard.querySelector('.ziel-percentage');
                const progressFill = goalCard.querySelector('.progress-fill');
                
                // Create inline edit container
                const editContainer = document.createElement('div');
                editContainer.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; background: #f9f9f9; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px;';
                
                // Create progress input
                const input = document.createElement('input');
                input.type = 'number';
                input.min = '0';
                input.max = '100';
                input.value = goal.progress;
                input.style.cssText = 'width: 50px; padding: 2px 4px; border: 1px solid #ccc; font-size: 0.9rem; text-align: center;';
                
                // Create complete button
                const completeBtn = document.createElement('button');
                completeBtn.textContent = '✓ Erledigt';
                completeBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; border: 1px solid #28a745; background: #28a745; color: white; border-radius: 3px; cursor: pointer;';
                
                // Create cancel button
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = '×';
                cancelBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; border: 1px solid #ccc; background: #f8f9fa; border-radius: 3px; cursor: pointer;';
                
                editContainer.appendChild(input);
                editContainer.appendChild(completeBtn);
                editContainer.appendChild(cancelBtn);
                
                // Replace percentage display with edit container
                const originalText = percentageElement.textContent;
                percentageElement.replaceWith(editContainer);
                input.focus();
                input.select();
                
                // Prevent double execution
                let isHandled = false;
                
                // Handle save/cancel
                const saveProgress = async () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    const newValue = parseInt(input.value);
                    if (!isNaN(newValue) && newValue >= 0 && newValue <= 100) {
                        await this.updateGoalProgress(goalId, newValue);
                        
                        // Update UI
                        const newPercentageElement = document.createElement('span');
                        newPercentageElement.className = 'ziel-percentage';
                        newPercentageElement.textContent = `${newValue}%`;
                        editContainer.replaceWith(newPercentageElement);
                        
                        // Update progress bar
                        progressFill.style.width = `${newValue}%`;
                        
                        // Refresh view if goal completed
                        if (newValue >= 100) {
                            this.refreshCurrentView();
                        }
                    } else {
                        cancelEdit();
                    }
                };
                
                const markComplete = async () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    await this.updateGoalProgress(goalId, 100);
                    
                    // Update UI
                    const newPercentageElement = document.createElement('span');
                    newPercentageElement.className = 'ziel-percentage';
                    newPercentageElement.textContent = '100%';
                    editContainer.replaceWith(newPercentageElement);
                    
                    // Update progress bar
                    progressFill.style.width = '100%';
                    
                    // Refresh view to move to archive
                    this.refreshCurrentView();
                };
                
                const cancelEdit = () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    const newPercentageElement = document.createElement('span');
                    newPercentageElement.className = 'ziel-percentage';
                    newPercentageElement.textContent = originalText;
                    editContainer.replaceWith(newPercentageElement);
                };
                
                // Event listeners
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveProgress();
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
                
                completeBtn.addEventListener('click', markComplete);
                cancelBtn.addEventListener('click', cancelEdit);
                
                // Auto-save on blur for input
                input.addEventListener('blur', (e) => {
                    // Only if user didn't click on buttons
                    setTimeout(() => {
                        if (!isHandled && document.contains(editContainer)) {
                            saveProgress();
                        }
                    }, 100);
                });
            }
        };

        // Make GoalManager globally available
        window.GoalManager = GoalManager;

        // === JOURNAL MANAGEMENT ===
        const JournalManager = {
            entries: [], // In-memory storage for demo
            
            async loadEntries() {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ JournalManager: Not authenticated - pure cloud mode requires authentication');
                    this.entries = [];
                    return;
                }
                
                try {
                    const data = await supabase.select('journal_entries', '*');
                    if (data && Array.isArray(data)) {
                        // Transform database data to ensure tags is always an array
                        this.entries = data.map(entry => {
                            let tags = [];
                            if (Array.isArray(entry.tags)) {
                                tags = entry.tags;
                            } else if (entry.tags) {
                                if (typeof entry.tags === 'string') {
                                    try {
                                        // Try to parse as JSON first
                                        tags = JSON.parse(entry.tags);
                                        if (!Array.isArray(tags)) {
                                            // If it's not an array, treat as single tag
                                            tags = [entry.tags];
                                        }
                                    } catch (e) {
                                        // If JSON.parse fails, treat as single tag
                                        tags = [entry.tags];
                                    }
                                } else {
                                    tags = [entry.tags];
                                }
                            }
                            return {
                                ...entry,
                                tags: tags
                            };
                        });
                        console.log(`☁️ JournalManager: Loaded ${this.entries.length} entries from cloud`);
                        this.refreshCurrentView();
                    } else {
                        console.log('☁️ JournalManager: No entries found in cloud');
                        this.entries = [];
                    }
                } catch (error) {
                    console.error('❌ JournalManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            showAddJournalModal() {
                const modal = document.getElementById('add-journal-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('journal-date').value = today;
            },
            
            hideAddJournalModal() {
                const modal = document.getElementById('add-journal-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-journal-form').reset();
                // Reset date back to today
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('journal-date').value = today;
            },
            
            async addEntry(entryData) {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ JournalManager: Not authenticated - cannot add entry in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Journal-Eintrag kann nicht gespeichert werden.');
                    return;
                }
                
                const entry = {
                    title: entryData.title,
                    content: entryData.content,
                    tags: entryData.tags || [], // Array of tags
                    date: entryData.date, // Keep date for local use
                    entry_date: entryData.date, // Use entry_date for database
                    user_id: supabase?.user?.id,
                    created_at: new Date().toISOString()
                };
                
                try {
                    // Create database entry without 'date' and 'created_at' fields (auto-generated)
                    const dbEntry = { ...entry };
                    delete dbEntry.date;
                    delete dbEntry.created_at;
                    console.log('☁️ JournalManager: Saving entry to cloud:', dbEntry);
                    const result = await supabase.insert('journal_entries', dbEntry);
                    if (result && result.length > 0) {
                        this.entries.push(result[0]);
                        console.log('☁️ JournalManager: Entry saved to cloud with ID:', result[0].id);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ JournalManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Journal-Eintrags: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('☁️ JournalManager: Entry added:', entry);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.journal-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-journal-category') : 'alle';
                
                this.displayEntriesForCategory(activeCategory);
            },
            
            displayEntriesForCategory(category) {
                const container = document.getElementById(`journal-${category}`);
                if (!container) return;
                
                let filteredEntries = [];
                
                switch(category) {
                    case 'alle':
                        filteredEntries = this.entries;
                        break;
                    default:
                        // Filter entries that have the selected tag
                        filteredEntries = this.entries.filter(entry => 
                            entry.tags && entry.tags.includes(category)
                        );
                }
                
                // Sort by date (newest first)
                filteredEntries.sort((a, b) => new Date(b.entry_date || b.date) - new Date(a.entry_date || a.date));
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredEntries.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Journal-Einträge vorhanden</p>';
                    return;
                }
                
                // Create grid for entries
                const grid = document.createElement('div');
                grid.className = 'grid-2'; // 2-spaltig für Journal-Einträge
                
                // Display entries
                filteredEntries.forEach(entry => {
                    const entryElement = this.createEntryElement(entry);
                    grid.appendChild(entryElement);
                });
                
                container.appendChild(grid);
            },
            
            createEntryElement(entry) {
                const entryCard = document.createElement('div');
                entryCard.className = 'ziel-card';
                entryCard.dataset.entryId = entry.id;
                
                const entryDate = new Date(entry.entry_date || entry.date);
                const formattedDate = entryDate.toLocaleDateString('de-DE', {
                    day: '2-digit',
                    month: '2-digit', 
                    year: 'numeric'
                });
                
                // Ensure tags is always an array before mapping
                const tags = Array.isArray(entry.tags) ? entry.tags : 
                           (entry.tags ? (typeof entry.tags === 'string' ? JSON.parse(entry.tags) : []) : []);
                const tagsHtml = tags.length > 0 
                    ? tags.map(tag => `<span class="todo-tag normal" style="margin-right: 0.5rem;">${tag}</span>`).join('')
                    : '';
                
                entryCard.innerHTML = `
                    <div class="ziel-header">
                        <div class="ziel-name">${entry.title}</div>
                        <div class="ziel-beschreibung">${entry.content}</div>
                    </div>
                    <div class="ziel-progress-section">
                        <div class="ziel-progress-header">
                            <span class="ziel-progress-label">${formattedDate}</span>
                            <button class="delete-entry-btn" data-entry-id="${entry.id}" style="background: none; border: none; color: #cc0000; cursor: pointer; padding: 0.25rem; font-size: 0.9rem;" title="Eintrag löschen">
                                🗑️
                            </button>
                        </div>
                        <div style="margin-top: 0.5rem;">
                            ${tagsHtml}
                        </div>
                    </div>
                `;
                
                return entryCard;
            },
            
            async deleteEntry(entryId) {
                if (!confirm('Diesen Journal-Eintrag wirklich löschen?')) {
                    return;
                }
                
                try {
                    // Delete from database if authenticated
                    if (supabase?.isAuthenticated()) {
                        await supabase.delete('journal_entries', entryId);
                        console.log('✅ Journal entry deleted from database:', entryId);
                    }
                    
                    // Remove from local entries array
                    this.entries = this.entries.filter(entry => entry.id != entryId);
                    
                    // Refresh current view
                    this.refreshCurrentView();
                    
                    console.log('✅ Journal entry deleted:', entryId);
                } catch (error) {
                    console.error('❌ Error deleting journal entry:', error);
                    alert('Fehler beim Löschen des Eintrags: ' + error.message);
                }
            }
        };

        // Make JournalManager globally available
        window.JournalManager = JournalManager;

        // === TERMIN MANAGEMENT ===
        const TerminManager = {
            termine: [], // In-memory storage for demo
            
            async loadTermine(forceReload = false) {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TerminManager: Not authenticated - pure cloud mode requires authentication');
                    this.termine = [];
                    this.displayTermine();
                    return;
                }
                
                try {
                    console.log('☁️ TerminManager: Loading termine from cloud...');
                    const user = supabase.getCurrentUser();
                    const data = await supabase.query(`termine?user_id=eq.${user.id}&select=*`);
                    
                    if (data && Array.isArray(data)) {
                        this.termine = data;
                        console.log(`☁️ TerminManager: Loaded ${this.termine.length} termine from cloud`);
                        this.displayTermine();
                    } else {
                        console.log('☁️ TerminManager: No termine found in cloud');
                        this.termine = [];
                        this.displayTermine();
                    }
                } catch (error) {
                    console.error('❌ TerminManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            showAddTerminModal() {
                const modal = document.getElementById('add-termin-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('termin-date').value = today;
                
                // Leave time field empty - user can fill if needed
                document.getElementById('termin-time').value = '';
            },
            
            hideAddTerminModal() {
                const modal = document.getElementById('add-termin-modal');
                const form = document.getElementById('add-termin-form');
                const submitBtn = form.querySelector('button[type="submit"]');
                
                modal.classList.add('hide');
                form.reset();
                delete form.dataset.editId; // Clear edit mode
                if (submitBtn) {
                    submitBtn.textContent = 'Hinzufügen'; // Reset button text
                }
            },
            
            async addTermin(terminData) {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TerminManager: Not authenticated - cannot add termin in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Termin kann nicht gespeichert werden.');
                    return;
                }
                
                const termin = {
                    title: terminData.title,
                    description: terminData.description,
                    date: terminData.date,
                    time: terminData.time,
                    user_id: supabase.getCurrentUser().id,
                    created_at: new Date().toISOString()
                };
                
                try {
                    console.log('☁️ TerminManager: Saving termin to cloud:', termin.title);
                    const result = await supabase.insert('termine', termin);
                    if (result && result.length > 0) {
                        this.termine.push(result[0]);
                        console.log('☁️ TerminManager: Termin saved to cloud with ID:', result[0].id);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ TerminManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Termins: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('☁️ TerminManager: Termin added:', termin);
                this.displayTermine();
            },
            
            async updateTermin(terminId, terminData) {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TerminManager: Not authenticated - cannot update termin in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Termin kann nicht aktualisiert werden.');
                    return;
                }
                
                const terminIndex = this.termine.findIndex(t => t.id == terminId);
                if (terminIndex === -1) {
                    console.error('❌ TerminManager: Termin not found for update:', terminId);
                    alert('Termin nicht gefunden!');
                    return;
                }
                
                const updatedTermin = {
                    ...this.termine[terminIndex],
                    title: terminData.title,
                    description: terminData.description,
                    date: terminData.date,
                    time: terminData.time,
                    updated_at: new Date().toISOString()
                };
                
                try {
                    console.log('☁️ TerminManager: Updating termin in cloud:', terminId);
                    await supabase.update('termine', updatedTermin, terminId);
                    this.termine[terminIndex] = updatedTermin;
                    console.log('☁️ TerminManager: Termin updated in cloud');
                } catch (error) {
                    console.error('❌ TerminManager: Error updating in cloud:', error);
                    alert('Fehler beim Aktualisieren des Termins: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('☁️ TerminManager: Termin updated:', updatedTermin);
                this.displayTermine();
            },
            
            displayTermine() {
                console.log('📅 TerminManager.displayTermine() called');
                console.log('📊 Current termine in memory:', this.termine);
                console.log('📈 Termine count:', this.termine.length);
                
                const container = document.getElementById('termine-container');
                if (!container) {
                    console.error('❌ Termine container DOM element not found - check if #termine-container exists');
                    return;
                }
                
                console.log('✅ Termine container found:', container);
                
                // Clear container
                container.innerHTML = '';
                
                if (this.termine.length === 0) {
                    console.log('ℹ️ No termine to display - showing empty state message');
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem; grid-column: 1 / -1;">Keine Termine vorhanden</p>';
                    return;
                }
                
                console.log(`📊 Rendering ${this.termine.length} termine to DOM...`);
                
                // Sort by date/time (earliest first)
                const sortedTermine = this.termine.sort((a, b) => {
                    const dateTimeA = new Date(`${a.date}T${a.time || '00:00'}`);
                    const dateTimeB = new Date(`${b.date}T${b.time || '00:00'}`);
                    return dateTimeA - dateTimeB;
                });
                
                console.log('🔄 Termine sorted by date:', sortedTermine.map(t => `${t.title} - ${t.date}`));
                
                // Add termine
                sortedTermine.forEach((termin, index) => {
                    console.log(`🔄 Creating element for termin ${index + 1}:`, termin.title);
                    const terminElement = this.createTerminElement(termin);
                    container.appendChild(terminElement);
                });
                
                console.log('✅ All termine rendered to DOM');
            },
            
            createTerminElement(termin) {
                const terminCard = document.createElement('div');
                terminCard.className = 'termin-card';
                terminCard.dataset.terminId = termin.id;
                
                const terminDate = new Date(termin.date);
                const formattedDate = terminDate.toLocaleDateString('de-DE', {
                    weekday: 'long',
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                });
                
                let displayDate = formattedDate;
                if (termin.time) {
                    const timeDate = new Date(`${termin.date}T${termin.time}`);
                    const formattedTime = timeDate.toLocaleTimeString('de-DE', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    displayDate += `, ${formattedTime}`;
                }
                
                // Calculate days until appointment
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const appointmentDate = new Date(termin.date);
                appointmentDate.setHours(0, 0, 0, 0);
                const daysDifference = Math.ceil((appointmentDate - today) / (1000 * 60 * 60 * 24));
                
                let daysUntilText = '';
                let badgeColor1 = '';
                let badgeColor2 = '';
                
                if (daysDifference === 0) {
                    daysUntilText = 'Heute';
                    badgeColor1 = '#ef4444';
                    badgeColor2 = '#dc2626';
                } else if (daysDifference === 1) {
                    daysUntilText = 'Morgen';
                    badgeColor1 = '#f97316';
                    badgeColor2 = '#ea580c';
                } else if (daysDifference === -1) {
                    daysUntilText = 'Gestern';
                    badgeColor1 = '#6b7280';
                    badgeColor2 = '#4b5563';
                } else if (daysDifference > 1) {
                    daysUntilText = `in ${daysDifference} Tagen`;
                    badgeColor1 = '#3b82f6';
                    badgeColor2 = '#2563eb';
                } else if (daysDifference < -1) {
                    daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                    badgeColor1 = '#6b7280';
                    badgeColor2 = '#4b5563';
                }
                
                // Set CSS custom properties for badge colors
                const badgeColorVars = `--badge-color-1: ${badgeColor1}; --badge-color-2: ${badgeColor2};`;
                
                terminCard.style.cssText += badgeColorVars;
                
                terminCard.innerHTML = `
                    <div class="termin-days-until">${daysUntilText}</div>
                    <div class="termin-date">${displayDate}</div>
                    <div class="termin-title">${termin.title}</div>
                    <div class="termin-description">${termin.description}</div>
                    <div class="termin-edit-icon" onclick="TerminManager.editTermin('${termin.id}')">✎</div>
                    <div class="termin-delete-icon" onclick="TerminManager.deleteTermin('${termin.id}')">🗑</div>
                `;
                
                return terminCard;
            },
            
            async editTermin(terminId) {
                console.log('🖊️ Edit termin clicked:', terminId);
                console.log('📋 Available termine:', this.termine);
                
                const termin = this.termine.find(t => t.id == terminId);
                if (!termin) {
                    console.error('❌ Termin not found:', terminId);
                    alert('Termin nicht gefunden!');
                    return;
                }
                
                console.log('✅ Found termin for editing:', termin);
                
                // Pre-fill the form with existing values
                document.getElementById('termin-title').value = termin.title;
                document.getElementById('termin-description').value = termin.description;
                document.getElementById('termin-date').value = termin.date;
                document.getElementById('termin-time').value = termin.time || '';
                
                // Store the ID for updating
                const form = document.getElementById('add-termin-form');
                form.dataset.editId = terminId;
                
                // Change button text
                const submitBtn = form.querySelector('button[type="submit"]');
                submitBtn.textContent = 'Termin aktualisieren';
                
                console.log('📝 Form prepared for editing, opening modal...');
                
                // Show modal
                this.showAddTerminModal();
            },
            
            async deleteTermin(terminId) {
                if (!confirm('Möchtest du diesen Termin wirklich löschen?')) {
                    return;
                }
                
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ TerminManager: Not authenticated - cannot delete termin in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Termin kann nicht gelöscht werden.');
                    return;
                }
                
                try {
                    console.log('☁️ TerminManager: Deleting termin from cloud:', terminId);
                    await supabase.delete('termine', terminId);
                    console.log('☁️ TerminManager: Termin deleted from cloud');
                } catch (error) {
                    console.error('❌ TerminManager: Error deleting from cloud:', error);
                    alert('Fehler beim Löschen: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                // Remove from local array
                this.termine = this.termine.filter(t => t.id != terminId);
                
                // Pure cloud mode - no localStorage caching
                
                // Refresh view
                this.displayTermine();
                
                console.log('☁️ TerminManager: Termin deleted successfully');
            }
        };

        // Make TerminManager globally available
        window.TerminManager = TerminManager;

        // === INITIALIZE ===
        document.addEventListener('DOMContentLoaded', async () => {
            // Logout is now handled by separate logout.html page
            
            console.log('✅ DOM loaded');
            
            // Initialize Supabase first
            if (window.initializeSupabase) {
                window.initializeSupabase();
            }
            
            // Initialize authentication (this will handle data loading via showDashboard)
            await Auth.init();
            
            // Initialize Wiki
            if (window.Wiki) {
                Wiki.init();
            }
            
            // Initialize Lucide icons globally
            if (window.lucide) {
                lucide.createIcons();
            }
            
            // ResourceManager will be initialized after its definition (moved down)
            
            // Logout button is already handled by Auth.setupEventListeners()
            
            // Journal form submission
            const journalForm = document.querySelector('.journal-form');
            if (journalForm) {
                journalForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const input = this.querySelector('.journal-input');
                    if (input.value.trim()) {
                        console.log('Journal entry:', input.value);
                        input.value = '';
                    }
                });
            }
            
            // Add Todo Button
            const addTodoBtn = document.getElementById('add-todo-btn');
            if (addTodoBtn) {
                addTodoBtn.addEventListener('click', () => {
                    TodoManager.showAddTodoModal();
                });
            }
            
            // Clear Archive Button
            const clearArchiveBtn = document.getElementById('clear-archive-btn');
            if (clearArchiveBtn) {
                clearArchiveBtn.addEventListener('click', () => {
                    TodoManager.clearArchive();
                });
            }
            
            // Cancel Todo Button
            const cancelTodoBtn = document.getElementById('cancel-todo-btn');
            if (cancelTodoBtn) {
                cancelTodoBtn.addEventListener('click', () => {
                    TodoManager.hideAddTodoModal();
                });
            }
            
            // Add Todo Form Submission
            const addTodoForm = document.getElementById('add-todo-form');
            if (addTodoForm) {
                addTodoForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const todoData = {
                        title: document.getElementById('todo-title').value,
                        category: document.getElementById('todo-category').value,
                        priority: document.getElementById('todo-priority').value,
                        deadline: document.getElementById('todo-deadline').value,
                        time: document.getElementById('todo-time').value
                    };
                    
                    console.log('📝 Form data being sent:', todoData);
                    console.log('📝 Priority element value:', document.getElementById('todo-priority').value);
                    console.log('📝 Priority element selectedIndex:', document.getElementById('todo-priority').selectedIndex);
                    
                    await TodoManager.addTodo(todoData);
                    TodoManager.hideAddTodoModal();
                });
            }
            
            // Close modal when clicking outside
            const addTodoModal = document.getElementById('add-todo-modal');
            if (addTodoModal) {
                addTodoModal.addEventListener('click', (e) => {
                    if (e.target === addTodoModal) {
                        TodoManager.hideAddTodoModal();
                    }
                });
            }
            
            // === GOAL EVENT LISTENERS ===
            
            // Add Goal Button
            const addGoalBtn = document.getElementById('add-goal-btn');
            if (addGoalBtn) {
                addGoalBtn.addEventListener('click', () => {
                    GoalManager.showAddGoalModal();
                });
            }
            
            // Cancel Goal Button
            const cancelGoalBtn = document.getElementById('cancel-goal-btn');
            if (cancelGoalBtn) {
                cancelGoalBtn.addEventListener('click', () => {
                    GoalManager.hideAddGoalModal();
                });
            }
            
            // Add Goal Form Submission
            const addGoalForm = document.getElementById('add-goal-form');
            if (addGoalForm) {
                addGoalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const goalData = {
                        name: document.getElementById('goal-name').value,
                        description: document.getElementById('goal-description').value,
                        category: document.getElementById('goal-category').value,
                        timeframe: document.getElementById('goal-timeframe').value,
                        deadline: document.getElementById('goal-deadline').value,
                        unit: document.getElementById('goal-unit').value,
                        startValue: parseFloat(document.getElementById('goal-start-value').value) || 0,
                        targetValue: parseFloat(document.getElementById('goal-target-value').value)
                    };
                    
                    await GoalManager.addGoal(goalData);
                    GoalManager.hideAddGoalModal();
                });
            }
            
            // Timeframe change listener - automatically update deadline
            const goalTimeframeSelect = document.getElementById('goal-timeframe');
            if (goalTimeframeSelect) {
                goalTimeframeSelect.addEventListener('change', (e) => {
                    const deadlineInput = document.getElementById('goal-deadline');
                    if (deadlineInput) {
                        deadlineInput.value = GoalManager.calculateDeadline(e.target.value);
                    }
                });
            }
            
            // Close goal modal when clicking outside
            const addGoalModal = document.getElementById('add-goal-modal');
            if (addGoalModal) {
                addGoalModal.addEventListener('click', (e) => {
                    if (e.target === addGoalModal) {
                        GoalManager.hideAddGoalModal();
                    }
                });
            }
            
            // Clear Goal Archive Button
            const clearGoalArchiveBtn = document.getElementById('clear-goal-archive-btn');
            if (clearGoalArchiveBtn) {
                clearGoalArchiveBtn.addEventListener('click', () => {
                    GoalManager.clearGoalArchive();
                });
            }
            
            // === JOURNAL EVENT LISTENERS ===
            
            // Add Journal Button
            const addJournalBtn = document.getElementById('add-journal-btn');
            if (addJournalBtn) {
                addJournalBtn.addEventListener('click', () => {
                    JournalManager.showAddJournalModal();
                });
            }
            
            // Cancel Journal Button
            const cancelJournalBtn = document.getElementById('cancel-journal-btn');
            if (cancelJournalBtn) {
                cancelJournalBtn.addEventListener('click', () => {
                    JournalManager.hideAddJournalModal();
                });
            }
            
            // Tag selection functionality
            let selectedTags = [];
            
            function updateTagsDisplay() {
                const hiddenInput = document.getElementById('journal-category');
                
                // Update hidden input (use first tag or 'allgemein' as fallback for compatibility)
                hiddenInput.value = selectedTags.length > 0 ? selectedTags[0] : 'allgemein';
                
                // Update tag option buttons
                document.querySelectorAll('.tag-option').forEach(btn => {
                    const tag = btn.getAttribute('data-tag');
                    btn.classList.toggle('selected', selectedTags.includes(tag));
                });
            }
            
            // Tag option click handlers
            document.querySelectorAll('.tag-option').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    
                    // If clicking on the X, remove the tag
                    if (e.target.classList.contains('remove-tag')) {
                        const tag = btn.getAttribute('data-tag');
                        selectedTags = selectedTags.filter(t => t !== tag);
                        updateTagsDisplay();
                        return;
                    }
                    
                    const tag = btn.getAttribute('data-tag');
                    
                    if (selectedTags.includes(tag)) {
                        // Already selected, remove it
                        selectedTags = selectedTags.filter(t => t !== tag);
                    } else {
                        // Not selected, add it
                        selectedTags.push(tag);
                    }
                    
                    updateTagsDisplay();
                });
            });
            
            // Add Journal Form Submission
            const addJournalForm = document.getElementById('add-journal-form');
            if (addJournalForm) {
                addJournalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    if (selectedTags.length === 0) {
                        alert('Bitte wähle mindestens einen Tag aus.');
                        return;
                    }
                    
                    const entryData = {
                        title: document.getElementById('journal-title').value,
                        content: document.getElementById('journal-content').value,
                        tags: [...selectedTags], // Copy array
                        date: document.getElementById('journal-date').value
                    };
                    
                    await JournalManager.addEntry(entryData);
                    JournalManager.hideAddJournalModal();
                    
                    // Reset tags
                    selectedTags = [];
                    updateTagsDisplay();
                });
            }
            
            // Close journal modal when clicking outside
            const addJournalModal = document.getElementById('add-journal-modal');
            if (addJournalModal) {
                addJournalModal.addEventListener('click', (e) => {
                    if (e.target === addJournalModal) {
                        JournalManager.hideAddJournalModal();
                    }
                });
            }
            
            // === TERMIN EVENT LISTENERS ===
            
            // Add Termin Button
            const addTerminBtn = document.getElementById('add-termin-btn');
            if (addTerminBtn) {
                addTerminBtn.addEventListener('click', () => {
                    TerminManager.showAddTerminModal();
                });
            }
            
            // Cancel Termin Button
            const cancelTerminBtn = document.getElementById('cancel-termin-btn');
            if (cancelTerminBtn) {
                cancelTerminBtn.addEventListener('click', () => {
                    TerminManager.hideAddTerminModal();
                });
            }
            
            // Add Termin Form Submission
            const addTerminForm = document.getElementById('add-termin-form');
            if (addTerminForm) {
                addTerminForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const terminData = {
                        title: document.getElementById('termin-title').value,
                        description: document.getElementById('termin-description').value,
                        date: document.getElementById('termin-date').value,
                        time: document.getElementById('termin-time').value
                    };
                    
                    // Check if we're editing an existing termin
                    const editId = addTerminForm.dataset.editId;
                    if (editId) {
                        await TerminManager.updateTermin(editId, terminData);
                    } else {
                        await TerminManager.addTermin(terminData);
                    }
                    
                    TerminManager.hideAddTerminModal();
                });
            }
            
            // Close termin modal when clicking outside
            const addTerminModal = document.getElementById('add-termin-modal');
            if (addTerminModal) {
                addTerminModal.addEventListener('click', (e) => {
                    if (e.target === addTerminModal) {
                        TerminManager.hideAddTerminModal();
                    }
                });
            }
            
            // Load routine states on page load
            loadRoutineStates();
            
            // Update routine progress to reflect loaded states
            updateRoutineProgress();
            
            // Initialize settings functionality
            initializeSettings();
            
            // Todo counter is now initialized in showDashboard() after authentication
            
            // === EDIT GOAL VALUE MODAL EVENT LISTENERS ===
            // Event listeners are now set up globally at the end of the script
            
            // === RESOURCE MANAGER ===
            const ResourceManager = {
                resources: [],
                
                async loadResources() {
                    if (!supabase?.isAuthenticated()) {
                        console.error('❌ ResourceManager: Not authenticated - pure cloud mode requires authentication');
                        this.resources = [];
                        this.renderResources();
                        return;
                    }
                    
                    try {
                        console.log('☁️ ResourceManager: Loading resources from cloud...');
                        this.resources = await cloudStorage.getResources() || [];
                        console.log(`☁️ ResourceManager: Loaded ${this.resources.length} resources from cloud`);
                        
                        // Migrate old emoji icons to lucide icons (one-time migration)
                        this.migrateEmojiIcons();
                        
                        this.renderResources();
                        console.log('☁️ ResourceManager: Load completed');
                    } catch (error) {
                        console.error('❌ ResourceManager: Error loading from cloud:', error);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                },
                
                renderResources() {
                    console.log('🎨 ResourceManager.renderResources() called with', this.resources.length, 'resources');
                    // Refresh current view
                    this.refreshCurrentView();
                },
                
                refreshCurrentView() {
                    // Get current active category
                    const activeTab = document.querySelector('.resource-tab.active');
                    const activeCategory = activeTab ? activeTab.getAttribute('data-resource-category') : 'alle';
                    
                    console.log('🔄 Refreshing view for category:', activeCategory);
                    this.displayResourcesForCategory(activeCategory);
                },
                
                displayResourcesForCategory(category) {
                    const container = document.getElementById(`resource-${category}`);
                    if (!container) return;
                    
                    let filteredResources = [];
                    
                    switch(category) {
                        case 'privat':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Privat'
                            );
                            break;
                        case 'arbeit':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Arbeit'
                            );
                            break;
                        case 'uni':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Uni'
                            );
                            break;
                        case 'crypto':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Crypto'
                            );
                            break;
                        case 'alle':
                        default:
                            filteredResources = this.resources;
                            break;
                    }
                    
                    let html = '';
                    
                    if (filteredResources.length === 0) {
                        html = '<p style="text-align: center; color: #666; padding: 3rem;">Keine Resources vorhanden</p>';
                    } else {
                        // Todo-style grid layout for all categories
                        html += '<div class="resource-grid">';
                        
                        filteredResources.forEach(resource => {
                            const icon = resource.icon || 'link';
                            const description = resource.description || '';
                            const truncatedTitle = resource.title.length > 25 ? resource.title.substring(0, 25) + '...' : resource.title;
                            const fullTitle = `${resource.title}${description ? ` - ${description}` : ''}`;
                            html += `
                                <div class="resource-card" 
                                     onclick="window.open('${resource.url}', '_blank')" 
                                     oncontextmenu="event.preventDefault(); ResourceManager.showDeleteButton(this, '${resource.id}'); return false;"
                                     title="${fullTitle}">
                                    <span class="resource-icon"><i data-lucide="${icon}" style="width: 16px; height: 16px;"></i></span>
                                    <span class="resource-title">${truncatedTitle}</span>
                                    <div class="resource-actions" style="opacity: 0;">
                                        <button class="resource-delete-btn" onclick="event.stopPropagation(); ResourceManager.deleteResource('${resource.id}')" title="Rechtsklick zum Löschen">
                                            <i data-lucide="x" style="width: 12px; height: 12px;"></i>
                                        </button>
                                    </div>
                                </div>
                            `;
                        });
                        
                        html += '</div>';
                    }
                    
                    container.innerHTML = html;
                    
                    // Enhanced Lucide initialization with icon verification
                    setTimeout(() => {
                        if (window.lucide) {
                            lucide.createIcons();
                            console.log('🎨 Lucide icons initialized for resource category:', category);
                            
                            // Verify icons are actually rendered
                            setTimeout(() => {
                                const actionBtns = container.querySelectorAll('.resource-actions');
                                console.log(`🔍 Found ${actionBtns.length} action button containers in ${category}`);
                                
                                actionBtns.forEach((actions, index) => {
                                    const buttons = actions.querySelectorAll('button');
                                    const icons = actions.querySelectorAll('svg');
                                    console.log(`  Container ${index}: ${buttons.length} buttons, ${icons.length} SVG icons, opacity: ${getComputedStyle(actions).opacity}`);
                                    
                                    // Force re-render if icons missing
                                    if (buttons.length > 0 && icons.length === 0) {
                                        console.log('⚠️ Missing icons detected, forcing re-render...');
                                        lucide.createIcons();
                                    }
                                });
                            }, 50);
                        }
                    }, 150);
                },
                
                showAddResourceModal() {
                    const modal = document.getElementById('add-resource-modal');
                    modal.classList.remove('hide');
                    document.getElementById('resource-title').focus();
                },
                
                hideAddResourceModal() {
                    const modal = document.getElementById('add-resource-modal');
                    modal.classList.add('hide');
                    document.getElementById('add-resource-form').reset();
                },
                
                async addResource(resourceData) {
                    if (!supabase?.isAuthenticated()) {
                        console.error('❌ ResourceManager: Not authenticated - cannot add resource in pure cloud mode');
                        alert('Fehler: Nicht authentifiziert. Resource kann nicht gespeichert werden.');
                        return;
                    }
                    
                    const resource = {
                        title: resourceData.title,
                        category: resourceData.category,
                        url: resourceData.url,
                        description: resourceData.description || '',
                        icon: resourceData.icon || 'link',
                        user_id: supabase.getCurrentUser().id,
                        created_at: new Date().toISOString()
                    };
                    
                    try {
                        console.log('☁️ ResourceManager: Saving resource to cloud:', resource.title);
                        await cloudStorage.saveResource(resource);
                        console.log('☁️ ResourceManager: Resource saved to cloud successfully');
                        
                        // Reload resources from cloud to get updated data with proper IDs
                        console.log('🔄 Reloading resources to get updated list...');
                        await this.loadResources();
                        
                        console.log('☁️ ResourceManager: Resource added:', resource.title);
                    } catch (error) {
                        console.error('❌ ResourceManager: Error saving resource:', error);
                        alert('Fehler beim Speichern der Resource: ' + error.message);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                },
                
                async deleteResource(resourceId) {
                    if (!confirm('Are you sure you want to delete this resource?')) {
                        return;
                    }
                    
                    if (!supabase?.isAuthenticated()) {
                        console.error('❌ ResourceManager: Not authenticated - cannot delete resource in pure cloud mode');
                        alert('Fehler: Nicht authentifiziert. Resource kann nicht gelöscht werden.');
                        return;
                    }
                    
                    try {
                        console.log('☁️ ResourceManager: Deleting resource from cloud:', resourceId);
                        await cloudStorage.deleteResource(resourceId);
                        console.log('☁️ ResourceManager: Resource deleted from cloud successfully');
                        
                        // Pure cloud mode - no localStorage
                        
                        // Reload resources from cloud to get updated list
                        await this.loadResources();
                        
                        console.log('☁️ ResourceManager: Resource deleted and UI updated');
                    } catch (error) {
                        console.error('❌ ResourceManager: Error deleting resource:', error);
                        alert('Fehler beim Löschen der Resource: ' + error.message);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                },
                
                editResource(resourceId) {
                    const resource = this.resources.find(r => r.id === resourceId);
                    if (!resource) return;
                    
                    // Populate form with existing data
                    document.getElementById('resource-title').value = resource.title;
                    document.getElementById('resource-category').value = resource.category;
                    document.getElementById('resource-url').value = resource.url;
                    document.getElementById('resource-description').value = resource.description || '';
                    document.getElementById('resource-icon').value = resource.icon || '';
                    
                    // Mark form as editing
                    const form = document.getElementById('add-resource-form');
                    form.dataset.editId = resourceId;
                    
                    this.showAddResourceModal();
                },
                
                selectIcon(iconName) {
                    const iconInput = document.getElementById('resource-icon');
                    if (iconInput) {
                        iconInput.value = iconName;
                    }
                },
                
                toggleIconInput() {
                    const iconInput = document.getElementById('resource-icon');
                    const toggleBtn = event.target;
                    
                    if (iconInput.readOnly) {
                        iconInput.readOnly = false;
                        iconInput.placeholder = 'Type lucide icon name manually...';
                        iconInput.focus();
                        toggleBtn.textContent = 'Use icon palette';
                    } else {
                        iconInput.readOnly = true;
                        iconInput.placeholder = 'Click icon below or type manually';
                        toggleBtn.textContent = 'Enable manual typing';
                    }
                },
                
                migrateEmojiIcons() {
                    const emojiToLucideMap = {
                        '📧': 'mail',
                        '💼': 'briefcase',
                        '📚': 'book',
                        '🏠': 'home',
                        '💬': 'message-circle',
                        '🏦': 'building',
                        '🔧': 'wrench',
                        '📊': 'bar-chart-3',
                        '📝': 'file-text',
                        '👥': 'users',
                        '🌐': 'globe',
                        '💰': 'dollar-sign',
                        '🎯': 'target',
                        '⚡': 'zap',
                        '🔐': 'lock',
                        '🔗': 'link',
                        '🚀': 'rocket',
                        '🎨': 'palette',
                        '🏃': 'activity',
                        '🤖': 'bot',
                        '🌱': 'sprout'
                    };
                    
                    if (!supabase?.isAuthenticated()) {
                        return; // Skip migration if not authenticated
                    }
                    
                    let migrationNeeded = false;
                    
                    this.resources.forEach(resource => {
                        if (emojiToLucideMap[resource.icon]) {
                            console.log(`🔄 Migrating icon for "${resource.title}": ${resource.icon} → ${emojiToLucideMap[resource.icon]}`);
                            resource.icon = emojiToLucideMap[resource.icon];
                            migrationNeeded = true;
                        }
                    });
                    
                    if (migrationNeeded) {
                        console.log('☁️ Icon migration completed, saving to cloud');
                        // Pure cloud mode - only save to cloud
                        this.resources.forEach(resource => cloudStorage.saveResource(resource));
                    }
                },
                
                showDeleteButton(cardElement, resourceId) {
                    // Hide all other delete buttons first
                    document.querySelectorAll('.resource-actions').forEach(actions => {
                        actions.style.opacity = '0';
                    });
                    
                    // Show delete button for this card
                    const actions = cardElement.querySelector('.resource-actions');
                    if (actions) {
                        actions.style.opacity = '1';
                        console.log('🗑️ Delete button shown for resource:', resourceId);
                        
                        // Hide button after 3 seconds
                        setTimeout(() => {
                            actions.style.opacity = '0';
                        }, 3000);
                    }
                },
                
                hideAllDeleteButtons() {
                    document.querySelectorAll('.resource-actions').forEach(actions => {
                        actions.style.opacity = '0';
                    });
                }
            };
            
            // Make ResourceManager global
            window.ResourceManager = ResourceManager;
            
            // Initialize ResourceManager now that it's properly defined
            console.log('🔄 Initializing ResourceManager after definition...');
            ResourceManager.loadResources();
            
            // Hide delete buttons when clicking elsewhere
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.resource-card') && !e.target.closest('.resource-actions')) {
                    ResourceManager.hideAllDeleteButtons();
                }
            });
            
            // === JOURNAL DELETE BUTTONS ===
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-entry-btn')) {
                    const entryId = e.target.dataset.entryId;
                    if (entryId) {
                        JournalManager.deleteEntry(entryId);
                    }
                }
            });

            // === RESOURCE EVENT LISTENERS ===
            
            // Add Resource Button
            const addResourceBtn = document.getElementById('add-resource-btn');
            if (addResourceBtn) {
                addResourceBtn.addEventListener('click', () => {
                    ResourceManager.showAddResourceModal();
                });
            }
            
            // Add Resource Form Submission
            const addResourceForm = document.getElementById('add-resource-form');
            if (addResourceForm) {
                addResourceForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const resourceData = {
                        title: document.getElementById('resource-title').value,
                        category: document.getElementById('resource-category').value,
                        url: document.getElementById('resource-url').value,
                        description: document.getElementById('resource-description').value,
                        icon: document.getElementById('resource-icon').value
                    };
                    
                    // Check if we're editing an existing resource
                    const editId = addResourceForm.dataset.editId;
                    if (editId) {
                        // Update existing resource
                        const resource = ResourceManager.resources.find(r => r.id === editId);
                        if (resource) {
                            if (!supabase?.isAuthenticated()) {
                                console.error('❌ ResourceManager: Not authenticated - cannot update resource in pure cloud mode');
                                alert('Fehler: Nicht authentifiziert. Resource kann nicht aktualisiert werden.');
                                return;
                            }
                            
                            Object.assign(resource, resourceData);
                            try {
                                console.log('☁️ ResourceManager: Updating resource in cloud:', resource.title);
                                await cloudStorage.saveResource(resource);
                                ResourceManager.renderResources();
                                console.log('☁️ ResourceManager: Resource updated:', resource.title);
                            } catch (error) {
                                console.error('❌ ResourceManager: Error updating resource:', error);
                                alert('Fehler beim Aktualisieren der Resource: ' + error.message);
                                throw error; // Don't hide errors in pure cloud mode
                            }
                        }
                        // Clear edit mode
                        delete addResourceForm.dataset.editId;
                    } else {
                        // Add new resource
                        await ResourceManager.addResource(resourceData);
                    }
                    
                    ResourceManager.hideAddResourceModal();
                });
            }
            
            // Close resource modal when clicking outside
            const addResourceModal = document.getElementById('add-resource-modal');
            if (addResourceModal) {
                addResourceModal.addEventListener('click', (e) => {
                    if (e.target === addResourceModal) {
                        ResourceManager.hideAddResourceModal();
                    }
                });
            }
            
            // Render resources when Resources tab is selected (don't reload from scratch)
            const ressourcenTab = document.querySelector('[data-tab="ressourcen"]');
            if (ressourcenTab) {
                ressourcenTab.addEventListener('click', () => {
                    // Only render existing resources, don't reload from cloud/storage
                    ResourceManager.renderResources();
                    console.log('🎨 Resources tab clicked - rendering existing resources');
                });
            }
            
            // ResourceManager initialization moved to main DOMContentLoaded listener
            
            // === SIMPLE LOGOUT (URL-based) ===
            console.log('✅ Logout is now URL-based, no JavaScript needed');
            
            // === ROUTINE RESET FUNCTIONALITY ===
            // Use event delegation to catch button clicks even if tab is loaded later
            document.addEventListener('click', async function(e) {
                if (e.target && e.target.id === 'reset-routines-btn') {
                    console.log('🖱️ Reset routines button clicked');
                    
                    const confirmed = confirm(
                        '⚠️ ACHTUNG: Routine-Datenbank komplett zurücksetzen?\n\n' +
                        '• Löscht ALLE Routine-Daten (lokal und cloud)\n' +
                        '• Setzt alle Counter auf 0\n' +
                        '• Betrifft alle Geräte\n' +
                        '• Kann nicht rückgängig gemacht werden\n\n' +
                        'Fortfahren?'
                    );
                    
                    if (confirmed) {
                        console.log('✅ User confirmed reset');
                        const success = await resetRoutineDatabase();
                        if (success) {
                            alert('✅ Routine-Datenbank wurde komplett zurückgesetzt!\n\nBitte refreshe die Seite auf allen Geräten.');
                            window.location.reload();
                        } else {
                            alert('❌ Fehler beim Zurücksetzen. Bitte Console prüfen.');
                        }
                    } else {
                        console.log('❌ User cancelled reset');
                    }
                }
            });
            
            // Complete Routine Database Reset Function
            async function resetRoutineDatabase() {
                console.log('🔄 Starting complete routine database reset...');
                
                try {
                    // 1. Clear all localStorage routine data (old and new)
                    const keysToRemove = [
                        'routineCompletionData',
                        'routine_completions_cache', 
                        'monthlyRoutineCompletions',
                        'routineData',
                        'lastRoutineResetDate',
                        'routineResetTime',
                        'morningRoutineStreak',
                        'eveningRoutineStreak',
                        'simple_routine_data' // New system
                    ];
                    
                    keysToRemove.forEach(key => {
                        if (localStorage.getItem(key)) {
                            localStorage.removeItem(key);
                            console.log(`🗑️ Removed localStorage: ${key}`);
                        }
                    });
                    
                    // 2. Clear Supabase tables if authenticated
                    if (window.supabase && window.supabase.isAuthenticated()) {
                        const user = window.supabase.getCurrentUser();
                        console.log('🔄 Clearing cloud routine data for user:', user.email);
                        
                        try {
                            // Delete old system data
                            await window.supabase.delete('routine_completions', `user_id=eq.${user.id}`);
                            console.log('✅ Cleared old routine_completions table');
                            
                            // Delete new system data
                            await window.supabase.delete('simple_routines', `user_id=eq.${user.id}`);
                            console.log('✅ Cleared new simple_routines table');
                        } catch (error) {
                            console.warn('⚠️ Could not clear cloud data:', error);
                        }
                    }
                    
                    // 3. Reset routine checkboxes on page
                    const morningCheckboxes = document.querySelectorAll('#morning-routine input[type="checkbox"]');
                    const eveningCheckboxes = document.querySelectorAll('#evening-routine input[type="checkbox"]');
                    
                    [...morningCheckboxes, ...eveningCheckboxes].forEach(checkbox => {
                        checkbox.checked = false;
                        const label = checkbox.nextElementSibling;
                        if (label) {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    });
                    console.log('✅ Reset all routine checkboxes');
                    
                    // 4. Reset routine counters to 0 - DISABLED to prevent CloudCounters conflict
                    // NOTE: This code was interfering with CloudCounters by overriding the correct values
                    /*
                    const streakTiles = document.querySelectorAll('.streak-tile');
                    if (streakTiles.length >= 2) {
                        const morningTile = streakTiles[0];
                        const eveningTile = streakTiles[1];
                        
                        const morningNumber = morningTile?.querySelector('.streak-number');
                        const eveningNumber = eveningTile?.querySelector('.streak-number');
                        
                        if (morningNumber) morningNumber.textContent = '0';
                        if (eveningNumber) eveningNumber.textContent = '0';
                        
                        console.log('✅ Reset routine counters to 0');
                    }
                    */
                    
                    // 5. Reset new simple routine manager if available
                    if (window.simpleRoutineManager) {
                        await window.simpleRoutineManager.reset();
                        console.log('✅ Reset SimpleRoutineManager');
                    }
                    
                    console.log('🎉 Routine database reset complete!');
                    console.log('📝 All routine data has been cleared and counters reset');
                    console.log('🔄 Refresh the page to ensure clean state across devices');
                    
                    return true;
                    
                } catch (error) {
                    console.error('❌ Error during routine reset:', error);
                    return false;
                }
            }
            
            // === DEBUG ROUTINE SYSTEM ===
            window.debugRoutineSystem = function() {
                console.log('🔍 ROUTINE SYSTEM DEBUG');
                console.log('======================');
                
                // Check localStorage
                const simpleData = localStorage.getItem('simple_routine_data');
                console.log('📱 simple_routine_data:', simpleData ? JSON.parse(simpleData) : 'NOT FOUND');
                
                const oldData = localStorage.getItem('routineCompletionData');
                console.log('📱 routineCompletionData (old):', oldData ? JSON.parse(oldData) : 'NOT FOUND');
                
                // Check SimpleRoutineManager
                if (window.simpleRoutineManager) {
                    console.log('✅ SimpleRoutineManager exists');
                    console.log('📊 Current data:', window.simpleRoutineManager.routineData);
                    console.log('📅 Today:', window.simpleRoutineManager.today);
                } else {
                    console.log('❌ SimpleRoutineManager NOT FOUND');
                }
                
                // Check checkboxes
                const morningCheckboxes = document.querySelectorAll('#morning-routine input[type="checkbox"]');
                const eveningCheckboxes = document.querySelectorAll('#evening-routine input[type="checkbox"]');
                
                console.log('🌅 Morning checkboxes:');
                morningCheckboxes.forEach(cb => {
                    const label = cb.nextElementSibling;
                    console.log(`- ${cb.id}: checked=${cb.checked}, strikethrough=${label?.style?.textDecoration || 'none'}`);
                });
                
                console.log('🌙 Evening checkboxes:');
                eveningCheckboxes.forEach(cb => {
                    const label = cb.nextElementSibling;
                    console.log(`- ${cb.id}: checked=${cb.checked}, strikethrough=${label?.style?.textDecoration || 'none'}`);
                });
                
                // Check counters
                const streakTiles = document.querySelectorAll('.streak-tile');
                console.log('📊 Counter tiles:');
                streakTiles.forEach((tile, index) => {
                    const number = tile.querySelector('.streak-number');
                    const label = tile.querySelector('.streak-label');
                    console.log(`- Tile ${index}: ${label?.textContent} = ${number?.textContent}`);
                });
                
                alert('Debug info logged to console - press F12 to see details');
            };
            
            // === GLOBAL ROUTINE RESET HANDLER ===
            window.handleRoutineReset = async function() {
                console.log('🖱️ handleRoutineReset called via onclick');
                
                const confirmed = confirm(
                    '⚠️ ACHTUNG: Routine-Datenbank komplett zurücksetzen?\n\n' +
                    '• Löscht ALLE Routine-Daten (lokal und cloud)\n' +
                    '• Setzt alle Counter auf 0\n' +
                    '• Betrifft alle Geräte\n' +
                    '• Kann nicht rückgängig gemacht werden\n\n' +
                    'Fortfahren?'
                );
                
                if (confirmed) {
                    console.log('✅ User confirmed reset');
                    const success = await resetRoutineDatabase();
                    if (success) {
                        alert('✅ Routine-Datenbank wurde komplett zurückgesetzt!\n\nBitte refreshe die Seite auf allen Geräten.');
                        window.location.reload();
                    } else {
                        alert('❌ Fehler beim Zurücksetzen. Bitte Console prüfen.');
                    }
                } else {
                    console.log('❌ User cancelled reset');
                }
            };
            
            // Initialize hash-based navigation
            initializeFromHash();
            
            // Add hash change event listener
            window.addEventListener('hashchange', handleHashChange);
            
            // Initialize URL hash for current active tab (only if authenticated)
            setTimeout(() => {
                if (supabase?.isAuthenticated()) {
                    const activeTab = document.querySelector('.nav-tab.active');
                    if (activeTab && !window.location.hash) {
                        const tabId = activeTab.getAttribute('data-tab');
                        if (tabId && tabHashMapping[tabId]) {
                            const hash = tabHashMapping[tabId];
                            window.history.replaceState(null, null, `#${hash}`);
                            console.log(`🔗 Initial tab loaded: ${tabId}, URL set to #${hash}`);
                        }
                    }
                }
            }, 100);
            
            // Pure cloud counter system - no force refresh needed
            setTimeout(() => {
                console.log('☁️ Ensuring cloud counters are initialized...');
                
                // Only initialize cloud counters if not already done
                if (window.CloudCounters && !window.CloudCounters.isInitialized && supabase?.isAuthenticated()) {
                    window.CloudCounters.init();
                }
                
                // Debug function for checking todo counts
                window.debugTodoCount = async function() {
                    if (!supabase?.isAuthenticated()) {
                        console.log('❌ Not authenticated');
                        return;
                    }
                    
                    const now = new Date();
                    const currentMonth = now.getMonth() + 1;
                    const currentYear = now.getFullYear();
                    const startOfMonth = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-01`;
                    const endOfMonth = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-31`;
                    
                    const user = supabase.getCurrentUser();
                    
                    console.log('🔍 Debug Todo Count for', `${currentMonth}/${currentYear}`);
                    console.log('📅 Date range:', startOfMonth, 'to', endOfMonth);
                    
                    // All todos this month
                    const allTodos = await supabase.query(`todos?user_id=eq.${user.id}&created_at=gte.${startOfMonth}&created_at=lt.${endOfMonth}&select=*`);
                    console.log('📝 All todos this month:', allTodos?.length || 0, allTodos);
                    
                    // Completed todos this month  
                    const completedTodos = await supabase.query(`todos?user_id=eq.${user.id}&completed=eq.true&created_at=gte.${startOfMonth}&created_at=lt.${endOfMonth}&select=*`);
                    console.log('✅ Completed todos this month:', completedTodos?.length || 0, completedTodos);
                    
                    return { all: allTodos, completed: completedTodos };
                };
                
                console.log('🔧 Debug function available: debugTodoCount()');
            }, 2000);
            
            // Mobile debug removed for cleaner console output
        });

        // === WIKI MANAGER ===
        const Wiki = {
            entries: [],
            filteredEntries: [],
            
            init() {
                console.log('🔧 Wiki: Initializing...');
                this.loadEntries();
                this.setupEventListeners();
                this.render();
            },
            
            setupEventListeners() {
                const form = document.getElementById('add-wiki-form');
                const searchInput = document.getElementById('wiki-search');
                
                if (form) {
                    form.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.addEntry();
                    });
                }
                
                if (searchInput) {
                    searchInput.addEventListener('input', () => {
                        clearTimeout(this.searchTimeout);
                        this.searchTimeout = setTimeout(() => this.search(), 300);
                    });
                }
            },
            
            showAddModal() {
                const modal = document.getElementById('add-wiki-modal');
                if (modal) {
                    modal.classList.remove('hide');
                    document.getElementById('wiki-title').focus();
                }
            },
            
            hideAddModal() {
                const modal = document.getElementById('add-wiki-modal');
                if (modal) {
                    modal.classList.add('hide');
                    document.getElementById('add-wiki-form').reset();
                }
            },
            
            async addEntry() {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ Wiki: Not authenticated - cannot add entry in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Wiki-Eintrag kann nicht gespeichert werden.');
                    return;
                }
                
                const title = document.getElementById('wiki-title').value;
                const content = document.getElementById('wiki-content').value;
                const tagsText = document.getElementById('wiki-tags').value;
                const source = document.getElementById('wiki-source').value;
                
                if (!title || !tagsText || !content) {
                    alert('Please fill in all required fields');
                    return;
                }
                
                const tags = tagsText.split(',').map(tag => tag.trim()).filter(tag => tag);
                
                // Generate a unique ID for the wiki entry
                const entryId = Date.now(); // Use timestamp as ID
                
                const entry = {
                    id: entryId, // Manually set ID since table doesn't auto-generate
                    title,
                    content,
                    tags,
                    source,
                    user_id: supabase.getCurrentUser().id,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                };
                
                // Remove any undefined fields that might cause issues
                Object.keys(entry).forEach(key => {
                    if (entry[key] === undefined || entry[key] === null) {
                        delete entry[key];
                    }
                });
                
                try {
                    console.log('☁️ Wiki: Saving entry to cloud:', title);
                    console.log('☁️ Wiki: Entry data:', entry);
                    
                    // Use array format for insert
                    const result = await supabase.insert('crypto_wiki_entries', [entry]);
                    console.log('☁️ Wiki: Insert result:', result);
                    
                    if (result && result.length > 0) {
                        this.entries.push(result[0]);
                        console.log('☁️ Wiki: Entry saved to cloud with ID:', result[0].id);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('❌ Wiki: Error saving to cloud:', error);
                    console.error('❌ Wiki: Error details:', error.message);
                    alert('Fehler beim Speichern des Wiki-Eintrags: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                this.hideAddModal();
                this.render();
                
                console.log('☁️ Wiki: Entry added:', title);
            },
            
            async deleteEntry(id) {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ Wiki: Not authenticated - cannot delete entry in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Wiki-Eintrag kann nicht gelöscht werden.');
                    return;
                }
                
                const entry = this.entries.find(e => e.id === id);
                if (!entry) return;
                
                if (confirm(`Delete wiki entry "${entry.title}"?`)) {
                    try {
                        console.log('☁️ Wiki: Deleting entry from cloud:', id);
                        await supabase.delete('crypto_wiki_entries', `id=eq.${id}`);
                        console.log('☁️ Wiki: Entry deleted from cloud');
                    } catch (error) {
                        console.error('❌ Wiki: Error deleting from cloud:', error);
                        alert('Fehler beim Löschen des Wiki-Eintrags: ' + error.message);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                    
                    // Remove from local array
                    this.entries = this.entries.filter(e => e.id !== id);
                    
                    // Pure cloud mode - no localStorage
                    
                    this.render();
                    console.log('☁️ Wiki: Entry deleted:', entry.title);
                }
            },
            
            search() {
                const query = document.getElementById('wiki-search').value.toLowerCase();
                
                this.filteredEntries = this.entries.filter(entry => {
                    const matchesSearch = !query || 
                        entry.title.toLowerCase().includes(query) ||
                        entry.content.toLowerCase().includes(query) ||
                        entry.tags.some(tag => tag.toLowerCase().includes(query)) ||
                        (entry.source && entry.source.toLowerCase().includes(query));
                    
                    return matchesSearch;
                });
                
                this.render();
            },
            
            filterByTags() {
                const tagFilter = document.getElementById('wiki-tag-filter').value.toLowerCase();
                
                this.filteredEntries = this.entries.filter(entry => {
                    if (!tagFilter) return true;
                    
                    return entry.tags.some(tag => tag.toLowerCase().includes(tagFilter));
                });
                
                this.render();
            },
            
            render() {
                const container = document.getElementById('wiki-entries');
                if (!container) return;
                
                const entriesToShow = this.filteredEntries.length > 0 || 
                    document.getElementById('wiki-search').value || 
                    document.getElementById('wiki-tag-filter').value 
                    ? this.filteredEntries : this.entries;
                
                if (entriesToShow.length === 0) {
                    container.innerHTML = '<div class="empty-wiki">No wiki entries found. Add your first knowledge entry!</div>';
                    return;
                }
                
                const html = entriesToShow
                    .sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at))
                    .map(entry => this.renderEntry(entry))
                    .join('');
                
                container.innerHTML = html;
                
                // Initialize Lucide icons after rendering
                setTimeout(() => {
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                }, 100);
            },
            
            renderEntry(entry) {
                const tagsHtml = entry.tags.map(tag => `<span class="wiki-tag">${tag}</span>`).join('');
                const sourceHtml = entry.source ? `<span class="wiki-entry-source">Source: ${entry.source}</span>` : '';
                const dateHtml = new Date(entry.created_at).toLocaleDateString('de-DE');
                
                return `
                    <div class="wiki-entry">
                        <div class="wiki-entry-header">
                            <h3 class="wiki-entry-title">${entry.title}</h3>
                        </div>
                        <div class="wiki-entry-content">${entry.content}</div>
                        <div class="wiki-entry-meta">
                            <div class="wiki-entry-left">
                                <div class="wiki-entry-tags">${tagsHtml}</div>
                                ${sourceHtml}
                            </div>
                            <div class="wiki-entry-right">
                                <span>${dateHtml}</span>
                                <div class="wiki-entry-actions">
                                    <button onclick="Wiki.deleteEntry('${entry.id}')" title="Delete">
                                        <i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            },
            
            async loadEntries() {
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ Wiki: Not authenticated - pure cloud mode requires authentication');
                    this.entries = [];
                    this.render();
                    return;
                }
                
                try {
                    await this.loadFromCloud();
                } catch (error) {
                    console.error('❌ Wiki: Error loading entries:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },

            
            async saveEntries() {
                // Pure cloud mode - no localStorage saving
                if (!supabase?.isAuthenticated()) {
                    console.error('❌ Wiki: Not authenticated - cannot save in pure cloud mode');
                    return;
                }
                
                try {
                    await this.saveToCloud();
                } catch (error) {
                    console.error('❌ Wiki: Error saving entries:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            async loadFromCloud() {
                try {
                    console.log('☁️ Wiki: Loading from cloud...');
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        throw new Error('No user found');
                    }

                    const data = await supabase.query(`crypto_wiki_entries?user_id=eq.${user.id}&order=updated_at.desc&select=*`);
                    
                    if (data && Array.isArray(data)) {
                        this.entries = data;
                        console.log(`☁️ Wiki: Loaded ${this.entries.length} entries from cloud`);
                        this.render();
                    } else {
                        console.log('☁️ Wiki: No entries found in cloud');
                        this.entries = [];
                        this.render();
                    }
                } catch (error) {
                    console.error('❌ Wiki: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            async saveToCloud() {
                try {
                    console.log('🔄 Wiki: Saving to Supabase...');
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        console.log('❌ Wiki: No user found');
                        return;
                    }

                    // We'll save entries individually when they're created/updated
                    console.log('✅ Wiki: Cloud sync ready');
                } catch (error) {
                    console.error('❌ Wiki: Error saving to cloud:', error);
                }
            },

            async saveEntryToCloud(entry) {
                try {
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        throw new Error('No user found');
                    }

                    const entryWithUserId = {
                        ...entry,
                        user_id: user.id
                    };

                    const data = await supabase.insert('crypto_wiki_entries', entryWithUserId);
                    
                    if (!data || !Array.isArray(data) || data.length === 0) {
                        throw new Error('Insert did not return data');
                    }

                    console.log('☁️ Wiki: Entry saved to cloud:', entry.title);
                    return true;
                } catch (error) {
                    console.error('❌ Wiki: Error in saveEntryToCloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },

            async deleteEntryFromCloud(entryId) {
                try {
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        throw new Error('No user found');
                    }

                    const result = await supabase.delete('crypto_wiki_entries', `id=eq.${entryId}`);
                    
                    console.log('☁️ Wiki: Entry deleted from cloud');
                    return true;
                } catch (error) {
                    console.error('❌ Wiki: Error in deleteEntryFromCloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            }
        };

        // Make Wiki globally available
        window.Wiki = Wiki;
        
        // === POMODORO TIMER CLASS ===
        class PomodoroTimer {
            constructor() {
                this.duration = 25 * 60; // 25 minutes in seconds
                this.timeLeft = this.duration;
                this.isRunning = false;
                this.isPaused = false;
                this.interval = null;
                this.originalTitle = document.title;
                this.timerBtn = document.getElementById('timer-btn');
                
                // Set initial tooltip
                if (this.timerBtn) {
                    this.timerBtn.title = 'Pomodoro Timer (25 min) | Right-click to reset';
                }
                
                console.log('🍅 PomodoroTimer initialized (25 min) - Left click: start/stop, Right click: reset');
            }
            
            toggle() {
                if (this.isRunning) {
                    this.pause();
                } else {
                    this.start();
                }
            }
            
            start() {
                console.log('🍅 Timer started');
                this.isRunning = true;
                this.isPaused = false;
                
                // Update button appearance
                this.timerBtn.classList.add('timer-running');
                this.timerBtn.classList.remove('timer-paused');
                this.timerBtn.title = 'Running - Click to pause';
                
                this.interval = setInterval(() => {
                    this.timeLeft--;
                    this.updateDisplay();
                    
                    if (this.timeLeft <= 0) {
                        this.complete();
                    }
                }, 1000);
            }
            
            pause() {
                console.log('🍅 Timer paused');
                this.isRunning = false;
                this.isPaused = true;
                
                // Update button appearance
                this.timerBtn.classList.remove('timer-running');
                this.timerBtn.classList.add('timer-paused');
                this.timerBtn.title = 'Paused - Click to resume';
                
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
            }
            
            complete() {
                console.log('🍅 Timer completed!');
                this.reset();
                
                // Show notification
                this.showNotification();
                
                // Play sound (if available)
                this.playCompletionSound();
            }
            
            reset() {
                console.log('🍅 Timer reset to 25:00');
                this.isRunning = false;
                this.isPaused = false;
                this.timeLeft = this.duration;
                
                // Reset button appearance
                this.timerBtn.classList.remove('timer-running', 'timer-paused');
                this.timerBtn.title = 'Pomodoro Timer (25 min) | Right-click to reset';
                
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
                
                // Reset title
                document.title = this.originalTitle;
            }
            
            updateDisplay() {
                const minutes = Math.floor(this.timeLeft / 60);
                const seconds = this.timeLeft % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Update page title
                document.title = `🍅 ${timeString} | ${this.originalTitle}`;
            }
            
            showNotification() {
                // Browser notification
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification('🍅 Pomodoro Complete!', {
                        body: '25 minutes focused work completed. Time for a break!',
                        icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="80">🍅</text></svg>'
                    });
                } else if ('Notification' in window && Notification.permission !== 'denied') {
                    // Request permission
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            this.showNotification();
                        }
                    });
                }
                
                // Fallback alert
                alert('🍅 Pomodoro Complete!\n\n25 minutes focused work completed.\nTime for a break!');
            }
            
            playCompletionSound() {
                // Create a simple beep sound
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (error) {
                    console.log('🔇 Could not play completion sound:', error);
                }
            }
        }
        
        // Make PomodoroTimer globally available
        window.PomodoroTimer = new PomodoroTimer();
        
        // === QUICK ADD CLASS ===
        class QuickAdd {
            constructor() {
                this.isVisible = false;
                this.overlay = null;
                this.modal = null;
                console.log('⚡ QuickAdd initialized');
            }
            
            show() {
                if (this.isVisible) return;
                
                console.log('⚡ QuickAdd: Showing modal');
                this.createModal();
                this.isVisible = true;
            }
            
            hide() {
                if (!this.isVisible) return;
                
                console.log('⚡ QuickAdd: Hiding modal');
                if (this.overlay) {
                    this.overlay.remove();
                    this.overlay = null;
                    this.modal = null;
                }
                this.isVisible = false;
            }
            
            createModal() {
                // Create overlay
                this.overlay = document.createElement('div');
                this.overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    z-index: 2000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                
                // Create modal
                this.modal = document.createElement('div');
                this.modal.style.cssText = `
                    background: white;
                    border-radius: 8px;
                    padding: 2rem;
                    min-width: 400px;
                    max-width: 500px;
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
                `;
                
                this.modal.innerHTML = `
                    <h3 style="margin: 0 0 1rem 0; font-size: 1.2rem;">⚡ Quick Add Todo</h3>
                    <form id="quick-add-form" autocomplete="off">
                        <input type="text" id="quick-todo-title" placeholder="Todo eingeben..." autocomplete="off"
                               style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 1rem; font-size: 1rem;" />
                        
                        <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                            <select id="quick-todo-category" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="privat">Privat</option>
                                <option value="uni">Uni</option>
                                <option value="arbeit">Arbeit</option>
                            </select>
                            
                            <select id="quick-todo-priority" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="mittel">Mittel</option>
                                <option value="wichtig">Wichtig</option>
                                <option value="dringend">Dringend</option>
                            </select>
                        </div>
                        
                        <input type="date" id="quick-todo-deadline" 
                               style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 1rem;" />
                        
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                            <button type="button" id="quick-add-cancel" 
                                    style="padding: 0.5rem 1rem; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">
                                Abbrechen
                            </button>
                            <button type="submit" 
                                    style="padding: 0.5rem 1rem; border: none; background: #059669; color: white; border-radius: 4px; cursor: pointer;">
                                Hinzufügen
                            </button>
                        </div>
                    </form>
                `;
                
                this.overlay.appendChild(this.modal);
                document.body.appendChild(this.overlay);
                
                // Set today as default deadline
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('quick-todo-deadline').value = today;
                
                // Focus title input
                const titleInput = document.getElementById('quick-todo-title');
                setTimeout(() => titleInput.focus(), 100);
                
                // Event listeners
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // Close on overlay click
                this.overlay.addEventListener('click', (e) => {
                    if (e.target === this.overlay) {
                        this.hide();
                    }
                });
                
                // Close on ESC key
                document.addEventListener('keydown', this.handleKeydown.bind(this));
                
                // Cancel button
                document.getElementById('quick-add-cancel').addEventListener('click', () => {
                    this.hide();
                });
                
                // Form submit
                document.getElementById('quick-add-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleSubmit();
                });
            }
            
            handleKeydown(e) {
                if (e.key === 'Escape' && this.isVisible) {
                    this.hide();
                }
            }
            
            async handleSubmit() {
                const title = document.getElementById('quick-todo-title').value.trim();
                const category = document.getElementById('quick-todo-category').value;
                const priority = document.getElementById('quick-todo-priority').value;
                const deadline = document.getElementById('quick-todo-deadline').value;
                
                if (!title) {
                    alert('Bitte gib einen Todo-Titel ein!');
                    return;
                }
                
                // Map priority string to integer for database
                const priorityMap = {
                    'mittel': 2,
                    'wichtig': 3,
                    'dringend': 4
                };
                
                const todo = {
                    text: title,  // Database uses 'text', not 'title'
                    category: category,
                    priority: priorityMap[priority] || 2,  // Convert to integer
                    date: deadline || null,  // Database uses 'date', not 'deadline'
                    time: null,  // No time specified in quick-add
                    completed: false,
                    created_at: new Date().toISOString()
                };
                
                try {
                    console.log('⚡ QuickAdd: Saving todo:', todo);
                    
                    // Check if authenticated
                    if (!window.supabase?.isAuthenticated()) {
                        alert('Nicht authentifiziert! Bitte logge dich ein.');
                        return;
                    }
                    
                    // Save using CloudStorage directly for more reliability
                    if (window.cloudStorage) {
                        await window.cloudStorage.saveTodo(todo);
                        console.log('✅ QuickAdd: Todo saved successfully via CloudStorage');
                    } else if (window.TodoManager) {
                        await window.TodoManager.saveTodo(todo);
                        console.log('✅ QuickAdd: Todo saved successfully via TodoManager');
                    } else {
                        throw new Error('No todo saving mechanism available');
                    }
                    
                    // Refresh todo display immediately after saving
                    if (window.TodoManager) {
                        console.log('🔄 QuickAdd: Refreshing todo display...');
                        
                        // Load todos from database first
                        await window.TodoManager.loadTodos();
                        
                        // Then refresh the current view
                        if (typeof window.TodoManager.refreshCurrentView === 'function') {
                            window.TodoManager.refreshCurrentView();
                        }
                        
                        // Also update home view for counters
                        if (typeof window.TodoManager.updateHomeTodos === 'function') {
                            window.TodoManager.updateHomeTodos();
                        }
                        
                        console.log('✅ QuickAdd: Todo display refreshed');
                    } else {
                        console.log('⚠️ QuickAdd: TodoManager not available');
                    }
                    
                    console.log('✅ QuickAdd: All done, hiding modal');
                    this.hide();
                } catch (error) {
                    console.error('❌ QuickAdd: Error saving todo:', error);
                    console.error('❌ QuickAdd: Error details:', error.message, error.stack);
                    alert(`Fehler beim Speichern des Todos: ${error.message}`);
                }
            }
        }
        
        // Make QuickAdd globally available
        window.QuickAdd = new QuickAdd();
        
        // Wiki and Lucide icons initialization moved to main DOMContentLoaded listener
    </script>
    
    <!-- ========================================= -->
    <!-- TRADING MANAGER -->
    <!-- ========================================= -->
    <script>
        class TradingManager {
            constructor() {
                this.apiKey = '35ffdb6a-2061-4573-a66b-ea263c5eaa34';
                this.trades = [];
                this.solPrice = 0;
                this.requestCount = 0;
                this.maxRequestsPerHour = 30; // Conservative limit
                
                this.init();
            }

            async init() {
                // Setup event listeners
                this.setupEventListeners();
                
                // Load trades from cloud when tab is accessed
                this.setupTabListener();
                
                // Get current SOL price
                await this.updateSolPrice();
            }

            setupEventListeners() {
                // Add trade button
                const addTradeBtn = document.getElementById('add-trade-btn');
                if (addTradeBtn) {
                    addTradeBtn.addEventListener('click', () => this.addTrade());
                }

                // Refresh prices button
                const refreshPricesBtn = document.getElementById('refresh-prices-btn');
                if (refreshPricesBtn) {
                    refreshPricesBtn.addEventListener('click', () => this.refreshPrices());
                }
            }

            setupTabListener() {
                document.addEventListener('click', (e) => {
                    if (e.target.matches('[data-tab="tab-trading"]')) {
                        this.loadTrades();
                    }
                });
            }

            async updateSolPrice() {
                try {
                    // Use simple CoinGecko API for SOL price (no API key needed)
                    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.solPrice = data.solana?.usd || 200;
                    } else {
                        this.solPrice = 200; // Fallback
                    }
                } catch (error) {
                    this.solPrice = 200; // Fallback
                }
            }


            async addTrade() {
                const token = document.getElementById('trade-token').value.trim().toUpperCase();
                const solAmount = parseFloat(document.getElementById('trade-sol-amount').value);
                const entryMcap = document.getElementById('trade-mcap').value.trim();

                if (!token || !solAmount || !entryMcap) {
                    alert('Please fill in all fields');
                    return;
                }

                const trade = {
                    id: Date.now().toString(),
                    token,
                    sol_amount: solAmount,
                    entry_mcap: entryMcap,
                    entry_price: this.solPrice * solAmount,
                    entry_date: new Date().toISOString(),
                    status: 'open',
                    pnl: 0,
                    user_id: window.supabase?.getCurrentUser()?.id
                };

                try {
                    // Save to cloud
                    await this.saveTradeToCloud(trade);
                    
                    // Add to local array
                    this.trades.push(trade);
                    
                    // Clear form
                    document.getElementById('trade-token').value = '';
                    document.getElementById('trade-sol-amount').value = '';
                    document.getElementById('trade-mcap').value = '';
                    
                    // Refresh display
                    this.renderTrades();
                    this.updatePortfolioStats();

                } catch (error) {
                    console.error('Error adding trade:', error);
                    alert('Failed to save trade');
                }
            }

            async saveTradeToCloud(trade) {
                if (!window.supabase || !window.supabase.isAuthenticated()) {
                    throw new Error('Not authenticated');
                }

                await window.supabase.insert('trades', [trade]);
            }

            async loadTrades() {
                try {
                    if (!window.supabase || !window.supabase.isAuthenticated()) {
                        return;
                    }

                    const user = window.supabase.getCurrentUser();
                    const data = await window.supabase.query(`trades?user_id=eq.${user.id}&select=*`);
                    
                    if (data) {
                        this.trades = data;
                        this.renderTrades();
                        this.updatePortfolioStats();
                    }

                } catch (error) {
                    console.error('Error loading trades:', error);
                }
            }

            renderTrades() {
                const openTrades = this.trades.filter(t => t.status === 'open');
                const closedTrades = this.trades.filter(t => t.status === 'closed');

                this.renderOpenTrades(openTrades);
                this.renderClosedTrades(closedTrades);
            }

            renderOpenTrades(trades) {
                const container = document.getElementById('open-trades-list');
                
                if (!trades.length) {
                    container.innerHTML = '<div class="empty-trades">No open trades yet</div>';
                    return;
                }

                const html = `
                    <div class="trade-header">
                        <div>Token</div>
                        <div>SOL Amount</div>
                        <div>Entry McAP</div>
                        <div>Entry Price</div>
                        <div>P&L</div>
                        <div>Actions</div>
                    </div>
                    ${trades.map(trade => `
                        <div class="trade-row">
                            <div class="trade-token" data-label="Token">
                                <strong>${trade.token}</strong>
                            </div>
                            <div class="trade-amount" data-label="SOL Amount">${trade.sol_amount} SOL</div>
                            <div class="trade-entry-price" data-label="Entry McAP">${trade.entry_mcap}</div>
                            <div class="trade-entry-price" data-label="Entry Price">$${trade.entry_price.toFixed(0)}</div>
                            <div class="trade-pnl ${trade.pnl >= 0 ? 'positive' : 'negative'}" data-label="P&L">
                                ${trade.pnl >= 0 ? '+' : ''}${trade.pnl.toFixed(2)} SOL
                            </div>
                            <div class="trade-actions" data-label="Actions">
                                <button class="btn secondary" onclick="window.TradingManager.editTrade('${trade.id}')">Edit</button>
                                <button class="btn secondary" onclick="window.TradingManager.closeTrade('${trade.id}')">Close</button>
                            </div>
                        </div>
                    `).join('')}
                `;

                container.innerHTML = html;
            }

            renderClosedTrades(trades) {
                const container = document.getElementById('closed-trades-list');
                
                if (!trades.length) {
                    container.innerHTML = '<div class="empty-trades">No closed trades yet</div>';
                    return;
                }

                const html = `
                    <div class="trade-header">
                        <div>Token</div>
                        <div>SOL Amount</div>
                        <div>Entry → Exit</div>
                        <div>Entry → Exit Price</div>
                        <div>Final P&L</div>
                        <div>Date</div>
                        <div>Actions</div>
                    </div>
                    ${trades.map(trade => `
                        <div class="trade-row">
                            <div class="trade-token" data-label="Token">
                                <strong>${trade.token}</strong>
                            </div>
                            <div class="trade-amount" data-label="SOL Amount">${trade.sol_amount} SOL</div>
                            <div class="trade-entry-price" data-label="McAP">${trade.entry_mcap} → ${trade.exit_mcap || 'N/A'}</div>
                            <div class="trade-entry-price" data-label="Price">$${trade.entry_price.toFixed(0)} → $${(trade.exit_price || 0).toFixed(0)}</div>
                            <div class="trade-pnl ${trade.final_pnl >= 0 ? 'positive' : 'negative'}" data-label="P&L">
                                ${trade.final_pnl >= 0 ? '+' : ''}${trade.final_pnl.toFixed(2)} SOL
                            </div>
                            <div data-label="Date">${new Date(trade.exit_date || trade.entry_date).toLocaleDateString()}</div>
                            <div class="trade-actions" data-label="Actions">
                                <button class="btn secondary" onclick="window.TradingManager.deleteTrade('${trade.id}')">Delete</button>
                            </div>
                        </div>
                    `).join('')}
                `;

                container.innerHTML = html;
            }

            updatePortfolioStats() {
                const openTrades = this.trades.filter(t => t.status === 'open');
                const closedTrades = this.trades.filter(t => t.status === 'closed');
                
                const totalPnl = closedTrades.reduce((sum, t) => sum + (t.final_pnl || 0), 0);
                const winningTrades = closedTrades.filter(t => (t.final_pnl || 0) > 0).length;
                const winRate = closedTrades.length > 0 ? (winningTrades / closedTrades.length * 100) : 0;

                document.getElementById('total-pnl').textContent = `${totalPnl >= 0 ? '+' : ''}${totalPnl.toFixed(2)} SOL`;
                document.getElementById('total-pnl').className = `stat-number ${totalPnl >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('open-trades').textContent = openTrades.length;
                document.getElementById('win-rate').textContent = `${winRate.toFixed(1)}%`;
            }

            async editTrade(tradeId) {
                const trade = this.trades.find(t => t.id === tradeId);
                if (!trade) return;

                const newMcap = prompt(`Current Market Cap for ${trade.token}:`, trade.entry_mcap);
                const newSol = prompt(`Current SOL value:`, trade.sol_amount);

                if (newMcap && newSol) {
                    trade.current_mcap = newMcap;
                    trade.current_sol = parseFloat(newSol);
                    trade.pnl = trade.current_sol - trade.sol_amount;

                    await this.updateTradeInCloud(trade);
                    this.renderTrades();
                    this.updatePortfolioStats();
                }
            }

            async closeTrade(tradeId) {
                const trade = this.trades.find(t => t.id === tradeId);
                if (!trade) return;

                const exitMcap = prompt(`Exit Market Cap for ${trade.token}:`, trade.entry_mcap);
                const receivedSol = prompt(`SOL received:`, trade.sol_amount);

                if (exitMcap && receivedSol) {
                    trade.status = 'closed';
                    trade.exit_mcap = exitMcap;
                    trade.exit_price = this.solPrice * parseFloat(receivedSol);
                    trade.received_sol = parseFloat(receivedSol);
                    trade.final_pnl = trade.received_sol - trade.sol_amount;
                    trade.exit_date = new Date().toISOString();

                    await this.updateTradeInCloud(trade);
                    this.renderTrades();
                    this.updatePortfolioStats();
                }
            }

            async updateTradeInCloud(trade) {
                if (!window.supabase || !window.supabase.isAuthenticated()) return;
                await window.supabase.update('trades', trade, trade.id);
            }

            async deleteTrade(tradeId) {
                if (!confirm('Are you sure you want to delete this trade?')) return;

                try {
                    // Remove from cloud
                    if (window.supabase && window.supabase.isAuthenticated()) {
                        await window.supabase.delete('trades', tradeId);
                    }
                    
                    // Remove from local array
                    this.trades = this.trades.filter(t => t.id !== tradeId);
                    
                    // Refresh display
                    this.renderTrades();
                    this.updatePortfolioStats();

                } catch (error) {
                    console.error('Error deleting trade:', error);
                    alert('Failed to delete trade');
                }
            }


            async refreshPrices() {
                await this.updateSolPrice();
                // Would update all current market caps here
                alert(`SOL Price updated: $${this.solPrice.toFixed(2)}`);
            }
        }

        // Initialize Trading Manager
        window.TradingManager = new TradingManager();
    </script>
    
    <!-- ========================================= -->
    <!-- CLOUD-FIRST POLICY ENFORCEMENT -->
    <!-- ========================================= -->
    <script src="CLOUD_POLICY.js"></script>
    <script>
        // Aktiviere Cloud-Policy für alle Manager
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🛡️ Activating Cloud-First Policy enforcement...');
            
            // Validiere alle existierenden Manager
            setTimeout(() => {
                const managers = [
                    { name: 'TodoManager', obj: window.TodoManager },
                    { name: 'GoalManager', obj: window.GoalManager },
                    { name: 'JournalManager', obj: window.JournalManager },
                    { name: 'TerminManager', obj: window.TerminManager },
                    { name: 'ResourceManager', obj: window.ResourceManager },
                    { name: 'Wiki', obj: window.Wiki },
                    { name: 'SimpleRoutineManager', obj: window.simpleRoutineManager }
                ];
                
                console.log('🔍 Validating all managers for Cloud-First compliance...');
                
                managers.forEach(({ name, obj }) => {
                    if (obj) {
                        console.log(`✅ ${name}: Available and cloud-compliant`);
                    } else {
                        console.warn(`⚠️ ${name}: Not found`);
                    }
                });
                
                console.log('🎉 Cloud-First Policy validation complete');
                console.log('📋 All future implementations must follow CLOUD_POLICY.js guidelines');
                
            }, 2000);
        });
        
        // === GLOBAL GOAL EDIT MODAL EVENT LISTENERS SETUP ===
        // This needs to be outside of DOMContentLoaded to ensure it runs
        console.log('🎯 GLOBAL: Setting up goal edit modal event listeners...');
        
        // Make event listener initialization globally available
        window.initGoalEditModalEventListeners = function() {
            console.log('🎯 GLOBAL: Initializing goal edit modal event listeners...');
            
            const cancelEditGoalBtn = document.getElementById('cancel-edit-goal-value-btn');
            if (cancelEditGoalBtn) {
                console.log('✅ GLOBAL: Found cancel-edit-goal-value-btn, adding event listener');
                // Remove existing listeners first
                const newCancelBtn = cancelEditGoalBtn.cloneNode(true);
                cancelEditGoalBtn.parentNode.replaceChild(newCancelBtn, cancelEditGoalBtn);
                
                newCancelBtn.addEventListener('click', () => {
                    console.log('🎯 GLOBAL: Cancel button clicked');
                    if (window.GoalManager && window.GoalManager.hideEditGoalValueModal) {
                        window.GoalManager.hideEditGoalValueModal();
                    } else {
                        console.error('❌ GoalManager not available');
                    }
                });
            } else {
                console.error('❌ GLOBAL: cancel-edit-goal-value-btn not found');
            }

            const editGoalForm = document.getElementById('edit-goal-value-form');
            if (editGoalForm) {
                console.log('✅ GLOBAL: Found edit-goal-value-form, adding event listener');
                // Remove existing listeners first
                const newForm = editGoalForm.cloneNode(true);
                editGoalForm.parentNode.replaceChild(newForm, editGoalForm);
                
                newForm.addEventListener('submit', async (e) => {
                    console.log('🎯 GLOBAL: Form submit event triggered');
                    e.preventDefault();
                    
                    const goalId = e.target.dataset.goalId;
                    console.log('🎯 GLOBAL: Form submit goalId:', goalId);
                    if (goalId && window.GoalManager && window.GoalManager.editGoalValue) {
                        await window.GoalManager.editGoalValue(goalId);
                    } else {
                        console.error('❌ GLOBAL: No goalId found or GoalManager not available');
                    }
                });
            } else {
                console.error('❌ GLOBAL: edit-goal-value-form not found');
            }
        };
        
        // Try to initialize immediately
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('🎯 GLOBAL: DOM ready, initializing...');
                window.initGoalEditModalEventListeners();
            });
        } else {
            console.log('🎯 GLOBAL: DOM already ready, initializing now...');
            window.initGoalEditModalEventListeners();
        }
        
        // Event listeners are initialized when DOM is ready and when modal opens
        // No need for redundant retries
    </script>
</body>
</html>