<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-eval' 'unsafe-inline' https://unpkg.com https://cdn.jsdelivr.net; object-src 'none'; base-uri 'self';">
    <title>DASHBOARD v4.0 - PRO DEPLOYMENT</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22 font-family=%22-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif%22 font-weight=%22700%22 fill=%22%23000000%22>A</text></svg>">
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* === RESET & BASE === */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #000000;
            line-height: 1.6;
            padding-top: 80px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* === STICKY NAVIGATION === */
        .sticky-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #ffffff;
            border-bottom: 1px solid #e0e0e0;
            z-index: 1000;
            padding: 1rem 0;
        }
        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            position: relative;
        }
        .nav-tab {
            text-decoration: none;
            color: #666666;
            font-size: 0.8rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            padding: 0.4rem 0.75rem;
            border: 1px solid transparent;
            transition: all 0.2s ease;
            cursor: pointer;
            background: none;
            font-family: inherit;
        }
        .nav-tab:hover { border-color: #000000; color: #000000; }
        .nav-tab.active {
            color: #000000;
            font-weight: 700;
            border: 1px solid transparent;
            background: transparent;
        }
        
        /* === LOGOUT & SETTINGS BUTTONS === */
        .nav-actions {
            position: absolute;
            right: 0;
            display: flex;
            gap: 0.25rem;
            align-items: center;
        }
        
        .logout-btn, .settings-btn, .timer-btn, .quick-add-btn {
            color: #666666 !important;
            font-weight: 400 !important;
            background: transparent !important;
            border: none !important;
            border-color: transparent !important;
            outline: none !important;
            cursor: pointer !important;
            pointer-events: auto !important;
            position: relative !important;
            z-index: 1000 !important;
            box-shadow: none !important;
            text-transform: none !important;
            letter-spacing: normal !important;
            padding: 0.5rem 1rem !important;
        }
        
        /* Mobile-safe hover states - override nav-tab hover */
        .logout-btn:hover, .settings-btn:hover, .timer-btn:hover, .quick-add-btn:hover,
        .logout-btn:active, .settings-btn:active, .timer-btn:active, .quick-add-btn:active,
        .logout-btn:focus, .settings-btn:focus, .timer-btn:focus, .quick-add-btn:focus {
            background: transparent !important;
            border: none !important;
            border-color: transparent !important;
        }
        
        /* Specific override for nav-tab hover border */
        .nav-tab.logout-btn:hover, .nav-tab.settings-btn:hover, .nav-tab.timer-btn:hover, .nav-tab.quick-add-btn:hover {
            border: none !important;
            border-color: transparent !important;
            background: transparent !important;
        }
        
        /* Override conflicting nav-tab hover rules for quick-add */
        .nav-tab.quick-add-btn:hover {
            border-color: transparent !important;
        }
        
        .logout-btn:hover span, .logout-btn:active span, .logout-btn:focus span,
        .logout-btn:hover svg, .logout-btn:active svg, .logout-btn:focus svg {
            color: #dc2626 !important;
            stroke: #dc2626 !important;
        }
        
        /* Timer button specific styles */
        .timer-btn.timer-running {
            color: #059669 !important;
        }
        .timer-btn.timer-running i {
            stroke: #059669 !important;
            animation: pulse 2s infinite;
        }
        .timer-btn.timer-paused {
            color: #d97706 !important;
        }
        .timer-btn.timer-paused i {
            stroke: #d97706 !important;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Quick-add button - JavaScript only approach */
        .nav-tab.quick-add-btn i {
            transition: transform 0.3s ease !important;
            will-change: transform !important;
        }
        
        .settings-btn:hover span, .settings-btn:active span, .settings-btn:focus span,
        .settings-btn:hover i, .settings-btn:active i, .settings-btn:focus i {
            color: #059669 !important;
            stroke: #059669 !important;
        }
        
        .timer-btn:hover i, .timer-btn:active i, .timer-btn:focus i {
            stroke: #059669 !important;
            color: #059669 !important;
        }
        
        /* Force reset any stuck hover states on mobile */
        @media (max-width: 768px) {
            .logout-btn span {
                color: #666666 !important;
            }
            .logout-btn:hover span {
                color: #dc2626 !important;
            }
        }
        
        .logout-btn span, .settings-btn span {
            font-size: 1.2rem;
            pointer-events: none !important;
        }

        /* === SETTINGS PAGE === */
        .settings-container {
            max-width: 600px;
            margin: 0 auto;
        }
        
        .setting-group {
            background: #f8f9fa;
            padding: 2rem;
            margin-bottom: 2rem;
            border-radius: 12px;
            border: 1px solid #e0e0e0;
        }
        
        .setting-group h3 {
            margin: 0 0 1.5rem 0;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .setting-item:last-child {
            margin-bottom: 0;
        }
        
        .setting-item label {
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .setting-item input[type="time"] {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            max-width: 200px;
        }
        
        .setting-description {
            font-size: 0.85rem;
            color: #666666;
            margin-top: 0.25rem;
        }
        
        .btn-secondary {
            background: #6b7280 !important;
        }
        
        .btn-secondary:hover {
            background: #4b5563 !important;
        }

        /* === MAIN CONTENT === */
        .main-content { padding: 0 20px 40px 20px; }
        .tab-section { display: none; }
        .tab-section.active { display: block; }

        /* === SHARED COMPONENTS === */
        .section-title {
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 3rem;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 1rem;
        }
        .card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            transition: border-color 0.2s ease;
        }
        .card:hover { border-color: #000000; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 3rem; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2rem; }
        .btn {
            padding: 0.75rem 1.5rem;
            border: 1px solid #000000;
            background: #ffffff;
            color: #000000;
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-block;
        }
        .btn:hover { background: #000000; color: #ffffff; }
        .btn.secondary { border-color: #e0e0e0; color: #666666; }
        .btn.secondary:hover { border-color: #000000; background: #f0f0f0; color: #000000; }

        /* === CHECKBOX COMPONENT === */
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .checkbox-item.todo-item {
            justify-content: space-between;
            width: 100%;
        }
        .checkbox-item.todo-item .todo-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
            min-width: 0; /* Allow shrinking */
        }
        .checkbox-item.todo-item .todo-time {
            font-size: 0.85rem;
            color: #666;
            font-weight: 500;
            flex-shrink: 0;
            margin-left: 1rem;
            text-align: right;
        }
        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            border: 2px solid #000000;
            appearance: none;
            cursor: pointer;
            flex-shrink: 0;
        }
        .checkbox-item input[type="checkbox"]:checked {
            background-color: #000000;
            position: relative;
        }
        .checkbox-item input[type="checkbox"]:checked::after {
            content: 'âœ“';
            color: white;
            position: absolute;
            top: -2px;
            left: 2px;
            font-size: 12px;
        }
        .checkbox-item label {
            font-size: 0.95rem;
            cursor: pointer;
            line-height: 1.4;
        }

        /* === PROGRESS BAR === */
        .progress-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .progress-bar {
            flex: 1;
            height: 8px;
            background-color: #f0f0f0;
            border: 1px solid #e0e0e0;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: #000000;
            transition: width 0.3s ease;
        }

        /* === STREAK TILES === */
        .streak-overview {
            margin-bottom: 3rem;
        }
        .streak-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2rem;
        }
        .streak-tile {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .streak-tile:hover {
            border-color: #000000;
        }
        
        /* Success Animation - Smooth and Unified */
        .streak-tile.success-animation {
            animation: smoothSuccess 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes smoothSuccess {
            0% {
                transform: scale(1);
                border-color: #e0e0e0;
                box-shadow: 0 0 0 rgba(5, 150, 105, 0);
                background: #ffffff;
            }
            30% {
                transform: scale(1.02);
                border-color: #059669;
                box-shadow: 0 0 15px rgba(5, 150, 105, 0.4);
                background: rgba(5, 150, 105, 0.05);
            }
            70% {
                transform: scale(1.01);
                border-color: #059669;
                box-shadow: 0 0 25px rgba(5, 150, 105, 0.6);
                background: rgba(5, 150, 105, 0.08);
            }
            100% {
                transform: scale(1);
                border-color: #059669;
                box-shadow: 0 0 15px rgba(5, 150, 105, 0.3);
                background: #ffffff;
            }
        }
        
        .streak-number {
            font-size: 3rem;
            font-weight: 300;
            color: #000000;
            margin-bottom: 0.5rem;
            line-height: 1;
            transition: all 0.3s ease;
        }
        
        .streak-tile.success-animation .streak-number {
            animation: smoothNumberGlow 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            color: #059669;
        }
        
        @keyframes smoothNumberGlow {
            0% { 
                transform: scale(1); 
                color: #000000;
                text-shadow: none;
            }
            40% { 
                transform: scale(1.08); 
                color: #059669;
                text-shadow: 0 0 10px rgba(5, 150, 105, 0.5);
            }
            100% { 
                transform: scale(1); 
                color: #059669;
                text-shadow: 0 0 5px rgba(5, 150, 105, 0.3);
            }
        }
        .streak-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }
        .streak-date {
            font-size: 0.8rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* === ROUTINE SPECIFIC === */
        .routine-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
            margin-bottom: 4rem;
            height: auto;
            min-height: 300px;
        }
        .routine-section {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            min-height: 250px;
        }
        .routine-section h2 {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .routine-section .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex: 1;
            margin-bottom: 1rem;
        }

        /* === TODO SPECIFIC === */
        .category-tabs {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 3rem;
        }
        .category-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .category-tab:hover { border-color: #000000; color: #000000; }
        .category-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        
        .badge {
            background: #dc2626;
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 4px;
            min-width: 16px;
            text-align: center;
        }
        .category-content { display: none; }
        .category-content.active { display: block; }
        
        /* === ZIELE SPECIFIC TABS === */
        .ziel-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .ziel-tab:hover { border-color: #000000; color: #000000; }
        .ziel-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .ziel-content { display: none; }
        
        /* === RESOURCE TABS === */
        .resource-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .resource-tab:hover { border-color: #000000; color: #000000; }
        .resource-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .resource-content { display: none; }
        .resource-content.active { display: block; }
        .ziel-content.active { display: block; }
        
        /* === JOURNAL SPECIFIC TABS === */
        .journal-tab {
            padding: 0.75rem 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            color: #666666;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .journal-tab:hover { border-color: #000000; color: #000000; }
        .journal-tab.active {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .journal-content { display: none; }
        .journal-content.active { display: block; }
        
        /* === TAG SELECTION === */
        .tag-option {
            padding: 0.5rem 1rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            color: #666666;
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .tag-option:hover { border-color: #000000; color: #000000; }
        .tag-option.selected {
            background: #000000;
            border-color: #000000;
            color: #ffffff;
        }
        .tag-option .remove-tag {
            cursor: pointer;
            font-size: 1rem;
            opacity: 0.8;
            display: none;
        }
        .tag-option.selected .remove-tag {
            display: inline;
        }
        .tag-option .remove-tag:hover {
            opacity: 1;
        }
        .todo-section {
            margin-bottom: 2rem;
        }
        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .section-header h3 {
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #444444;
        }
        .section-divider {
            flex: 1;
            height: 1px;
            background: #e0e0e0;
        }
        .section-count {
            font-size: 0.8rem;
            color: #666666;
            background: #f0f0f0;
            padding: 0.25rem 0.75rem;
            border: 1px solid #e0e0e0;
        }
        .todo-item {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: border-color 0.2s ease;
        }
        .todo-item:hover { border-color: #000000; }
        .todo-item.completed { opacity: 0.6; background: #fafafa; }
        .todo-item.completed .todo-title { text-decoration: line-through; }
        .todo-header {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }
        .todo-content { flex: 1; }
        .todo-title {
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }
        .todo-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .todo-deadline {
            font-size: 0.8rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .todo-deadline.today { color: #000000; font-weight: 500; }
        .todo-deadline.overdue { color: #cc0000; font-weight: 500; }
        .todo-deadline.soon { color: #ff6600; font-weight: 500; }
        
        /* Days until badge (similar to termine) */
        .days-until-badge {
            display: inline-block;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-left: 0.5rem;
        }
        .days-until-badge.heute {
            background: #000000;
            color: #ffffff;
        }
        .days-until-badge.morgen {
            background: #ff6600;
            color: #ffffff;
        }
        .days-until-badge.future {
            background: #3b82f6;
            color: #ffffff;
        }
        .days-until-badge.overdue {
            background: #cc0000;
            color: #ffffff;
        }
        
        .todo-tag {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.25rem 0.75rem;
            border: 1px solid;
            color: #ffffff;
            font-weight: 500;
        }
        .todo-tag.wichtig { background-color: #ff6600; border-color: #ff6600; }
        .todo-tag.dringend { background-color: #cc0000; border-color: #cc0000; }
        .todo-tag.normal { background-color: #666666; border-color: #666666; }

        /* === ZIELE SPECIFIC === */
        .ziel-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 200px;
        }
        .ziel-kategorie {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666666;
            border: 1px solid #e0e0e0;
            padding: 0.2rem 0.5rem;
            background: #fafafa;
            white-space: nowrap;
        }
        .ziel-header {
            margin-bottom: 1rem;
            margin-right: 6rem;
        }
        .ziel-name {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }
        .ziel-beschreibung {
            font-size: 0.9rem;
            color: #666666;
            line-height: 1.5;
            margin-bottom: 2rem;
        }
        .ziel-progress-section { margin-top: auto; }
        .ziel-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .ziel-progress-label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #444444;
        }
        .ziel-percentage {
            font-size: 1rem;
            font-weight: 500;
        }

        /* === JOURNAL SPECIFIC === */
        .quick-journal {
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            margin-bottom: 3rem;
        }
        .quick-journal h2 {
            font-size: 1rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .journal-form {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        .journal-input {
            flex: 1;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .journal-input:focus { outline: none; border-color: #000000; }
        .journal-entry {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 2rem;
            margin-bottom: 2rem;
        }
        .journal-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1.5rem;
            gap: 1rem;
        }
        .journal-date {
            font-size: 1rem;
            font-weight: 500;
            color: #000000;
        }
        .journal-kategorie {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666666;
            border: 1px solid #e0e0e0;
            padding: 0.4rem 1rem;
            background: #fafafa;
        }
        .journal-content {
            font-size: 0.95rem;
            line-height: 1.7;
            color: #333333;
        }

        /* === TERMINE SPECIFIC === */
        .termin-card {
            position: relative;
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 0;
            padding: 1.5rem;
            box-shadow: none;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .termin-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        }
        
        /* Base styling for days badges - dezent und rechteckig wie Kategorien */
        .termin-days-until, .ziel-days-until {
            position: absolute !important;
            top: 0.5rem !important;
            background: #fafafa !important;
            color: #666666 !important;
            padding: 0.2rem 0.5rem !important;
            border: 1px solid #e0e0e0 !important;
            font-size: 0.65rem !important;
            font-weight: 500 !important;
            text-transform: uppercase !important;
            letter-spacing: 0.1em !important;
            white-space: nowrap !important;
        }
        
        /* Termine: RechtsbÃ¼ndig */
        .termin-days-until {
            right: 0.5rem !important;
        }
        
        /* Ziele: Mittig */
        .ziel-days-until {
            left: 50% !important;
            transform: translateX(-50%) !important;
        }
        
        /* === RESSOURCEN GRID === */
        .resource-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 200px));
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: start;
        }
        
        .resource-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 0.75rem;
            position: relative;
            transition: all 0.2s ease;
            height: 50px;
            display: flex;
            align-items: center;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .resource-card:hover {
            border-color: #000000;
            background: #f8f8f8;
        }
        
        .resource-icon {
            margin-right: 0.5rem;
            flex-shrink: 0;
            display: flex;
            align-items: center;
        }
        
        .resource-title {
            font-size: 0.85rem;
            font-weight: 500;
            color: #000000;
            margin: 0;
            flex: 1;
            line-height: 1.2;
        }
        
        
        /* === EMOJI PALETTE === */
        .emoji-palette {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 0.25rem;
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            position: relative;
            z-index: 1;
        }
        
        .emoji-btn {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 0.25rem;
            cursor: pointer;
            font-size: 1rem;
            border-radius: 2px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 28px;
            width: 28px;
        }
        
        .emoji-btn:hover {
            background: #000000;
            border-color: #000000;
            transform: scale(1.1);
        }
        
        .btn-link {
            background: none;
            border: none;
            color: #666666;
            cursor: pointer;
            text-decoration: underline;
            font-family: inherit;
        }
        
        .btn-link:hover {
            color: #000000;
        }
        
        .resource-footer {
            margin-top: auto;
            padding-top: 1rem;
            border-top: 1px solid #f0f0f0;
        }
        
        .resource-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #000000;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            padding: 0.5rem 1rem;
            border: 1px solid #e0e0e0;
            transition: all 0.2s ease;
        }
        
        .resource-link:hover {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
        }
        
        .resource-actions {
            position: absolute;
            top: 0.4rem;
            right: 0.4rem;
            display: flex;
            gap: 0.2rem;
            opacity: 1;
            transition: opacity 0.2s ease;
            z-index: 10;
        }
        
        
        .resource-edit-btn,
        .resource-delete-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #333333;
            cursor: pointer;
            padding: 0.25rem;
            transition: all 0.2s ease;
            border-radius: 4px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        
        
        .resource-delete-btn:hover {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }
        
        .resource-edit-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.3);
            color: #3b82f6;
        }
        
        .resource-edit-btn:hover i,
        .resource-delete-btn:hover i {
            stroke: currentColor;
        }
        
        /* === RESOURCE CATEGORIES (bsp1.jpg style) === */
        .resource-category-section {
            margin-bottom: 3rem;
        }
        
        .resource-category-title {
            font-size: 1.8rem;
            font-weight: 300;
            color: #000000;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        .resource-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
        }
        
        .resource-button {
            background: #333333;
            border: 1px solid #555555;
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            text-decoration: none;
            min-width: 140px;
            justify-content: flex-start;
        }
        
        .resource-button:hover {
            background: #444444;
            border-color: #666666;
            transform: translateY(-1px);
        }
        
        .resource-icon {
            font-size: 1rem;
            margin-right: 0.25rem;
        }
        
        .resource-name {
            flex: 1;
            text-align: left;
        }
        
        .resource-button .resource-actions {
            position: absolute;
            top: -0.25rem;
            right: -0.25rem;
            display: flex;
            gap: 0.125rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        
        .resource-button .resource-edit-btn,
        .resource-button .resource-delete-btn {
            background: rgba(0, 0, 0, 0.8);
            border: none;
            color: #ffffff;
            padding: 0.25rem;
            font-size: 0.7rem;
            border-radius: 2px;
            cursor: pointer;
            opacity: 1;
        }
        
        .resource-button .resource-delete-btn:hover {
            background: #cc0000;
        }
        
        .resource-button .resource-edit-btn:hover {
            background: #007acc;
        }
        
        .termin-date {
            font-size: 0.8rem;
            color: #64748b;
            font-weight: 500;
            margin-bottom: 0.75rem;
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .termin-date::before {
            content: 'ðŸ“…';
            font-size: 0.9rem;
        }
        
        .termin-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #1e293b;
            line-height: 1.3;
        }
        
        .termin-description {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #64748b;
            margin-bottom: 1rem;
        }
        
        .termin-edit-icon, .termin-delete-icon {
            position: absolute !important;
            bottom: 1rem !important;
            width: 32px !important;
            height: 32px !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 0.85rem !important;
            transition: all 0.2s ease !important;
            cursor: pointer !important;
        }
        
        .termin-edit-icon {
            right: 3.5rem !important;
            background: rgba(59, 130, 246, 0.1) !important;
            color: #3b82f6 !important;
            top: auto !important;
        }
        
        .termin-edit-icon:hover {
            background: #3b82f6 !important;
            color: white !important;
            transform: scale(1.1) !important;
        }
        
        .termin-delete-icon {
            right: 1rem !important;
            background: rgba(239, 68, 68, 0.1) !important;
            color: #ef4444 !important;
            top: auto !important;
        }
        
        .termin-delete-icon:hover {
            background: #ef4444 !important;
            color: white !important;
            transform: scale(1.1) !important;
        }

        /* === ADD TODO MODAL === */
        .add-todo-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            padding: 1rem;
        }
        .add-todo-modal.hide { display: none; }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            padding: 1rem;
        }
        .modal.hide { display: none; }
        .modal-content {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 500px;
            position: relative;
            z-index: 4001;
        }
        .modal-content .close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            cursor: pointer;
            font-size: 1.5rem;
            color: #666;
        }
        .modal-content .close:hover {
            color: #000;
        }
        .add-todo-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 500px;
        }
        .add-todo-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .add-todo-header h2 {
            font-size: 1.5rem;
            font-weight: 500;
            color: #000000;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .form-row .form-group {
            flex: 1;
        }
        .form-group select {
            width: 100%;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .form-group select:focus { outline: none; border-color: #000000; }
        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        /* === AUTH SCREEN === */
        .auth-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 1rem;
        }
        .auth-screen.hide { display: none; }
        .auth-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 3rem;
            width: 100%;
            max-width: 400px;
        }
        .auth-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .auth-header h2 {
            font-size: 1.5rem;
            font-weight: 500;
            color: #000000;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-group {
            margin-bottom: 1.5rem;
        }
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #000000;
            font-weight: 500;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .form-group input {
            width: 100%;
            padding: 1rem;
            border: 1px solid #d0d0d0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.95rem;
        }
        .form-group input:focus { outline: none; border-color: #000000; }
        .auth-btn {
            width: 100%;
            padding: 1rem;
            border: 1px solid #000000;
            background: #ffffff;
            color: #000000;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .auth-btn:hover {
            background: #000000;
            color: #ffffff;
        }
        .auth-error {
            color: #cc0000;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            display: none;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .auth-error.show { display: block; }

        /* === RESPONSIVE === */
        /* === CRYPTO WIKI STYLES === */
        .wiki-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .search-container {
            display: flex;
            flex: 1;
            min-width: 300px;
        }
        
        .search-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-right: none;
            border-radius: 0;
            font-size: 0.95rem;
        }
        
        .search-btn {
            padding: 0.75rem 1rem;
            border: 1px solid #d1d5db;
            border-left: none;
            border-radius: 0;
            background: #f8f9fa;
            cursor: pointer;
        }
        
        .filter-container {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex: 1;
            min-width: 250px;
        }
        
        .filter-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.95rem;
            background: #ffffff;
        }
        
        .filter-input:focus {
            outline: none;
            border-color: #000000;
            box-shadow: 0 0 0 1px #000000;
        }
        
        .filter-container select {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0;
            font-size: 0.95rem;
            background: #ffffff;
        }
        
        .wiki-content {
            display: grid;
            gap: 1.5rem;
        }
        
        .wiki-entry {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 1.5rem;
        }
        
        .wiki-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }
        
        .wiki-entry-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #000000;
            margin: 0;
        }
        
        .wiki-entry-content {
            color: #333333;
            line-height: 1.6;
            margin-bottom: 1rem;
            white-space: pre-wrap;
        }
        
        .wiki-entry-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 1rem;
            border-top: 1px solid #e0e0e0;
            font-size: 0.85rem;
            color: #666666;
        }
        
        .wiki-entry-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .wiki-tag {
            background: #e5e7eb;
            color: #374151;
            padding: 0.25rem 0.5rem;
            border-radius: 0;
            font-size: 0.75rem;
        }
        
        .wiki-entry-source {
            font-style: italic;
        }
        
        .wiki-entry-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .wiki-entry-actions button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
        }
        
        .empty-wiki {
            text-align: center;
            color: #666666;
            padding: 3rem;
        }

        /* === QUICK NOTES STYLES === */
        .quicknotes-section {
            margin-top: 2rem;
            background: #ffffff;
            border: 1px solid #e0e0e0;
        }

        .quicknotes-header {
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            padding: 1rem 1.5rem;
        }

        .quicknotes-header h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .quicknotes-content {
            padding: 1.5rem;
        }

        #quicknotes-textarea {
            width: 100%;
            min-height: 200px;
            padding: 1rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            font-family: inherit;
            font-size: 0.9rem;
            line-height: 1.6;
            resize: none;
            box-sizing: border-box;
            overflow: hidden;
        }

        #quicknotes-textarea:focus {
            outline: none;
            border-color: #000000;
        }

        #quicknotes-textarea::placeholder {
            color: #999999;
        }

        /* === TRADING TAB STYLES === */
        .add-trade-section {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .add-trade-section h3 {
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .trade-form .form-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .trade-form .form-group {
            display: flex;
            flex-direction: column;
        }

        .trade-form .form-group label {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #333333;
        }

        .trade-form .form-group input {
            padding: 0.75rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            font-size: 0.9rem;
            width: 100%;
            box-sizing: border-box;
        }

        .trade-form .form-group input:focus {
            outline: none;
            border-color: #000000;
        }

        .trade-form .form-actions {
            display: flex;
            gap: 0.5rem;
        }

        .sol-input-group, .mcap-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .sol-input-group input, .mcap-input-group input {
            width: 100%;
        }

        .mcap-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .mcap-container input {
            flex: 1;
        }

        .mcap-select {
            min-width: 60px;
            padding: 0.75rem 0.5rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            font-size: 0.9rem;
            border-radius: 6px;
        }

        .mcap-select:focus {
            outline: none;
            border-color: #000000;
        }

        .sol-buttons, .mcap-buttons, .sol-sell-buttons {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
        }

        .sol-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.25rem;
        }

        .sol-btn, .mcap-btn, .sol-percent-btn {
            padding: 0.4rem 0.6rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 35px;
            text-align: center;
        }

        .sol-btn:hover, .mcap-btn:hover, .sol-percent-btn:hover {
            border-color: #000000;
            background: #f5f5f5;
        }

        .mcap-btn.active {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
        }

        /* === CLOSE TRADE MODAL === */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #ffffff;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.2rem;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: #000000;
        }

        .modal-body {
            padding: 1.5rem;
        }

        .trade-info {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .info-row:last-child {
            margin-bottom: 0;
        }

        .info-label {
            font-weight: 500;
            color: #666666;
        }

        .info-value {
            font-weight: 600;
            color: #000000;
        }

        /* === TRADE DETAILS MODAL === */
        .trade-details-info {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .details-section {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 1rem;
        }

        .details-section h4 {
            margin: 0 0 1rem 0;
            font-size: 0.9rem;
            font-weight: 600;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 0.5rem;
        }

        .info-grid {
            display: grid;
            gap: 0.75rem;
        }

        .notes-content, .learnings-content {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 1rem;
            min-height: 80px;
            white-space: pre-wrap;
            font-family: inherit;
            line-height: 1.5;
            color: #000000;
        }

        .learnings-content {
            border-left: 4px solid #059669;
        }

        .notes-content:empty::before {
            content: 'Keine Entry Notes verfÃ¼gbar';
            color: #999999;
            font-style: italic;
        }

        .learnings-content:empty::before {
            content: 'Keine Learnings verfÃ¼gbar';
            color: #999999;
            font-style: italic;
        }

        /* === MOTIVATIONAL QUOTE WIDGET === */
        .quote-widget {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 0;
            margin-bottom: 4rem;
            transition: all 0.2s ease;
        }

        .quote-widget:hover {
            border-color: #000000;
        }

        .quote-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            padding: 1.5rem;
            color: #000000;
        }

        .quote-icon {
            font-size: 1.5rem;
            color: #666666;
            min-width: 24px;
        }

        .quote-content {
            flex: 1;
        }

        .quote-text {
            font-size: 1rem;
            font-weight: 500;
            line-height: 1.6;
            margin-bottom: 0.5rem;
            color: #000000;
        }

        .quote-author {
            font-size: 0.8rem;
            color: #666666;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .quote-refresh-btn {
            background: none;
            border: 1px solid #e0e0e0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666666;
        }

        .quote-refresh-btn:hover {
            border-color: #000000;
            color: #000000;
        }

        @media (max-width: 768px) {
            .quote-container {
                flex-direction: column;
                text-align: center;
                gap: 1rem;
                padding: 1.25rem;
            }
            
            .quote-text {
                font-size: 0.9rem;
            }
        }

        /* === RESOURCES BLOCKS DESIGN === */
        .resources-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .resources-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2rem;
        }

        .resource-block {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 0;
            transition: all 0.2s ease;
            min-height: 300px;
        }

        .resource-block:hover {
            border-color: #000000;
        }

        .resource-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.25rem;
            border-bottom: 1px solid #e0e0e0;
            background: #fafafa;
        }

        .resource-block-header h3 {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin: 0;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #000000;
        }

        .resource-block-header i {
            color: #666666;
        }

        .add-to-category-btn {
            background: none;
            border: 1px solid #e0e0e0;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666666;
        }

        .add-to-category-btn:hover {
            border-color: #000000;
            color: #000000;
        }

        .resource-links {
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-height: 200px;
        }

        .resource-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border: 1px solid #f0f0f0;
            transition: all 0.2s ease;
            text-decoration: none;
            color: inherit;
            position: relative;
        }

        .resource-item:hover {
            border-color: #e0e0e0;
            background: #fafafa;
        }

        .delete-overlay {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            animation: fadeIn 0.2s ease;
            z-index: 10;
        }

        .delete-icon {
            background: #dc2626;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 4px rgba(220, 38, 38, 0.3);
        }

        .delete-icon:hover {
            background: #b91c1c;
            transform: scale(1.05);
            box-shadow: 0 2px 6px rgba(220, 38, 38, 0.4);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .resource-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
        }

        .resource-icon {
            color: #666666;
            min-width: 16px;
        }

        .resource-details {
            flex: 1;
        }

        .resource-title {
            font-weight: 500;
            font-size: 0.9rem;
            color: #000000;
            margin-bottom: 0.25rem;
        }

        .resource-description {
            font-size: 0.8rem;
            color: #666666;
            line-height: 1.4;
        }

        .resource-actions {
            display: flex;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .resource-action-btn {
            background: none;
            border: none;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #666666;
            transition: all 0.2s ease;
        }

        .resource-action-btn:hover {
            color: #dc2626;
        }

        .empty-resources {
            text-align: center;
            padding: 2rem 1rem;
            color: #999999;
            font-style: italic;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .resources-grid {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
            
            .resources-header {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
                text-align: center;
            }
        }

        .close-trade-form .form-group {
            margin-bottom: 1.5rem;
        }

        .close-trade-form .form-group:last-child {
            margin-bottom: 0;
        }

        .close-trade-form label {
            display: block;
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #333333;
        }

        .modal-footer {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            padding: 1.5rem;
            border-top: 1px solid #e0e0e0;
        }

        .portfolio-overview {
            margin-bottom: 2rem;
        }

        .portfolio-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
        }

        .portfolio-stat {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            text-align: center;
        }

        .stat-number {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .stat-number.positive { color: #059669; }
        .stat-number.negative { color: #dc2626; }

        .stat-label {
            font-size: 0.9rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }


        .trading-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .trades-view {
            /* Ensure only one view is visible at a time */
            width: 100%;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .section-header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .section-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .section-actions .btn {
            padding: 0.25rem 0.75rem;
            font-size: 0.85rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        /* === ANALYTICS STYLES === */
        .analytics-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .analytics-card {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
        }

        .analytics-card h3 {
            margin: 0 0 0.5rem 0;
            font-size: 0.9rem;
            font-weight: 500;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #000000;
            margin: 0.5rem 0;
        }

        .metric-value.positive { color: #22c55e; }
        .metric-value.negative { color: #ef4444; }

        .metric-subtitle {
            font-size: 0.8rem;
            color: #888888;
        }

        .charts-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .chart-container {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1.5rem;
        }

        .chart-container h3 {
            margin: 0 0 1rem 0;
            font-size: 1rem;
            font-weight: 600;
        }

        .chart-placeholder {
            height: 200px;
            background: #f8f9fa;
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666666;
            font-size: 1rem;
        }

        .analytics-charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-bottom: 1rem;
        }

        .chart-section {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1.5rem;
            height: 400px;
            max-height: 400px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chart-container {
            height: 280px;
            position: relative;
            flex: none;
        }

        .chart-container canvas {
            max-height: 100%;
            width: 100% !important;
            height: 100% !important;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin: 0 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #f0f0f0;
        }

        .chart-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-end;
        }

        .time-period-buttons {
            display: flex;
            gap: 0.25rem;
        }

        .period-btn {
            padding: 0.4rem 0.8rem;
            border: 1px solid #e0e0e0;
            background: #ffffff;
            color: #666666;
            font-size: 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .period-btn:hover {
            background: #f5f5f5;
        }

        .period-btn.active {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
        }

        .chart-header h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            color: #000000;
        }

        .chart-info {
            font-size: 0.9rem;
            color: #666666;
            font-weight: 500;
        }

        /* Heatmap Styles */
        .heatmap-container {
            padding: 1rem 0;
            height: 280px;
            display: flex;
            flex-direction: column;
            flex: none;
        }

        .heatmap-months {
            display: flex;
            margin-bottom: 0.5rem;
            padding-left: 15px;
            font-size: 0.7rem;
            color: #666666;
            flex-shrink: 0;
        }

        .heatmap-month {
            flex: 1;
            text-align: left;
            min-width: 0;
        }

        .heatmap-grid {
            display: grid;
            grid-template-columns: repeat(53, 1fr);
            grid-template-rows: repeat(7, 1fr);
            gap: 1px;
            padding: 0;
            margin: 0;
            flex: 1;
            max-width: 100%;
            overflow: hidden;
        }

        .heatmap-square {
            width: 100%;
            height: 100%;
            min-width: 8px;
            min-height: 8px;
            border-radius: 1px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        @media (max-width: 768px) {
            .analytics-charts-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-container {
                height: 230px;
            }
            
            .heatmap-container {
                height: 230px;
            }
        }

        .heatmap-square:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .heatmap-square.level-0 {
            background-color: #ebedf0;
        }

        .heatmap-square.level-1 {
            background-color: #9be9a8;
        }

        .heatmap-square.level-2 {
            background-color: #40c463;
        }

        .heatmap-square.level-3 {
            background-color: #30a14e;
        }

        .heatmap-square.level-4 {
            background-color: #216e39;
        }

        .heatmap-legend {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-top: 1rem;
            font-size: 0.75rem;
            color: #666666;
            gap: 0.5rem;
        }

        .legend-colors {
            display: flex;
            gap: 2px;
        }

        .legend-square {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .legend-square.level-0 {
            background-color: #ebedf0;
        }

        /* === TRADING STICKY NOTE === */
        .trading-rules-sticky {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .trading-rules-sticky:hover {
            border-color: #000000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .trading-rules-sticky::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, #000000, transparent);
            animation: slideRule 4s ease-in-out infinite;
        }
        
        @keyframes slideRule {
            0%, 100% { left: -100%; opacity: 0; }
            50% { left: 100%; opacity: 1; }
        }
        
        .sticky-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid #f0f0f0;
            background: #fafafa;
        }
        
        .sticky-title {
            font-weight: 500;
            font-size: 0.9rem;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .sticky-minimize {
            background: none;
            border: none;
            font-size: 1rem;
            font-weight: 300;
            color: #666666;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            transition: all 0.3s ease;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .sticky-minimize:hover {
            color: #000000;
            transform: rotate(180deg) scale(1.1);
        }
        
        .sticky-content {
            padding: 1.5rem;
        }
        
        .rules-list {
            list-style: none;
            margin: 0;
            padding: 0;
            display: grid;
            gap: 1rem;
        }
        
        .rules-list li {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #000000;
            padding: 0.75rem;
            border: 1px solid transparent;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .rules-list li:hover {
            border-color: #e0e0e0;
            background: #fafafa;
            transform: translateX(2px);
        }
        
        .rules-list li::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #000000;
            transform: scaleY(0);
            transition: transform 0.2s ease;
            transform-origin: bottom;
        }
        
        .rules-list li:hover::before {
            transform: scaleY(1);
        }
        
        .rules-list strong {
            color: #000000;
            font-weight: 500;
        }
        
        .trading-rules-sticky.minimized .sticky-content {
            display: none;
        }
        
        .trading-rules-sticky.minimized .sticky-minimize {
            /* Remove rotation since we now change the text content */
        }
        
        .trading-rules-sticky.minimized .sticky-header {
            border-bottom: none;
        }
        
        @media (max-width: 768px) {
            .rules-list {
                gap: 0.75rem;
            }
            
            .rules-list li {
                font-size: 0.85rem;
                padding: 0.6rem;
                gap: 0.75rem;
            }
            
            .sticky-content {
                padding: 1rem;
            }
            
            .sticky-header {
                padding: 1rem 1.25rem;
            }
        }

        .legend-square.level-1 {
            background-color: #9be9a8;
        }

        .legend-square.level-2 {
            background-color: #40c463;
        }

        .legend-square.level-3 {
            background-color: #30a14e;
        }

        .legend-square.level-4 {
            background-color: #216e39;
        }

        .heatmap-info {
            font-size: 0.9rem;
            color: #666666;
            font-weight: 500;
        }

        .performers-section {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1.5rem;
        }

        .performers-section h3 {
            margin: 0 0 1rem 0;
            font-size: 1rem;
            font-weight: 600;
        }

        .performer-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .performer-item:last-child {
            border-bottom: none;
        }

        .token-name {
            font-weight: 500;
        }

        .token-pnl.positive { color: #22c55e; }
        .token-pnl.negative { color: #ef4444; }

        @media (max-width: 768px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
            
            .analytics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* === ENHANCED TRADE FORM STYLES === */
        .form-section {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #f0f0f0;
        }

        .form-section-title {
            margin: 0 0 1rem 0;
            font-size: 0.9rem;
            font-weight: 600;
            color: #444444;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .form-group textarea {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.9rem;
            resize: vertical;
            min-height: 80px;
        }

        .form-group textarea:focus {
            outline: none;
            border-color: #000000;
        }

        .form-group textarea::placeholder {
            color: #999999;
            font-style: italic;
        }

        .stoploss-btn.active {
            background: #fecaca !important;
            color: #dc2626 !important;
            border-color: #dc2626 !important;
        }

        .takeprofit-btn.active {
            background: #bbf7d0 !important;
            color: #059669 !important;
            border-color: #059669 !important;
        }

        /* === TRADE ACTION BUTTONS === */
        .trade-action-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            color: #666666;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .trade-action-btn:hover {
            background: transparent;
            color: #16a34a;
        }

        .trade-action-btn:hover i {
            stroke: #16a34a;
        }

        /* === TRADE BADGE ICONS === */
        .trade-badge-icon {
            width: 16px;
            height: 16px;
            margin-left: 0.5rem;
            vertical-align: middle;
        }

        .initials-icon {
            stroke: #16a34a;
            stroke-width: 2;
        }

        .free-ride-icon {
            stroke: #2563eb;
            stroke-width: 2;
        }

        .trades-table {
            overflow-x: auto;
        }

        .trade-row {
            display: grid;
            grid-template-columns: 1fr 0.8fr 1fr 1fr 0.8fr 1fr 0.8fr auto;
            gap: 0.5rem;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f0f0f0;
            align-items: center;
        }

        #open-trades-view .trade-row {
            grid-template-columns: 1fr 0.8fr 1fr 1fr 0.8fr 0.8fr 0.8fr 1fr auto;
        }

        .trade-row:last-child {
            border-bottom: none;
        }

        .trade-header {
            display: grid;
            grid-template-columns: 1fr 0.8fr 1fr 1fr 0.8fr 1fr 0.8fr auto;
            gap: 0.5rem;
            padding: 0.5rem 0;
            border-bottom: 2px solid #e0e0e0;
            font-weight: 600;
            font-size: 0.85rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        #open-trades-view .trade-header {
            grid-template-columns: 1fr 0.8fr 1fr 1fr 0.8fr 0.8fr 0.8fr 1fr auto;
        }

        .trade-token {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .trade-amount {
            font-size: 0.9rem;
        }

        .trade-risk {
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .trade-notes {
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .trade-entry-price {
            font-size: 0.9rem;
            color: #666666;
        }

        .trade-current-price {
            font-size: 0.9rem;
        }

        .trade-pnl {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .trade-pnl.positive { color: #059669; }
        .trade-pnl.negative { color: #dc2626; }

        .trade-actions {
            display: flex;
            gap: 0.5rem;
        }

        .trade-actions button {
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
        }

        .empty-trades {
            text-align: center;
            color: #666666;
            padding: 2rem;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .trade-form .form-row {
                grid-template-columns: 1fr;
            }
            
            .portfolio-stats {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .trade-row, .trade-header {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }

            .trade-row > div::before {
                content: attr(data-label) ": ";
                font-weight: 600;
                display: inline-block;
                width: 80px;
            }
        }

        /* === LUCIDE ICON STYLES === */
        .icon-palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .icon-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            background: #ffffff;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .icon-btn:hover {
            background: #f3f4f6;
            border-color: #000000;
        }
        
        .icon-btn:active {
            background: #e5e7eb;
        }

        @media (max-width: 768px) {
            .grid-2, .grid-3, .routine-grid, .streak-grid { grid-template-columns: 1fr; gap: 2rem; }
            .routine-grid { height: auto; }
            .routine-section { height: auto; min-height: 350px; }
            .main-content { padding: 0 15px 40px 15px; }
            .nav-container { flex-wrap: wrap; gap: 1rem; }
            .nav-tab { font-size: 0.8rem; padding: 0.4rem 0.8rem; }
            .ziel-kategorie { position: static; align-self: flex-start; margin-bottom: 1rem; }
            .ziel-header { margin-right: 0; }
            .journal-form { flex-direction: column; align-items: stretch; }
            .journal-entry-header { flex-direction: column; align-items: flex-start; }
            
            /* Resource mobile optimization */
            .resource-grid { 
                grid-template-columns: repeat(auto-fill, minmax(170px, 170px)); 
                gap: 0.4rem;
            }
            .resource-card { 
                height: 46px;
                padding: 0.6rem;
            }
            .resource-title { 
                font-size: 0.8rem; 
            }
            .resource-icon {
                font-size: 0.95rem;
                margin-right: 0.4rem;
            }
            .emoji-palette { 
                grid-template-columns: repeat(8, 1fr); 
                gap: 0.2rem;
                padding: 0.3rem;
            }
            .emoji-btn {
                min-height: 24px;
                width: 24px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <!-- === ADD TODO MODAL === -->
    <div id="add-todo-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Todo hinzufÃ¼gen</h2>
            </div>
            
            <form id="add-todo-form" autocomplete="off">
                <div class="form-group">
                    <label for="todo-title">Aufgabe</label>
                    <input type="text" id="todo-title" name="todo-title" placeholder="Was mÃ¶chtest du erledigen?" required autocomplete="off">
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="todo-category">Kategorie</label>
                        <select id="todo-category" name="todo-category" required autocomplete="off">
                            <option value="">Kategorie wÃ¤hlen</option>
                            <option value="privat">Privat</option>
                            <option value="uni">Uni</option>
                            <option value="arbeit">Arbeit</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="todo-priority">PrioritÃ¤t</label>
                        <select id="todo-priority" name="todo-priority" required autocomplete="off">
                            <option value="mittel" selected>Normal</option>
                            <option value="wichtig">Wichtig</option>
                            <option value="dringend">Dringend</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="todo-deadline">Deadline</label>
                        <input type="date" id="todo-deadline" name="todo-deadline" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="todo-time">Uhrzeit</label>
                        <input type="time" id="todo-time" name="todo-time" value="21:00" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-todo-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Todo erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD GOAL MODAL === -->
    <div id="add-goal-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Ziel hinzufÃ¼gen</h2>
            </div>
            
            <form id="add-goal-form" autocomplete="off">
                <div class="form-group">
                    <label for="goal-name">Ziel-Name</label>
                    <input type="text" id="goal-name" name="goal-name" placeholder="Was mÃ¶chtest du erreichen?" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="goal-description">Beschreibung</label>
                    <textarea id="goal-description" placeholder="Detaillierte Beschreibung des Ziels..." rows="3" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-category">Kategorie</label>
                        <input type="text" id="goal-category" placeholder="z.B. Fitness, Karriere, Finanzen..." required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-timeframe">Zeitrahmen</label>
                        <select id="goal-timeframe" required autocomplete="off">
                            <option value="monat">Monat</option>
                            <option value="quartal">Quartal</option>
                            <option value="jahr">Jahr</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-deadline">Deadline</label>
                        <input type="date" id="goal-deadline" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-unit">Einheit</label>
                        <input type="text" id="goal-unit" placeholder="z.B. kg, â‚¬, BÃ¼cher, Stunden..." autocomplete="off">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="goal-start-value">Startwert</label>
                        <input type="number" id="goal-start-value" placeholder="z.B. 80" step="0.01" autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="goal-target-value">Zielwert</label>
                        <input type="number" id="goal-target-value" placeholder="z.B. 70" step="0.01" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-goal-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Ziel erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD JOURNAL MODAL === -->
    <div id="add-journal-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Journal Eintrag hinzufÃ¼gen</h2>
            </div>
            
            <form id="add-journal-form" autocomplete="off">
                <div class="form-group">
                    <label for="journal-title">Titel</label>
                    <input type="text" id="journal-title" placeholder="Titel fÃ¼r den Eintrag..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="journal-content">Inhalt</label>
                    <textarea id="journal-content" placeholder="Was beschÃ¤ftigt dich heute...?" rows="6" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="journal-tags">Tags (mehrere mÃ¶glich)</label>
                        <div id="journal-tag-options" style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                            <button type="button" class="tag-option" data-tag="allgemein">
                                Allgemein
                                <span class="remove-tag">Ã—</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="fitness">
                                Fitness
                                <span class="remove-tag">Ã—</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="uni">
                                Uni
                                <span class="remove-tag">Ã—</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="crypto">
                                Crypto
                                <span class="remove-tag">Ã—</span>
                            </button>
                            <button type="button" class="tag-option" data-tag="lesen">
                                Lesen
                                <span class="remove-tag">Ã—</span>
                            </button>
                        </div>
                        <input type="hidden" id="journal-category" required>
                    </div>
                    <div class="form-group">
                        <label for="journal-date">Datum</label>
                        <input type="date" id="journal-date" required autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-journal-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Journal erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === ADD TERMIN MODAL === -->
    <div id="add-termin-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2>Termin hinzufÃ¼gen</h2>
            </div>
            
            <form id="add-termin-form" autocomplete="off">
                <div class="form-group">
                    <label for="termin-title">Titel</label>
                    <input type="text" id="termin-title" placeholder="z.B. Zahnarzt Termin..." required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="termin-description">Beschreibung</label>
                    <textarea id="termin-description" placeholder="Weitere Details zum Termin..." rows="3" required autocomplete="off" style="width: 100%; padding: 1rem; border: 1px solid #d0d0d0; font-family: inherit; font-size: 0.95rem; resize: vertical;"></textarea>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="termin-date">Datum</label>
                        <input type="date" id="termin-date" required autocomplete="off">
                    </div>
                    <div class="form-group">
                        <label for="termin-time">Uhrzeit (optional)</label>
                        <input type="time" id="termin-time" autocomplete="off">
                    </div>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-termin-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Termin erstellen</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === EDIT GOAL VALUE MODAL === -->
    <div id="edit-goal-value-modal" class="add-todo-modal hide">
        <div class="add-todo-container">
            <div class="add-todo-header">
                <h2 id="edit-goal-modal-title">Fortschritt aktualisieren</h2>
            </div>
            
            <div id="edit-goal-current-status" style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; font-size: 0.9rem; color: #666;">
                <!-- Current goal status will be inserted here -->
            </div>
            
            <form id="edit-goal-value-form" autocomplete="off">
                <div class="form-group">
                    <label for="new-goal-value">Neuer aktueller Wert</label>
                    <input type="number" id="new-goal-value" name="new-goal-value" step="0.01" required autocomplete="off" style="font-size: 1.1rem; padding: 0.75rem;">
                </div>
                
                <div class="form-actions">
                    <button type="button" id="cancel-edit-goal-value-btn" class="btn secondary">Abbrechen</button>
                    <button type="submit" class="btn">Wert aktualisieren</button>
                </div>
            </form>
        </div>
    </div>

    <!-- === AUTH SCREEN === -->
    <div id="auth-screen" class="auth-screen hide">
        <div class="auth-container">
            <div class="auth-header">
                <h2>DASHBOARD</h2>
            </div>
            
            <div class="form-group">
                <label for="login-email">Email</label>
                <input type="email" id="login-email" name="email" placeholder="your@email.com" required autocomplete="email">
            </div>
            <div class="form-group">
                <label for="login-password">Password</label>
                <input type="password" id="login-password" name="password" placeholder="Your password" required autocomplete="current-password">
            </div>
            <button id="login-btn" class="auth-btn">Login</button>
            <div id="login-error" class="auth-error"></div>
        </div>
    </div>

    <!-- === STICKY NAVIGATION === -->
    <nav class="sticky-nav">
        <div class="nav-container">
            <button class="nav-tab active" data-tab="tab-home">Home</button>
            <button class="nav-tab" data-tab="tab-todos">ToDos</button>
            <button class="nav-tab" data-tab="tab-ziele">Ziele</button>
            <button class="nav-tab" data-tab="tab-journal">Journal</button>
            <button class="nav-tab" data-tab="tab-trading">Trading</button>
            <button class="nav-tab" data-tab="tab-analytics">Analytics</button>
            <button class="nav-tab" data-tab="tab-ressourcen">Ressourcen</button>
            <button class="nav-tab" data-tab="tab-wiki">Wiki</button>
            <button class="nav-tab" data-tab="tab-settings" style="display: none;">Settings</button>
            <div class="nav-actions">
                <button id="quick-add-btn" class="nav-tab quick-add-btn" title="Quick Add Todo">
                    <i data-lucide="plus" style="width: 18px; height: 18px;"></i>
                </button>
                <button id="timer-btn" class="nav-tab timer-btn" title="Pomodoro Timer (25 min) | Right-click to reset">
                    <i data-lucide="timer" style="width: 18px; height: 18px;"></i>
                </button>
                <button id="settings-btn" class="nav-tab settings-btn">
                    <i data-lucide="settings" style="width: 18px; height: 18px;"></i>
                </button>
                <button id="logout-btn" class="nav-tab logout-btn" style="display:flex;align-items:center;justify-content:center;">
                    <i data-lucide="log-out" style="width: 18px; height: 18px;"></i>
                </button>
            </div>
        </div>
    </nav>

    <div class="main-content">
        <!-- === HOME TAB === -->
        <section id="tab-home" class="tab-section active">
            <!-- Streak Kacheln -->
            <section class="streak-overview" style="margin-bottom: 4rem;">
                <div class="streak-grid">
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Morgenroutine</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Abendroutine</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0</div>
                        <div class="streak-label">Todos Erledigt</div>
                    </div>
                    <div class="streak-tile">
                        <div class="streak-number">0.00</div>
                        <div class="streak-label">SOL Balance</div>
                        <div class="streak-date">Live</div>
                    </div>
                </div>
            </section>

            <!-- Routinen Section -->
            <div class="routine-grid" style="margin-bottom: 4rem;">
                <div id="morning-routine" class="routine-section">
                    <h2>Morgenroutine</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="wasser-kreatin">
                            <label for="wasser-kreatin">Wasser und Kreatin</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="bbue-sport">
                            <label for="bbue-sport">BBÃœ und Sport</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="tag-planen">
                            <label for="tag-planen">Tag planen</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="todos-checken">
                            <label for="todos-checken">Todos checken</label>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <div id="evening-routine" class="routine-section">
                    <h2>Abendroutine</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="journal-reflexion">
                            <label for="journal-reflexion">Tag reflektieren per Journal</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="lesen-lessons">
                            <label for="lesen-lessons">Lesen und Lessons nachhalten</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="trades-evaluieren">
                            <label for="trades-evaluieren">Trades evaluieren und Lessons nachhalten</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="naechsten-tag-planen">
                            <label for="naechsten-tag-planen">NÃ¤chsten Tag planen</label>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Heutige Aufgaben -->
            <section class="card" style="margin-bottom: 4rem;">
                <h2 style="font-size: 1.2rem; font-weight: 500; margin-bottom: 1.5rem; text-transform: uppercase; letter-spacing: 0.1em;">Heutige Aufgaben</h2>
                <div class="checkbox-group" id="home-todos">
                    <!-- Todos will be loaded from database -->
                </div>
            </section>

            <!-- Anstehende Termine -->
            <section style="margin-bottom: 4rem;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 2rem; margin-bottom: 1.5rem;">
                    <h2 style="font-size: 1.2rem; font-weight: 500; text-transform: uppercase; letter-spacing: 0.1em; margin: 0;">Anstehende Termine</h2>
                    <button id="add-termin-btn" class="btn" style="font-size: 0.7rem; padding: 0.5rem 1rem;">Add New</button>
                </div>
                <div class="grid-3" id="termine-container">
                    <!-- Termine will be loaded from TerminManager -->
                </div>
            </section>

            <!-- Motivational Quote Widget -->
            <section class="quote-widget">
                <div class="quote-container">
                    <div class="quote-icon">
                        <i data-lucide="quote" style="width: 20px; height: 20px;"></i>
                    </div>
                    <div class="quote-content">
                        <div class="quote-text" id="daily-quote">
                            "The way to get started is to quit talking and begin doing."
                        </div>
                        <div class="quote-author" id="quote-author">Walt Disney</div>
                    </div>
                    <button class="quote-refresh-btn" id="refresh-quote-btn" title="New Quote">
                        <i data-lucide="refresh-cw" style="width: 14px; height: 14px;"></i>
                    </button>
                </div>
            </section>
        </section>

        <!-- === TODOS TAB === -->
        <section id="tab-todos" class="tab-section">
            
            <div class="category-tabs">
                <button class="category-tab active" data-category="alle">Alle <span id="overdue-count" class="badge" style="display: none;"></span></button>
                <button class="category-tab" data-category="heute">Heute</button>
                <button class="category-tab" data-category="privat">Privat</button>
                <button class="category-tab" data-category="uni">Uni</button>
                <button class="category-tab" data-category="arbeit">Arbeit</button>
                <button class="category-tab" data-category="archiv">Archiv</button>
                <button id="add-todo-btn" class="btn" style="margin-left: 2rem;">+ Add Todo</button>
                <button id="clear-archive-btn" class="btn secondary" style="margin-left: 1rem; display: none;">ðŸ—‘ï¸ Archiv leeren</button>
            </div>

            <!-- HEUTE KATEGORIE -->
            <div class="category-content" id="heute">
                <!-- Todos for today and overdue will be loaded from database -->
            </div>

            <!-- PRIVAT KATEGORIE -->
            <div class="category-content" id="privat">
                <!-- Private todos will be loaded from database -->
            </div>

            <!-- UNI KATEGORIE -->
            <div class="category-content" id="uni">
                <!-- Uni todos will be loaded from database -->
            </div>

            <!-- ARBEIT KATEGORIE -->
            <div class="category-content" id="arbeit">
                <!-- Work todos will be loaded from database -->
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="category-content active" id="alle">
                <!-- All todos will be loaded from database -->
            </div>

            <!-- ARCHIV KATEGORIE -->
            <div class="category-content" id="archiv">
                <!-- Completed/archived todos will be loaded from database -->
            </div>
        </section>

        <!-- === ZIELE TAB === -->
        <section id="tab-ziele" class="tab-section">
            
            <div class="category-tabs">
                <button class="ziel-tab active" data-ziel-category="alle">Alle</button>
                <button class="ziel-tab" data-ziel-category="monat">Monat</button>
                <button class="ziel-tab" data-ziel-category="quartal">Quartal</button>
                <button class="ziel-tab" data-ziel-category="jahr">Jahr</button>
                <button class="ziel-tab" data-ziel-category="archiv">Archiv</button>
                <button id="add-goal-btn" class="btn" style="margin-left: 2rem;">+ Add Goal</button>
                <button id="clear-goal-archive-btn" class="btn secondary" style="margin-left: 1rem; display: none;">ðŸ—‘ï¸ Archiv leeren</button>
            </div>

            <!-- MONAT KATEGORIE -->
            <div class="ziel-content" id="ziel-monat">
                <!-- Monatsziele will be loaded from database -->
            </div>

            <!-- QUARTAL KATEGORIE -->
            <div class="ziel-content" id="ziel-quartal">
                <!-- Quartalsziele will be loaded from database -->
            </div>

            <!-- JAHR KATEGORIE -->
            <div class="ziel-content" id="ziel-jahr">
                <!-- Jahresziele will be loaded from database -->
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="ziel-content active" id="ziel-alle">
                <!-- All ziele will be loaded from database -->
            </div>

            <!-- ARCHIV KATEGORIE -->
            <div class="ziel-content" id="ziel-archiv">
                <!-- Completed/archived ziele will be loaded from database -->
            </div>

        </section>

        <!-- === JOURNAL TAB === -->
        <section id="tab-journal" class="tab-section">
            
            <div class="category-tabs">
                <button class="journal-tab active" data-journal-category="alle">Alle</button>
                <button class="journal-tab" data-journal-category="allgemein">Allgemein</button>
                <button class="journal-tab" data-journal-category="fitness">Fitness</button>
                <button class="journal-tab" data-journal-category="uni">Uni</button>
                <button class="journal-tab" data-journal-category="crypto">Crypto</button>
                <button class="journal-tab" data-journal-category="lesen">Lesen</button>
                <button id="add-journal-btn" class="btn" style="margin-left: 2rem;">+ Add Journal</button>
            </div>

            <!-- ALLE KATEGORIE -->
            <div class="journal-content active" id="journal-alle">
                <!-- All journal entries will be loaded from database -->
            </div>

            <!-- ALLGEMEIN KATEGORIE -->
            <div class="journal-content" id="journal-allgemein">
                <!-- Allgemein entries will be loaded from database -->
            </div>

            <!-- FITNESS KATEGORIE -->
            <div class="journal-content" id="journal-fitness">
                <!-- Fitness entries will be loaded from database -->
            </div>

            <!-- UNI KATEGORIE -->
            <div class="journal-content" id="journal-uni">
                <!-- Uni entries will be loaded from database -->
            </div>

            <!-- CRYPTO KATEGORIE -->
            <div class="journal-content" id="journal-crypto">
                <!-- Crypto entries will be loaded from database -->
            </div>

            <!-- LESEN KATEGORIE -->
            <div class="journal-content" id="journal-lesen">
                <!-- Lesen entries will be loaded from database -->
            </div>

        </section>

        <!-- === TRADING TAB === -->
        <section id="tab-trading" class="tab-section">
            
            <!-- Trading Rules Sticky Note -->
            <div class="trading-rules-sticky">
                <div class="sticky-header">
                    <span class="sticky-title">ðŸ“ Trading Grundregeln</span>
                    <button class="sticky-minimize" onclick="this.parentElement.parentElement.classList.toggle('minimized'); this.textContent = this.parentElement.parentElement.classList.contains('minimized') ? '+' : 'âˆ’'" title="Ein-/Ausklappen">âˆ’</button>
                </div>
                <div class="sticky-content">
                    <ul class="rules-list">
                        <li>ðŸ’° <strong>Risk Management:</strong> Nie mehr als 2-5% pro Trade riskieren</li>
                        <li>ðŸŽ¯ <strong>Take Profit:</strong> Initials raus bei 2x, Rest laufen lassen</li>
                        <li>ðŸ›‘ <strong>Stop Loss:</strong> Bei -20% aussteigen, keine Emotionen</li>
                        <li>ðŸ“Š <strong>Research:</strong> Nur Coins traden, die du verstehst</li>
                        <li>â° <strong>Timing:</strong> Nicht FOMO - warten auf Setup</li>
                        <li>ðŸ“ <strong>Journal:</strong> Jeden Trade dokumentieren und lernen</li>
                    </ul>
                </div>
            </div>

            <!-- Portfolio Overview -->
            <div class="portfolio-overview">
                <div class="portfolio-stats">
                    <div class="portfolio-stat">
                        <div class="stat-number" id="sol-balance">0.00 SOL</div>
                        <div class="stat-label">SOL Balance</div>
                    </div>
                    <div class="portfolio-stat">
                        <div class="stat-number" id="sol-in-trades">0.00 SOL</div>
                        <div class="stat-label">SOL in Open Trades</div>
                    </div>
                    <div class="portfolio-stat">
                        <div class="stat-number" id="total-pnl">+0.00 SOL</div>
                        <div class="stat-label">Total P&L (SOL)</div>
                    </div>
                    <div class="portfolio-stat">
                        <div class="stat-number" id="open-trades">0</div>
                        <div class="stat-label">Open Positions</div>
                    </div>
                    <div class="portfolio-stat">
                        <div class="stat-number" id="win-rate">0%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                    <div class="portfolio-stat">
                        <div class="stat-number" id="total-pnl-usd">+$0.00</div>
                        <div class="stat-label">Total P&L (USD)</div>
                    </div>
                </div>
            </div>

            <!-- Trading Container -->
            <div class="trading-container">
                <div class="section-header">
                    <h3 id="trading-section-title">Open Positions</h3>
                    <div class="section-actions">
                        <button id="add-trade-btn" class="trade-action-btn">
                            <i data-lucide="plus" style="width: 18px; height: 18px;"></i>
                        </button>
                        <button id="refresh-prices-btn" class="trade-action-btn">
                            <i data-lucide="refresh-cw" style="width: 18px; height: 18px;"></i>
                        </button>
                        <button id="lock-btn" class="trade-action-btn">
                            <i data-lucide="lock" style="width: 18px; height: 18px;"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Open Trades View -->
                <div id="open-trades-view" class="trades-view">
                    <div class="trades-table" id="open-trades-list">
                        <div class="empty-trades">No open trades yet</div>
                    </div>
                </div>

                <!-- Closed Trades View -->
                <div id="closed-trades-view" class="trades-view" style="display: none;">
                    <div class="trades-table" id="closed-trades-list">
                        <div class="empty-trades">No closed trades yet</div>
                    </div>
                </div>
            </div>

        </section>

        <!-- === CLOSE TRADE MODAL === -->
        <div id="close-trade-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Close Trade</h3>
                    <button class="modal-close" id="close-trade-modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="trade-info">
                        <div class="info-row">
                            <span class="info-label">Token:</span>
                            <span class="info-value" id="close-trade-token">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Entry Amount:</span>
                            <span class="info-value" id="close-trade-entry-amount">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Entry McAP:</span>
                            <span class="info-value" id="close-trade-entry-mcap">-</span>
                        </div>
                    </div>
                    
                    <div class="close-trade-form">
                        <div class="form-group">
                            <label for="close-exit-mcap">Exit Market Cap</label>
                            <div class="mcap-input-group">
                                <input type="number" id="close-exit-mcap" placeholder="2.5" step="0.1" autocomplete="off">
                                <div class="mcap-buttons">
                                    <button type="button" class="mcap-btn" data-multiplier="K">K</button>
                                    <button type="button" class="mcap-btn" data-multiplier="M">M</button>
                                    <button type="button" class="mcap-btn active" data-multiplier="B">B</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="close-take-profit">SOL zu verkaufen</label>
                            <div class="sol-input-group">
                                <input type="number" id="close-take-profit" placeholder="2.0" step="0.001" autocomplete="off">
                                <div class="sol-sell-buttons">
                                    <button type="button" class="sol-percent-btn" data-percent="initials">Initials</button>
                                    <button type="button" class="sol-percent-btn" data-percent="25">25%</button>
                                    <button type="button" class="sol-percent-btn" data-percent="50">50%</button>
                                    <button type="button" class="sol-percent-btn" data-percent="75">75%</button>
                                    <button type="button" class="sol-percent-btn" data-percent="100">100%</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="close-keep-position">SOL verbleibend</label>
                            <input type="number" id="close-keep-position" placeholder="2.0" step="0.001" autocomplete="off" readonly style="background: #f8f9fa;">
                        </div>
                        
                        <div class="form-group">
                            <label for="close-trade-learnings">Learnings & Notes</label>
                            <textarea id="close-trade-learnings" placeholder="Was hast du gelernt? Warum hast du geschlossen? Fehler, Erfolge, Strategien..." rows="4" autocomplete="off" style="width: 100%; padding: 0.75rem; border: 1px solid #e0e0e0; border-radius: 4px; font-family: inherit; resize: vertical; min-height: 100px;"></textarea>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn secondary" id="close-trade-cancel">Cancel</button>
                    <button class="btn" id="close-trade-confirm">Close Trade</button>
                </div>
            </div>
        </div>

        <!-- === ADD TRADE MODAL === -->
        <div id="add-trade-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Add New Trade</h2>
                    <button class="modal-close" id="add-trade-modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="trade-form">
                        <div class="form-row">
                            <div class="form-group">
                                <label for="modal-trade-token">Token</label>
                                <input type="text" id="modal-trade-token" placeholder="BONK" autocomplete="off">
                            </div>
                            <div class="form-group">
                                <label for="modal-trade-sol-amount">SOL</label>
                                <input type="number" id="modal-trade-sol-amount" placeholder="0.5" step="0.001" autocomplete="off">
                            </div>
                            <div class="form-group">
                                <label for="modal-trade-mcap">Market Cap</label>
                                <input type="text" id="modal-trade-mcap" placeholder="2.1M" autocomplete="off">
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="modal-trade-notes">Notes</label>
                            <textarea id="modal-trade-notes" placeholder="e.g., Strong community, upcoming catalyst, technical breakout, stop loss, take profit..." rows="3" autocomplete="off"></textarea>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn secondary" id="add-trade-cancel">Cancel</button>
                    <button class="btn" id="add-trade-confirm">Add Trade</button>
                </div>
            </div>
        </div>

        <!-- === VIEW TRADE DETAILS MODAL === -->
        <div id="view-trade-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Trade Details</h3>
                    <button class="modal-close" id="view-trade-modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="trade-details-info">
                        <div class="details-section">
                            <h4>Trade Information</h4>
                            <div class="info-grid">
                                <div class="info-row">
                                    <span class="info-label">Token:</span>
                                    <span class="info-value" id="detail-token">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">SOL Amount:</span>
                                    <span class="info-value" id="detail-sol-amount">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Entry McAP:</span>
                                    <span class="info-value" id="detail-entry-mcap">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Exit McAP:</span>
                                    <span class="info-value" id="detail-exit-mcap">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Final P&L:</span>
                                    <span class="info-value" id="detail-pnl">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Entry Date:</span>
                                    <span class="info-value" id="detail-entry-date">-</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Exit Date:</span>
                                    <span class="info-value" id="detail-exit-date">-</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="details-section">
                            <h4>Entry Notes</h4>
                            <div class="notes-content" id="detail-entry-notes">-</div>
                        </div>
                        
                        <div class="details-section">
                            <h4>Close Learnings</h4>
                            <div class="learnings-content" id="detail-close-learnings">-</div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn secondary" id="close-details-modal">Close</button>
                </div>
            </div>
        </div>

        <!-- === ANALYTICS TAB === -->
        <section id="tab-analytics" class="tab-section">
            <div class="analytics-container">
                
                <!-- Analytics Charts Grid -->
                <div class="analytics-charts-grid">
                    <!-- SOL Balance Chart -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>SOL Balance History</h3>
                            <div class="chart-controls">
                                <div class="time-period-buttons">
                                    <button class="period-btn active" data-period="week">Woche</button>
                                    <button class="period-btn" data-period="month">Monat</button>
                                    <button class="period-btn" data-period="quarter">Quartal</button>
                                    <button class="period-btn" data-period="year">Jahr</button>
                                </div>
                                <div class="chart-info">
                                    <span id="current-sol-balance">Loading...</span>
                                </div>
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="solBalanceChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Todo Heatmap -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <h3>Todo Activity</h3>
                            <div class="heatmap-info">
                                <span id="heatmap-stats">Loading...</span>
                            </div>
                        </div>
                        <div class="heatmap-container">
                            <div class="heatmap-months" id="heatmap-months"></div>
                            <div class="heatmap-grid" id="heatmap-grid"></div>
                            <div class="heatmap-legend">
                                <span>Less</span>
                                <div class="legend-colors">
                                    <div class="legend-square level-0" title="0 todos"></div>
                                    <div class="legend-square level-1" title="1-2 todos"></div>
                                    <div class="legend-square level-2" title="3-5 todos"></div>
                                    <div class="legend-square level-3" title="6-10 todos"></div>
                                    <div class="legend-square level-4" title="11+ todos"></div>
                                </div>
                                <span>More</span>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </section>

        <!-- === RESSOURCEN TAB === -->
        <section id="tab-ressourcen" class="tab-section">

            <div class="resources-grid">
                <!-- PRIVAT BLOCK -->
                <div class="resource-block">
                    <div class="resource-block-header">
                        <h3>
                            <i data-lucide="home" style="width: 18px; height: 18px;"></i>
                            Privat
                        </h3>
                        <button class="add-to-category-btn" data-category="privat" title="Add to Privat">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <div class="resource-links" id="resource-privat">
                        <!-- Private resources will be loaded here -->
                    </div>
                </div>

                <!-- CRYPTO BLOCK -->
                <div class="resource-block">
                    <div class="resource-block-header">
                        <h3>
                            <i data-lucide="trending-up" style="width: 18px; height: 18px;"></i>
                            Crypto
                        </h3>
                        <button class="add-to-category-btn" data-category="crypto" title="Add to Crypto">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <div class="resource-links" id="resource-crypto">
                        <!-- Crypto resources will be loaded here -->
                    </div>
                </div>

                <!-- ARBEIT BLOCK -->
                <div class="resource-block">
                    <div class="resource-block-header">
                        <h3>
                            <i data-lucide="briefcase" style="width: 18px; height: 18px;"></i>
                            Arbeit
                        </h3>
                        <button class="add-to-category-btn" data-category="arbeit" title="Add to Arbeit">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <div class="resource-links" id="resource-arbeit">
                        <!-- Work resources will be loaded here -->
                    </div>
                </div>

                <!-- STUDIUM BLOCK -->
                <div class="resource-block">
                    <div class="resource-block-header">
                        <h3>
                            <i data-lucide="book-open" style="width: 18px; height: 18px;"></i>
                            Studium
                        </h3>
                        <button class="add-to-category-btn" data-category="uni" title="Add to Studium">
                            <i data-lucide="plus" style="width: 16px; height: 16px;"></i>
                        </button>
                    </div>
                    <div class="resource-links" id="resource-uni">
                        <!-- University resources will be loaded here -->
                    </div>
                </div>
            </div> <!-- end resources-grid -->

            <!-- QUICK NOTES SECTION -->
            <div class="quicknotes-section">
                <div class="quicknotes-header">
                    <h3>Quick Notes</h3>
                </div>
                <div class="quicknotes-content">
                    <textarea id="quicknotes-textarea" placeholder="Notizen hier eingeben..."></textarea>
                </div>
            </div>

        </section>


        <!-- === SETTINGS TAB === -->
        <section id="tab-settings" class="tab-section">
            <h1 class="section-title">Einstellungen</h1>
            
            <div class="settings-container">
                <div class="setting-group">
                    <h3>Routinen</h3>
                    <div class="setting-item">
                        <label for="routine-reset-time">Routine Reset Zeit:</label>
                        <input type="time" id="routine-reset-time" value="06:00">
                        <span class="setting-description">Zeit, zu der die Routinen tÃ¤glich zurÃ¼ckgesetzt werden</span>
                    </div>
                    <button id="save-routine-settings" class="btn">Speichern</button>
                </div>
                
                <div class="setting-group">
                    <h3>Analytics</h3>
                    <div class="setting-item">
                        <label for="balance-tracking-time">SOL Balance Tracking Zeit:</label>
                        <input type="time" id="balance-tracking-time" value="06:00">
                        <span class="setting-description">Zeit, zu der tÃ¤glich die SOL Balance fÃ¼r den Chart aufgezeichnet wird</span>
                    </div>
                    <button id="save-analytics-settings" class="btn">Speichern</button>
                </div>
            </div>
        </section>

        <!-- === WIKI TAB === -->
        <section id="tab-wiki" class="tab-section">
            <!-- Search and Filter Bar -->
            <div class="wiki-controls">
                <div class="search-container">
                    <input type="text" id="wiki-search" placeholder="Search wiki entries..." class="search-input">
                    <button class="search-btn" onclick="Wiki.search()">
                        <i data-lucide="search" style="width: 16px; height: 16px;"></i>
                    </button>
                </div>
                <div class="filter-container">
                    <input type="text" id="wiki-tag-filter" placeholder="Filter by tags..." class="filter-input" oninput="Wiki.filterByTags()">
                    <button class="btn" onclick="Wiki.showAddModal()">+ Add Entry</button>
                </div>
            </div>

            <!-- Wiki Content -->
            <div class="wiki-content" id="wiki-entries">
                <!-- Wiki entries will be loaded here -->
            </div>
        </section>

    </div>

    <!-- Add Resource Modal -->
    <div id="add-resource-modal" class="modal hide">
        <div class="modal-content">
            <span class="close" onclick="ResourceManager.hideAddResourceModal()">&times;</span>
            <h2>Add Resource</h2>
            <form id="add-resource-form">
                <div class="form-group">
                    <label for="resource-title">Title *</label>
                    <input type="text" id="resource-title" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="resource-category">Category *</label>
                    <select id="resource-category" required autocomplete="off">
                        <option value="">Choose category...</option>
                        <option value="Privat">Privat</option>
                        <option value="Arbeit">Arbeit</option>
                        <option value="Uni">Uni</option>
                        <option value="Crypto">Crypto</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="resource-url">URL *</label>
                    <input type="url" id="resource-url" placeholder="https://example.com" required autocomplete="off">
                </div>
                
                <div class="form-group">
                    <label for="resource-description">Description</label>
                    <textarea id="resource-description" rows="3" placeholder="Optional description..." autocomplete="off"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="resource-icon">Icon (optional)</label>
                    <input type="text" id="resource-icon" placeholder="Click icon below or type lucide icon name" readonly>
                    <div class="icon-palette">
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('mail')"><i data-lucide="mail" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('briefcase')"><i data-lucide="briefcase" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('book')"><i data-lucide="book" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('home')"><i data-lucide="home" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('message-circle')"><i data-lucide="message-circle" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('building')"><i data-lucide="building" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('wrench')"><i data-lucide="wrench" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('bar-chart-3')"><i data-lucide="bar-chart-3" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('file-text')"><i data-lucide="file-text" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('users')"><i data-lucide="users" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('globe')"><i data-lucide="globe" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('dollar-sign')"><i data-lucide="dollar-sign" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('target')"><i data-lucide="target" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('zap')"><i data-lucide="zap" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('lock')"><i data-lucide="lock" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('link')"><i data-lucide="link" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('rocket')"><i data-lucide="rocket" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('palette')"><i data-lucide="palette" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('activity')"><i data-lucide="activity" style="width: 16px; height: 16px;"></i></button>
                        <button type="button" class="icon-btn" onclick="ResourceManager.selectIcon('bot')"><i data-lucide="bot" style="width: 16px; height: 16px;"></i></button>
                    </div>
                    <small style="margin-top: 0.5rem; display: block;">Click an icon above or make input editable to type manually</small>
                    <button type="button" class="btn-link" onclick="ResourceManager.toggleIconInput()" style="font-size: 0.8rem; margin-top: 0.25rem;">Enable manual typing</button>
                </div>
                
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="ResourceManager.hideAddResourceModal()">Cancel</button>
                    <button type="submit" class="btn">Add Resource</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Add Wiki Entry Modal -->
    <div id="add-wiki-modal" class="modal hide">
        <div class="modal-content">
            <span class="close" onclick="Wiki.hideAddModal()">
                <i data-lucide="x" style="width: 20px; height: 20px;"></i>
            </span>
            <h2>Add Wiki Entry</h2>
            <form id="add-wiki-form">
                <div class="form-group">
                    <label for="wiki-title">Title *</label>
                    <input type="text" id="wiki-title" required autocomplete="off" placeholder="e.g. CME Gap Trading Strategy">
                </div>
                
                <div class="form-group">
                    <label for="wiki-tags">Tags *</label>
                    <input type="text" id="wiki-tags" required placeholder="e.g. crypto, trading, analysis, finance" autocomplete="off">
                    <small>Separate tags with commas for better filtering.</small>
                </div>
                
                <div class="form-group">
                    <label for="wiki-content">Content *</label>
                    <textarea id="wiki-content" rows="15" required autocomplete="off" placeholder="Enter detailed explanation, rules, or learnings..." style="resize: vertical; min-height: 300px; width: 100%;"></textarea>
                </div>
                
                
                <div class="form-group">
                    <label for="wiki-source">Source (optional)</label>
                    <input type="text" id="wiki-source" placeholder="Video title, book, website..." autocomplete="off">
                </div>
                
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="Wiki.hideAddModal()">Cancel</button>
                    <button type="submit" class="btn">Add Entry</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Scripts -->
    <script src="supabase-config.js"></script>
    <script src="cloud-storage.js"></script>
    <script src="simple-counters.js"></script>
    <script src="simple-routine-system.js"></script>
    <script>
        // Debug: Check if basic JavaScript works
        console.log('ðŸ”§ JavaScript loading started...');
        
        window.addEventListener('error', function(e) {
            console.error('âŒ JavaScript Error:', e.error);
            alert('JavaScript Error: ' + e.message + ' at line ' + e.lineno);
        });
        
        // === AUTHENTICATION ===
        const Auth = {
            isAuthenticated: false,
            currentUser: null,
            
            async init() {
                window.Auth = this;
                
                if (!supabase) {
                    console.log('âš ï¸ Demo mode - no authentication');
                    await this.showDashboard();
                    return;
                }
                
                this.currentUser = supabase.getCurrentUser();
                if (supabase.isAuthenticated()) {
                    console.log('âœ… User authenticated successfully');
                    this.isAuthenticated = true;
                    await this.showDashboard();
                } else {
                    this.showAuthScreen();
                }
                
                this.setupEventListeners();
            },
            
            setupEventListeners() {
                const loginBtn = document.getElementById('login-btn');
                const logoutBtn = document.getElementById('logout-btn');
                
                if (loginBtn) {
                    loginBtn.addEventListener('click', () => this.handleLogin());
                }
                
                if (logoutBtn) {
                    logoutBtn.addEventListener('click', () => this.handleLogout());
                }
            },
            
            async handleLogin() {
                const email = document.getElementById('login-email').value;
                const password = document.getElementById('login-password').value;
                const errorEl = document.getElementById('login-error');
                
                if (!email || !password) {
                    this.showError('Please enter email and password');
                    return;
                }
                
                try {
                    const { user, error } = await supabase.signIn(email, password);
                    
                    if (error) {
                        this.showError(error);
                        return;
                    }
                    
                    if (user) {
                        this.currentUser = user;
                        this.isAuthenticated = true;
                        await this.showDashboard();
                    }
                } catch (error) {
                    this.showError(error.message);
                }
            },
            
            async handleLogout() {
                console.log('ðŸšª Logout clicked');
                try {
                    if (supabase && typeof supabase.signOut === 'function') {
                        await supabase.signOut();
                    }
                    // Only clear auth-related data, preserve routine/todo data
                    localStorage.removeItem('supabase.auth.token');
                    sessionStorage.clear();
                    console.log('âœ… Logout successful, redirecting to login...');
                    
                    // Clear URL hash and redirect to clean login page
                    window.history.replaceState(null, null, window.location.pathname);
                    window.location.reload();
                } catch (error) {
                    console.error('âŒ Logout error:', error);
                    // Only clear auth-related data, preserve user data
                    localStorage.removeItem('supabase.auth.token');
                    sessionStorage.clear();
                    window.location.reload();
                }
            },
            
            showError(message) {
                const errorEl = document.getElementById('login-error');
                if (errorEl) {
                    errorEl.textContent = message;
                    errorEl.classList.add('show');
                    setTimeout(() => errorEl.classList.remove('show'), 5000);
                }
            },
            
            showAuthScreen() {
                document.getElementById('auth-screen').classList.remove('hide');
            },
            
            async refreshRoutineUI() {
                // Simple refresh for routine UI without retries
                console.log('ðŸ”„ Refreshing routine UI...');
                
                try {
                    // Note: Counter updates now handled by SimpleCounters
                    
                    // Dispatch update event for routine elements
                    const routineSections = document.querySelectorAll('.routine-item, .habit-item');
                    if (routineSections.length > 0) {
                        routineSections.forEach(section => {
                            const event = new Event('routineUpdate', { bubbles: true });
                            section.dispatchEvent(event);
                        });
                    }
                    
                    console.log('âœ… Routine UI refreshed');
                } catch (error) {
                    console.error('âŒ Error refreshing routine UI:', error);
                }
            },
            
            async showDashboard() {
                document.getElementById('auth-screen').classList.add('hide');
                
                // Load all data after successful login
                if (supabase?.isAuthenticated()) {
                    console.log('ðŸ”„ Loading dashboard data...');
                    
                    // Load all data in parallel for better performance
                    await Promise.all([
                        TodoManager.loadTodos(),
                        GoalManager.loadGoals(),
                        JournalManager.loadEntries(),
                        TerminManager.loadTermine(),
                        // Load Wiki data if available
                        window.Wiki ? window.Wiki.loadEntries() : Promise.resolve(),
                        // Load ResourceManager data if it exists (after login)
                        window.ResourceManager ? window.ResourceManager.loadResources() : Promise.resolve()
                    ]);
                    
                    // Initialize routine system FIRST, then counters to avoid race condition
                    if (window.simpleRoutineManager) {
                        console.log('ðŸ”„ Re-initializing routine manager after login...');
                        await window.simpleRoutineManager.loadTodaysData();
                        window.simpleRoutineManager.restoreCheckboxes();
                        window.simpleRoutineManager.updateProgressBarsOnly();
                    }
                    
                    // Initialize counters AFTER routine system is ready
                    if (window.SimpleCounters) {
                        await window.SimpleCounters.init();
                    }
                    
                    // Render Wiki after data is loaded
                    if (window.Wiki) {
                        window.Wiki.render();
                    }
                    
                    console.log('âœ… Dashboard data loaded');
                    
                    // After login, always go to home tab for clean UX
                    console.log('ðŸ  After login, redirecting to home tab');
                    switchTab('tab-home', true); // Update URL to #home
                } else {
                    // Initialize displays for local storage mode
                    TodoManager.updateHomeTodos();
                    TerminManager.displayTermine();
                }
            }
        };

        // === TAB SYSTEM ===
        // Mapping between tab IDs and URL hashes
        const tabHashMapping = {
            'tab-home': 'home',
            'tab-todos': 'todos',
            'tab-ziele': 'goals', 
            'tab-journal': 'journal',
            'tab-trading': 'trading',
            'tab-ressourcen': 'resources',
            'tab-wiki': 'wiki',
            'tab-settings': 'settings'
        };

        // Reverse mapping for hash to tab ID
        const hashTabMapping = Object.fromEntries(
            Object.entries(tabHashMapping).map(([key, value]) => [value, key])
        );

        function switchTab(tabId, updateHash = true) {
            document.querySelectorAll('.tab-section').forEach(section => {
                section.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            const targetSection = document.getElementById(tabId);
            const targetTab = document.querySelector(`[data-tab="${tabId}"]`);
            
            if (targetSection && targetTab) {
                targetSection.classList.add('active');
                targetTab.classList.add('active');
                
                // Update URL hash
                if (updateHash && tabHashMapping[tabId]) {
                    const hash = tabHashMapping[tabId];
                    
                    window.history.replaceState(null, null, `#${hash}`);
                    console.log(`ðŸ”— Tab switched to ${tabId}, URL updated to #${hash}`);
                } else if (updateHash) {
                    // Fallback: if no hash mapping, clear hash
                    window.history.replaceState(null, null, window.location.pathname);
                }
            }
            
            // If switching to todos tab, load the active category
            if (tabId === 'tab-todos') {
                const activeTab = document.querySelector('.category-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-category') : 'heute';
                TodoManager.displayTodosForCategory(activeCategory);
            }
            
            // If switching to home tab, update home todos
            if (tabId === 'tab-home') {
                TodoManager.updateHomeTodos();
            }
            
            // If switching to ziele tab, load the active category
            if (tabId === 'tab-ziele') {
                const activeTab = document.querySelector('.ziel-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-ziel-category') : 'alle';
                GoalManager.displayGoalsForCategory(activeCategory);
            }
            
            // If switching to journal tab, load the active category
            if (tabId === 'tab-journal') {
                const activeTab = document.querySelector('.journal-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-journal-category') : 'alle';
                JournalManager.displayEntriesForCategory(activeCategory);
            }
            
            // If switching to resources tab, load the active category
            if (tabId === 'tab-ressourcen') {
                if (window.ResourceManager) {
                    const activeTab = document.querySelector('.resource-tab.active');
                    const activeCategory = activeTab ? activeTab.getAttribute('data-resource-category') : 'alle';
                    ResourceManager.displayResourcesForCategory(activeCategory);
                }
            }
            
            // If switching to trading tab, update portfolio stats
            if (tabId === 'tab-trading') {
                if (window.TradingManager) {
                    window.TradingManager.updatePortfolioStats();
                }
            }
        }

        // Handle hash changes for direct URL navigation
        function handleHashChange() {
            const hash = window.location.hash.slice(1); // Remove the '#'
            if (hash && hashTabMapping[hash]) {
                console.log(`ðŸ”— Hash changed to #${hash}, switching to ${hashTabMapping[hash]}`);
                switchTab(hashTabMapping[hash], false); // Don't update hash again
            } else if (!hash && supabase?.isAuthenticated()) {
                // Only default to home if authenticated (not on login screen)
                console.log('ðŸ”— No hash found, defaulting to home (authenticated user)');
                switchTab('tab-home', false);
            }
            // If not authenticated and no hash, do nothing (stay on login screen)
        }

        // Initialize tab from URL hash on page load
        function initializeFromHash() {
            const hash = window.location.hash.slice(1);
            if (hash && hashTabMapping[hash]) {
                switchTab(hashTabMapping[hash], false);
            } else if (!hash && supabase?.isAuthenticated()) {
                // Only default to home if authenticated
                switchTab('tab-home', false);
            }
            // If not authenticated and no hash, do nothing (stay on login screen)
        }

        // === ROUTINE PROGRESS ===
        // Load saved checkbox states from cloud only (pure cloud mode)
        async function loadRoutineStates() {
            const today = new Date().toISOString().split('T')[0];
            let savedStates = {};
            
            // Pure cloud mode - no localStorage fallback needed
            console.log('â˜ï¸ Pure cloud mode - loading routine states from cloud only');
            
            // If authenticated, load from database
            if (supabase?.isAuthenticated()) {
                try {
                    const routineCompletions = getRoutineCompletions();
                    if (routineCompletions && routineCompletions.length > 0) {
                        console.log(`ðŸ”„ Loading ${routineCompletions.length} routine completions from database for ${today}`);
                        
                        // Filter for today's completions
                        const todayCompletions = routineCompletions.filter(c => c.date === today);
                        console.log(`ðŸ“… Found ${todayCompletions.length} routine completions for today`);
                        
                        // Convert database completions to checkbox states
                        todayCompletions.forEach(completion => {
                            if (completion.checkbox_id) {
                                savedStates[completion.checkbox_id] = completion.completed;
                                console.log(`âœ… Restored from database: ${completion.checkbox_id} = ${completion.completed}`);
                            }
                        });
                        
                        // Pure cloud mode - no localStorage updates needed
                        console.log('â˜ï¸ Routine states loaded from cloud');
                    }
                } catch (error) {
                    console.error('Error loading routine states from database:', error);
                    // Continue with localStorage-only states
                }
            }
            
            // Apply states to checkboxes
            Object.keys(savedStates).forEach(checkboxId => {
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.checked = savedStates[checkboxId];
                    // Apply visual styling
                    const label = checkbox.nextElementSibling;
                    if (label) {
                        if (checkbox.checked) {
                            label.style.textDecoration = 'line-through';
                            label.style.color = '#999';
                        } else {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    }
                }
            });
            
            console.log(`âœ… Loaded routine states for ${today}:`, savedStates);
        }
        
        // Save checkbox state to both localStorage and database
        async function saveCheckboxState(checkboxId, isChecked) {
            const today = new Date().toISOString().split('T')[0];
            
            // Pure cloud mode - no localStorage saving needed
            console.log(`â˜ï¸ Pure cloud mode: Checkbox state ${checkboxId} = ${isChecked} (not saved to localStorage)`);
            
            // Skip database save for routine checkboxes - handled by routine completion system
            const checkbox = document.getElementById(checkboxId);
            const routineSection = checkbox?.closest('.routine-section');
            
            if (routineSection) {
                console.log(`ðŸ“ Routine checkbox ${checkboxId} state saved to localStorage only - database sync handled by routine system`);
                return;
            }
            
            // Save non-routine checkboxes to database if authenticated
            if (supabase?.isAuthenticated()) {
                console.log(`ðŸ’¾ Saving non-routine checkbox ${checkboxId} to database...`);
                // Only save non-routine checkboxes to database
                // Routine checkboxes are handled by the routine completion system
            }
        }

        function updateRoutineProgress() {
            // DISABLED - conflicts with SimpleRoutineManager
            return;
            const routineTab = document.getElementById('tab-home');
            if (!routineTab) return;
            
            const routineSections = routineTab.querySelectorAll('.routine-section');
            
            routineSections.forEach(section => {
                const checkboxes = section.querySelectorAll('input[type="checkbox"]');
                const checkedBoxes = section.querySelectorAll('input[type="checkbox"]:checked');
                
                if (checkboxes.length === 0) return;
                
                const percentage = Math.round((checkedBoxes.length / checkboxes.length) * 100);
                
                const progressFill = section.querySelector('.progress-fill');
                if (progressFill) {
                    progressFill.style.width = percentage + '%';
                }
                
                // Optional: Log progress for debugging
                console.log(`Routine progress: ${percentage}% (${checkedBoxes.length}/${checkboxes.length})`);
                
                // Update monthly streaks based on completion status (pure cloud mode)
                const today = new Date().toISOString().split('T')[0];
                const routineType = section.querySelector('h2').textContent.includes('Morgen') ? 'morning' : 'evening';
                
                let completionStatus;
                if (percentage === 100) {
                    console.log('ðŸ” DEBUG: 100% reached, marking as complete');
                    completionStatus = true;
                } else {
                    console.log('ðŸ” DEBUG: Less than 100%, marking as incomplete');
                    completionStatus = false;
                }
                
                console.log(`â˜ï¸ Pure cloud mode: ${routineType} completion: ${completionStatus}`);
                
                // Save to cloud if authenticated (async without blocking)
                if (supabase?.isAuthenticated()) {
                    (async () => {
                        try {
                            console.log(`â˜ï¸ Saving routine completion to cloud: ${routineType} = ${completionStatus}`);
                            await cloudStorage.saveRoutineCompletion(`${routineType}_routine`, today, completionStatus);
                            
                            // Note: Counter updates now handled by SimpleCounters
                        } catch (error) {
                            console.warn('âš ï¸ Could not save routine completion to cloud:', error);
                        }
                    })();
                }
                
                // Note: Counter updates now handled by SimpleCounters
            });
        }

        // === CATEGORY SYSTEM (for todos) ===
        function switchCategory(categoryId) {
            const parentTab = document.querySelector('#tab-todos');
            // Hide all category contents within todos
            parentTab.querySelectorAll('.category-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all category tabs
            parentTab.querySelectorAll('.category-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-category="${categoryId}"]`).classList.add('active');
            
            // Show/hide clear archive button
            const clearArchiveBtn = document.getElementById('clear-archive-btn');
            if (clearArchiveBtn) {
                if (categoryId === 'archiv') {
                    clearArchiveBtn.style.display = 'inline-block';
                } else {
                    clearArchiveBtn.style.display = 'none';
                }
            }
            
            // Load todos for this category
            TodoManager.displayTodosForCategory(categoryId);
        }

        // === ZIELE CATEGORY SYSTEM ===
        function switchZielCategory(categoryId) {
            const parentTab = document.querySelector('#tab-ziele');
            // Hide all ziel contents
            parentTab.querySelectorAll('.ziel-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all ziel tabs
            parentTab.querySelectorAll('.ziel-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#ziel-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-ziel-category="${categoryId}"]`).classList.add('active');
            
            // Show/hide clear goal archive button
            const clearGoalArchiveBtn = document.getElementById('clear-goal-archive-btn');
            if (clearGoalArchiveBtn) {
                if (categoryId === 'archiv') {
                    clearGoalArchiveBtn.style.display = 'inline-block';
                } else {
                    clearGoalArchiveBtn.style.display = 'none';
                }
            }
            
            // Load goals for this category
            GoalManager.displayGoalsForCategory(categoryId);
        }

        // === RESOURCE CATEGORY SYSTEM ===
        function switchResourceCategory(categoryId) {
            const parentTab = document.querySelector('#tab-ressourcen');
            // Hide all resource contents
            parentTab.querySelectorAll('.resource-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all resource tabs
            parentTab.querySelectorAll('.resource-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#resource-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-resource-category="${categoryId}"]`).classList.add('active');
            
            // Load resources for this category
            ResourceManager.displayResourcesForCategory(categoryId);
        }

        // === JOURNAL CATEGORY SYSTEM ===
        function switchJournalCategory(categoryId) {
            const parentTab = document.querySelector('#tab-journal');
            // Hide all journal contents
            parentTab.querySelectorAll('.journal-content').forEach(content => {
                content.classList.remove('active');
            });
            // Remove active from all journal tabs
            parentTab.querySelectorAll('.journal-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            // Show selected category
            parentTab.querySelector(`#journal-${categoryId}`).classList.add('active');
            // Activate selected category tab
            parentTab.querySelector(`[data-journal-category="${categoryId}"]`).classList.add('active');
            
            // Load journal entries for this category
            JournalManager.displayEntriesForCategory(categoryId);
        }

        // === SETTINGS FUNCTIONALITY ===
        function initializeSettings() {
            // Pure cloud mode - use default reset time (settings could be moved to cloud later)
            console.log('â˜ï¸ Pure cloud mode: Using default routine reset time');
            const savedResetTime = '06:00'; // Default time, no localStorage needed
            const timeInput = document.getElementById('routine-reset-time');
            if (timeInput) {
                timeInput.value = savedResetTime;
            }
            
            // Save routine settings button
            const saveBtn = document.getElementById('save-routine-settings');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    const resetTime = timeInput.value;
                    console.log('â˜ï¸ Pure cloud mode: Settings change noted but not persisted');
                    alert(`Routine Reset Zeit auf ${resetTime} temporÃ¤r gesetzt! (Pure Cloud Mode - nicht dauerhaft gespeichert)`);
                    console.log(`Routine reset time noted: ${resetTime} (not persisted in pure cloud mode)`);
                });
            }
            
            // Reset routines today button
            const resetBtn = document.getElementById('reset-routines-today');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    if (confirm('MÃ¶chtest du wirklich alle Routinen fÃ¼r heute zurÃ¼cksetzen?')) {
                        resetRoutinesToday();
                    }
                });
            }
            
            // Reset monthly todos button
            const resetTodosBtn = document.getElementById('reset-monthly-todos');
            if (resetTodosBtn) {
                resetTodosBtn.addEventListener('click', () => {
                    const now = new Date();
                    const monthName = ['Januar', 'Februar', 'MÃ¤rz', 'April', 'Mai', 'Juni',
                                     'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
                    if (confirm(`MÃ¶chtest du wirklich den Todo-ZÃ¤hler fÃ¼r ${monthName} ${now.getFullYear()} zurÃ¼cksetzen?`)) {
                        resetMonthlyTodos();
                    }
                });
            }
        }
        
        function resetRoutinesToday() {
            const today = new Date().toISOString().split('T')[0];
            
            // Pure cloud mode - no localStorage operations needed
            console.log('â˜ï¸ Pure cloud mode: Routine reset will only affect UI, not persistent storage');
            console.log(`â˜ï¸ Resetting routines for ${today} (UI only)`);
            
            // Note: In pure cloud mode, this only resets the UI
            // The actual cloud data would need to be reset via cloud operations
            
            // Uncheck all routine checkboxes
            document.querySelectorAll('.routine-section input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
                const label = checkbox.nextElementSibling;
                if (label) {
                    label.style.textDecoration = 'none';
                    label.style.color = 'inherit';
                }
            });
            
            // Update progress displays
            updateRoutineProgress();
            // Note: Counter updates now handled by SimpleCounters
            
            alert('Routinen fÃ¼r heute wurden zurÃ¼ckgesetzt!');
            console.log('Routines reset for today');
        }
        
        function resetMonthlyTodos() {
            const now = new Date();
            const monthKey = `${now.getFullYear()}-${now.getMonth()}`;
            
            // Reset monthly todo completions
            const monthlyData = JSON.parse(localStorage.getItem('monthlyTodoCompletions') || '{}');
            monthlyData[monthKey] = 0;
            localStorage.setItem('monthlyTodoCompletions', JSON.stringify(monthlyData));
            
            // Note: Counter updates now handled by SimpleCounters
            
            const monthName = ['Januar', 'Februar', 'MÃ¤rz', 'April', 'Mai', 'Juni',
                             'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'][now.getMonth()];
            alert(`Todo-ZÃ¤hler fÃ¼r ${monthName} ${now.getFullYear()} wurde auf 0 zurÃ¼ckgesetzt!`);
            console.log(`Monthly todos reset for ${monthKey}`);
        }
        
        // === TODO COUNTER SYSTEMS REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        // === MOBILE-FIRST ROUTINE COMPLETIONS ===
        let globalRoutineCompletions = []; // Always keep in memory for mobile
        
        async function loadRoutineCompletions() {
            try {
                console.log('ðŸ”„ Loading routine completions (Cloud-First with Migration)...');
                
                // STEP 1: If not authenticated, use local data only
                if (!supabase?.isAuthenticated()) {
                    console.log('âš ï¸ Not authenticated, using local data only');
                    try {
                        const localData = localStorage.getItem('routine_completions_cache');
                        if (localData) {
                            globalRoutineCompletions = JSON.parse(localData);
                            // Note: Counter updates now handled by SimpleCounters
                        }
                    } catch (e) {
                        console.warn('âš ï¸ Could not read local data:', e);
                        globalRoutineCompletions = [];
                    }
                    return;
                }
                
                // STEP 2: Load cloud data
                const cloudCompletions = await supabase.query('routine_completions?select=*');
                console.log(`â˜ï¸ Loaded ${cloudCompletions?.length || 0} routine completions from cloud`);
                
                // STEP 3: Cloud-first with improved migration
                if (cloudCompletions && cloudCompletions.length > 0) {
                    // Use cloud data if available
                    globalRoutineCompletions = cloudCompletions;
                    console.log(`â˜ï¸ Using ${cloudCompletions.length} completions from cloud`);
                } else {
                    // Cloud is empty - try migration with new improved approach
                    console.log('ðŸ” Cloud is empty, attempting migration with new schema...');
                    const migrationSuccess = await migrateLocalDataToCloudV2();
                    
                    if (migrationSuccess) {
                        // Reload after successful migration
                        const newCloudCompletions = await supabase.query('routine_completions?select=*');
                        console.log(`ðŸ”„ After migration: ${newCloudCompletions?.length || 0} completions in cloud`);
                        globalRoutineCompletions = newCloudCompletions || [];
                    } else {
                        // Migration failed - use local data as fallback
                        console.log('âš ï¸ Migration failed, using local data as fallback');
                        globalRoutineCompletions = [];
                        
                        // Load from all local sources
                        const localSources = ['routine_completions_cache', 'routineCompletionData'];
                        for (const source of localSources) {
                            try {
                                const localData = localStorage.getItem(source);
                                if (localData) {
                                    const parsed = JSON.parse(localData);
                                    
                                    if (source === 'routineCompletionData') {
                                        // Convert old format
                                        Object.keys(parsed).forEach(date => {
                                            const dayData = parsed[date];
                                            if (dayData.morning !== undefined) {
                                                globalRoutineCompletions.push({
                                                    template_id: 'morning_routine',
                                                    date: date,
                                                    completed: dayData.morning
                                                });
                                            }
                                            if (dayData.evening !== undefined) {
                                                globalRoutineCompletions.push({
                                                    template_id: 'evening_routine',
                                                    date: date,
                                                    completed: dayData.evening
                                                });
                                            }
                                        });
                                    } else if (Array.isArray(parsed)) {
                                        globalRoutineCompletions.push(...parsed);
                                    }
                                }
                            } catch (e) {
                                console.warn(`âš ï¸ Could not load fallback from ${source}:`, e);
                            }
                        }
                        console.log(`ðŸ“± Using ${globalRoutineCompletions.length} local completions as fallback`);
                    }
                }
                
                // STEP 4: Pure cloud mode - no local caching needed
                console.log('â˜ï¸ Pure cloud mode - skipping local cache storage');
                
                // STEP 5: Counter updates now handled by SimpleCounters
                
            } catch (error) {
                console.error('âŒ Error loading routine completions:', error);
                // Fallback to local data on error
                try {
                    const localData = localStorage.getItem('routine_completions_cache');
                    if (localData) {
                        globalRoutineCompletions = JSON.parse(localData);
                        console.log('ðŸ”„ Fallback to local data due to error');
                    } else {
                        globalRoutineCompletions = [];
                    }
                } catch (e) {
                    globalRoutineCompletions = [];
                }
            }
        }
        
        // === IMPROVED MIGRATION FUNCTION V2 ===
        async function migrateLocalDataToCloudV2() {
            try {
                console.log('ðŸš€ Starting IMPROVED migration (V2) of local routine data to cloud...');
                
                // Get current user
                const currentUser = supabase.getCurrentUser();
                if (!currentUser || !currentUser.id) {
                    console.error('âŒ No authenticated user found for migration');
                    return false;
                }
                
                console.log('ðŸ‘¤ Starting data migration...');
                
                // Collect all local data
                const localCompletions = [];
                
                // Source 1: routineCompletionData (legacy format)
                try {
                    const legacyData = localStorage.getItem('routineCompletionData');
                    if (legacyData) {
                        const parsed = JSON.parse(legacyData);
                        console.log(`ðŸ“ Found legacy data for ${Object.keys(parsed).length} dates`);
                        
                        Object.keys(parsed).forEach(date => {
                            const dayData = parsed[date];
                            if (dayData.morning !== undefined) {
                                localCompletions.push({
                                    template_id: 'morning_routine',
                                    date: date,
                                    completed: Boolean(dayData.morning),
                                    user_id: currentUser.id
                                });
                            }
                            if (dayData.evening !== undefined) {
                                localCompletions.push({
                                    template_id: 'evening_routine',
                                    date: date,
                                    completed: Boolean(dayData.evening),
                                    user_id: currentUser.id
                                });
                            }
                        });
                    }
                } catch (e) {
                    console.warn('âš ï¸ Could not parse legacy routine data:', e);
                }
                
                console.log(`ðŸ“Š Prepared ${localCompletions.length} completions for migration`);
                
                if (localCompletions.length === 0) {
                    console.log('ðŸ“­ No local data found to migrate');
                    return true;
                }
                
                // Remove duplicates based on user_id + template_id + date
                const uniqueCompletions = [];
                const seen = new Set();
                
                localCompletions.forEach(completion => {
                    const key = `${completion.user_id}_${completion.template_id}_${completion.date}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueCompletions.push(completion);
                    }
                });
                
                console.log(`ðŸ” After deduplication: ${uniqueCompletions.length} unique completions`);
                
                // Upload to cloud
                let uploadedCount = 0;
                
                for (const completion of uniqueCompletions) {
                    try {
                        console.log(`â¬†ï¸ Uploading: ${completion.template_id} for ${completion.date} (${completion.completed})`);
                        
                        const result = await supabase.insert('routine_completions', [completion]);
                        if (result && result.length > 0) {
                            uploadedCount++;
                            console.log(`âœ… Uploaded successfully`);
                        } else {
                            console.warn(`âš ï¸ Upload returned no result`);
                        }
                    } catch (uploadError) {
                        console.error(`âŒ Failed to upload completion:`, uploadError);
                        
                        // Check if it's a duplicate key error (which is OK)
                        if (uploadError.message && uploadError.message.includes('unique constraint')) {
                            console.log(`â„¹ï¸ Duplicate entry (already exists) - skipping`);
                            uploadedCount++; // Count as success since data exists
                        } else {
                            console.error(`âŒ Real upload error:`, uploadError.message);
                        }
                    }
                }
                
                console.log(`ðŸŽ‰ Migration V2 complete! Successfully processed ${uploadedCount}/${uniqueCompletions.length} completions`);
                return uploadedCount > 0;
                
            } catch (error) {
                console.error('âŒ Migration V2 failed:', error);
                return false;
            }
        }
        
        // === OLD MIGRATION FUNCTION (DEPRECATED) ===
        async function migrateLocalDataToCloud() {
            try {
                console.log('ðŸš€ Starting migration of local routine data to cloud...');
                
                // Get all local routine data sources
                const sources = [
                    'routine_completions_cache',
                    'routineCompletionData',
                    'monthlyRoutineCompletions'
                ];
                
                let allLocalCompletions = [];
                
                for (const source of sources) {
                    try {
                        const data = localStorage.getItem(source);
                        if (data) {
                            let parsed = JSON.parse(data);
                            console.log(`ðŸ“ Found data in ${source}:`, parsed);
                            
                            if (source === 'routineCompletionData') {
                                // Convert old format to new format
                                Object.keys(parsed).forEach(date => {
                                    const dayData = parsed[date];
                                    if (dayData.morning !== undefined) {
                                        allLocalCompletions.push({
                                            template_id: 'morning_routine',
                                            date: date,
                                            completed: dayData.morning,
                                            user_id: supabase.getCurrentUser()?.id
                                            // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                        });
                                    }
                                    if (dayData.evening !== undefined) {
                                        allLocalCompletions.push({
                                            template_id: 'evening_routine', 
                                            date: date,
                                            completed: dayData.evening,
                                            user_id: supabase.getCurrentUser()?.id
                                            // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                        });
                                    }
                                });
                            } else if (Array.isArray(parsed)) {
                                // Add user_id to existing completions and remove any existing id
                                parsed.forEach(completion => {
                                    const cleanCompletion = {
                                        template_id: completion.template_id,
                                        date: completion.date,
                                        completed: completion.completed,
                                        user_id: supabase.getCurrentUser()?.id
                                        // NOTE: No 'id' field - BIGSERIAL will auto-generate
                                    };
                                    allLocalCompletions.push(cleanCompletion);
                                });
                            }
                        }
                    } catch (e) {
                        console.warn(`âš ï¸ Could not parse ${source}:`, e);
                    }
                }
                
                console.log(`ðŸ“Š Found ${allLocalCompletions.length} local completions to migrate`);
                
                if (allLocalCompletions.length === 0) {
                    console.log('ðŸ“­ No local data found to migrate');
                    return true; // No data to migrate is considered success
                }
                
                // Clean all completions: remove any existing IDs and ensure clean data
                const cleanedCompletions = allLocalCompletions.map(completion => ({
                    template_id: completion.template_id,
                    date: completion.date,
                    completed: completion.completed,
                    user_id: completion.user_id || supabase.getCurrentUser()?.id
                    // Explicitly exclude: id, created_at, updated_at - these will be auto-generated
                }));
                
                console.log(`ðŸ§¹ Cleaned data, removing ${allLocalCompletions.length - cleanedCompletions.length} invalid entries`);
                
                // Upload to cloud in batches
                const batchSize = 50;
                let uploaded = 0;
                let hasErrors = false;
                
                for (let i = 0; i < cleanedCompletions.length; i += batchSize) {
                    const batch = cleanedCompletions.slice(i, i + batchSize);
                    try {
                        const result = await supabase.insert('routine_completions', batch);
                        if (result) {
                            uploaded += batch.length;
                            console.log(`âœ… Uploaded batch: ${uploaded}/${cleanedCompletions.length}`);
                        } else {
                            console.error('âŒ Batch upload returned no result');
                            hasErrors = true;
                        }
                    } catch (batchError) {
                        console.error('âŒ Batch upload failed:', batchError);
                        hasErrors = true;
                        
                        // Check if it's an RLS error
                        if (batchError.message && batchError.message.includes('row-level security')) {
                            console.error('ðŸ”’ RLS Error: Please run the fix-routine-completions-rls.sql file in Supabase');
                            return false; // Stop migration on RLS error
                        }
                    }
                }
                
                if (hasErrors && uploaded === 0) {
                    console.log('âŒ Migration failed completely');
                    return false;
                } else if (hasErrors) {
                    console.log(`âš ï¸ Migration partially successful: ${uploaded}/${cleanedCompletions.length} uploaded`);
                    return uploaded > 0; // Partial success
                } else {
                    console.log(`ðŸŽ‰ Migration complete! Uploaded ${uploaded} routine completions to cloud`);
                    return true;
                }
                
            } catch (error) {
                console.error('âŒ Migration failed:', error);
                return false;
            }
        }
        
        // Mobile-safe function that uses memory first, localStorage as fallback
        function getRoutineCompletions() {
            if (globalRoutineCompletions && globalRoutineCompletions.length > 0) {
                console.log('ðŸ“± Using routine completions from memory (Mobile-safe)');
                return globalRoutineCompletions;
            }
            
            // Fallback to localStorage if available
            try {
                const cached = localStorage.getItem('routine_completions_cache');
                if (cached) {
                    const parsed = JSON.parse(cached);
                    console.log('ðŸ’¾ Using routine completions from localStorage fallback');
                    return parsed;
                }
            } catch (e) {
                console.warn('âš ï¸ localStorage read failed, using empty array');
            }
            
            return [];
        }
        
        // === CLOUD-BASED ROUTINE STREAK UPDATER REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        // === LOCAL FALLBACK FOR ROUTINE STREAKS REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        // === MONTHLY STREAK DISPLAY FUNCTIONS REMOVED ===
        // Note: Counter updates now handled by SimpleCounters
        
        function getRoutineCompletions() {
            // Return empty array for now
            return [];
        }
        
        // === MAKE FUNCTIONS GLOBALLY AVAILABLE ===
        window.getRoutineCompletions = getRoutineCompletions;
        window.loadRoutineCompletions = loadRoutineCompletions;
        window.loadRoutineStates = loadRoutineStates;
        window.updateRoutineProgress = updateRoutineProgress;

        // === EVENT LISTENERS ===
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Skip action buttons - they have their own handlers
                if (tab.id === 'logout-btn' || tab.id === 'settings-btn' || tab.id === 'timer-btn' || tab.id === 'quick-add-btn') return;
                
                const tabId = tab.getAttribute('data-tab');
                if (tabId) switchTab(tabId);
            });
        });
        
        // Settings button event listener
        const settingsBtn = document.getElementById('settings-btn');
        if (settingsBtn) {
            settingsBtn.addEventListener('click', () => {
                console.log('Settings clicked');
                switchTab('tab-settings');
            });
        }

        // Quick-add button event listener
        const quickAddBtn = document.getElementById('quick-add-btn');
        if (quickAddBtn) {
            quickAddBtn.addEventListener('click', () => {
                console.log('Quick-add clicked');
                if (window.QuickAdd) {
                    window.QuickAdd.show();
                }
            });
            
            // Setup Quick-Add animation after Lucide processes icons
            function setupQuickAddAnimation() {
                let quickAddIcon = quickAddBtn.querySelector('svg');
                
                if (quickAddIcon) {
                    quickAddIcon.style.cssText = `
                        transition: all 0.3s ease !important;
                        transform-origin: center !important;
                        display: inline-block !important;
                    `;
                    
                    quickAddBtn.onmouseenter = function() {
                        const svg = quickAddBtn.querySelector('svg');
                        if (svg) {
                            svg.style.transform = 'rotate(90deg)';
                            svg.style.stroke = '#059669';
                        }
                    };
                    
                    quickAddBtn.onmouseleave = function() {
                        const svg = quickAddBtn.querySelector('svg');
                        if (svg) {
                            svg.style.transform = 'rotate(0deg)';
                            svg.style.stroke = '';
                        }
                    };
                    
                    return true;
                }
                return false;
            }
            
            // Retry setup with delays for Lucide
            if (!setupQuickAddAnimation()) {
                setTimeout(() => {
                    if (!setupQuickAddAnimation()) {
                        setTimeout(setupQuickAddAnimation, 1000);
                    }
                }, 500);
            }
            
            // Setup Timer and Settings hover animations
            function setupActionButtonHovers() {
                const timerBtn = document.getElementById('timer-btn');
                const settingsBtn = document.getElementById('settings-btn');
                
                if (timerBtn?.querySelector('svg')) {
                    timerBtn.onmouseenter = function() {
                        const svg = timerBtn.querySelector('svg');
                        if (svg && !timerBtn.classList.contains('timer-running') && !timerBtn.classList.contains('timer-paused')) {
                            svg.style.stroke = '#059669';
                            svg.style.color = '#059669';
                        }
                    };
                    timerBtn.onmouseleave = function() {
                        const svg = timerBtn.querySelector('svg');
                        if (svg && !timerBtn.classList.contains('timer-running') && !timerBtn.classList.contains('timer-paused')) {
                            svg.style.stroke = '';
                            svg.style.color = '';
                        }
                    };
                }
                
                if (settingsBtn?.querySelector('svg')) {
                    settingsBtn.onmouseenter = function() {
                        const svg = settingsBtn.querySelector('svg');
                        if (svg) {
                            svg.style.stroke = '#059669';
                            svg.style.color = '#059669';
                        }
                    };
                    settingsBtn.onmouseleave = function() {
                        const svg = settingsBtn.querySelector('svg');
                        if (svg) {
                            svg.style.stroke = '';
                            svg.style.color = '';
                        }
                    };
                }
            }
            
            // Setup action button hovers after Lucide
            setTimeout(setupActionButtonHovers, 1000);
        }

        // Timer button event listener
        const timerBtn = document.getElementById('timer-btn');
        if (timerBtn) {
            // Left click: start/stop
            timerBtn.addEventListener('click', () => {
                console.log('Timer clicked');
                if (window.PomodoroTimer) {
                    window.PomodoroTimer.toggle();
                }
            });
            
            // Right click: reset to 25:00
            timerBtn.addEventListener('contextmenu', (e) => {
                e.preventDefault(); // Prevent context menu
                console.log('Timer right-clicked - reset');
                if (window.PomodoroTimer) {
                    window.PomodoroTimer.reset();
                }
            });
        }

        // Todo category tabs
        document.querySelectorAll('.category-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-category');
                switchCategory(categoryId);
            });
        });

        // Ziele category tabs
        document.querySelectorAll('.ziel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-ziel-category');
                switchZielCategory(categoryId);
            });
        });

        // Resource category tabs
        document.querySelectorAll('.resource-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-resource-category');
                switchResourceCategory(categoryId);
            });
        });

        // Journal category tabs
        document.querySelectorAll('.journal-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const categoryId = tab.getAttribute('data-journal-category');
                switchJournalCategory(categoryId);
            });
        });

        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', async function() {
                // ToDo-Items als completed markieren
                const todoItem = this.closest('.todo-item');
                if (todoItem) {
                    todoItem.classList.toggle('completed', this.checked);
                }
                
                // Routine-Progress aktualisieren (nur bei Routine-Checkboxen)
                const routineSection = this.closest('.routine-section');
                if (routineSection) {
                    // Apply visual styling immediately
                    const label = this.nextElementSibling;
                    if (label) {
                        if (this.checked) {
                            label.style.textDecoration = 'line-through';
                            label.style.color = '#999';
                        } else {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    }
                    
                    // DISABLED - SimpleRoutineManager handles this
                    // await saveCheckboxState(this.id, this.checked);
                    // updateRoutineProgress();
                }
            });
        });

        // === TODO MANAGEMENT ===
        const TodoManager = {
            todos: [], // In-memory storage for demo
            
            priorityIntToString(priorityInt) {
                switch(priorityInt) {
                    case 1: return 'mittel'; // Map old niedrig to mittel
                    case 2: return 'mittel';
                    case 3: return 'wichtig';
                    case 4: return 'dringend';
                    default: return 'mittel';
                }
            },
            
            getPriorityString(priority) {
                if (typeof priority === 'string') {
                    return priority;
                }
                return this.priorityIntToString(priority);
            },
            
            getPriorityDisplay(priority) {
                const priorityStr = this.getPriorityString(priority);
                return priorityStr.charAt(0).toUpperCase() + priorityStr.slice(1);
            },
            
            async loadTodos() {
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ TodoManager: Not authenticated - pure cloud mode requires authentication');
                    this.todos = [];
                    return;
                }
                
                try {
                    const user = supabase.getCurrentUser();
                    const data = await supabase.query(`todos?user_id=eq.${user.id}&select=*`);
                    if (data && Array.isArray(data)) {
                        // Transform database data to match UI expectations
                        this.todos = data.map(todo => {
                            // Convert priority integer back to string
                            let priorityString = 'mittel';
                            switch(todo.priority) {
                                case 1: priorityString = 'mittel'; break; // Map old niedrig to mittel
                                case 2: priorityString = 'mittel'; break;
                                case 3: priorityString = 'wichtig'; break;
                                case 4: priorityString = 'dringend'; break;
                                default: priorityString = 'mittel';
                            }
                            
                            return {
                                ...todo,
                                title: todo.text, // Map text to title for UI
                                deadline: todo.date, // Use date field only (no due_date)
                                priority: priorityString // Convert integer to string
                            };
                        });
                        this.refreshCurrentView();
                        this.updateHomeTodos();
                    } else {
                        console.log('â˜ï¸ TodoManager: No todos found in cloud');
                        this.todos = [];
                    }
                } catch (error) {
                    console.error('âŒ TodoManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            showAddTodoModal() {
                const modal = document.getElementById('add-todo-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('todo-deadline').value = today;
            },
            
            hideAddTodoModal() {
                const modal = document.getElementById('add-todo-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-todo-form').reset();
                // Reset to default values
                document.getElementById('todo-time').value = '21:00';
                document.getElementById('todo-priority').value = 'mittel';
            },
            
            async addTodo(todoData) {
                // DON'T create due_date with timezone - it causes issues
                // Just store date and time separately
                
                // Convert priority string to integer
                let priorityInt = 2; // Default to mittel
                switch(todoData.priority) {
                    case 'niedrig': priorityInt = 1; break; // Keep for backwards compatibility
                    case 'mittel': priorityInt = 2; break;
                    case 'wichtig': priorityInt = 3; break;
                    case 'dringend': priorityInt = 4; break;
                    default: priorityInt = 2;
                }
                
                const todo = {
                    text: todoData.title,
                    category: todoData.category,
                    priority: priorityInt,
                    date: todoData.deadline,
                    time: todoData.time,
                    // Remove due_date field to avoid timezone issues
                    completed: false,
                    user_id: supabase?.user?.id || 'anonymous'
                };
                
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ TodoManager: Not authenticated - cannot add todo in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Todo kann nicht gespeichert werden.');
                    return;
                }
                
                try {
                    const result = await supabase.insert('todos', todo);
                    console.log('ðŸ’¾ Supabase insert result:', result);
                    if (result && Array.isArray(result) && result.length > 0) {
                        // Transform the database result to match UI expectations
                        const dbTodo = result[0];
                        console.log('â˜ï¸ TodoManager: Todo saved to cloud with ID:', dbTodo.id);
                        const uiTodo = {
                            ...dbTodo,
                            title: dbTodo.text,
                            deadline: dbTodo.date, // Use date field only
                            priority: this.priorityIntToString(dbTodo.priority || 1)
                        };
                        this.todos.push(uiTodo);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('âŒ TodoManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Todos: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.category-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-category') : 'heute';
                
                console.log('ðŸ”„ Refreshing view for category:', activeCategory);
                
                this.displayTodosForCategory(activeCategory);
                
                // Also update home todos
                this.updateHomeTodos();
                
                // Update overdue badge
                this.updateOverdueBadge();
            },
            
            updateOverdueBadge() {
                // Count overdue todos
                const today = new Date();
                const todayStr = today.getFullYear() + '-' + 
                               String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(today.getDate()).padStart(2, '0');
                
                const overdueCount = this.todos.filter(todo => 
                    todo.date && todo.date < todayStr && !todo.completed
                ).length;
                
                const badge = document.getElementById('overdue-count');
                if (badge) {
                    if (overdueCount > 0) {
                        badge.textContent = overdueCount;
                        badge.style.display = 'inline';
                    } else {
                        badge.style.display = 'none';
                    }
                }
            },
            
            displayTodosForCategory(category) {
                const container = document.getElementById(category);
                if (!container) return;
                
                let filteredTodos = [];
                
                switch(category) {
                    case 'heute':
                        // Get today without timezone conversion
                        const today = new Date();
                        const todayStr = today.getFullYear() + '-' + 
                                       String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                                       String(today.getDate()).padStart(2, '0');
                        
                        // Include both today's todos AND overdue todos
                        filteredTodos = this.todos.filter(todo => 
                            todo.date && todo.date <= todayStr && !todo.completed
                        );
                        break;
                    case 'alle':
                        filteredTodos = this.todos.filter(todo => !todo.completed);
                        break;
                    case 'archiv':
                        filteredTodos = this.todos.filter(todo => todo.completed);
                        break;
                    default:
                        filteredTodos = this.todos.filter(todo => 
                            todo.category === category && !todo.completed
                        );
                }
                // Sort by date first, then by time
                filteredTodos.sort((a, b) => {
                    // First by date
                    const dateA = a.date || '9999-12-31';
                    const dateB = b.date || '9999-12-31';
                    const dateComparison = dateA.localeCompare(dateB);
                    
                    if (dateComparison !== 0) {
                        return dateComparison;
                    }
                    
                    // Then by time
                    const timeA = a.time || '23:59';
                    const timeB = b.time || '23:59';
                    return timeA.localeCompare(timeB);
                });
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredTodos.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Todos vorhanden</p>';
                    return;
                }
                
                // Create grid for todos
                const grid = document.createElement('div');
                grid.className = 'grid-3'; // 3-spaltig fÃ¼r kompaktere Todo-Kacheln
                
                // Display todos
                filteredTodos.forEach(todo => {
                    const todoElement = this.createTodoElement(todo);
                    grid.appendChild(todoElement);
                });
                
                container.appendChild(grid);
            },
            
            createTodoElement(todo) {
                const todoCard = document.createElement('div');
                todoCard.className = `ziel-card${todo.completed ? ' completed' : ''}`;
                todoCard.dataset.todoId = todo.id;
                
                // COMPLETELY AVOID DATE PARSING - just use raw strings
                let deadlineClass = '';
                let deadlineText = '';
                
                if (todo.date) {
                    // Get today as YYYY-MM-DD string (no timezone conversion)
                    const today = new Date();
                    const todayStr = today.getFullYear() + '-' + 
                                   String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                                   String(today.getDate()).padStart(2, '0');
                    
                    const isToday = todo.date === todayStr;
                    
                    if (todo.time) {
                        // Todo has both date and time
                        const todoDate = new Date(todo.date + 'T' + todo.time);
                        const now = new Date();
                        
                        if (isToday) {
                            // Check if time has passed for today
                            if (todoDate < now) {
                                deadlineClass = 'overdue';
                                deadlineText = `ÃœberfÃ¤llig ${todo.time}`;
                            } else {
                                deadlineClass = 'today';
                                deadlineText = `Heute ${todo.time}`;
                            }
                        } else if (todo.date < todayStr) {
                            // Past date - definitely overdue
                            deadlineClass = 'overdue';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = `ÃœberfÃ¤llig ${germanDate} ${todo.time}`;
                        } else {
                            // Future date
                            deadlineClass = 'soon';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = `${germanDate} ${todo.time}`;
                        }
                    } else {
                        // Todo has only date, no time
                        if (isToday) {
                            deadlineClass = 'today';
                            deadlineText = 'Heute';
                        } else if (todo.date < todayStr) {
                            // Past date - overdue
                            deadlineClass = 'overdue';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = `ÃœberfÃ¤llig ${germanDate}`;
                        } else {
                            // Future date
                            deadlineClass = 'soon';
                            const [year, month, day] = todo.date.split('-');
                            const germanDate = `${day}.${month}.${year}`;
                            deadlineText = germanDate;
                        }
                    }
                } else {
                    deadlineText = 'Kein Termin';
                    deadlineClass = 'none';
                }
                
                // Calculate days until deadline (similar to termine)
                let daysUntilText = '';
                let daysUntilBadge = '';
                if (todo.date) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const todoDateObj = new Date(todo.date);
                    todoDateObj.setHours(0, 0, 0, 0);
                    const daysDifference = Math.ceil((todoDateObj - today) / (1000 * 60 * 60 * 24));
                    
                    if (daysDifference === 0) {
                        daysUntilText = 'Heute';
                        daysUntilBadge = `<span class="days-until-badge heute">Heute</span>`;
                    } else if (daysDifference === 1) {
                        daysUntilText = 'Morgen';
                        daysUntilBadge = `<span class="days-until-badge morgen">Morgen</span>`;
                    } else if (daysDifference === -1) {
                        daysUntilText = 'Gestern';
                        daysUntilBadge = `<span class="days-until-badge overdue">1 Tag Ã¼berfÃ¤llig</span>`;
                    } else if (daysDifference > 1) {
                        daysUntilText = `in ${daysDifference} Tagen`;
                        daysUntilBadge = `<span class="days-until-badge future">${daysDifference} Tage</span>`;
                    } else if (daysDifference < -1) {
                        daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                        daysUntilBadge = `<span class="days-until-badge overdue">${Math.abs(daysDifference)} Tage Ã¼berfÃ¤llig</span>`;
                    }
                }

                todoCard.innerHTML = `
                    <div class="ziel-kategorie">${todo.category}</div>
                    <div class="ziel-header">
                        <div class="ziel-name">${todo.title}</div>
                        <div class="ziel-beschreibung">
                            <span class="todo-deadline ${deadlineClass}">${deadlineText}</span>
                            ${daysUntilBadge}
                        </div>
                    </div>
                    <div class="ziel-progress-section">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <input type="checkbox" class="todo-checkbox" ${todo.completed ? 'checked' : ''} 
                                   onchange="TodoManager.toggleTodo('${todo.id}')"
                                   style="width: 20px; height: 20px; border: 2px solid #000; appearance: none; cursor: pointer;">
                            <span class="todo-tag ${TodoManager.getPriorityString(todo.priority)}" style="margin-left: auto;">${TodoManager.getPriorityDisplay(todo.priority)}</span>
                        </div>
                    </div>
                `;
                
                // Add checkbox styling
                const checkbox = todoCard.querySelector('.todo-checkbox');
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        this.style.backgroundColor = '#000';
                        this.innerHTML = '<span style="color: white; position: absolute; top: -2px; left: 2px; font-size: 12px;">âœ“</span>';
                    } else {
                        this.style.backgroundColor = 'transparent';
                        this.innerHTML = '';
                    }
                });
                
                // Set initial checkbox state
                if (todo.completed) {
                    checkbox.style.backgroundColor = '#000';
                    checkbox.innerHTML = '<span style="color: white; position: absolute; top: -2px; left: 2px; font-size: 12px;">âœ“</span>';
                }
                
                return todoCard;
            },
            
            async toggleTodo(todoId) {
                
                const todo = this.todos.find(t => String(t.id) === String(todoId));
                if (todo) {
                    const wasCompleted = todo.completed;
                    todo.completed = !todo.completed;
                    
                    // Update counter display when todo status changes (now cloud-based)
                    if (todo.completed !== wasCompleted) {
                        console.log('â˜ï¸ Todo status changed, will refresh cloud counter after database update...');
                    }
                    
                    if (supabase?.isAuthenticated()) {
                        try {
                            console.log('ðŸ’¾ Updating in database - ID:', todo.id, 'Type:', typeof todo.id, 'Completed:', todo.completed);
                            
                            // Make sure we use the right ID type
                            const updateId = Number.isInteger(Number(todo.id)) ? Number(todo.id) : todo.id;
                            const result = await supabase.update('todos', { completed: todo.completed }, updateId);
                            
                            console.log('ðŸ’¾ Database update result:', result);
                            
                            console.log('âœ… Database update successful');
                            
                            // Refresh simple counter after successful database update
                            if (todo.completed !== wasCompleted) {
                                console.log('â˜ï¸ Refreshing todo counter via SimpleCounters...');
                                if (window.SimpleCounters) {
                                    window.SimpleCounters.onTodoChanged();
                                }
                            }
                            
                        } catch (error) {
                            console.error('âŒ Database update failed:', error);
                            alert('Fehler: ' + error.message + '\nTodo wird nicht gespeichert!');
                            // Revert on error
                            todo.completed = wasCompleted;
                            return; // Don't refresh if update failed
                        }
                    }
                    
                    this.refreshCurrentView();
                    this.updateHomeTodos();
                } else {
                    console.error('âŒ Todo not found for ID:', todoId);
                    alert('Todo nicht gefunden! ID: ' + todoId);
                }
            },
            
            async clearArchive() {
                console.log('â˜ï¸ TodoManager: clearArchive() called (pure cloud mode)');
                if (!confirm('Wirklich alle erledigten Todos dauerhaft lÃ¶schen?\n\nDiese Aktion kann nicht rÃ¼ckgÃ¤ngig gemacht werden!')) {
                    console.log('ðŸ” Archive clear cancelled by user');
                    return;
                }
                
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ TodoManager: Not authenticated - cannot clear archive in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Archive kann nicht geleert werden.');
                    return;
                }
                
                const completedTodos = this.todos.filter(todo => todo.completed);
                console.log('â˜ï¸ TodoManager: Deleting', completedTodos.length, 'completed todos from cloud');
                
                try {
                    // Delete from cloud database
                    for (const todo of completedTodos) {
                        console.log(`â˜ï¸ Deleting todo from cloud: ID ${todo.id}, Title: "${todo.title}"`);
                        if (!todo.id) {
                            console.warn(`âš ï¸ Skipping todo without ID: "${todo.title}"`);
                            continue;
                        }
                        const result = await supabase.delete('todos', String(todo.id));
                        console.log(`âœ… Delete result for ${todo.id}:`, result);
                    }
                    console.log('â˜ï¸ TodoManager: All completed todos deleted from cloud');
                    
                    // Remove from local array
                    this.todos = this.todos.filter(todo => !todo.completed);
                    
                    // Refresh current view
                    this.refreshCurrentView();
                    
                    alert(`âœ… ${completedTodos.length} erledigte Todos wurden gelÃ¶scht!`);
                } catch (error) {
                    console.error('âŒ TodoManager: Error deleting from cloud:', error);
                    alert('Fehler beim LÃ¶schen aus der Cloud: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            updateHomeTodos() {
                const homeContainer = document.getElementById('home-todos');
                if (!homeContainer) return;
                
                // Show today's and overdue uncompleted todos on home
                const today = new Date();
                const todayStr = today.getFullYear() + '-' + 
                               String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(today.getDate()).padStart(2, '0');
                
                const todayTodos = this.todos.filter(todo => 
                    todo.date && todo.date <= todayStr && !todo.completed
                ).sort((a, b) => {
                    // First sort by date (overdue first)
                    const dateA = a.date || '9999-12-31';
                    const dateB = b.date || '9999-12-31';
                    const dateComparison = dateA.localeCompare(dateB);
                    
                    if (dateComparison !== 0) {
                        return dateComparison;
                    }
                    
                    // Then by time
                    const timeA = a.time || '23:59';
                    const timeB = b.time || '23:59';
                    return timeA.localeCompare(timeB);
                });
                
                homeContainer.innerHTML = '';
                
                if (todayTodos.length === 0) {
                    homeContainer.innerHTML = '<p style="text-align: center; color: #666; padding: 1rem;">Keine Todos fÃ¼r heute</p>';
                    return;
                }
                
                todayTodos.forEach(todo => {
                    const todoItem = document.createElement('div');
                    todoItem.className = 'checkbox-item todo-item';
                    todoItem.innerHTML = `
                        <div class="todo-left">
                            <input type="checkbox" id="home-todo-${todo.id}" onchange="TodoManager.toggleTodo('${todo.id}')">
                            <label for="home-todo-${todo.id}">
                                ${todo.title} 
                                <span class="todo-tag ${TodoManager.getPriorityString(todo.priority)}" style="margin-left: 0.5rem;">${TodoManager.getPriorityDisplay(todo.priority)}</span>
                            </label>
                        </div>
                        <span class="todo-time">${todo.time || '21:00'}</span>
                    `;
                    homeContainer.appendChild(todoItem);
                });
                
                // Also update overdue badge when updating home
                this.updateOverdueBadge();
            }
        };

        // Make TodoManager globally available
        window.TodoManager = TodoManager;

        // === GOAL MANAGEMENT ===
        const GoalManager = {
            goals: [], // In-memory storage for demo
            
            async loadGoals() {
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ GoalManager: Not authenticated - pure cloud mode requires authentication');
                    this.goals = [];
                    return;
                }
                
                try {
                    const user = supabase.getCurrentUser();
                    const data = await supabase.query(`goals?user_id=eq.${user.id}&select=*`);
                    console.log('â˜ï¸ GoalManager: Raw goals from cloud:', data);
                    if (data && Array.isArray(data)) {
                        // Transform database data to match UI expectations
                        this.goals = data.map(goal => {
                            console.log('ðŸ”„ Transforming goal:', goal);
                            return {
                                ...goal,
                                name: goal.title, // Map title to name for UI
                                deadline: goal.target_date, // Map target_date to deadline for UI
                                progress: goal.progress || 0, // Use DB progress field
                                timeframe: goal.timeframe || 'monat', // Use DB timeframe field
                                completed: goal.completed, // Use DB completed field
                                // Map new progress fields
                                startValue: goal.start_value,
                                targetValue: goal.target_value, 
                                currentValue: goal.current_value,
                                unit: goal.unit
                            };
                        });
                        this.refreshCurrentView();
                    } else {
                        console.log('â˜ï¸ GoalManager: No goals found in cloud');
                        this.goals = [];
                    }
                } catch (error) {
                    console.error('âŒ GoalManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            // Calculate automatic deadlines based on timeframe
            calculateDeadline(timeframe) {
                const now = new Date();
                
                switch(timeframe) {
                    case 'monat': {
                        // Last day of current month - use day 0 of next month
                        const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                        // Format manually to avoid timezone issues
                        const year = endOfMonth.getFullYear();
                        const month = String(endOfMonth.getMonth() + 1).padStart(2, '0');
                        const day = String(endOfMonth.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    case 'quartal': {
                        // Last day of current quarter
                        const currentQuarter = Math.floor(now.getMonth() / 3);
                        const quarterEndMonth = (currentQuarter + 1) * 3; // 3, 6, 9, 12
                        const endOfQuarter = new Date(now.getFullYear(), quarterEndMonth, 0);
                        // Format manually to avoid timezone issues
                        const year = endOfQuarter.getFullYear();
                        const month = String(endOfQuarter.getMonth() + 1).padStart(2, '0');
                        const day = String(endOfQuarter.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }
                    case 'jahr': {
                        // December 31st of current year
                        const year = now.getFullYear();
                        return `${year}-12-31`;
                    }
                    default:
                        return now.toISOString().split('T')[0];
                }
            },
            
            showAddGoalModal() {
                const modal = document.getElementById('add-goal-modal');
                modal.classList.remove('hide');
                
                // Set default deadline based on current timeframe selection
                const timeframeSelect = document.getElementById('goal-timeframe');
                const deadlineInput = document.getElementById('goal-deadline');
                if (timeframeSelect && deadlineInput) {
                    deadlineInput.value = this.calculateDeadline(timeframeSelect.value);
                }
            },
            
            hideAddGoalModal() {
                const modal = document.getElementById('add-goal-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-goal-form').reset();
            },
            
            calculateProgress(startValue, targetValue, currentValue) {
                if (startValue === targetValue) return 100; // Edge case
                const progress = ((currentValue - startValue) / (targetValue - startValue)) * 100;
                return Math.max(0, Math.min(100, Math.round(progress))); // Clamp between 0-100
            },
            
            async addGoal(goalData) {
                const goal = {
                    id: Date.now().toString(),
                    name: goalData.name,
                    description: goalData.description,
                    category: goalData.category,
                    timeframe: goalData.timeframe, // WICHTIG: timeframe fÃ¼r Filterung
                    deadline: goalData.deadline,
                    unit: goalData.unit || '',
                    startValue: goalData.startValue || 0,
                    targetValue: goalData.targetValue,
                    currentValue: goalData.startValue || 0, // Start with start value
                    progress: 0, // Will be calculated
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                // Calculate initial progress
                goal.progress = this.calculateProgress(goal.startValue, goal.targetValue, goal.currentValue);
                
                console.log('ðŸŽ¯ Created goal with progress data:', {
                    name: goal.name,
                    startValue: goal.startValue,
                    targetValue: goal.targetValue,
                    currentValue: goal.currentValue,
                    unit: goal.unit,
                    progress: goal.progress
                });
                
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ GoalManager: Not authenticated - cannot add goal in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Ziel kann nicht gespeichert werden.');
                    return;
                }
                
                try {
                    // Map UI fields to database schema - all progress fields now supported
                    const dbGoal = {
                        title: goal.name,
                        description: goal.description,
                        category: goal.category,
                        target_date: goal.deadline,
                        progress: goal.progress,
                        timeframe: goal.timeframe,
                        completed: goal.completed,
                        start_value: goal.startValue,
                        target_value: goal.targetValue, 
                        current_value: goal.currentValue,
                        unit: goal.unit,
                        user_id: supabase?.user?.id
                    };
                    
                    console.log('â˜ï¸ GoalManager: Saving goal to cloud:', dbGoal);
                    const result = await supabase.insert('goals', dbGoal);
                    console.log('â˜ï¸ GoalManager: Cloud result:', result);
                    
                    if (result && Array.isArray(result) && result.length > 0) {
                        // Use database result and transform back to UI format
                        const savedGoal = {
                            ...result[0],
                            name: result[0].title,
                            deadline: result[0].target_date,
                            timeframe: result[0].timeframe,
                            progress: result[0].progress,
                            completed: result[0].completed,
                            startValue: result[0].start_value,
                            targetValue: result[0].target_value,
                            currentValue: result[0].current_value,
                            unit: result[0].unit,
                            database_id: result[0].id // Store real DB ID for updates
                        };
                        this.goals.push(savedGoal);
                        console.log('â˜ï¸ GoalManager: Goal saved to cloud with ID:', result[0].id);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('âŒ GoalManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Ziels: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('Goal added:', goal);
                console.log('All goals after adding:', this.goals);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.ziel-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-ziel-category') : 'alle';
                
                console.log('ðŸŽ¯ Goals refresh - active category:', activeCategory);
                console.log('ðŸŽ¯ All goals:', this.goals.map(g => ({name: g.name, category: g.category, timeframe: g.timeframe})));
                
                this.displayGoalsForCategory(activeCategory);
            },
            
            displayGoalsForCategory(category) {
                const container = document.getElementById(`ziel-${category}`);
                if (!container) return;
                
                let filteredGoals = [];
                
                switch(category) {
                    case 'monat':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'monat' && !goal.completed
                        );
                        break;
                    case 'quartal':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'quartal' && !goal.completed
                        );
                        break;
                    case 'jahr':
                        filteredGoals = this.goals.filter(goal => 
                            goal.timeframe === 'jahr' && !goal.completed
                        );
                        break;
                    case 'alle':
                        filteredGoals = this.goals.filter(goal => !goal.completed);
                        break;
                    case 'archiv':
                        filteredGoals = this.goals.filter(goal => goal.completed);
                        break;
                }
                
                // Sort by deadline
                filteredGoals.sort((a, b) => new Date(a.deadline) - new Date(b.deadline));
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredGoals.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Ziele vorhanden</p>';
                    return;
                }
                
                // Create grid for goals
                const grid = document.createElement('div');
                grid.className = 'grid-2';
                
                // Display goals
                filteredGoals.forEach(goal => {
                    const goalElement = this.createGoalElement(goal);
                    grid.appendChild(goalElement);
                });
                
                container.appendChild(grid);
            },
            
            createGoalElement(goal) {
                const goalCard = document.createElement('div');
                goalCard.className = `termin-card${goal.completed ? ' completed' : ''}`;
                goalCard.dataset.goalId = goal.id;
                
                // Calculate days until deadline (exactly like termine)
                let daysUntilText = '';
                let badgeColor1 = '';
                let badgeColor2 = '';
                let formattedDeadline = '';
                
                if (goal.deadline) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const goalDate = new Date(goal.deadline);
                    goalDate.setHours(0, 0, 0, 0);
                    const daysDifference = Math.ceil((goalDate - today) / (1000 * 60 * 60 * 24));
                    
                    // Format deadline like termine
                    formattedDeadline = goalDate.toLocaleDateString('de-DE', {
                        weekday: 'long',
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric'
                    });
                    
                    // Badge styling (exactly like termine)
                    if (daysDifference === 0) {
                        daysUntilText = 'Heute';
                        badgeColor1 = '#ef4444';
                        badgeColor2 = '#dc2626';
                    } else if (daysDifference === 1) {
                        daysUntilText = 'Morgen';
                        badgeColor1 = '#f97316';
                        badgeColor2 = '#ea580c';
                    } else if (daysDifference === -1) {
                        daysUntilText = 'Gestern';
                        badgeColor1 = '#6b7280';
                        badgeColor2 = '#4b5563';
                    } else if (daysDifference > 1) {
                        daysUntilText = `in ${daysDifference} Tagen`;
                        badgeColor1 = '#3b82f6';
                        badgeColor2 = '#2563eb';
                    } else if (daysDifference < -1) {
                        daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                        badgeColor1 = '#6b7280';
                        badgeColor2 = '#4b5563';
                    }
                }
                
                // Set CSS custom properties for badge colors (like terme)
                const badgeColorVars = `--badge-color-1: ${badgeColor1}; --badge-color-2: ${badgeColor2};`;
                goalCard.style.cssText += badgeColorVars;
                
                // Prepare progress display  
                const hasProgressData = goal.hasOwnProperty('startValue') && goal.hasOwnProperty('targetValue');
                console.log('ðŸ” hasProgressData:', hasProgressData);
                console.log('ðŸ” currentValue:', goal.currentValue, typeof goal.currentValue);
                const progressSection = hasProgressData ? `
                    <div class="goal-progress-section" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0;">
                        <div class="goal-values" style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem; color: #666;">
                            <span>${goal.startValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                            <span style="font-weight: 600; color: #000;">${goal.currentValue || goal.startValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                            <span>${goal.targetValue}${goal.unit ? ' ' + goal.unit : ''}</span>
                        </div>
                        <div class="progress-container" style="background: #f0f0f0; height: 6px; border-radius: 3px; overflow: hidden;">
                            <div class="progress-fill" style="background: linear-gradient(90deg, #3b82f6, #1d4ed8); height: 100%; width: ${goal.progress || 0}%; transition: width 0.3s ease;"></div>
                        </div>
                        <div style="text-align: center; margin-top: 0.5rem; font-size: 0.9rem; font-weight: 600; color: #1d4ed8;">
                            ${goal.progress || 0}%
                        </div>
                    </div>
                ` : '';
                
                console.log('ðŸ” progressSection generated:', hasProgressData ? 'YES' : 'NO');
                console.log('ðŸ” progressSection length:', progressSection.length);

                goalCard.innerHTML = `
                    ${daysUntilText ? `<div class="ziel-days-until">${daysUntilText}</div>` : ''}
                    <div class="ziel-kategorie">${goal.category}</div>
                    ${formattedDeadline ? `<div class="termin-date">ðŸŽ¯ ${formattedDeadline}</div>` : ''}
                    <div class="termin-title">${goal.name}</div>
                    <div class="termin-description">${goal.description}</div>
                    ${progressSection}
                    <div class="termin-edit-icon" onclick="GoalManager.showEditGoalValueModal('${goal.id}')">âœŽ</div>
                    <div class="termin-delete-icon" onclick="GoalManager.deleteGoal('${goal.id}')">ðŸ—‘</div>
                `;
                
                return goalCard;
            },
            
            async updateGoalProgress(goalId, newProgress) {
                const goal = this.goals.find(g => g.id == goalId); // Use == for flexible ID matching
                if (goal) {
                    const oldProgress = goal.progress;
                    goal.progress = parseInt(newProgress);
                    goal.completed = goal.progress >= 100;
                    
                    console.log('ðŸŽ¯ Updating goal:', goal.name, 'to progress:', goal.progress);
                    
                    // Check if goal has real database ID or use database_id field
                    const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                    
                    if (supabase?.isAuthenticated() && dbId) {
                        try {
                            console.log('ðŸ’¾ Updating goal in database with ID:', dbId);
                            const result = await supabase.update('goals', { 
                                progress: goal.progress,
                                completed: goal.completed
                            }, dbId);
                            console.log('âœ… Goal progress updated in cloud database:', result);
                        } catch (error) {
                            console.error('âŒ Error updating goal progress:', error);
                            // Don't revert - keep local change even if DB fails
                            console.warn('âš ï¸ Goal updated locally only (database update failed)');
                        }
                    } else {
                        console.warn('âš ï¸ Goal updated locally only (no database ID or not authenticated)');
                    }
                    
                    console.log('âœ… Goal progress updated locally:', goal);
                    this.refreshCurrentView();
                } else {
                    console.error('âŒ Goal not found for ID:', goalId);
                }
            },
            
            showEditGoalValueModal(goalId) {
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                const currentValue = goal.currentValue || goal.startValue || 0;
                const unit = goal.unit ? ` ${goal.unit}` : '';
                
                // Set modal title and current status
                document.getElementById('edit-goal-modal-title').textContent = `Fortschritt fÃ¼r "${goal.name}"`;
                document.getElementById('edit-goal-current-status').innerHTML = `
                    <strong>Aktueller Status:</strong><br>
                    Start: <strong>${goal.startValue}${unit}</strong> â†’ 
                    Ziel: <strong>${goal.targetValue}${unit}</strong><br>
                    Aktuell: <strong>${currentValue}${unit}</strong> 
                    (${goal.progress || 0}% erreicht)
                `;
                
                // Pre-fill current value
                document.getElementById('new-goal-value').value = currentValue;
                
                // Store goal ID for form submission
                document.getElementById('edit-goal-value-form').dataset.goalId = goalId;
                
                // Show modal
                document.getElementById('edit-goal-value-modal').classList.remove('hide');
                
                // Ensure event listeners are set up when modal opens
                console.log('ðŸŽ¯ Modal opened, reinitializing event listeners...');
                if (window.initGoalEditModalEventListeners) {
                    window.initGoalEditModalEventListeners();
                }
                
                // Focus input
                setTimeout(() => {
                    document.getElementById('new-goal-value').focus();
                    document.getElementById('new-goal-value').select();
                }, 100);
            },
            
            hideEditGoalValueModal() {
                document.getElementById('edit-goal-value-modal').classList.add('hide');
                document.getElementById('edit-goal-value-form').reset();
                delete document.getElementById('edit-goal-value-form').dataset.goalId;
            },
            
            async editGoalValue(goalId) {
                console.log('ðŸŽ¯ editGoalValue called with goalId:', goalId);
                
                // This method is now called by the modal form submission
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    console.error('âŒ Goal not found for ID:', goalId);
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                console.log('ðŸŽ¯ Found goal:', goal.name, 'Current value:', goal.currentValue);
                
                const newValueInput = document.getElementById('new-goal-value').value;
                console.log('ðŸŽ¯ Input value:', newValueInput);
                
                const newValue = parseFloat(newValueInput);
                if (isNaN(newValue)) {
                    console.error('âŒ Invalid number:', newValueInput);
                    alert('Bitte eine gÃ¼ltige Zahl eingeben!');
                    return;
                }
                
                console.log('ðŸŽ¯ Parsed new value:', newValue);
                
                // Pure cloud mode - require authentication
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ GoalManager: Not authenticated - cannot update goal value in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Ziel-Wert kann nicht aktualisiert werden.');
                    return;
                }
                
                const unit = goal.unit ? ` ${goal.unit}` : '';
                
                // Update values
                const oldCurrentValue = goal.currentValue;
                const oldProgress = goal.progress;
                
                goal.currentValue = newValue;
                goal.progress = this.calculateProgress(goal.startValue, goal.targetValue, goal.currentValue);
                goal.completed = goal.progress >= 100;
                
                console.log('ðŸŽ¯ Updated values:', {
                    oldCurrentValue,
                    newCurrentValue: goal.currentValue,
                    oldProgress,
                    newProgress: goal.progress,
                    startValue: goal.startValue,
                    targetValue: goal.targetValue
                });
                
                // Update in database - use database ID
                const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                console.log('ðŸŽ¯ Database ID for update:', dbId);
                
                if (dbId) {
                    try {
                        console.log('ðŸ’¾ Updating goal in database...');
                        const updateData = { 
                            current_value: goal.currentValue, // Use DB field name
                            progress: goal.progress,
                            completed: goal.completed
                        };
                        console.log('ðŸ’¾ Update data:', updateData);
                        
                        await supabase.update('goals', updateData, dbId);
                        console.log('âœ… Goal value updated in database');
                    } catch (error) {
                        console.error('âŒ Error updating goal value:', error);
                        alert('Fehler beim Speichern: ' + error.message);
                        return;
                    }
                } else {
                    console.error('âŒ No valid database ID found for goal:', goal);
                    alert('Fehler: Kann Ziel nicht in der Datenbank aktualisieren (keine gÃ¼ltige ID).');
                    return;
                }
                
                // Hide modal and refresh view
                console.log('ðŸŽ¯ Hiding modal and refreshing view...');
                this.hideEditGoalValueModal();
                this.refreshCurrentView();
                
                console.log('âœ… Goal value updated:', goal.name, `${goal.currentValue}${unit}`, `${goal.progress}%`);
            },
            
            async deleteGoal(goalId) {
                if (!confirm('Dieses Ziel ins Archiv verschieben?\n\n(Es wird als abgeschlossen markiert und ins Archiv verschoben)')) {
                    return;
                }
                
                const goal = this.goals.find(g => g.id == goalId);
                if (!goal) {
                    console.error('âŒ Goal not found for archiving:', goalId);
                    alert('Ziel nicht gefunden!');
                    return;
                }
                
                console.log('ðŸ“¦ Archiving goal:', goal.name);
                
                // Mark as completed (move to archive)
                const oldCompleted = goal.completed;
                goal.completed = true;
                goal.progress = 100; // Set to 100% when archived
                
                // Update in database if authenticated and has real DB ID
                const dbId = goal.database_id || (goal.id && !isNaN(goal.id) && goal.id.toString().length < 10 ? goal.id : null);
                
                if (supabase?.isAuthenticated() && dbId) {
                    try {
                        console.log('ðŸ’¾ Updating goal in database with ID:', dbId);
                        await supabase.update('goals', { 
                            completed: true,
                            progress: 100
                        }, dbId);
                        console.log('âœ… Goal archived in database');
                    } catch (error) {
                        console.error('âŒ Error archiving goal in database:', error);
                        alert('Fehler beim Archivieren: ' + error.message);
                        // Revert on error
                        goal.completed = oldCompleted;
                        return;
                    }
                }
                
                // Refresh current view
                this.refreshCurrentView();
                
                console.log('âœ… Goal archived successfully:', goal.name);
            },
            
            async clearGoalArchive() {
                if (!confirm('Wirklich alle erledigten Ziele dauerhaft lÃ¶schen?\n\nDiese Aktion kann nicht rÃ¼ckgÃ¤ngig gemacht werden!')) {
                    return;
                }
                
                const completedGoals = this.goals.filter(goal => goal.completed);
                console.log('ðŸ—‘ï¸ Deleting', completedGoals.length, 'completed goals from archive');
                
                if (supabase?.isAuthenticated()) {
                    try {
                        // Delete from database (only goals with database IDs)
                        for (const goal of completedGoals) {
                            const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                            if (hasDbId) {
                                await supabase.delete('goals', goal.id);
                                console.log('ðŸ’¾ Deleted goal from database:', goal.name);
                            } else {
                                console.log('ðŸ’¾ Skipped local-only goal:', goal.name);
                            }
                        }
                        console.log('âœ… All database goals deleted');
                    } catch (error) {
                        console.error('âŒ Error deleting goals from database:', error);
                        alert('Fehler beim LÃ¶schen aus der Datenbank: ' + error.message);
                        return;
                    }
                }
                
                // Remove from local array
                this.goals = this.goals.filter(goal => !goal.completed);
                
                // Refresh current view
                this.refreshCurrentView();
                
                alert(`âœ… ${completedGoals.length} erledigte Ziele wurden gelÃ¶scht!`);
            },
            
            clearLocalGoals() {
                if (confirm('Alle lokalen Ziele lÃ¶schen? (Nur Ziele die nicht in der Datenbank sind)\n\nDas kann alte/kaputte Ziele entfernen.')) {
                    const before = this.goals.length;
                    // Keep only goals that look like they have database IDs
                    this.goals = this.goals.filter(goal => {
                        const hasDbId = goal.id && !isNaN(goal.id) && goal.id.toString().length < 10;
                        return hasDbId;
                    });
                    const after = this.goals.length;
                    console.log(`ðŸ—‘ï¸ Removed ${before - after} local-only goals`);
                    this.refreshCurrentView();
                    alert(`${before - after} lokale Ziele gelÃ¶scht!`);
                }
            },
            
            editGoalProgress(goalId) {
                console.log('âœï¸ Edit goal progress - ID:', goalId, 'Type:', typeof goalId);
                const goal = this.goals.find(g => g.id == goalId); // Flexible matching
                if (!goal) {
                    console.error('âŒ Goal not found for edit. ID:', goalId);
                    console.log('âŒ Available goals:', this.goals.map(g => ({id: g.id, name: g.name})));
                    return;
                }
                console.log('âœï¸ Editing goal:', goal.name, 'Current progress:', goal.progress);
                
                // Find the goal card and progress percentage element
                const goalCard = document.querySelector(`[data-goal-id="${goalId}"]`);
                const percentageElement = goalCard.querySelector('.ziel-percentage');
                const progressFill = goalCard.querySelector('.progress-fill');
                
                // Create inline edit container
                const editContainer = document.createElement('div');
                editContainer.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; background: #f9f9f9; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px;';
                
                // Create progress input
                const input = document.createElement('input');
                input.type = 'number';
                input.min = '0';
                input.max = '100';
                input.value = goal.progress;
                input.style.cssText = 'width: 50px; padding: 2px 4px; border: 1px solid #ccc; font-size: 0.9rem; text-align: center;';
                
                // Create complete button
                const completeBtn = document.createElement('button');
                completeBtn.textContent = 'âœ“ Erledigt';
                completeBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; border: 1px solid #28a745; background: #28a745; color: white; border-radius: 3px; cursor: pointer;';
                
                // Create cancel button
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Ã—';
                cancelBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; border: 1px solid #ccc; background: #f8f9fa; border-radius: 3px; cursor: pointer;';
                
                editContainer.appendChild(input);
                editContainer.appendChild(completeBtn);
                editContainer.appendChild(cancelBtn);
                
                // Replace percentage display with edit container
                const originalText = percentageElement.textContent;
                percentageElement.replaceWith(editContainer);
                input.focus();
                input.select();
                
                // Prevent double execution
                let isHandled = false;
                
                // Handle save/cancel
                const saveProgress = async () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    const newValue = parseInt(input.value);
                    if (!isNaN(newValue) && newValue >= 0 && newValue <= 100) {
                        await this.updateGoalProgress(goalId, newValue);
                        
                        // Update UI
                        const newPercentageElement = document.createElement('span');
                        newPercentageElement.className = 'ziel-percentage';
                        newPercentageElement.textContent = `${newValue}%`;
                        editContainer.replaceWith(newPercentageElement);
                        
                        // Update progress bar
                        progressFill.style.width = `${newValue}%`;
                        
                        // Refresh view if goal completed
                        if (newValue >= 100) {
                            this.refreshCurrentView();
                        }
                    } else {
                        cancelEdit();
                    }
                };
                
                const markComplete = async () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    await this.updateGoalProgress(goalId, 100);
                    
                    // Update UI
                    const newPercentageElement = document.createElement('span');
                    newPercentageElement.className = 'ziel-percentage';
                    newPercentageElement.textContent = '100%';
                    editContainer.replaceWith(newPercentageElement);
                    
                    // Update progress bar
                    progressFill.style.width = '100%';
                    
                    // Refresh view to move to archive
                    this.refreshCurrentView();
                };
                
                const cancelEdit = () => {
                    if (isHandled) return;
                    isHandled = true;
                    
                    const newPercentageElement = document.createElement('span');
                    newPercentageElement.className = 'ziel-percentage';
                    newPercentageElement.textContent = originalText;
                    editContainer.replaceWith(newPercentageElement);
                };
                
                // Event listeners
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveProgress();
                    }
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
                
                completeBtn.addEventListener('click', markComplete);
                cancelBtn.addEventListener('click', cancelEdit);
                
                // Auto-save on blur for input
                input.addEventListener('blur', (e) => {
                    // Only if user didn't click on buttons
                    setTimeout(() => {
                        if (!isHandled && document.contains(editContainer)) {
                            saveProgress();
                        }
                    }, 100);
                });
            }
        };

        // Make GoalManager globally available
        window.GoalManager = GoalManager;

        // === JOURNAL MANAGEMENT ===
        const JournalManager = {
            entries: [], // In-memory storage for demo
            
            async loadEntries() {
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ JournalManager: Not authenticated - pure cloud mode requires authentication');
                    this.entries = [];
                    return;
                }
                
                try {
                    const data = await supabase.select('journal_entries', '*');
                    if (data && Array.isArray(data)) {
                        // Transform database data to ensure tags is always an array
                        this.entries = data.map(entry => {
                            let tags = [];
                            if (Array.isArray(entry.tags)) {
                                tags = entry.tags;
                            } else if (entry.tags) {
                                if (typeof entry.tags === 'string') {
                                    try {
                                        // Try to parse as JSON first
                                        tags = JSON.parse(entry.tags);
                                        if (!Array.isArray(tags)) {
                                            // If it's not an array, treat as single tag
                                            tags = [entry.tags];
                                        }
                                    } catch (e) {
                                        // If JSON.parse fails, treat as single tag
                                        tags = [entry.tags];
                                    }
                                } else {
                                    tags = [entry.tags];
                                }
                            }
                            return {
                                ...entry,
                                tags: tags
                            };
                        });
                        this.refreshCurrentView();
                    } else {
                        console.log('â˜ï¸ JournalManager: No entries found in cloud');
                        this.entries = [];
                    }
                } catch (error) {
                    console.error('âŒ JournalManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            showAddJournalModal() {
                const modal = document.getElementById('add-journal-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('journal-date').value = today;
            },
            
            hideAddJournalModal() {
                const modal = document.getElementById('add-journal-modal');
                modal.classList.add('hide');
                // Reset form
                document.getElementById('add-journal-form').reset();
                // Reset date back to today
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('journal-date').value = today;
            },
            
            async addEntry(entryData) {
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ JournalManager: Not authenticated - cannot add entry in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Journal-Eintrag kann nicht gespeichert werden.');
                    return;
                }
                
                const entry = {
                    title: entryData.title,
                    content: entryData.content,
                    tags: entryData.tags || [], // Array of tags
                    date: entryData.date, // Keep date for local use
                    entry_date: entryData.date, // Use entry_date for database
                    user_id: supabase?.user?.id,
                    created_at: new Date().toISOString()
                };
                
                try {
                    // Create database entry without 'date' and 'created_at' fields (auto-generated)
                    const dbEntry = { ...entry };
                    delete dbEntry.date;
                    delete dbEntry.created_at;
                    console.log('â˜ï¸ JournalManager: Saving entry to cloud:', dbEntry);
                    const result = await supabase.insert('journal_entries', dbEntry);
                    if (result && result.length > 0) {
                        this.entries.push(result[0]);
                        console.log('â˜ï¸ JournalManager: Entry saved to cloud with ID:', result[0].id);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('âŒ JournalManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Journal-Eintrags: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('â˜ï¸ JournalManager: Entry added:', entry);
                
                // Refresh current view
                this.refreshCurrentView();
            },
            
            refreshCurrentView() {
                // Get current active category
                const activeTab = document.querySelector('.journal-tab.active');
                const activeCategory = activeTab ? activeTab.getAttribute('data-journal-category') : 'alle';
                
                this.displayEntriesForCategory(activeCategory);
            },
            
            displayEntriesForCategory(category) {
                const container = document.getElementById(`journal-${category}`);
                if (!container) return;
                
                let filteredEntries = [];
                
                switch(category) {
                    case 'alle':
                        filteredEntries = this.entries;
                        break;
                    default:
                        // Filter entries that have the selected tag
                        filteredEntries = this.entries.filter(entry => 
                            entry.tags && entry.tags.includes(category)
                        );
                }
                
                // Sort by date (newest first)
                filteredEntries.sort((a, b) => new Date(b.entry_date || b.date) - new Date(a.entry_date || a.date));
                
                // Clear container
                container.innerHTML = '';
                
                if (filteredEntries.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Keine Journal-EintrÃ¤ge vorhanden</p>';
                    return;
                }
                
                // Create grid for entries
                const grid = document.createElement('div');
                grid.className = 'grid-2'; // 2-spaltig fÃ¼r Journal-EintrÃ¤ge
                
                // Display entries
                filteredEntries.forEach(entry => {
                    const entryElement = this.createEntryElement(entry);
                    grid.appendChild(entryElement);
                });
                
                container.appendChild(grid);
            },
            
            createEntryElement(entry) {
                const entryCard = document.createElement('div');
                entryCard.className = 'ziel-card';
                entryCard.dataset.entryId = entry.id;
                
                const entryDate = new Date(entry.entry_date || entry.date);
                const formattedDate = entryDate.toLocaleDateString('de-DE', {
                    day: '2-digit',
                    month: '2-digit', 
                    year: 'numeric'
                });
                
                // Ensure tags is always an array before mapping
                const tags = Array.isArray(entry.tags) ? entry.tags : 
                           (entry.tags ? (typeof entry.tags === 'string' ? JSON.parse(entry.tags) : []) : []);
                const tagsHtml = tags.length > 0 
                    ? tags.map(tag => `<span class="todo-tag normal" style="margin-right: 0.5rem;">${tag}</span>`).join('')
                    : '';
                
                entryCard.innerHTML = `
                    <div class="ziel-header">
                        <div class="ziel-name">${entry.title}</div>
                        <div class="ziel-beschreibung">${entry.content}</div>
                    </div>
                    <div class="ziel-progress-section">
                        <div class="ziel-progress-header">
                            <span class="ziel-progress-label">${formattedDate}</span>
                            <button class="delete-entry-btn" data-entry-id="${entry.id}" style="background: none; border: none; color: #cc0000; cursor: pointer; padding: 0.25rem; font-size: 0.9rem;" title="Eintrag lÃ¶schen">
                                ðŸ—‘ï¸
                            </button>
                        </div>
                        <div style="margin-top: 0.5rem;">
                            ${tagsHtml}
                        </div>
                    </div>
                `;
                
                return entryCard;
            },
            
            async deleteEntry(entryId) {
                if (!confirm('Diesen Journal-Eintrag wirklich lÃ¶schen?')) {
                    return;
                }
                
                try {
                    // Delete from database if authenticated
                    if (supabase?.isAuthenticated()) {
                        await supabase.delete('journal_entries', entryId);
                        console.log('âœ… Journal entry deleted from database:', entryId);
                    }
                    
                    // Remove from local entries array
                    this.entries = this.entries.filter(entry => entry.id != entryId);
                    
                    // Refresh current view
                    this.refreshCurrentView();
                    
                    console.log('âœ… Journal entry deleted:', entryId);
                } catch (error) {
                    console.error('âŒ Error deleting journal entry:', error);
                    alert('Fehler beim LÃ¶schen des Eintrags: ' + error.message);
                }
            }
        };

        // Make JournalManager globally available
        window.JournalManager = JournalManager;

        // === TERMIN MANAGEMENT ===
        const TerminManager = {
            termine: [], // In-memory storage for demo
            
            async loadTermine(forceReload = false) {
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ TerminManager: Not authenticated - pure cloud mode requires authentication');
                    this.termine = [];
                    this.displayTermine();
                    return;
                }
                
                try {
                    console.log('â˜ï¸ TerminManager: Loading termine from cloud...');
                    const user = supabase.getCurrentUser();
                    const data = await supabase.query(`termine?user_id=eq.${user.id}&select=*`);
                    
                    if (data && Array.isArray(data)) {
                        this.termine = data;
                        this.displayTermine();
                    } else {
                        console.log('â˜ï¸ TerminManager: No termine found in cloud');
                        this.termine = [];
                        this.displayTermine();
                    }
                } catch (error) {
                    console.error('âŒ TerminManager: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            showAddTerminModal() {
                const modal = document.getElementById('add-termin-modal');
                modal.classList.remove('hide');
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('termin-date').value = today;
                
                // Leave time field empty - user can fill if needed
                document.getElementById('termin-time').value = '';
            },
            
            hideAddTerminModal() {
                const modal = document.getElementById('add-termin-modal');
                const form = document.getElementById('add-termin-form');
                const submitBtn = form.querySelector('button[type="submit"]');
                
                modal.classList.add('hide');
                form.reset();
                delete form.dataset.editId; // Clear edit mode
                if (submitBtn) {
                    submitBtn.textContent = 'HinzufÃ¼gen'; // Reset button text
                }
            },
            
            async addTermin(terminData) {
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ TerminManager: Not authenticated - cannot add termin in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Termin kann nicht gespeichert werden.');
                    return;
                }
                
                const termin = {
                    title: terminData.title,
                    description: terminData.description,
                    date: terminData.date,
                    time: terminData.time,
                    user_id: supabase.getCurrentUser().id,
                    created_at: new Date().toISOString()
                };
                
                try {
                    console.log('â˜ï¸ TerminManager: Saving termin to cloud:', termin.title);
                    const result = await supabase.insert('termine', termin);
                    if (result && result.length > 0) {
                        this.termine.push(result[0]);
                        console.log('â˜ï¸ TerminManager: Termin saved to cloud with ID:', result[0].id);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('âŒ TerminManager: Error saving to cloud:', error);
                    alert('Fehler beim Speichern des Termins: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('â˜ï¸ TerminManager: Termin added:', termin);
                this.displayTermine();
            },
            
            async updateTermin(terminId, terminData) {
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ TerminManager: Not authenticated - cannot update termin in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Termin kann nicht aktualisiert werden.');
                    return;
                }
                
                const terminIndex = this.termine.findIndex(t => t.id == terminId);
                if (terminIndex === -1) {
                    console.error('âŒ TerminManager: Termin not found for update:', terminId);
                    alert('Termin nicht gefunden!');
                    return;
                }
                
                const updatedTermin = {
                    ...this.termine[terminIndex],
                    title: terminData.title,
                    description: terminData.description,
                    date: terminData.date,
                    time: terminData.time,
                    updated_at: new Date().toISOString()
                };
                
                try {
                    console.log('â˜ï¸ TerminManager: Updating termin in cloud:', terminId);
                    await supabase.update('termine', updatedTermin, terminId);
                    this.termine[terminIndex] = updatedTermin;
                    console.log('â˜ï¸ TerminManager: Termin updated in cloud');
                } catch (error) {
                    console.error('âŒ TerminManager: Error updating in cloud:', error);
                    alert('Fehler beim Aktualisieren des Termins: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                console.log('â˜ï¸ TerminManager: Termin updated:', updatedTermin);
                this.displayTermine();
            },
            
            displayTermine() {
                console.log('ðŸ“… TerminManager.displayTermine() called');
                console.log('ðŸ“Š Current termine in memory:', this.termine);
                
                const container = document.getElementById('termine-container');
                if (!container) {
                    console.error('âŒ Termine container DOM element not found - check if #termine-container exists');
                    return;
                }
                
                console.log('âœ… Termine container found:', container);
                
                // Clear container
                container.innerHTML = '';
                
                if (this.termine.length === 0) {
                    console.log('â„¹ï¸ No termine to display - showing empty state message');
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem; grid-column: 1 / -1;">Keine Termine vorhanden</p>';
                    return;
                }
                
                
                // Sort by date/time (earliest first)
                const sortedTermine = this.termine.sort((a, b) => {
                    const dateTimeA = new Date(`${a.date}T${a.time || '00:00'}`);
                    const dateTimeB = new Date(`${b.date}T${b.time || '00:00'}`);
                    return dateTimeA - dateTimeB;
                });
                
                console.log('ðŸ”„ Termine sorted by date:', sortedTermine.map(t => `${t.title} - ${t.date}`));
                
                // Add termine
                sortedTermine.forEach((termin, index) => {
                    console.log(`ðŸ”„ Creating element for termin ${index + 1}:`, termin.title);
                    const terminElement = this.createTerminElement(termin);
                    container.appendChild(terminElement);
                });
                
                console.log('âœ… All termine rendered to DOM');
            },
            
            createTerminElement(termin) {
                const terminCard = document.createElement('div');
                terminCard.className = 'termin-card';
                terminCard.dataset.terminId = termin.id;
                
                const terminDate = new Date(termin.date);
                const formattedDate = terminDate.toLocaleDateString('de-DE', {
                    weekday: 'long',
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                });
                
                let displayDate = formattedDate;
                if (termin.time) {
                    const timeDate = new Date(`${termin.date}T${termin.time}`);
                    const formattedTime = timeDate.toLocaleTimeString('de-DE', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    displayDate += `, ${formattedTime}`;
                }
                
                // Calculate days until appointment
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const appointmentDate = new Date(termin.date);
                appointmentDate.setHours(0, 0, 0, 0);
                const daysDifference = Math.ceil((appointmentDate - today) / (1000 * 60 * 60 * 24));
                
                let daysUntilText = '';
                let badgeColor1 = '';
                let badgeColor2 = '';
                
                if (daysDifference === 0) {
                    daysUntilText = 'Heute';
                    badgeColor1 = '#ef4444';
                    badgeColor2 = '#dc2626';
                } else if (daysDifference === 1) {
                    daysUntilText = 'Morgen';
                    badgeColor1 = '#f97316';
                    badgeColor2 = '#ea580c';
                } else if (daysDifference === -1) {
                    daysUntilText = 'Gestern';
                    badgeColor1 = '#6b7280';
                    badgeColor2 = '#4b5563';
                } else if (daysDifference > 1) {
                    daysUntilText = `in ${daysDifference} Tagen`;
                    badgeColor1 = '#3b82f6';
                    badgeColor2 = '#2563eb';
                } else if (daysDifference < -1) {
                    daysUntilText = `vor ${Math.abs(daysDifference)} Tagen`;
                    badgeColor1 = '#6b7280';
                    badgeColor2 = '#4b5563';
                }
                
                // Set CSS custom properties for badge colors
                const badgeColorVars = `--badge-color-1: ${badgeColor1}; --badge-color-2: ${badgeColor2};`;
                
                terminCard.style.cssText += badgeColorVars;
                
                terminCard.innerHTML = `
                    <div class="termin-days-until">${daysUntilText}</div>
                    <div class="termin-date">${displayDate}</div>
                    <div class="termin-title">${termin.title}</div>
                    <div class="termin-description">${termin.description}</div>
                    <div class="termin-edit-icon" onclick="TerminManager.editTermin('${termin.id}')">âœŽ</div>
                    <div class="termin-delete-icon" onclick="TerminManager.deleteTermin('${termin.id}')">ðŸ—‘</div>
                `;
                
                return terminCard;
            },
            
            async editTermin(terminId) {
                console.log('ðŸ–Šï¸ Edit termin clicked:', terminId);
                console.log('ðŸ“‹ Available termine:', this.termine);
                
                const termin = this.termine.find(t => t.id == terminId);
                if (!termin) {
                    console.error('âŒ Termin not found:', terminId);
                    alert('Termin nicht gefunden!');
                    return;
                }
                
                console.log('âœ… Found termin for editing:', termin);
                
                // Pre-fill the form with existing values
                document.getElementById('termin-title').value = termin.title;
                document.getElementById('termin-description').value = termin.description;
                document.getElementById('termin-date').value = termin.date;
                document.getElementById('termin-time').value = termin.time || '';
                
                // Store the ID for updating
                const form = document.getElementById('add-termin-form');
                form.dataset.editId = terminId;
                
                // Change button text
                const submitBtn = form.querySelector('button[type="submit"]');
                submitBtn.textContent = 'Termin aktualisieren';
                
                console.log('ðŸ“ Form prepared for editing, opening modal...');
                
                // Show modal
                this.showAddTerminModal();
            },
            
            async deleteTermin(terminId) {
                if (!confirm('MÃ¶chtest du diesen Termin wirklich lÃ¶schen?')) {
                    return;
                }
                
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ TerminManager: Not authenticated - cannot delete termin in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Termin kann nicht gelÃ¶scht werden.');
                    return;
                }
                
                try {
                    console.log('â˜ï¸ TerminManager: Deleting termin from cloud:', terminId);
                    await supabase.delete('termine', terminId);
                    console.log('â˜ï¸ TerminManager: Termin deleted from cloud');
                } catch (error) {
                    console.error('âŒ TerminManager: Error deleting from cloud:', error);
                    alert('Fehler beim LÃ¶schen: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                // Remove from local array
                this.termine = this.termine.filter(t => t.id != terminId);
                
                // Pure cloud mode - no localStorage caching
                
                // Refresh view
                this.displayTermine();
                
                console.log('â˜ï¸ TerminManager: Termin deleted successfully');
            }
        };

        // Make TerminManager globally available
        window.TerminManager = TerminManager;

        // === INITIALIZE ===
        document.addEventListener('DOMContentLoaded', async () => {
            // Logout is now handled by separate logout.html page
            
            console.log('âœ… DOM loaded');
            
            // Initialize Supabase first
            if (window.initializeSupabase) {
                window.initializeSupabase();
            }
            
            // Initialize authentication (this will handle data loading via showDashboard)
            await Auth.init();
            
            // Initialize Wiki
            if (window.Wiki) {
                Wiki.init();
            }
            
            // Initialize Lucide icons globally
            if (window.lucide) {
                lucide.createIcons();
            }
            
            // ResourceManager will be initialized after its definition (moved down)
            
            // Logout button is already handled by Auth.setupEventListeners()
            
            // Journal form submission
            const journalForm = document.querySelector('.journal-form');
            if (journalForm) {
                journalForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const input = this.querySelector('.journal-input');
                    if (input.value.trim()) {
                        console.log('Journal entry:', input.value);
                        input.value = '';
                    }
                });
            }
            
            // Add Todo Button
            const addTodoBtn = document.getElementById('add-todo-btn');
            if (addTodoBtn) {
                addTodoBtn.addEventListener('click', () => {
                    TodoManager.showAddTodoModal();
                });
            }
            
            // Clear Archive Button
            const clearArchiveBtn = document.getElementById('clear-archive-btn');
            if (clearArchiveBtn) {
                clearArchiveBtn.addEventListener('click', () => {
                    TodoManager.clearArchive();
                });
            }
            
            // Cancel Todo Button
            const cancelTodoBtn = document.getElementById('cancel-todo-btn');
            if (cancelTodoBtn) {
                cancelTodoBtn.addEventListener('click', () => {
                    TodoManager.hideAddTodoModal();
                });
            }
            
            // Add Todo Form Submission
            const addTodoForm = document.getElementById('add-todo-form');
            if (addTodoForm) {
                addTodoForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const todoData = {
                        title: document.getElementById('todo-title').value,
                        category: document.getElementById('todo-category').value,
                        priority: document.getElementById('todo-priority').value,
                        deadline: document.getElementById('todo-deadline').value,
                        time: document.getElementById('todo-time').value
                    };
                    
                    console.log('ðŸ“ Form data being sent:', todoData);
                    console.log('ðŸ“ Priority element value:', document.getElementById('todo-priority').value);
                    console.log('ðŸ“ Priority element selectedIndex:', document.getElementById('todo-priority').selectedIndex);
                    
                    await TodoManager.addTodo(todoData);
                    TodoManager.hideAddTodoModal();
                });
            }
            
            // Close modal when clicking outside
            const addTodoModal = document.getElementById('add-todo-modal');
            if (addTodoModal) {
                addTodoModal.addEventListener('click', (e) => {
                    if (e.target === addTodoModal) {
                        TodoManager.hideAddTodoModal();
                    }
                });
            }
            
            // === GOAL EVENT LISTENERS ===
            
            // Add Goal Button
            const addGoalBtn = document.getElementById('add-goal-btn');
            if (addGoalBtn) {
                addGoalBtn.addEventListener('click', () => {
                    GoalManager.showAddGoalModal();
                });
            }
            
            // Cancel Goal Button
            const cancelGoalBtn = document.getElementById('cancel-goal-btn');
            if (cancelGoalBtn) {
                cancelGoalBtn.addEventListener('click', () => {
                    GoalManager.hideAddGoalModal();
                });
            }
            
            // Add Goal Form Submission
            const addGoalForm = document.getElementById('add-goal-form');
            if (addGoalForm) {
                addGoalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const goalData = {
                        name: document.getElementById('goal-name').value,
                        description: document.getElementById('goal-description').value,
                        category: document.getElementById('goal-category').value,
                        timeframe: document.getElementById('goal-timeframe').value,
                        deadline: document.getElementById('goal-deadline').value,
                        unit: document.getElementById('goal-unit').value,
                        startValue: parseFloat(document.getElementById('goal-start-value').value) || 0,
                        targetValue: parseFloat(document.getElementById('goal-target-value').value)
                    };
                    
                    await GoalManager.addGoal(goalData);
                    GoalManager.hideAddGoalModal();
                });
            }
            
            // Timeframe change listener - automatically update deadline
            const goalTimeframeSelect = document.getElementById('goal-timeframe');
            if (goalTimeframeSelect) {
                goalTimeframeSelect.addEventListener('change', (e) => {
                    const deadlineInput = document.getElementById('goal-deadline');
                    if (deadlineInput) {
                        deadlineInput.value = GoalManager.calculateDeadline(e.target.value);
                    }
                });
            }
            
            // Close goal modal when clicking outside
            const addGoalModal = document.getElementById('add-goal-modal');
            if (addGoalModal) {
                addGoalModal.addEventListener('click', (e) => {
                    if (e.target === addGoalModal) {
                        GoalManager.hideAddGoalModal();
                    }
                });
            }
            
            // Clear Goal Archive Button
            const clearGoalArchiveBtn = document.getElementById('clear-goal-archive-btn');
            if (clearGoalArchiveBtn) {
                clearGoalArchiveBtn.addEventListener('click', () => {
                    GoalManager.clearGoalArchive();
                });
            }
            
            // === JOURNAL EVENT LISTENERS ===
            
            // Add Journal Button
            const addJournalBtn = document.getElementById('add-journal-btn');
            if (addJournalBtn) {
                addJournalBtn.addEventListener('click', () => {
                    JournalManager.showAddJournalModal();
                });
            }
            
            // Cancel Journal Button
            const cancelJournalBtn = document.getElementById('cancel-journal-btn');
            if (cancelJournalBtn) {
                cancelJournalBtn.addEventListener('click', () => {
                    JournalManager.hideAddJournalModal();
                });
            }
            
            // Tag selection functionality
            let selectedTags = [];
            
            function updateTagsDisplay() {
                const hiddenInput = document.getElementById('journal-category');
                
                // Update hidden input (use first tag or 'allgemein' as fallback for compatibility)
                hiddenInput.value = selectedTags.length > 0 ? selectedTags[0] : 'allgemein';
                
                // Update tag option buttons
                document.querySelectorAll('.tag-option').forEach(btn => {
                    const tag = btn.getAttribute('data-tag');
                    btn.classList.toggle('selected', selectedTags.includes(tag));
                });
            }
            
            // Tag option click handlers
            document.querySelectorAll('.tag-option').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    
                    // If clicking on the X, remove the tag
                    if (e.target.classList.contains('remove-tag')) {
                        const tag = btn.getAttribute('data-tag');
                        selectedTags = selectedTags.filter(t => t !== tag);
                        updateTagsDisplay();
                        return;
                    }
                    
                    const tag = btn.getAttribute('data-tag');
                    
                    if (selectedTags.includes(tag)) {
                        // Already selected, remove it
                        selectedTags = selectedTags.filter(t => t !== tag);
                    } else {
                        // Not selected, add it
                        selectedTags.push(tag);
                    }
                    
                    updateTagsDisplay();
                });
            });
            
            // Add Journal Form Submission
            const addJournalForm = document.getElementById('add-journal-form');
            if (addJournalForm) {
                addJournalForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    if (selectedTags.length === 0) {
                        alert('Bitte wÃ¤hle mindestens einen Tag aus.');
                        return;
                    }
                    
                    const entryData = {
                        title: document.getElementById('journal-title').value,
                        content: document.getElementById('journal-content').value,
                        tags: [...selectedTags], // Copy array
                        date: document.getElementById('journal-date').value
                    };
                    
                    await JournalManager.addEntry(entryData);
                    JournalManager.hideAddJournalModal();
                    
                    // Reset tags
                    selectedTags = [];
                    updateTagsDisplay();
                });
            }
            
            // Close journal modal when clicking outside
            const addJournalModal = document.getElementById('add-journal-modal');
            if (addJournalModal) {
                addJournalModal.addEventListener('click', (e) => {
                    if (e.target === addJournalModal) {
                        JournalManager.hideAddJournalModal();
                    }
                });
            }
            
            // === TERMIN EVENT LISTENERS ===
            
            // Add Termin Button
            const addTerminBtn = document.getElementById('add-termin-btn');
            if (addTerminBtn) {
                addTerminBtn.addEventListener('click', () => {
                    TerminManager.showAddTerminModal();
                });
            }
            
            // Cancel Termin Button
            const cancelTerminBtn = document.getElementById('cancel-termin-btn');
            if (cancelTerminBtn) {
                cancelTerminBtn.addEventListener('click', () => {
                    TerminManager.hideAddTerminModal();
                });
            }
            
            // Add Termin Form Submission
            const addTerminForm = document.getElementById('add-termin-form');
            if (addTerminForm) {
                addTerminForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const terminData = {
                        title: document.getElementById('termin-title').value,
                        description: document.getElementById('termin-description').value,
                        date: document.getElementById('termin-date').value,
                        time: document.getElementById('termin-time').value
                    };
                    
                    // Check if we're editing an existing termin
                    const editId = addTerminForm.dataset.editId;
                    if (editId) {
                        await TerminManager.updateTermin(editId, terminData);
                    } else {
                        await TerminManager.addTermin(terminData);
                    }
                    
                    TerminManager.hideAddTerminModal();
                });
            }
            
            // Close termin modal when clicking outside
            const addTerminModal = document.getElementById('add-termin-modal');
            if (addTerminModal) {
                addTerminModal.addEventListener('click', (e) => {
                    if (e.target === addTerminModal) {
                        TerminManager.hideAddTerminModal();
                    }
                });
            }
            
            // Load routine states on page load
            loadRoutineStates();
            
            // Update routine progress to reflect loaded states
            updateRoutineProgress();
            
            // Initialize settings functionality
            initializeSettings();
            
            // Todo counter is now initialized in showDashboard() after authentication
            
            // === EDIT GOAL VALUE MODAL EVENT LISTENERS ===
            // Event listeners are now set up globally at the end of the script
            
            // === RESOURCE MANAGER ===
            const ResourceManager = {
                resources: [],
                
                async loadResources() {
                    if (!supabase?.isAuthenticated()) {
                        console.error('âŒ ResourceManager: Not authenticated - pure cloud mode requires authentication');
                        this.resources = [];
                        this.renderResources();
                        return;
                    }
                    
                    try {
                        console.log('â˜ï¸ ResourceManager: Loading resources from cloud...');
                        this.resources = await cloudStorage.getResources() || [];
                        
                        // Migrate old emoji icons to lucide icons (one-time migration)
                        this.migrateEmojiIcons();
                        
                        this.renderResources();
                        console.log('â˜ï¸ ResourceManager: Load completed');
                    } catch (error) {
                        console.error('âŒ ResourceManager: Error loading from cloud:', error);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                },
                
                renderResources() {
                    console.log('ðŸŽ¨ ResourceManager.renderResources() called with', this.resources.length, 'resources');
                    // Render all categories at once in block layout
                    this.displayResourcesForCategory('privat');
                    this.displayResourcesForCategory('crypto'); 
                    this.displayResourcesForCategory('arbeit');
                    this.displayResourcesForCategory('uni');
                },
                
                displayResourcesForCategory(category) {
                    const container = document.getElementById(`resource-${category}`);
                    if (!container) return;
                    
                    let filteredResources = [];
                    
                    switch(category) {
                        case 'privat':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Privat'
                            );
                            break;
                        case 'arbeit':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Arbeit'
                            );
                            break;
                        case 'uni':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Uni'
                            );
                            break;
                        case 'crypto':
                            filteredResources = this.resources.filter(resource => 
                                resource.category === 'Crypto'
                            );
                            break;
                    }
                    
                    let html = '';
                    
                    if (filteredResources.length === 0) {
                        html = '<div class="empty-resources">Keine Resources vorhanden</div>';
                    } else {
                        filteredResources.forEach(resource => {
                            const icon = resource.icon || 'link';
                            const description = resource.description || '';
                            html += `
                                <div class="resource-item" 
                                     onclick="window.open('${resource.url}', '_blank')"
                                     oncontextmenu="event.preventDefault(); ResourceManager.showDeleteConfirm('${resource.id}')"
                                     title="Rechtsklick zum LÃ¶schen">
                                    <div class="resource-info">
                                        <div class="resource-icon">
                                            <i data-lucide="${icon}" style="width: 16px; height: 16px;"></i>
                                        </div>
                                        <div class="resource-details">
                                            <div class="resource-title">${resource.title}</div>
                                            ${description ? `<div class="resource-description">${description}</div>` : ''}
                                        </div>
                                    </div>
                                </div>
                            `;
                        });
                    }
                    
                    container.innerHTML = html;
                    
                    // Enhanced Lucide initialization with icon verification
                    setTimeout(() => {
                        if (window.lucide) {
                            lucide.createIcons();
                            console.log('ðŸŽ¨ Lucide icons initialized for resource category:', category);
                            
                            // Verify icons are actually rendered
                            setTimeout(() => {
                                const actionBtns = container.querySelectorAll('.resource-actions');
                                
                                actionBtns.forEach((actions, index) => {
                                    const buttons = actions.querySelectorAll('button');
                                    const icons = actions.querySelectorAll('svg');
                                    
                                    // Force re-render if icons missing
                                    if (buttons.length > 0 && icons.length === 0) {
                                        console.log('âš ï¸ Missing icons detected, forcing re-render...');
                                        lucide.createIcons();
                                    }
                                });
                            }, 50);
                        }
                    }, 150);
                },
                
                showAddResourceModal(preselectedCategory = null) {
                    const modal = document.getElementById('add-resource-modal');
                    modal.classList.remove('hide');
                    
                    // Preselect category if provided
                    if (preselectedCategory) {
                        const categorySelect = document.getElementById('resource-category');
                        const categoryMapping = {
                            'privat': 'Privat',
                            'crypto': 'Crypto', 
                            'arbeit': 'Arbeit',
                            'uni': 'Uni'
                        };
                        const mappedCategory = categoryMapping[preselectedCategory];
                        if (mappedCategory && categorySelect) {
                            categorySelect.value = mappedCategory;
                        }
                    }
                    
                    document.getElementById('resource-title').focus();
                },
                
                hideAddResourceModal() {
                    const modal = document.getElementById('add-resource-modal');
                    modal.classList.add('hide');
                    document.getElementById('add-resource-form').reset();
                },

                showDeleteConfirm(resourceId, resourceTitle) {
                    // Hide any existing delete icons first
                    document.querySelectorAll('.delete-overlay').forEach(overlay => overlay.remove());
                    
                    // Find the resource item
                    const resourceItem = event.target.closest('.resource-item');
                    if (!resourceItem) return;
                    
                    // Create delete overlay
                    const deleteOverlay = document.createElement('div');
                    deleteOverlay.className = 'delete-overlay';
                    deleteOverlay.innerHTML = `
                        <div class="delete-icon" onclick="event.stopPropagation(); ResourceManager.confirmDelete('${resourceId}')">
                            <i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>
                        </div>
                    `;
                    
                    resourceItem.appendChild(deleteOverlay);
                    
                    // Initialize lucide icons for the new delete icon
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                    
                    // Auto-hide after 3 seconds or when clicking elsewhere
                    setTimeout(() => deleteOverlay.remove(), 3000);
                    
                    // Hide when clicking elsewhere
                    const hideOnClick = (e) => {
                        if (!deleteOverlay.contains(e.target)) {
                            deleteOverlay.remove();
                            document.removeEventListener('click', hideOnClick);
                        }
                    };
                    setTimeout(() => document.addEventListener('click', hideOnClick), 100);
                },

                confirmDelete(resourceId) {
                    // Remove the overlay
                    document.querySelectorAll('.delete-overlay').forEach(overlay => overlay.remove());
                    // Delete the resource
                    this.deleteResource(resourceId);
                },
                
                async addResource(resourceData) {
                    if (!supabase?.isAuthenticated()) {
                        console.error('âŒ ResourceManager: Not authenticated - cannot add resource in pure cloud mode');
                        alert('Fehler: Nicht authentifiziert. Resource kann nicht gespeichert werden.');
                        return;
                    }
                    
                    const resource = {
                        title: resourceData.title,
                        category: resourceData.category,
                        url: resourceData.url,
                        description: resourceData.description || '',
                        icon: resourceData.icon || 'link',
                        user_id: supabase.getCurrentUser().id,
                        created_at: new Date().toISOString()
                    };
                    
                    try {
                        console.log('â˜ï¸ ResourceManager: Saving resource to cloud:', resource.title);
                        await cloudStorage.saveResource(resource);
                        console.log('â˜ï¸ ResourceManager: Resource saved to cloud successfully');
                        
                        // Reload resources from cloud to get updated data with proper IDs
                        console.log('ðŸ”„ Reloading resources to get updated list...');
                        await this.loadResources();
                        
                        console.log('â˜ï¸ ResourceManager: Resource added:', resource.title);
                    } catch (error) {
                        console.error('âŒ ResourceManager: Error saving resource:', error);
                        alert('Fehler beim Speichern der Resource: ' + error.message);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                },
                
                async deleteResource(resourceId) {
                    if (!supabase?.isAuthenticated()) {
                        console.error('âŒ ResourceManager: Not authenticated - cannot delete resource in pure cloud mode');
                        alert('Fehler: Nicht authentifiziert. Resource kann nicht gelÃ¶scht werden.');
                        return;
                    }
                    
                    try {
                        console.log('â˜ï¸ ResourceManager: Deleting resource from cloud:', resourceId);
                        await cloudStorage.deleteResource(resourceId);
                        console.log('â˜ï¸ ResourceManager: Resource deleted from cloud successfully');
                        
                        // Pure cloud mode - no localStorage
                        
                        // Reload resources from cloud to get updated list
                        await this.loadResources();
                        
                        console.log('â˜ï¸ ResourceManager: Resource deleted and UI updated');
                    } catch (error) {
                        console.error('âŒ ResourceManager: Error deleting resource:', error);
                        alert('Fehler beim LÃ¶schen der Resource: ' + error.message);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                },
                
                editResource(resourceId) {
                    const resource = this.resources.find(r => r.id === resourceId);
                    if (!resource) return;
                    
                    // Populate form with existing data
                    document.getElementById('resource-title').value = resource.title;
                    document.getElementById('resource-category').value = resource.category;
                    document.getElementById('resource-url').value = resource.url;
                    document.getElementById('resource-description').value = resource.description || '';
                    document.getElementById('resource-icon').value = resource.icon || '';
                    
                    // Mark form as editing
                    const form = document.getElementById('add-resource-form');
                    form.dataset.editId = resourceId;
                    
                    this.showAddResourceModal();
                },
                
                selectIcon(iconName) {
                    const iconInput = document.getElementById('resource-icon');
                    if (iconInput) {
                        iconInput.value = iconName;
                    }
                },
                
                toggleIconInput() {
                    const iconInput = document.getElementById('resource-icon');
                    const toggleBtn = event.target;
                    
                    if (iconInput.readOnly) {
                        iconInput.readOnly = false;
                        iconInput.placeholder = 'Type lucide icon name manually...';
                        iconInput.focus();
                        toggleBtn.textContent = 'Use icon palette';
                    } else {
                        iconInput.readOnly = true;
                        iconInput.placeholder = 'Click icon below or type manually';
                        toggleBtn.textContent = 'Enable manual typing';
                    }
                },
                
                migrateEmojiIcons() {
                    const emojiToLucideMap = {
                        'ðŸ“§': 'mail',
                        'ðŸ’¼': 'briefcase',
                        'ðŸ“š': 'book',
                        'ðŸ ': 'home',
                        'ðŸ’¬': 'message-circle',
                        'ðŸ¦': 'building',
                        'ðŸ”§': 'wrench',
                        'ðŸ“Š': 'bar-chart-3',
                        'ðŸ“': 'file-text',
                        'ðŸ‘¥': 'users',
                        'ðŸŒ': 'globe',
                        'ðŸ’°': 'dollar-sign',
                        'ðŸŽ¯': 'target',
                        'âš¡': 'zap',
                        'ðŸ”': 'lock',
                        'ðŸ”—': 'link',
                        'ðŸš€': 'rocket',
                        'ðŸŽ¨': 'palette',
                        'ðŸƒ': 'activity',
                        'ðŸ¤–': 'bot',
                        'ðŸŒ±': 'sprout'
                    };
                    
                    if (!supabase?.isAuthenticated()) {
                        return; // Skip migration if not authenticated
                    }
                    
                    let migrationNeeded = false;
                    
                    this.resources.forEach(resource => {
                        if (emojiToLucideMap[resource.icon]) {
                            console.log(`ðŸ”„ Migrating icon for "${resource.title}": ${resource.icon} â†’ ${emojiToLucideMap[resource.icon]}`);
                            resource.icon = emojiToLucideMap[resource.icon];
                            migrationNeeded = true;
                        }
                    });
                    
                    if (migrationNeeded) {
                        console.log('â˜ï¸ Icon migration completed, saving to cloud');
                        // Pure cloud mode - only save to cloud
                        this.resources.forEach(resource => cloudStorage.saveResource(resource));
                    }
                },
                
            };
            
            // Make ResourceManager global
            window.ResourceManager = ResourceManager;
            
            // Initialize ResourceManager now that it's properly defined
            console.log('ðŸ”„ Initializing ResourceManager after definition...');
            ResourceManager.loadResources();

            // === QUICK NOTES FUNCTIONALITY ===
            const QuickNotes = {
                textarea: null,
                saveTimeout: null,

                init() {
                    this.textarea = document.getElementById('quicknotes-textarea');
                    if (!this.textarea) return;

                    // Load existing notes
                    this.loadNotes();
                    
                    // Initial auto-resize
                    this.autoResize();

                    // Auto-save on input with debounce + auto-resize
                    this.textarea.addEventListener('input', () => {
                        this.autoResize();
                        clearTimeout(this.saveTimeout);
                        this.saveTimeout = setTimeout(() => {
                            this.saveNotes();
                        }, 1000); // Save 1 second after user stops typing
                    });

                    // Save on blur (when user clicks away)
                    this.textarea.addEventListener('blur', () => {
                        clearTimeout(this.saveTimeout);
                        this.saveNotes();
                    });
                },

                async loadNotes() {
                    try {
                        if (!window.cloudStorage) return;
                        
                        const notes = await window.cloudStorage.getNotes('quicknotes');
                        if (notes && this.textarea) {
                            this.textarea.value = notes;
                            // Auto-resize after loading content
                            setTimeout(() => this.autoResize(), 100);
                        }
                    } catch (error) {
                        console.error('Error loading quick notes:', error);
                    }
                },

                autoResize() {
                    if (!this.textarea) return;
                    
                    // Reset height to auto to get correct scrollHeight
                    this.textarea.style.height = 'auto';
                    
                    // Set height to scrollHeight (content height)
                    const newHeight = Math.max(200, this.textarea.scrollHeight);
                    this.textarea.style.height = newHeight + 'px';
                },

                async saveNotes() {
                    try {
                        if (!window.cloudStorage || !this.textarea) return;
                        
                        const content = this.textarea.value;
                        await window.cloudStorage.saveNotes('quicknotes', content);
                        console.log('â˜ï¸ Quick notes saved to cloud');
                    } catch (error) {
                        console.error('Error saving quick notes:', error);
                    }
                }
            };

            // Initialize Quick Notes when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => QuickNotes.init());
            } else {
                QuickNotes.init();
            }

            // Make QuickNotes global for debugging
            window.QuickNotes = QuickNotes;
            
            
            // === JOURNAL DELETE BUTTONS ===
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('delete-entry-btn')) {
                    const entryId = e.target.dataset.entryId;
                    if (entryId) {
                        JournalManager.deleteEntry(entryId);
                    }
                }
            });

            // === RESOURCE EVENT LISTENERS ===
            
            // Add Resource Button
            const addResourceBtn = document.getElementById('add-resource-btn');
            if (addResourceBtn) {
                addResourceBtn.addEventListener('click', () => {
                    ResourceManager.showAddResourceModal();
                });
            }

            // Add to Category Buttons
            const addToCategoryBtns = document.querySelectorAll('.add-to-category-btn');
            addToCategoryBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const category = btn.getAttribute('data-category');
                    ResourceManager.showAddResourceModal(category);
                });
            });
            
            // Add Resource Form Submission
            const addResourceForm = document.getElementById('add-resource-form');
            if (addResourceForm) {
                addResourceForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const resourceData = {
                        title: document.getElementById('resource-title').value,
                        category: document.getElementById('resource-category').value,
                        url: document.getElementById('resource-url').value,
                        description: document.getElementById('resource-description').value,
                        icon: document.getElementById('resource-icon').value
                    };
                    
                    // Check if we're editing an existing resource
                    const editId = addResourceForm.dataset.editId;
                    if (editId) {
                        // Update existing resource
                        const resource = ResourceManager.resources.find(r => r.id === editId);
                        if (resource) {
                            if (!supabase?.isAuthenticated()) {
                                console.error('âŒ ResourceManager: Not authenticated - cannot update resource in pure cloud mode');
                                alert('Fehler: Nicht authentifiziert. Resource kann nicht aktualisiert werden.');
                                return;
                            }
                            
                            Object.assign(resource, resourceData);
                            try {
                                console.log('â˜ï¸ ResourceManager: Updating resource in cloud:', resource.title);
                                await cloudStorage.saveResource(resource);
                                ResourceManager.renderResources();
                                console.log('â˜ï¸ ResourceManager: Resource updated:', resource.title);
                            } catch (error) {
                                console.error('âŒ ResourceManager: Error updating resource:', error);
                                alert('Fehler beim Aktualisieren der Resource: ' + error.message);
                                throw error; // Don't hide errors in pure cloud mode
                            }
                        }
                        // Clear edit mode
                        delete addResourceForm.dataset.editId;
                    } else {
                        // Add new resource
                        await ResourceManager.addResource(resourceData);
                    }
                    
                    ResourceManager.hideAddResourceModal();
                });
            }
            
            // Close resource modal when clicking outside
            const addResourceModal = document.getElementById('add-resource-modal');
            if (addResourceModal) {
                addResourceModal.addEventListener('click', (e) => {
                    if (e.target === addResourceModal) {
                        ResourceManager.hideAddResourceModal();
                    }
                });
            }
            
            // Render resources when Resources tab is selected (don't reload from scratch)
            const ressourcenTab = document.querySelector('[data-tab="ressourcen"]');
            if (ressourcenTab) {
                ressourcenTab.addEventListener('click', () => {
                    // Only render existing resources, don't reload from cloud/storage
                    ResourceManager.renderResources();
                    console.log('ðŸŽ¨ Resources tab clicked - rendering existing resources');
                });
            }
            
            // ResourceManager initialization moved to main DOMContentLoaded listener
            
            // === SIMPLE LOGOUT (URL-based) ===
            console.log('âœ… Logout is now URL-based, no JavaScript needed');
            
            // === ROUTINE RESET FUNCTIONALITY ===
            // Use event delegation to catch button clicks even if tab is loaded later
            document.addEventListener('click', async function(e) {
                if (e.target && e.target.id === 'reset-routines-btn') {
                    console.log('ðŸ–±ï¸ Reset routines button clicked');
                    
                    const confirmed = confirm(
                        'âš ï¸ ACHTUNG: Routine-Datenbank komplett zurÃ¼cksetzen?\n\n' +
                        'â€¢ LÃ¶scht ALLE Routine-Daten (lokal und cloud)\n' +
                        'â€¢ Setzt alle Counter auf 0\n' +
                        'â€¢ Betrifft alle GerÃ¤te\n' +
                        'â€¢ Kann nicht rÃ¼ckgÃ¤ngig gemacht werden\n\n' +
                        'Fortfahren?'
                    );
                    
                    if (confirmed) {
                        console.log('âœ… User confirmed reset');
                        const success = await resetRoutineDatabase();
                        if (success) {
                            alert('âœ… Routine-Datenbank wurde komplett zurÃ¼ckgesetzt!\n\nBitte refreshe die Seite auf allen GerÃ¤ten.');
                            window.location.reload();
                        } else {
                            alert('âŒ Fehler beim ZurÃ¼cksetzen. Bitte Console prÃ¼fen.');
                        }
                    } else {
                        console.log('âŒ User cancelled reset');
                    }
                }
            });
            
            // Complete Routine Database Reset Function
            async function resetRoutineDatabase() {
                console.log('ðŸ”„ Starting complete routine database reset...');
                
                try {
                    // 1. Clear all localStorage routine data (old and new)
                    const keysToRemove = [
                        'routineCompletionData',
                        'routine_completions_cache', 
                        'monthlyRoutineCompletions',
                        'routineData',
                        'lastRoutineResetDate',
                        'routineResetTime',
                        'morningRoutineStreak',
                        'eveningRoutineStreak',
                        'simple_routine_data' // New system
                    ];
                    
                    keysToRemove.forEach(key => {
                        if (localStorage.getItem(key)) {
                            localStorage.removeItem(key);
                            console.log(`ðŸ—‘ï¸ Removed localStorage: ${key}`);
                        }
                    });
                    
                    // 2. Clear Supabase tables if authenticated
                    if (window.supabase && window.supabase.isAuthenticated()) {
                        const user = window.supabase.getCurrentUser();
                        console.log('ðŸ”„ Clearing cloud routine data for user:', user.email);
                        
                        try {
                            // Delete old system data
                            await window.supabase.delete('routine_completions', `user_id=eq.${user.id}`);
                            console.log('âœ… Cleared old routine_completions table');
                            
                            // Delete new system data
                            await window.supabase.delete('simple_routines', `user_id=eq.${user.id}`);
                            console.log('âœ… Cleared new simple_routines table');
                        } catch (error) {
                            console.warn('âš ï¸ Could not clear cloud data:', error);
                        }
                    }
                    
                    // 3. Reset routine checkboxes on page
                    const morningCheckboxes = document.querySelectorAll('#morning-routine input[type="checkbox"]');
                    const eveningCheckboxes = document.querySelectorAll('#evening-routine input[type="checkbox"]');
                    
                    [...morningCheckboxes, ...eveningCheckboxes].forEach(checkbox => {
                        checkbox.checked = false;
                        const label = checkbox.nextElementSibling;
                        if (label) {
                            label.style.textDecoration = 'none';
                            label.style.color = 'inherit';
                        }
                    });
                    console.log('âœ… Reset all routine checkboxes');
                    
                    // 4. Reset routine counters to 0 - DISABLED to prevent CloudCounters conflict
                    // NOTE: This code was interfering with CloudCounters by overriding the correct values
                    /*
                    const streakTiles = document.querySelectorAll('.streak-tile');
                    if (streakTiles.length >= 2) {
                        const morningTile = streakTiles[0];
                        const eveningTile = streakTiles[1];
                        
                        const morningNumber = morningTile?.querySelector('.streak-number');
                        const eveningNumber = eveningTile?.querySelector('.streak-number');
                        
                        if (morningNumber) morningNumber.textContent = '0';
                        if (eveningNumber) eveningNumber.textContent = '0';
                        
                        console.log('âœ… Reset routine counters to 0');
                    }
                    */
                    
                    // 5. Reset new simple routine manager if available
                    if (window.simpleRoutineManager) {
                        await window.simpleRoutineManager.reset();
                        console.log('âœ… Reset SimpleRoutineManager');
                    }
                    
                    console.log('ðŸŽ‰ Routine database reset complete!');
                    console.log('ðŸ“ All routine data has been cleared and counters reset');
                    console.log('ðŸ”„ Refresh the page to ensure clean state across devices');
                    
                    return true;
                    
                } catch (error) {
                    console.error('âŒ Error during routine reset:', error);
                    return false;
                }
            }
            
            // === DEBUG ROUTINE SYSTEM ===
            window.debugRoutineSystem = function() {
                console.log('ðŸ” ROUTINE SYSTEM DEBUG');
                console.log('======================');
                
                // Check localStorage
                const simpleData = localStorage.getItem('simple_routine_data');
                console.log('ðŸ“± simple_routine_data:', simpleData ? JSON.parse(simpleData) : 'NOT FOUND');
                
                const oldData = localStorage.getItem('routineCompletionData');
                console.log('ðŸ“± routineCompletionData (old):', oldData ? JSON.parse(oldData) : 'NOT FOUND');
                
                // Check SimpleRoutineManager
                if (window.simpleRoutineManager) {
                    console.log('âœ… SimpleRoutineManager exists');
                    console.log('ðŸ“Š Current data:', window.simpleRoutineManager.routineData);
                    console.log('ðŸ“… Today:', window.simpleRoutineManager.today);
                } else {
                    console.log('âŒ SimpleRoutineManager NOT FOUND');
                }
                
                // Check checkboxes
                const morningCheckboxes = document.querySelectorAll('#morning-routine input[type="checkbox"]');
                const eveningCheckboxes = document.querySelectorAll('#evening-routine input[type="checkbox"]');
                
                console.log('ðŸŒ… Morning checkboxes:');
                morningCheckboxes.forEach(cb => {
                    const label = cb.nextElementSibling;
                    console.log(`- ${cb.id}: checked=${cb.checked}, strikethrough=${label?.style?.textDecoration || 'none'}`);
                });
                
                console.log('ðŸŒ™ Evening checkboxes:');
                eveningCheckboxes.forEach(cb => {
                    const label = cb.nextElementSibling;
                    console.log(`- ${cb.id}: checked=${cb.checked}, strikethrough=${label?.style?.textDecoration || 'none'}`);
                });
                
                // Check counters
                const streakTiles = document.querySelectorAll('.streak-tile');
                console.log('ðŸ“Š Counter tiles:');
                streakTiles.forEach((tile, index) => {
                    const number = tile.querySelector('.streak-number');
                    const label = tile.querySelector('.streak-label');
                    console.log(`- Tile ${index}: ${label?.textContent} = ${number?.textContent}`);
                });
                
                alert('Debug info logged to console - press F12 to see details');
            };
            
            // === GLOBAL ROUTINE RESET HANDLER ===
            window.handleRoutineReset = async function() {
                console.log('ðŸ–±ï¸ handleRoutineReset called via onclick');
                
                const confirmed = confirm(
                    'âš ï¸ ACHTUNG: Routine-Datenbank komplett zurÃ¼cksetzen?\n\n' +
                    'â€¢ LÃ¶scht ALLE Routine-Daten (lokal und cloud)\n' +
                    'â€¢ Setzt alle Counter auf 0\n' +
                    'â€¢ Betrifft alle GerÃ¤te\n' +
                    'â€¢ Kann nicht rÃ¼ckgÃ¤ngig gemacht werden\n\n' +
                    'Fortfahren?'
                );
                
                if (confirmed) {
                    console.log('âœ… User confirmed reset');
                    const success = await resetRoutineDatabase();
                    if (success) {
                        alert('âœ… Routine-Datenbank wurde komplett zurÃ¼ckgesetzt!\n\nBitte refreshe die Seite auf allen GerÃ¤ten.');
                        window.location.reload();
                    } else {
                        alert('âŒ Fehler beim ZurÃ¼cksetzen. Bitte Console prÃ¼fen.');
                    }
                } else {
                    console.log('âŒ User cancelled reset');
                }
            };
            
            // Initialize hash-based navigation
            initializeFromHash();
            
            // Add hash change event listener
            window.addEventListener('hashchange', handleHashChange);
            
            // Initialize URL hash for current active tab (only if authenticated)
            setTimeout(() => {
                if (supabase?.isAuthenticated()) {
                    const activeTab = document.querySelector('.nav-tab.active');
                    if (activeTab && !window.location.hash) {
                        const tabId = activeTab.getAttribute('data-tab');
                        if (tabId && tabHashMapping[tabId]) {
                            const hash = tabHashMapping[tabId];
                            window.history.replaceState(null, null, `#${hash}`);
                            console.log(`ðŸ”— Initial tab loaded: ${tabId}, URL set to #${hash}`);
                        }
                    }
                }
            }, 100);
            
            // Pure cloud counter system - no force refresh needed
            setTimeout(() => {
                console.log('â˜ï¸ Ensuring cloud counters are initialized...');
                
                // Only initialize cloud counters if not already done
                if (window.CloudCounters && !window.CloudCounters.isInitialized && supabase?.isAuthenticated()) {
                    window.CloudCounters.init();
                }
                
                // Debug function for checking todo counts
                window.debugTodoCount = async function() {
                    if (!supabase?.isAuthenticated()) {
                        console.log('âŒ Not authenticated');
                        return;
                    }
                    
                    const now = new Date();
                    const currentMonth = now.getMonth() + 1;
                    const currentYear = now.getFullYear();
                    const startOfMonth = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-01`;
                    const endOfMonth = `${currentYear}-${currentMonth.toString().padStart(2, '0')}-31`;
                    
                    const user = supabase.getCurrentUser();
                    
                    console.log('ðŸ” Debug Todo Count for', `${currentMonth}/${currentYear}`);
                    console.log('ðŸ“… Date range:', startOfMonth, 'to', endOfMonth);
                    
                    // All todos this month
                    const allTodos = await supabase.query(`todos?user_id=eq.${user.id}&created_at=gte.${startOfMonth}&created_at=lt.${endOfMonth}&select=*`);
                    console.log('ðŸ“ All todos this month:', allTodos?.length || 0, allTodos);
                    
                    // Completed todos this month  
                    const completedTodos = await supabase.query(`todos?user_id=eq.${user.id}&completed=eq.true&created_at=gte.${startOfMonth}&created_at=lt.${endOfMonth}&select=*`);
                    console.log('âœ… Completed todos this month:', completedTodos?.length || 0, completedTodos);
                    
                    return { all: allTodos, completed: completedTodos };
                };
                
            }, 2000);
            
            // Mobile debug removed for cleaner console output
        });

        // === WIKI MANAGER ===
        const Wiki = {
            entries: [],
            filteredEntries: [],
            
            init() {
                console.log('ðŸ”§ Wiki: Initializing...');
                this.loadEntries();
                this.setupEventListeners();
                this.render();
            },
            
            setupEventListeners() {
                const form = document.getElementById('add-wiki-form');
                const searchInput = document.getElementById('wiki-search');
                
                if (form) {
                    form.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.addEntry();
                    });
                }
                
                if (searchInput) {
                    searchInput.addEventListener('input', () => {
                        clearTimeout(this.searchTimeout);
                        this.searchTimeout = setTimeout(() => this.search(), 300);
                    });
                }
            },
            
            showAddModal() {
                const modal = document.getElementById('add-wiki-modal');
                if (modal) {
                    modal.classList.remove('hide');
                    document.getElementById('wiki-title').focus();
                }
            },
            
            hideAddModal() {
                const modal = document.getElementById('add-wiki-modal');
                if (modal) {
                    modal.classList.add('hide');
                    document.getElementById('add-wiki-form').reset();
                }
            },
            
            async addEntry() {
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ Wiki: Not authenticated - cannot add entry in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Wiki-Eintrag kann nicht gespeichert werden.');
                    return;
                }
                
                const title = document.getElementById('wiki-title').value;
                const content = document.getElementById('wiki-content').value;
                const tagsText = document.getElementById('wiki-tags').value;
                const source = document.getElementById('wiki-source').value;
                
                if (!title || !tagsText || !content) {
                    alert('Please fill in all required fields');
                    return;
                }
                
                const tags = tagsText.split(',').map(tag => tag.trim()).filter(tag => tag);
                
                // Generate a unique ID for the wiki entry
                const entryId = Date.now(); // Use timestamp as ID
                
                const entry = {
                    id: entryId, // Manually set ID since table doesn't auto-generate
                    title,
                    content,
                    tags,
                    source,
                    user_id: supabase.getCurrentUser().id,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                };
                
                // Remove any undefined fields that might cause issues
                Object.keys(entry).forEach(key => {
                    if (entry[key] === undefined || entry[key] === null) {
                        delete entry[key];
                    }
                });
                
                try {
                    console.log('â˜ï¸ Wiki: Saving entry to cloud:', title);
                    console.log('â˜ï¸ Wiki: Entry data:', entry);
                    
                    // Use array format for insert
                    const result = await supabase.insert('crypto_wiki_entries', [entry]);
                    console.log('â˜ï¸ Wiki: Insert result:', result);
                    
                    if (result && result.length > 0) {
                        this.entries.push(result[0]);
                        console.log('â˜ï¸ Wiki: Entry saved to cloud with ID:', result[0].id);
                    } else {
                        throw new Error('Insert did not return data');
                    }
                } catch (error) {
                    console.error('âŒ Wiki: Error saving to cloud:', error);
                    console.error('âŒ Wiki: Error details:', error.message);
                    alert('Fehler beim Speichern des Wiki-Eintrags: ' + error.message);
                    throw error; // Don't hide errors in pure cloud mode
                }
                
                this.hideAddModal();
                this.render();
                
                console.log('â˜ï¸ Wiki: Entry added:', title);
            },
            
            async deleteEntry(id) {
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ Wiki: Not authenticated - cannot delete entry in pure cloud mode');
                    alert('Fehler: Nicht authentifiziert. Wiki-Eintrag kann nicht gelÃ¶scht werden.');
                    return;
                }
                
                const entry = this.entries.find(e => e.id === id);
                if (!entry) return;
                
                if (confirm(`Delete wiki entry "${entry.title}"?`)) {
                    try {
                        console.log('â˜ï¸ Wiki: Deleting entry from cloud:', id);
                        await supabase.delete('crypto_wiki_entries', `id=eq.${id}`);
                        console.log('â˜ï¸ Wiki: Entry deleted from cloud');
                    } catch (error) {
                        console.error('âŒ Wiki: Error deleting from cloud:', error);
                        alert('Fehler beim LÃ¶schen des Wiki-Eintrags: ' + error.message);
                        throw error; // Don't hide errors in pure cloud mode
                    }
                    
                    // Remove from local array
                    this.entries = this.entries.filter(e => e.id !== id);
                    
                    // Pure cloud mode - no localStorage
                    
                    this.render();
                    console.log('â˜ï¸ Wiki: Entry deleted:', entry.title);
                }
            },
            
            search() {
                const query = document.getElementById('wiki-search').value.toLowerCase();
                
                this.filteredEntries = this.entries.filter(entry => {
                    const matchesSearch = !query || 
                        entry.title.toLowerCase().includes(query) ||
                        entry.content.toLowerCase().includes(query) ||
                        entry.tags.some(tag => tag.toLowerCase().includes(query)) ||
                        (entry.source && entry.source.toLowerCase().includes(query));
                    
                    return matchesSearch;
                });
                
                this.render();
            },
            
            filterByTags() {
                const tagFilter = document.getElementById('wiki-tag-filter').value.toLowerCase();
                
                this.filteredEntries = this.entries.filter(entry => {
                    if (!tagFilter) return true;
                    
                    return entry.tags.some(tag => tag.toLowerCase().includes(tagFilter));
                });
                
                this.render();
            },
            
            render() {
                const container = document.getElementById('wiki-entries');
                if (!container) return;
                
                const entriesToShow = this.filteredEntries.length > 0 || 
                    document.getElementById('wiki-search').value || 
                    document.getElementById('wiki-tag-filter').value 
                    ? this.filteredEntries : this.entries;
                
                if (entriesToShow.length === 0) {
                    container.innerHTML = '<div class="empty-wiki">No wiki entries found. Add your first knowledge entry!</div>';
                    return;
                }
                
                const html = entriesToShow
                    .sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at))
                    .map(entry => this.renderEntry(entry))
                    .join('');
                
                container.innerHTML = html;
                
                // Initialize Lucide icons after rendering
                setTimeout(() => {
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                }, 100);
            },
            
            renderEntry(entry) {
                const tagsHtml = entry.tags.map(tag => `<span class="wiki-tag">${tag}</span>`).join('');
                const sourceHtml = entry.source ? `<span class="wiki-entry-source">Source: ${entry.source}</span>` : '';
                const dateHtml = new Date(entry.created_at).toLocaleDateString('de-DE');
                
                return `
                    <div class="wiki-entry">
                        <div class="wiki-entry-header">
                            <h3 class="wiki-entry-title">${entry.title}</h3>
                        </div>
                        <div class="wiki-entry-content">${entry.content}</div>
                        <div class="wiki-entry-meta">
                            <div class="wiki-entry-left">
                                <div class="wiki-entry-tags">${tagsHtml}</div>
                                ${sourceHtml}
                            </div>
                            <div class="wiki-entry-right">
                                <span>${dateHtml}</span>
                                <div class="wiki-entry-actions">
                                    <button onclick="Wiki.deleteEntry('${entry.id}')" title="Delete">
                                        <i data-lucide="trash-2" style="width: 14px; height: 14px;"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            },
            
            async loadEntries() {
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ Wiki: Not authenticated - pure cloud mode requires authentication');
                    this.entries = [];
                    this.render();
                    return;
                }
                
                try {
                    await this.loadFromCloud();
                } catch (error) {
                    console.error('âŒ Wiki: Error loading entries:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },

            
            async saveEntries() {
                // Pure cloud mode - no localStorage saving
                if (!supabase?.isAuthenticated()) {
                    console.error('âŒ Wiki: Not authenticated - cannot save in pure cloud mode');
                    return;
                }
                
                try {
                    await this.saveToCloud();
                } catch (error) {
                    console.error('âŒ Wiki: Error saving entries:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            async loadFromCloud() {
                try {
                    console.log('â˜ï¸ Wiki: Loading from cloud...');
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        throw new Error('No user found');
                    }

                    const data = await supabase.query(`crypto_wiki_entries?user_id=eq.${user.id}&order=updated_at.desc&select=*`);
                    
                    if (data && Array.isArray(data)) {
                        this.entries = data;
                        this.render();
                    } else {
                        console.log('â˜ï¸ Wiki: No entries found in cloud');
                        this.entries = [];
                        this.render();
                    }
                } catch (error) {
                    console.error('âŒ Wiki: Error loading from cloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },
            
            async saveToCloud() {
                try {
                    console.log('ðŸ”„ Wiki: Saving to Supabase...');
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        console.log('âŒ Wiki: No user found');
                        return;
                    }

                    // We'll save entries individually when they're created/updated
                    console.log('âœ… Wiki: Cloud sync ready');
                } catch (error) {
                    console.error('âŒ Wiki: Error saving to cloud:', error);
                }
            },

            async saveEntryToCloud(entry) {
                try {
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        throw new Error('No user found');
                    }

                    const entryWithUserId = {
                        ...entry,
                        user_id: user.id
                    };

                    const data = await supabase.insert('crypto_wiki_entries', entryWithUserId);
                    
                    if (!data || !Array.isArray(data) || data.length === 0) {
                        throw new Error('Insert did not return data');
                    }

                    console.log('â˜ï¸ Wiki: Entry saved to cloud:', entry.title);
                    return true;
                } catch (error) {
                    console.error('âŒ Wiki: Error in saveEntryToCloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            },

            async deleteEntryFromCloud(entryId) {
                try {
                    const user = supabase.getCurrentUser();
                    if (!user) {
                        throw new Error('No user found');
                    }

                    const result = await supabase.delete('crypto_wiki_entries', `id=eq.${entryId}`);
                    
                    console.log('â˜ï¸ Wiki: Entry deleted from cloud');
                    return true;
                } catch (error) {
                    console.error('âŒ Wiki: Error in deleteEntryFromCloud:', error);
                    throw error; // Don't hide errors in pure cloud mode
                }
            }
        };

        // Make Wiki globally available
        window.Wiki = Wiki;
        
        // === POMODORO TIMER CLASS ===
        class PomodoroTimer {
            constructor() {
                this.duration = 25 * 60; // 25 minutes in seconds
                this.timeLeft = this.duration;
                this.isRunning = false;
                this.isPaused = false;
                this.interval = null;
                this.originalTitle = document.title;
                this.timerBtn = document.getElementById('timer-btn');
                
                // Set initial tooltip
                if (this.timerBtn) {
                    this.timerBtn.title = 'Pomodoro Timer (25 min) | Right-click to reset';
                }
                
                console.log('ðŸ… PomodoroTimer initialized (25 min) - Left click: start/stop, Right click: reset');
            }
            
            toggle() {
                if (this.isRunning) {
                    this.pause();
                } else {
                    this.start();
                }
            }
            
            start() {
                console.log('ðŸ… Timer started');
                this.isRunning = true;
                this.isPaused = false;
                
                // Update button appearance
                this.timerBtn.classList.add('timer-running');
                this.timerBtn.classList.remove('timer-paused');
                this.timerBtn.title = 'Running - Click to pause';
                
                this.interval = setInterval(() => {
                    this.timeLeft--;
                    this.updateDisplay();
                    
                    if (this.timeLeft <= 0) {
                        this.complete();
                    }
                }, 1000);
            }
            
            pause() {
                console.log('ðŸ… Timer paused');
                this.isRunning = false;
                this.isPaused = true;
                
                // Update button appearance
                this.timerBtn.classList.remove('timer-running');
                this.timerBtn.classList.add('timer-paused');
                this.timerBtn.title = 'Paused - Click to resume';
                
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
            }
            
            complete() {
                console.log('ðŸ… Timer completed!');
                this.reset();
                
                // Show notification
                this.showNotification();
                
                // Play sound (if available)
                this.playCompletionSound();
            }
            
            reset() {
                console.log('ðŸ… Timer reset to 25:00');
                this.isRunning = false;
                this.isPaused = false;
                this.timeLeft = this.duration;
                
                // Reset button appearance
                this.timerBtn.classList.remove('timer-running', 'timer-paused');
                this.timerBtn.title = 'Pomodoro Timer (25 min) | Right-click to reset';
                
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
                
                // Reset title
                document.title = this.originalTitle;
            }
            
            updateDisplay() {
                const minutes = Math.floor(this.timeLeft / 60);
                const seconds = this.timeLeft % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Update page title
                document.title = `ðŸ… ${timeString} | ${this.originalTitle}`;
            }
            
            showNotification() {
                // Browser notification
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification('ðŸ… Pomodoro Complete!', {
                        body: '25 minutes focused work completed. Time for a break!',
                        icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="80">ðŸ…</text></svg>'
                    });
                } else if ('Notification' in window && Notification.permission !== 'denied') {
                    // Request permission
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            this.showNotification();
                        }
                    });
                }
                
                // Fallback alert
                alert('ðŸ… Pomodoro Complete!\n\n25 minutes focused work completed.\nTime for a break!');
            }
            
            playCompletionSound() {
                // Create a simple beep sound
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (error) {
                    console.log('ðŸ”‡ Could not play completion sound:', error);
                }
            }
        }
        
        // Make PomodoroTimer globally available
        window.PomodoroTimer = new PomodoroTimer();
        
        // === QUICK ADD CLASS ===
        class QuickAdd {
            constructor() {
                this.isVisible = false;
                this.overlay = null;
                this.modal = null;
                console.log('âš¡ QuickAdd initialized');
            }
            
            show() {
                if (this.isVisible) return;
                
                console.log('âš¡ QuickAdd: Showing modal');
                this.createModal();
                this.isVisible = true;
            }
            
            hide() {
                if (!this.isVisible) return;
                
                console.log('âš¡ QuickAdd: Hiding modal');
                if (this.overlay) {
                    this.overlay.remove();
                    this.overlay = null;
                    this.modal = null;
                }
                this.isVisible = false;
            }
            
            createModal() {
                // Create overlay
                this.overlay = document.createElement('div');
                this.overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    z-index: 2000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                
                // Create modal
                this.modal = document.createElement('div');
                this.modal.style.cssText = `
                    background: white;
                    border-radius: 8px;
                    padding: 2rem;
                    min-width: 400px;
                    max-width: 500px;
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
                `;
                
                this.modal.innerHTML = `
                    <h3 style="margin: 0 0 1rem 0; font-size: 1.2rem;">âš¡ Quick Add Todo</h3>
                    <form id="quick-add-form" autocomplete="off">
                        <input type="text" id="quick-todo-title" placeholder="Todo eingeben..." autocomplete="off"
                               style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 1rem; font-size: 1rem;" />
                        
                        <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                            <select id="quick-todo-category" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="privat">Privat</option>
                                <option value="uni">Uni</option>
                                <option value="arbeit">Arbeit</option>
                            </select>
                            
                            <select id="quick-todo-priority" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="mittel">Mittel</option>
                                <option value="wichtig">Wichtig</option>
                                <option value="dringend">Dringend</option>
                            </select>
                        </div>
                        
                        <input type="date" id="quick-todo-deadline" 
                               style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 1rem;" />
                        
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                            <button type="button" id="quick-add-cancel" 
                                    style="padding: 0.5rem 1rem; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">
                                Abbrechen
                            </button>
                            <button type="submit" 
                                    style="padding: 0.5rem 1rem; border: none; background: #059669; color: white; border-radius: 4px; cursor: pointer;">
                                HinzufÃ¼gen
                            </button>
                        </div>
                    </form>
                `;
                
                this.overlay.appendChild(this.modal);
                document.body.appendChild(this.overlay);
                
                // Set today as default deadline
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('quick-todo-deadline').value = today;
                
                // Focus title input
                const titleInput = document.getElementById('quick-todo-title');
                setTimeout(() => titleInput.focus(), 100);
                
                // Event listeners
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // Close on overlay click
                this.overlay.addEventListener('click', (e) => {
                    if (e.target === this.overlay) {
                        this.hide();
                    }
                });
                
                // Close on ESC key
                document.addEventListener('keydown', this.handleKeydown.bind(this));
                
                // Cancel button
                document.getElementById('quick-add-cancel').addEventListener('click', () => {
                    this.hide();
                });
                
                // Form submit
                document.getElementById('quick-add-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleSubmit();
                });
            }
            
            handleKeydown(e) {
                if (e.key === 'Escape' && this.isVisible) {
                    this.hide();
                }
            }
            
            async handleSubmit() {
                const title = document.getElementById('quick-todo-title').value.trim();
                const category = document.getElementById('quick-todo-category').value;
                const priority = document.getElementById('quick-todo-priority').value;
                const deadline = document.getElementById('quick-todo-deadline').value;
                
                if (!title) {
                    alert('Bitte gib einen Todo-Titel ein!');
                    return;
                }
                
                // Map priority string to integer for database
                const priorityMap = {
                    'mittel': 2,
                    'wichtig': 3,
                    'dringend': 4
                };
                
                const todo = {
                    text: title,  // Database uses 'text', not 'title'
                    category: category,
                    priority: priorityMap[priority] || 2,  // Convert to integer
                    date: deadline || null,  // Database uses 'date', not 'deadline'
                    time: null,  // No time specified in quick-add
                    completed: false,
                    created_at: new Date().toISOString()
                };
                
                try {
                    console.log('âš¡ QuickAdd: Saving todo:', todo);
                    
                    // Check if authenticated
                    if (!window.supabase?.isAuthenticated()) {
                        alert('Nicht authentifiziert! Bitte logge dich ein.');
                        return;
                    }
                    
                    // Save using CloudStorage directly for more reliability
                    if (window.cloudStorage) {
                        await window.cloudStorage.saveTodo(todo);
                        console.log('âœ… QuickAdd: Todo saved successfully via CloudStorage');
                    } else if (window.TodoManager) {
                        await window.TodoManager.saveTodo(todo);
                        console.log('âœ… QuickAdd: Todo saved successfully via TodoManager');
                    } else {
                        throw new Error('No todo saving mechanism available');
                    }
                    
                    // Refresh todo display immediately after saving
                    if (window.TodoManager) {
                        console.log('ðŸ”„ QuickAdd: Refreshing todo display...');
                        
                        // Load todos from database first
                        await window.TodoManager.loadTodos();
                        
                        // Then refresh the current view
                        if (typeof window.TodoManager.refreshCurrentView === 'function') {
                            window.TodoManager.refreshCurrentView();
                        }
                        
                        // Also update home view for counters
                        if (typeof window.TodoManager.updateHomeTodos === 'function') {
                            window.TodoManager.updateHomeTodos();
                        }
                        
                        console.log('âœ… QuickAdd: Todo display refreshed');
                    } else {
                        console.log('âš ï¸ QuickAdd: TodoManager not available');
                    }
                    
                    console.log('âœ… QuickAdd: All done, hiding modal');
                    this.hide();
                } catch (error) {
                    console.error('âŒ QuickAdd: Error saving todo:', error);
                    console.error('âŒ QuickAdd: Error details:', error.message, error.stack);
                    alert(`Fehler beim Speichern des Todos: ${error.message}`);
                }
            }
        }
        
        // Make QuickAdd globally available
        window.QuickAdd = new QuickAdd();
        
        // Wiki and Lucide icons initialization moved to main DOMContentLoaded listener
    </script>
    
    <!-- ========================================= -->
    <!-- TRADING MANAGER -->
    <!-- ========================================= -->
    <script>
        class TradingManager {
            constructor() {
                this.apiKey = '35ffdb6a-2061-4573-a66b-ea263c5eaa34';
                this.trades = [];
                this.solPrice = 0;
                this.requestCount = 0;
                this.maxRequestsPerHour = 30; // Conservative limit
                
                this.init();
            }

            async init() {
                // Setup event listeners
                this.setupEventListeners();
                
                // Load trades from cloud when tab is accessed
                this.setupTabListener();
                
                // Get current SOL price
                await this.updateSolPrice();
            }

            setupEventListeners() {
                // Add trade button - show modal
                const addTradeBtn = document.getElementById('add-trade-btn');
                if (addTradeBtn) {
                    addTradeBtn.addEventListener('click', () => this.showAddTradeModal());
                }

                // Add trade modal buttons
                const addTradeConfirm = document.getElementById('add-trade-confirm');
                if (addTradeConfirm) {
                    addTradeConfirm.addEventListener('click', () => this.addTrade());
                }

                const addTradeCancel = document.getElementById('add-trade-cancel');
                if (addTradeCancel) {
                    addTradeCancel.addEventListener('click', () => this.hideAddTradeModal());
                }

                const addTradeModalClose = document.getElementById('add-trade-modal-close');
                if (addTradeModalClose) {
                    addTradeModalClose.addEventListener('click', () => this.hideAddTradeModal());
                }

                // Refresh prices button
                const refreshPricesBtn = document.getElementById('refresh-prices-btn');
                if (refreshPricesBtn) {
                    refreshPricesBtn.addEventListener('click', () => this.refreshPrices());
                }

                // Lock button (placeholder for future functionality)
                const lockBtn = document.getElementById('lock-btn');
                if (lockBtn) {
                    lockBtn.addEventListener('click', () => this.handleLockButton());
                }




                // Close trade modal buttons
                const closeModal = document.getElementById('close-trade-modal');
                const closeModalClose = document.getElementById('close-trade-modal-close');
                const closeTradeCancel = document.getElementById('close-trade-cancel');
                const closeTradeConfirm = document.getElementById('close-trade-confirm');

                // Close modal handlers
                [closeModalClose, closeTradeCancel].forEach(btn => {
                    if (btn) {
                        btn.addEventListener('click', () => this.hideCloseTradeModal());
                    }
                });

                // Close on overlay click
                if (closeModal) {
                    closeModal.addEventListener('click', (e) => {
                        if (e.target === closeModal) {
                            this.hideCloseTradeModal();
                        }
                    });
                }

                // Confirm close trade
                if (closeTradeConfirm) {
                    closeTradeConfirm.addEventListener('click', () => this.confirmCloseTrade());
                }

                // View trade details modal
                const viewTradeModalClose = document.getElementById('view-trade-modal-close');
                const closeDetailsModal = document.getElementById('close-details-modal');
                const viewTradeModal = document.getElementById('view-trade-modal');

                [viewTradeModalClose, closeDetailsModal].forEach(btn => {
                    if (btn) {
                        btn.addEventListener('click', () => this.hideViewTradeModal());
                    }
                });

                // Close view trade modal on overlay click
                if (viewTradeModal) {
                    viewTradeModal.addEventListener('click', (e) => {
                        if (e.target === viewTradeModal) {
                            this.hideViewTradeModal();
                        }
                    });
                }

                // Modal SOL amount buttons
                document.addEventListener('click', (e) => {
                    if (e.target.matches('#close-trade-modal .sol-btn')) {
                        const amount = e.target.getAttribute('data-amount');
                        document.getElementById('close-received-sol').value = amount;
                    }
                });

                // Modal market cap buttons
                document.addEventListener('click', (e) => {
                    if (e.target.matches('#close-trade-modal .mcap-btn')) {
                        const modalMcapButtons = document.querySelectorAll('#close-trade-modal .mcap-btn');
                        modalMcapButtons.forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        // Auto-calculate keep position when unit changes
                        this.calculateKeepPosition();
                    }
                });

                // Auto-calculate when exit mcap input changes
                const exitMcapInput = document.getElementById('close-exit-mcap');
                if (exitMcapInput) {
                    exitMcapInput.addEventListener('input', () => this.calculateKeepPosition());
                }

                // Auto-calculate when take profit input changes
                const takeProfitInput = document.getElementById('close-take-profit');
                if (takeProfitInput) {
                    takeProfitInput.addEventListener('input', (e) => {
                        if (e.isTrusted) {
                            this.calculateKeepPosition();
                        }
                    });
                }

                // Percentage buttons for take profit (based on current value)
                document.addEventListener('click', (e) => {
                    if (e.target.matches('#close-trade-modal .sol-percent-btn')) {
                        const percentAttr = e.target.getAttribute('data-percent');
                        if (this.currentTradeToClose && percentAttr) {
                            const percent = percentAttr === 'initials' ? 'initials' : parseFloat(percentAttr);
                            this.calculateTakeProfitFromPercent(percent);
                        }
                    }
                });
            }

            setupTabListener() {
                document.addEventListener('click', (e) => {
                    if (e.target.matches('[data-tab="tab-trading"]')) {
                        this.loadTrades();
                    }
                });
            }

            async updateSolPrice() {
                try {
                    // Use simple CoinGecko API for SOL price (no API key needed)
                    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.solPrice = data.solana?.usd || 200;
                    } else {
                        this.solPrice = 200; // Fallback
                    }
                } catch (error) {
                    this.solPrice = 200; // Fallback
                }
            }


            async addTrade() {
                const token = document.getElementById('modal-trade-token').value.trim().toUpperCase();
                const solAmount = parseFloat(document.getElementById('modal-trade-sol-amount').value);
                const entryMcap = document.getElementById('modal-trade-mcap').value.trim();
                const notes = document.getElementById('modal-trade-notes').value.trim();

                if (!token || !solAmount || !entryMcap) {
                    alert('Please fill in all required fields');
                    return;
                }

                const trade = {
                    id: Date.now().toString(),
                    token,
                    sol_amount: solAmount,
                    entry_mcap: entryMcap,
                    entry_price: this.solPrice * solAmount,
                    entry_date: new Date().toISOString(),
                    status: 'open',
                    pnl: 0,
                    user_id: window.supabase?.getCurrentUser()?.id
                };

                // Add notes if provided
                if (notes) {
                    trade.notes = notes;
                }
                
                // Store cost_basis locally until DB schema is updated
                trade._cost_basis = solAmount;

                try {
                    // Save to cloud
                    await this.saveTradeToCloud(trade);
                    
                    // Add to local array
                    this.trades.push(trade);
                    
                    // Clear form and close modal
                    this.clearAddTradeForm();
                    this.hideAddTradeModal();
                    
                    // Refresh display
                    this.renderTrades();
                    this.updatePortfolioStats();

                } catch (error) {
                    console.error('Error adding trade:', error);
                    alert('Failed to save trade');
                }
            }

            showAddTradeModal() {
                document.getElementById('add-trade-modal').style.display = 'flex';
            }

            hideAddTradeModal() {
                document.getElementById('add-trade-modal').style.display = 'none';
            }

            clearAddTradeForm() {
                document.getElementById('modal-trade-token').value = '';
                document.getElementById('modal-trade-sol-amount').value = '';
                document.getElementById('modal-trade-mcap').value = '';
                document.getElementById('modal-trade-notes').value = '';
            }

            async saveTradeToCloud(trade) {
                if (!window.supabase || !window.supabase.isAuthenticated()) {
                    throw new Error('Not authenticated');
                }

                // Create a copy with only fields that exist in the database
                const dbTrade = {
                    id: trade.id,
                    token: trade.token,
                    sol_amount: trade.sol_amount,
                    entry_mcap: trade.entry_mcap,
                    entry_price: trade.entry_price,
                    entry_date: trade.entry_date,
                    status: trade.status,
                    pnl: trade.pnl,
                    user_id: trade.user_id
                };
                
                // Add badge-related flags to database
                if (trade._initials_recovered !== undefined) dbTrade._initials_recovered = trade._initials_recovered;
                if (trade._is_free_ride_trade !== undefined) dbTrade._is_free_ride_trade = trade._is_free_ride_trade;
                if (trade._is_free_ride !== undefined) dbTrade._is_free_ride = trade._is_free_ride;
                if (trade._initials_taken !== undefined) dbTrade._initials_taken = trade._initials_taken;
                if (trade._cost_basis !== undefined) dbTrade._cost_basis = trade._cost_basis;
                
                // TODO: Add these fields when database schema is updated
                // stop_loss: trade.stop_loss,
                // take_profit: trade.take_profit,
                // notes: trade.notes
                
                await window.supabase.insert('trades', [dbTrade]);
            }

            handleLockButton() {
                const openTradesView = document.getElementById('open-trades-view');
                const closedTradesView = document.getElementById('closed-trades-view');
                const sectionTitle = document.getElementById('trading-section-title');
                const lockBtn = document.getElementById('lock-btn');
                
                if (!openTradesView || !closedTradesView || !sectionTitle || !lockBtn) {
                    console.error('Cannot find required elements for lock button');
                    return;
                }
                
                const lockIcon = lockBtn.querySelector('i[data-lucide]');
                
                // Check current state based on which view is visible
                const showingClosed = closedTradesView.style.display !== 'none';
                
                if (showingClosed) {
                    // Switch to open trades (now showing open, next action is to go to closed)
                    openTradesView.style.display = 'block';
                    closedTradesView.style.display = 'none';
                    sectionTitle.textContent = 'Open Positions';
                    if (lockBtn) {
                        lockBtn.innerHTML = '<i data-lucide="lock" style="width: 18px; height: 18px;"></i>';
                    }
                    console.log('ðŸ”’ Switched to open positions, showing lock for next action');
                } else {
                    // Switch to closed trades (now showing closed, next action is to go to open)
                    openTradesView.style.display = 'none';
                    closedTradesView.style.display = 'block';
                    sectionTitle.textContent = 'Closed Trades';
                    if (lockBtn) {
                        lockBtn.innerHTML = '<i data-lucide="unlock" style="width: 18px; height: 18px;"></i>';
                    }
                    console.log('ðŸ”“ Switched to closed trades, showing unlock for next action');
                }
                
                // Recreate icons to update the changed icon
                if (window.lucide) {
                    lucide.createIcons();
                }
            }

            async loadTrades() {
                try {
                    if (!window.supabase || !window.supabase.isAuthenticated()) {
                        return;
                    }

                    const user = window.supabase.getCurrentUser();
                    const data = await window.supabase.query(`trades?user_id=eq.${user.id}&select=*`);
                    
                    if (data) {
                        // Add cost_basis fallback for existing trades
                        this.trades = data.map(trade => {
                            if (!trade._cost_basis) {
                                trade._cost_basis = trade.sol_amount; // Fallback: cost basis = original sol amount
                            }
                            return trade;
                        });
                        this.renderTrades();
                        this.updatePortfolioStats();
                    }

                } catch (error) {
                    console.error('Error loading trades:', error);
                }
            }

            renderTrades() {
                console.log(`RENDER TRADES: Total trades: ${this.trades.length}`);
                const openTrades = this.trades.filter(t => t.status === 'open');
                const closedTrades = this.trades.filter(t => t.status === 'closed');
                
                console.log(`RENDER TRADES: Open trades: ${openTrades.length}, Closed trades: ${closedTrades.length}`);
                openTrades.forEach((trade, i) => {
                    console.log(`OPEN TRADE ${i+1}:`, {
                        id: trade.id,
                        token: trade.token,
                        sol_amount: trade.sol_amount,
                        status: trade.status,
                        cost_basis: trade._cost_basis
                    });
                });

                this.renderOpenTrades(openTrades);
                this.renderClosedTrades(closedTrades);
            }

            renderOpenTrades(trades) {
                const container = document.getElementById('open-trades-list');
                
                if (!trades.length) {
                    container.innerHTML = '<div class="empty-trades">No open trades yet</div>';
                    return;
                }

                const html = `
                    <div class="trade-header">
                        <div>Token</div>
                        <div>SOL</div>
                        <div>Entry McAP</div>
                        <div>Entry Price</div>
                        <div>Stop Loss</div>
                        <div>Take Profit</div>
                        <div>P&L</div>
                        <div>Notes</div>
                        <div>Actions</div>
                    </div>
                    ${trades.map(trade => `
                        <div class="trade-row">
                            <div class="trade-token" data-label="Token">
                                <strong>${trade.token}</strong>
                            </div>
                            <div class="trade-amount" data-label="SOL Amount">${trade.sol_amount} SOL</div>
                            <div class="trade-entry-price" data-label="Entry McAP">${trade.entry_mcap}</div>
                            <div class="trade-entry-price" data-label="Entry Price">$${trade.entry_price.toFixed(0)}</div>
                            <div class="trade-risk" data-label="Stop Loss">${trade.stop_loss || '-'}</div>
                            <div class="trade-risk" data-label="Take Profit">${trade.take_profit || '-'}</div>
                            <div class="trade-pnl ${trade.pnl >= 0 ? 'positive' : 'negative'}" data-label="P&L">
                                ${trade.pnl >= 0 ? '+' : ''}${trade.pnl.toFixed(2)} SOL
                            </div>
                            <div class="trade-notes" data-label="Notes" title="${trade.notes || ''}">${trade.notes ? (trade.notes.length > 20 ? trade.notes.substring(0, 20) + '...' : trade.notes) : '-'}</div>
                            <div class="trade-actions" data-label="Actions">
                                <button class="trade-action-btn" onclick="window.TradingManager.closeTrade('${trade.id}')" title="Close Trade">
                                    <i data-lucide="x-circle" style="width: 16px; height: 16px;"></i>
                                </button>
                            </div>
                        </div>
                    `).join('')}
                `;

                container.innerHTML = html;
                
                // Initialize lucide icons for action buttons
                setTimeout(() => {
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                }, 50);
            }

            getBadgeIconForClosedTrade(trade) {
                console.log(`ðŸ” Badge check for ${trade.token} (${trade.sol_amount} SOL):`, {
                    cost_basis: trade._cost_basis || trade.cost_basis,
                    final_pnl: trade.final_pnl,
                    _initials_recovered: trade._initials_recovered,
                    _is_free_ride_trade: trade._is_free_ride_trade,
                    exit_date: trade.exit_date
                });
                
                // Use the persisted flags from the database
                if (trade._initials_recovered === true) {
                    console.log(`â†’ Showing Initials Raus icon`);
                    return '<i data-lucide="trophy" class="trade-badge-icon initials-icon" title="Initials Raus"></i>';
                } else if (trade._is_free_ride_trade === true) {
                    console.log(`â†’ Showing Free Ride icon`);
                    return '<i data-lucide="rocket" class="trade-badge-icon free-ride-icon" title="Free Ride"></i>';
                }
                
                console.log(`â†’ No badge (flags not set)`);
                return '';
            }

            renderClosedTrades(trades) {
                const container = document.getElementById('closed-trades-list');
                
                if (!trades.length) {
                    container.innerHTML = '<div class="empty-trades">No closed trades yet</div>';
                    return;
                }

                // Sort trades by exit_date (newest first)
                const sortedTrades = [...trades].sort((a, b) => {
                    const dateA = new Date(a.exit_date || a.entry_date);
                    const dateB = new Date(b.exit_date || b.entry_date);
                    return dateB.getTime() - dateA.getTime(); // Newest first
                });

                const html = `
                    <div class="trade-header">
                        <div>Token</div>
                        <div>SOL</div>
                        <div>Entry â†’ Exit</div>
                        <div>Entry â†’ Exit Price</div>
                        <div>Final P&L</div>
                        <div>Notes</div>
                        <div>Date</div>
                        <div>Actions</div>
                    </div>
                    ${sortedTrades.map(trade => `
                        <div class="trade-row">
                            <div class="trade-token" data-label="Token">
                                <strong>${trade.token}</strong>
                                ${this.getBadgeIconForClosedTrade(trade)}
                            </div>
                            <div class="trade-amount" data-label="SOL Amount">${trade.sol_amount} SOL</div>
                            <div class="trade-entry-price" data-label="McAP">${trade.entry_mcap} â†’ ${trade.exit_mcap || 'N/A'}</div>
                            <div class="trade-entry-price" data-label="Price">$${trade.entry_price.toFixed(0)} â†’ $${(trade.exit_price || 0).toFixed(0)}</div>
                            <div class="trade-pnl ${(trade.final_pnl || 0) >= 0 ? 'positive' : 'negative'}" data-label="P&L">
                                ${(trade.final_pnl || 0) >= 0 ? '+' : ''}${(trade.final_pnl || 0).toFixed(2)} SOL
                            </div>
                            <div class="trade-notes" data-label="Notes" title="${(trade.notes || '') + (trade.close_learnings ? '\n\nLearnings: ' + trade.close_learnings : '')}">
                                ${trade.notes ? (trade.notes.length > 15 ? trade.notes.substring(0, 15) + '...' : trade.notes) : '-'}
                                ${trade.close_learnings ? '<br><small style="color: #059669; font-style: italic;">ðŸ“ Learnings</small>' : ''}
                            </div>
                            <div data-label="Date">${new Date(trade.exit_date || trade.entry_date).toLocaleDateString()}</div>
                            <div class="trade-actions" data-label="Actions">
                                <button class="trade-action-btn" onclick="window.TradingManager.viewTradeDetails('${trade.id}')" title="View Details">
                                    <i data-lucide="eye" style="width: 16px; height: 16px;"></i>
                                </button>
                                <button class="trade-action-btn" onclick="window.TradingManager.deleteTrade('${trade.id}')" title="Delete Trade">
                                    <i data-lucide="trash-2" style="width: 16px; height: 16px;"></i>
                                </button>
                            </div>
                        </div>
                    `).join('')}
                `;

                container.innerHTML = html;
                
                // Initialize lucide icons for action buttons
                setTimeout(() => {
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                }, 50);
            }

            async updatePortfolioStats() {
                const openTrades = this.trades.filter(t => t.status === 'open');
                const closedTrades = this.trades.filter(t => t.status === 'closed');
                
                // Calculate existing stats
                const totalPnl = closedTrades.reduce((sum, t) => sum + (t.final_pnl || 0), 0);
                const winningTrades = closedTrades.filter(t => (t.final_pnl || 0) > 0).length;
                const losingTrades = closedTrades.filter(t => (t.final_pnl || 0) < 0).length;
                const nonBreakevenTrades = winningTrades + losingTrades;
                const winRate = nonBreakevenTrades > 0 ? (winningTrades / nonBreakevenTrades * 100) : 0;
                
                // Calculate SOL in open trades
                const solInTrades = openTrades.reduce((sum, t) => sum + (t.sol_amount || 0), 0);
                
                // Get SOL balance from SimpleCounters
                let solBalance = 0;
                if (window.SimpleCounters) {
                    solBalance = await window.SimpleCounters.getSolBalance();
                }

                // Calculate P&L in USD
                const totalPnlUsd = totalPnl * this.solPrice;

                // Update all stats
                document.getElementById('sol-balance').textContent = `${solBalance.toFixed(2)} SOL`;
                document.getElementById('sol-in-trades').textContent = `${solInTrades.toFixed(2)} SOL`;
                document.getElementById('total-pnl').textContent = `${totalPnl >= 0 ? '+' : ''}${totalPnl.toFixed(2)} SOL`;
                document.getElementById('total-pnl').className = `stat-number ${totalPnl >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('total-pnl-usd').textContent = `${totalPnlUsd >= 0 ? '+' : ''}$${totalPnlUsd.toFixed(2)}`;
                document.getElementById('total-pnl-usd').className = `stat-number ${totalPnlUsd >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('open-trades').textContent = openTrades.length;
                document.getElementById('win-rate').textContent = `${winRate.toFixed(1)}%`;
            }

            async editTrade(tradeId) {
                const trade = this.trades.find(t => t.id === tradeId);
                if (!trade) return;

                const newMcap = prompt(`Current Market Cap for ${trade.token}:`, trade.entry_mcap);
                const newSol = prompt(`Current SOL value:`, trade.sol_amount);

                if (newMcap && newSol) {
                    trade.current_mcap = newMcap;
                    trade.current_sol = parseFloat(newSol);
                    trade.pnl = trade.current_sol - trade.sol_amount;

                    await this.updateTradeInCloud(trade);
                    this.renderTrades();
                    this.updatePortfolioStats();
                }
            }

            closeTrade(tradeId) {
                const trade = this.trades.find(t => t.id === tradeId);
                if (!trade) return;

                this.showCloseTradeModal(trade);
            }

            showCloseTradeModal(trade) {
                this.currentTradeToClose = trade;

                // Fill trade info
                document.getElementById('close-trade-token').textContent = trade.token;
                document.getElementById('close-trade-entry-amount').textContent = `${trade.sol_amount} SOL`;
                document.getElementById('close-trade-entry-mcap').textContent = trade.entry_mcap;

                // Clear form
                document.getElementById('close-exit-mcap').value = '';
                document.getElementById('close-take-profit').value = '';
                document.getElementById('close-keep-position').value = trade.sol_amount.toFixed(3); // Show current position

                // Auto-select same market cap unit as entry
                const entryMcap = trade.entry_mcap;
                let entryUnit = 'B'; // Default fallback
                
                // Extract unit from entry market cap (e.g., "2.1B" -> "B")
                if (entryMcap) {
                    const lastChar = entryMcap.slice(-1).toUpperCase();
                    if (['K', 'M', 'B'].includes(lastChar)) {
                        entryUnit = lastChar;
                    }
                }

                // Set the same unit for exit
                document.querySelectorAll('#close-trade-modal .mcap-btn').forEach(btn => btn.classList.remove('active'));
                const targetButton = document.querySelector(`#close-trade-modal .mcap-btn[data-multiplier="${entryUnit}"]`);
                if (targetButton) {
                    targetButton.classList.add('active');
                } else {
                    // Fallback to B if unit not found
                    document.querySelector('#close-trade-modal .mcap-btn[data-multiplier="B"]').classList.add('active');
                }

                // Show modal
                document.getElementById('close-trade-modal').style.display = 'flex';
            }

            hideCloseTradeModal() {
                document.getElementById('close-trade-modal').style.display = 'none';
                this.currentTradeToClose = null;
                
                // Clear form fields
                document.getElementById('close-exit-mcap').value = '';
                document.getElementById('close-take-profit').value = '';
                document.getElementById('close-keep-position').value = '';
                document.getElementById('close-trade-learnings').value = '';
            }

            calculateTakeProfitFromPercent(percent) {
                if (!this.currentTradeToClose) return;

                const exitMcapValue = parseFloat(document.getElementById('close-exit-mcap').value);
                const activeMultiplier = document.querySelector('#close-trade-modal .mcap-btn.active')?.getAttribute('data-multiplier') || 'B';
                
                // Get original investment amounts
                const originalSolAmount = this.currentTradeToClose.sol_amount;
                const originalCostBasis = this.currentTradeToClose._cost_basis !== undefined ? this.currentTradeToClose._cost_basis : originalSolAmount; // Fallback for older trades
                
                if (percent === 'initials') {
                    // Initials button: Verkaufe originalCostBasis SOL aus der aktuellen Position
                    if (!exitMcapValue || isNaN(exitMcapValue)) {
                        // Ohne Exit Mcap - verwende ursprÃ¼ngliche Mengen
                        const solToSell = originalCostBasis;
                        const solRemaining = Math.max(0, originalSolAmount - solToSell);
                        
                        document.getElementById('close-take-profit').value = solToSell.toFixed(3);
                        document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                        return;
                    }
                    
                    // Mit Exit Mcap - berechne aktuelle Position und verkaufe originalCostBasis davon
                    try {
                        const entryMcap = this.currentTradeToClose.entry_mcap;
                        const entryValue = parseFloat(entryMcap);
                        const entryUnit = entryMcap.slice(-1).toUpperCase();
                        
                        const multipliers = { 'K': 1000, 'M': 1000000, 'B': 1000000000 };
                        const entryActual = entryValue * (multipliers[entryUnit] || 1000000000);
                        const exitActual = exitMcapValue * (multipliers[activeMultiplier] || 1000000000);
                        
                        const percentageChange = (exitActual - entryActual) / entryActual;
                        const currentTotalValue = originalSolAmount * (1 + percentageChange);
                        
                        const solToSell = originalCostBasis;
                        const solRemaining = Math.max(0, currentTotalValue - solToSell);
                        
                        console.log(`INITIALS: Current value ${currentTotalValue.toFixed(3)} SOL, selling ${solToSell} SOL (cost basis), keeping ${solRemaining.toFixed(3)} SOL (free ride)`);
                        
                        document.getElementById('close-take-profit').value = solToSell.toFixed(3);
                        document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                        return;
                    } catch (error) {
                        console.error('Error calculating initials:', error);
                        // Fallback
                        const solToSell = originalCostBasis;
                        const solRemaining = Math.max(0, originalSolAmount - solToSell);
                        
                        document.getElementById('close-take-profit').value = solToSell.toFixed(3);
                        document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                        return;
                    }
                }

                if (!exitMcapValue || isNaN(exitMcapValue)) {
                    // No exit mcap set yet, show percentage of current position
                    const takeProfit = (originalSolAmount * percent / 100).toFixed(3);
                    const keepPosition = (originalSolAmount * (100 - percent) / 100).toFixed(3);
                    
                    document.getElementById('close-take-profit').value = takeProfit;
                    document.getElementById('close-keep-position').value = keepPosition;
                    return;
                }

                try {
                    // Parse entry market cap
                    const entryMcap = this.currentTradeToClose.entry_mcap;
                    const entryValue = parseFloat(entryMcap);
                    const entryUnit = entryMcap.slice(-1).toUpperCase();
                    
                    // Convert both to same base
                    const multipliers = { 'K': 1000, 'M': 1000000, 'B': 1000000000 };
                    const entryActual = entryValue * (multipliers[entryUnit] || 1000000000);
                    const exitActual = exitMcapValue * (multipliers[activeMultiplier] || 1000000000);
                    
                    // Calculate percentage change
                    const percentageChange = (exitActual - entryActual) / entryActual;
                    
                    // Calculate current total value in SOL
                    const currentTotalValue = originalSolAmount * (1 + percentageChange);
                    
                    // Calculate SOL to sell (percent of current value)
                    const solToSell = currentTotalValue * (percent / 100);
                    const solRemaining = Math.max(0, currentTotalValue - solToSell);
                    
                    // Debug
                    console.log(`DEBUG: Entry ${originalSolAmount} SOL, Exit change: ${(percentageChange*100).toFixed(1)}%`);
                    console.log(`DEBUG: Current total value: ${currentTotalValue.toFixed(3)} SOL`);
                    console.log(`DEBUG: ${percent}% = ${solToSell.toFixed(3)} SOL to sell`);
                    console.log(`DEBUG: Remaining: ${solRemaining.toFixed(3)} SOL`);
                    
                    // Update inputs
                    document.getElementById('close-take-profit').value = solToSell.toFixed(3);
                    document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                    
                } catch (error) {
                    console.error('Error calculating take profit from percent:', error);
                    // Fall back to simple percentage of entry amount
                    const takeProfit = (originalSolAmount * percent / 100).toFixed(3);
                    const keepPosition = (originalSolAmount * (100 - percent) / 100).toFixed(3);
                    
                    document.getElementById('close-take-profit').value = takeProfit;
                    document.getElementById('close-keep-position').value = keepPosition;
                }
            }

            calculateKeepPosition() {
                if (!this.currentTradeToClose) return;

                const solToSell = parseFloat(document.getElementById('close-take-profit').value);
                const originalAmount = this.currentTradeToClose.sol_amount;
                
                if (!solToSell || isNaN(solToSell)) {
                    document.getElementById('close-keep-position').value = originalAmount.toFixed(3);
                    return;
                }

                const exitMcapValue = parseFloat(document.getElementById('close-exit-mcap').value);
                const activeMultiplier = document.querySelector('#close-trade-modal .mcap-btn.active')?.getAttribute('data-multiplier') || 'B';
                
                if (!exitMcapValue || isNaN(exitMcapValue)) {
                    // No exit mcap, simple calculation
                    const solRemaining = Math.max(0, originalAmount - solToSell);
                    document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                    return;
                }

                try {
                    // Parse entry market cap
                    const entryMcap = this.currentTradeToClose.entry_mcap;
                    const entryValue = parseFloat(entryMcap);
                    const entryUnit = entryMcap.slice(-1).toUpperCase();
                    
                    // Convert both to same base
                    const multipliers = { 'K': 1000, 'M': 1000000, 'B': 1000000000 };
                    const entryActual = entryValue * (multipliers[entryUnit] || 1000000000);
                    const exitActual = exitMcapValue * (multipliers[activeMultiplier] || 1000000000);
                    
                    // Calculate percentage change
                    const percentageChange = (exitActual - entryActual) / entryActual;
                    
                    // Calculate current total value and remaining position
                    const currentTotalValue = originalAmount * (1 + percentageChange);
                    const solRemaining = Math.max(0, currentTotalValue - solToSell);
                    
                    // Update remaining position
                    document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                    
                } catch (error) {
                    console.error('Error calculating keep position:', error);
                    const solRemaining = Math.max(0, originalAmount - solToSell);
                    document.getElementById('close-keep-position').value = solRemaining.toFixed(3);
                }
            }

            async confirmCloseTrade() {
                if (!this.currentTradeToClose) return;

                const mcapValue = parseFloat(document.getElementById('close-exit-mcap').value);
                const activeMultiplier = document.querySelector('#close-trade-modal .mcap-btn.active')?.getAttribute('data-multiplier') || 'B';
                const solToSell = parseFloat(document.getElementById('close-take-profit').value);
                const solRemaining = parseFloat(document.getElementById('close-keep-position').value);
                const learnings = document.getElementById('close-trade-learnings').value.trim();

                if (!mcapValue || !solToSell) {
                    alert('Please fill in all fields');
                    return;
                }

                const exitMcap = `${mcapValue}${activeMultiplier}`;
                const originalTrade = this.currentTradeToClose;
                const originalAmount = originalTrade.sol_amount;
                const originalCostBasis = originalTrade._cost_basis !== undefined ? originalTrade._cost_basis : originalAmount; // Fallback for older trades
                
                // Calculate current position value based on mcap change
                const entryMcap = originalTrade.entry_mcap;
                const entryValue = parseFloat(entryMcap);
                const entryUnit = entryMcap.slice(-1).toUpperCase();
                const multipliers = { 'K': 1000, 'M': 1000000, 'B': 1000000000 };
                const entryActual = entryValue * (multipliers[entryUnit] || 1000000000);
                const exitActual = mcapValue * (multipliers[activeMultiplier] || 1000000000);
                const percentageChange = (exitActual - entryActual) / entryActual;
                const currentPositionValue = originalAmount * (1 + percentageChange);
                
                console.log(`CLOSE TRADE: Selling ${solToSell} SOL, keeping ${solRemaining} SOL`);
                console.log(`ORIGINAL: ${originalAmount} SOL with cost basis ${originalCostBasis} SOL`);
                console.log(`CURRENT POSITION VALUE: ${currentPositionValue.toFixed(3)} SOL (${(percentageChange*100).toFixed(1)}% change)`);

                try {
                    if (solToSell >= currentPositionValue) {
                        // Full close - close the entire trade
                        originalTrade.status = 'closed';
                        originalTrade.exit_mcap = exitMcap;
                        originalTrade.exit_price = solToSell * this.solPrice; // USD value of sold amount
                        originalTrade.received_sol = solToSell;
                        originalTrade.final_pnl = solToSell - originalCostBasis;
                        originalTrade.exit_date = new Date().toISOString();
                        
                        // Add learnings if provided
                        if (learnings) {
                            originalTrade.close_learnings = learnings;
                        }

                        console.log(`FULL CLOSE: PnL = ${originalTrade.final_pnl.toFixed(3)} SOL`);
                        
                        // Add badge logic for full close
                        if (originalTrade._is_free_ride === true) {
                            originalTrade._is_free_ride_trade = true;
                            console.log(`FULL CLOSE: Setting _is_free_ride_trade = true (from free ride position)`);
                        } else if (originalCostBasis > 0 && originalTrade.final_pnl >= 0 && !originalTrade._initials_taken) {
                            originalTrade._initials_recovered = true;
                            console.log(`FULL CLOSE: Setting _initials_recovered = true (first initials recovery)`);
                        } else if (originalTrade._initials_taken === true) {
                            originalTrade._is_free_ride_trade = true;
                            console.log(`FULL CLOSE: Setting _is_free_ride_trade = true (subsequent after initials)`);
                        } else if (originalCostBasis === 0) {
                            originalTrade._is_free_ride_trade = true;
                            console.log(`FULL CLOSE: Setting _is_free_ride_trade = true (cost basis is 0)`);
                        }
                        
                        await this.updateTradeInCloud(originalTrade);
                    } else {
                        // Partial close - FREE RIDE LOGIC
                        
                        // Determine cost basis for sold portion
                        let soldCostBasis, remainingCostBasis;
                        
                        if (solToSell <= originalCostBasis) {
                            // Selling less than or equal to original cost basis
                            soldCostBasis = solToSell;
                            remainingCostBasis = originalCostBasis - solToSell;
                        } else {
                            // Selling more than original cost basis (taking profits)
                            soldCostBasis = originalCostBasis;
                            remainingCostBasis = 0; // FREE RIDE!
                        }
                        
                        console.log(`PARTIAL CLOSE: Sold cost basis = ${soldCostBasis}, Remaining cost basis = ${remainingCostBasis}`);
                        console.log(`PNL CALCULATION: ${solToSell} SOL sold - ${soldCostBasis} SOL cost = ${(solToSell - soldCostBasis).toFixed(3)} SOL PnL`);
                        
                        // Create closed trade for sold portion
                        const closedTrade = {
                            id: Date.now().toString(),
                            token: originalTrade.token,
                            sol_amount: solToSell,
                            entry_mcap: originalTrade.entry_mcap,
                            entry_price: soldCostBasis * this.solPrice, // USD value of invested amount
                            entry_date: originalTrade.entry_date,
                            status: 'closed',
                            exit_mcap: exitMcap,
                            exit_price: solToSell * this.solPrice, // USD value of sold amount
                            received_sol: solToSell,
                            final_pnl: solToSell - soldCostBasis,
                            exit_date: new Date().toISOString(),
                            user_id: originalTrade.user_id,
                            // Copy optional fields from original trade
                            notes: originalTrade.notes,
                            stop_loss: originalTrade.stop_loss,
                            take_profit: originalTrade.take_profit
                        };
                        
                        // Add learnings if provided
                        if (learnings) {
                            closedTrade.close_learnings = learnings;
                        }
                        
                        // Store cost_basis locally
                        closedTrade._cost_basis = soldCostBasis;
                        
                        // Mark trade type based on original position and what happens
                        console.log(`TRADE MARKING DEBUG:`, {
                            is_free_ride: originalTrade._is_free_ride,
                            soldCostBasis,
                            solToSell,
                            initials_taken: originalTrade._initials_taken,
                            condition1: originalTrade._is_free_ride === true,
                            condition2: soldCostBasis > 0 && solToSell >= soldCostBasis && !originalTrade._initials_taken,
                            condition3: originalTrade._initials_taken === true
                        });
                        
                        if (originalTrade._is_free_ride === true) {
                            // This trade is from a free ride position
                            closedTrade._is_free_ride_trade = true;
                            console.log(`Setting _is_free_ride_trade = true (from free ride position)`);
                        } else if (soldCostBasis > 0 && solToSell >= soldCostBasis && !originalTrade._initials_taken) {
                            // This is the FIRST "initials raus" trade (cost basis recovered or more)
                            closedTrade._initials_recovered = true;
                            originalTrade._initials_taken = true; // Mark that initials have been taken from this position
                            console.log(`Setting _initials_recovered = true (first initials recovery)`);
                        } else if (originalTrade._initials_taken === true) {
                            // Any subsequent trade after initials have been taken is a free ride
                            closedTrade._is_free_ride_trade = true;
                            console.log(`Setting _is_free_ride_trade = true (subsequent after initials)`);
                        } else {
                            // Fallback: if cost basis is 0, it's definitely a free ride trade
                            if (soldCostBasis === 0) {
                                closedTrade._is_free_ride_trade = true;
                                console.log(`Setting _is_free_ride_trade = true (cost basis is 0)`);
                            }
                        }
                        
                        // Mark if remaining position becomes free ride
                        if (remainingCostBasis === 0) {
                            originalTrade._is_free_ride = true;
                        }

                        console.log(`CLOSED TRADE: ${solToSell} SOL out, cost basis ${soldCostBasis} SOL, PnL = ${closedTrade.final_pnl.toFixed(3)} SOL`);
                        
                        // Check if there's actually something remaining
                        if (solRemaining <= 0) {
                            console.log(`WARNING: solRemaining is ${solRemaining} - marking trade as closed`);
                            originalTrade.status = 'closed';
                            originalTrade.exit_mcap = exitMcap;
                            originalTrade.exit_price = (originalAmount * this.solPrice);
                            originalTrade.received_sol = originalAmount;
                            originalTrade.final_pnl = originalAmount - originalCostBasis;
                            originalTrade.exit_date = new Date().toISOString();
                        } else {
                            // Update original trade for remaining position
                            originalTrade.sol_amount = solRemaining;
                            originalTrade._cost_basis = remainingCostBasis;
                            originalTrade.entry_mcap = exitMcap; // New entry = current level
                            originalTrade.entry_price = remainingCostBasis * this.solPrice; // USD value of remaining cost basis
                            // Keep status as 'open'
                        }

                        console.log(`REMAINING TRADE: ${solRemaining} SOL with cost basis ${remainingCostBasis} SOL`);
                        console.log(`REMAINING TRADE STATUS: ${originalTrade.status}`);
                        console.log(`REMAINING TRADE OBJECT:`, originalTrade);
                        if (remainingCostBasis === 0) {
                            console.log(`ðŸŽ‰ FREE RIDE ACTIVATED!`);
                        }

                        // Save both trades to cloud
                        await this.saveTradeToCloud(closedTrade);
                        await this.updateTradeInCloud(originalTrade);

                        // Add closed trade to local array
                        this.trades.push(closedTrade);
                        
                        // Update the original trade in local array too
                        const tradeIndex = this.trades.findIndex(t => t.id === originalTrade.id);
                        if (tradeIndex !== -1) {
                            this.trades[tradeIndex] = originalTrade;
                        }
                    }

                    this.renderTrades();
                    this.updatePortfolioStats();
                    this.hideCloseTradeModal();

                } catch (error) {
                    console.error('Error closing trade:', error);
                    alert('Failed to close trade');
                }
            }

            async updateTradeInCloud(trade) {
                if (!window.supabase || !window.supabase.isAuthenticated()) return;
                
                // Create a copy with only fields that exist in the database
                const dbTrade = {
                    id: trade.id,
                    token: trade.token,
                    sol_amount: trade.sol_amount,
                    entry_mcap: trade.entry_mcap,
                    entry_price: trade.entry_price,
                    entry_date: trade.entry_date,
                    status: trade.status,
                    pnl: trade.pnl,
                    user_id: trade.user_id
                };

                // Add fields that might exist for closed trades
                if (trade.exit_mcap !== undefined) dbTrade.exit_mcap = trade.exit_mcap;
                if (trade.exit_price !== undefined) dbTrade.exit_price = trade.exit_price;
                if (trade.exit_date !== undefined) dbTrade.exit_date = trade.exit_date;
                if (trade.final_pnl !== undefined) dbTrade.final_pnl = trade.final_pnl;
                if (trade.received_sol !== undefined) dbTrade.received_sol = trade.received_sol;
                if (trade.current_mcap !== undefined) dbTrade.current_mcap = trade.current_mcap;
                if (trade.current_sol !== undefined) dbTrade.current_sol = trade.current_sol;
                
                // Add badge-related flags to database
                if (trade._initials_recovered !== undefined) dbTrade._initials_recovered = trade._initials_recovered;
                if (trade._is_free_ride_trade !== undefined) dbTrade._is_free_ride_trade = trade._is_free_ride_trade;
                if (trade._is_free_ride !== undefined) dbTrade._is_free_ride = trade._is_free_ride;
                if (trade._initials_taken !== undefined) dbTrade._initials_taken = trade._initials_taken;
                if (trade._cost_basis !== undefined) dbTrade._cost_basis = trade._cost_basis;
                
                // TODO: Add these fields when database schema is updated
                // if (trade.stop_loss !== undefined) dbTrade.stop_loss = trade.stop_loss;
                // if (trade.take_profit !== undefined) dbTrade.take_profit = trade.take_profit;
                // if (trade.notes !== undefined) dbTrade.notes = trade.notes;
                
                await window.supabase.update('trades', dbTrade, trade.id);
            }

            async deleteTrade(tradeId) {
                if (!confirm('Are you sure you want to delete this trade?')) return;

                try {
                    // Remove from cloud
                    if (window.supabase && window.supabase.isAuthenticated()) {
                        await window.supabase.delete('trades', tradeId);
                    }
                    
                    // Remove from local array
                    this.trades = this.trades.filter(t => t.id !== tradeId);
                    
                    // Refresh display
                    this.renderTrades();
                    this.updatePortfolioStats();

                } catch (error) {
                    console.error('Error deleting trade:', error);
                    alert('Failed to delete trade');
                }
            }


            async refreshPrices() {
                await this.updateSolPrice();
                // Would update all current market caps here
                alert(`SOL Price updated: $${this.solPrice.toFixed(2)}`);
            }

            viewTradeDetails(tradeId) {
                const trade = this.trades.find(t => t.id === tradeId);
                if (!trade) {
                    console.error('Trade not found:', tradeId);
                    return;
                }

                // Populate modal with trade data
                document.getElementById('detail-token').textContent = trade.token;
                document.getElementById('detail-sol-amount').textContent = `${trade.sol_amount} SOL`;
                document.getElementById('detail-entry-mcap').textContent = trade.entry_mcap;
                document.getElementById('detail-exit-mcap').textContent = trade.exit_mcap || '-';
                
                const pnlValue = trade.final_pnl || 0;
                const pnlElement = document.getElementById('detail-pnl');
                pnlElement.textContent = `${pnlValue >= 0 ? '+' : ''}${pnlValue.toFixed(3)} SOL`;
                pnlElement.style.color = pnlValue >= 0 ? '#059669' : '#dc2626';
                
                document.getElementById('detail-entry-date').textContent = new Date(trade.entry_date).toLocaleDateString('de-DE');
                document.getElementById('detail-exit-date').textContent = trade.exit_date ? new Date(trade.exit_date).toLocaleDateString('de-DE') : '-';
                
                // Show notes and learnings
                const notesElement = document.getElementById('detail-entry-notes');
                notesElement.textContent = trade.notes || '';
                
                const learningsElement = document.getElementById('detail-close-learnings');
                learningsElement.textContent = trade.close_learnings || '';

                // Show modal
                document.getElementById('view-trade-modal').style.display = 'flex';
            }

            hideViewTradeModal() {
                document.getElementById('view-trade-modal').style.display = 'none';
            }
        }

        // Initialize Trading Manager
        window.TradingManager = new TradingManager();
        
        // Initialize lucide icons for trade action buttons
        setTimeout(() => {
            if (window.lucide) {
                lucide.createIcons();
                console.log('ðŸŽ¨ Lucide icons initialized for trade action buttons');
            }
        }, 100);
    </script>
    
    <!-- ========================================= -->
    <!-- ANALYTICS MANAGER -->
    <!-- ========================================= -->
    <script>
        class AnalyticsManager {
            constructor() {
                this.chart = null;
                this.currentPeriod = 'week';
                this.balanceHistory = [];
                this.init();
            }

            async init() {
                // Check if supabase is available and user is authenticated
                if (!window.supabase?.isAuthenticated()) {
                    console.warn('Analytics init skipped - not authenticated');
                    return;
                }
                
                await this.loadBalanceHistory();
                await this.checkAndRecordDailyBalance();
                this.setupPeriodButtons();
                await this.setupChart();
                await this.updateCurrentBalance();
                await this.setupHeatmap();
            }

            async loadBalanceHistory() {
                try {
                    if (!window.supabase?.isAuthenticated()) {
                        this.balanceHistory = [];
                        return;
                    }

                    const user = window.supabase.getCurrentUser();
                    if (!user) {
                        this.balanceHistory = [];
                        return;
                    }

                    // Query balance history from cloud
                    const data = await window.supabase.query(
                        `analytics_balance_history?user_id=eq.${user.id}&select=*&order=date.asc`
                    );

                    this.balanceHistory = data || [];
                    console.log(`ðŸ“Š Loaded ${this.balanceHistory.length} balance history records from cloud`);
                } catch (error) {
                    console.error('Error loading balance history:', error);
                    this.balanceHistory = [];
                }
            }

            async getTrackingTime() {
                try {
                    if (!window.supabase?.isAuthenticated()) return '06:00';
                    
                    const user = window.supabase.getCurrentUser();
                    if (!user) return '06:00';

                    // Query user settings from cloud
                    const settings = await window.supabase.query(
                        `user_settings?user_id=eq.${user.id}&setting_key=eq.balanceTrackingTime&select=setting_value`
                    );

                    return settings && settings.length > 0 ? settings[0].setting_value : '06:00';
                } catch (error) {
                    console.error('Error getting tracking time:', error);
                    return '06:00';
                }
            }

            async checkAndRecordDailyBalance() {
                const now = new Date();
                const today = now.toISOString().split('T')[0];
                const lastRecorded = this.balanceHistory[this.balanceHistory.length - 1];
                
                // Get tracking time from settings (default 06:00)
                const trackingTime = await this.getTrackingTime();
                const [hours, minutes] = trackingTime.split(':').map(Number);
                
                // Create target time for today
                const targetTime = new Date();
                targetTime.setHours(hours, minutes, 0, 0);
                
                // Check if we haven't recorded today AND it's past the target time
                const hasRecordedToday = lastRecorded && lastRecorded.date === today;
                const isPastTargetTime = now >= targetTime;
                
                if (!hasRecordedToday && isPastTargetTime) {
                    await this.recordDailyBalance();
                } else if (!hasRecordedToday) {
                    // Schedule recording for target time
                    this.scheduleNextRecording(targetTime);
                }
            }

            scheduleNextRecording(targetTime) {
                const now = new Date();
                const msUntilTarget = targetTime.getTime() - now.getTime();
                
                if (msUntilTarget > 0) {
                    console.log(`ðŸ“Š Next SOL balance recording scheduled for ${targetTime.toLocaleTimeString('de-DE')}`);
                    setTimeout(() => {
                        this.recordDailyBalance();
                    }, msUntilTarget);
                }
            }

            async recordDailyBalance() {
                try {
                    if (!window.supabase?.isAuthenticated()) {
                        console.log('ðŸ“Š Not authenticated, skipping balance recording');
                        return;
                    }

                    const user = window.supabase.getCurrentUser();
                    if (!user) return;

                    let balance = 0;
                    
                    // Get SOL balance from SimpleCounters
                    if (window.SimpleCounters) {
                        balance = await window.SimpleCounters.getSolBalance();
                    }
                    
                    const today = new Date().toISOString().split('T')[0];
                    
                    // Save to cloud database
                    const balanceRecord = {
                        user_id: user.id,
                        date: today,
                        balance: balance,
                        created_at: new Date().toISOString()
                    };

                    await window.supabase.insert('analytics_balance_history', [balanceRecord]);
                    console.log(`ðŸ“Š Saved balance record to cloud: ${balance} SOL for ${today}`);
                    
                    // Add to local array
                    this.balanceHistory.push({
                        date: today,
                        balance: balance
                    });
                    
                    // Keep only last 365 days in memory
                    if (this.balanceHistory.length > 365) {
                        this.balanceHistory = this.balanceHistory.slice(-365);
                    }
                    
                    console.log(`ðŸ“Š Recorded daily SOL balance: ${balance} SOL for ${today}`);
                    
                    // Update chart if it exists
                    if (this.chart) {
                        this.updateChart();
                    }
                } catch (error) {
                    console.error('Error recording daily balance:', error);
                }
            }

            async updateCurrentBalance() {
                try {
                    let balance = 0;
                    
                    if (window.SimpleCounters) {
                        balance = await window.SimpleCounters.getSolBalance();
                    }
                    
                    const balanceElement = document.getElementById('current-sol-balance');
                    if (balanceElement) {
                        balanceElement.textContent = `Current: ${balance.toFixed(3)} SOL`;
                    }
                } catch (error) {
                    console.error('Error updating current balance:', error);
                }
            }

            setupPeriodButtons() {
                const buttons = document.querySelectorAll('.period-btn');
                buttons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        // Remove active from all buttons
                        buttons.forEach(b => b.classList.remove('active'));
                        // Add active to clicked button
                        e.target.classList.add('active');
                        // Update period and refresh chart
                        this.currentPeriod = e.target.dataset.period;
                        this.updateChart();
                    });
                });
            }

            getFilteredData() {
                const now = new Date();
                let cutoffDate;
                
                switch(this.currentPeriod) {
                    case 'week':
                        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        break;
                    case 'month':
                        cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        break;
                    case 'quarter':
                        cutoffDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                        break;
                    case 'year':
                        cutoffDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
                        break;
                    default:
                        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                }
                
                return this.balanceHistory.filter(record => {
                    const recordDate = new Date(record.date);
                    return recordDate >= cutoffDate;
                });
            }

            async setupChart() {
                const canvas = document.getElementById('solBalanceChart');
                if (!canvas || !window.Chart) return;

                // Destroy existing chart if it exists
                if (this.chart) {
                    this.chart.destroy();
                    this.chart = null;
                }

                const ctx = canvas.getContext('2d');
                
                // Prepare data
                const filteredData = this.getFilteredData();
                const labels = filteredData.map(record => {
                    const date = new Date(record.date);
                    return date.toLocaleDateString('de-DE', { month: 'short', day: 'numeric' });
                });
                
                const data = filteredData.map(record => record.balance);
                
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'SOL Balance',
                            data: data,
                            borderColor: '#000000',
                            backgroundColor: 'rgba(0, 0, 0, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'SOL Balance',
                                    font: {
                                        size: 11
                                    }
                                },
                                ticks: {
                                    font: {
                                        size: 10
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date',
                                    font: {
                                        size: 11
                                    }
                                },
                                ticks: {
                                    font: {
                                        size: 10
                                    },
                                    maxTicksLimit: 8
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            title: {
                                display: false
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        }
                    }
                });
            }

            updateChart() {
                if (!this.chart) return;
                
                const filteredData = this.getFilteredData();
                const labels = filteredData.map(record => {
                    const date = new Date(record.date);
                    return date.toLocaleDateString('de-DE', { month: 'short', day: 'numeric' });
                });
                
                const data = filteredData.map(record => record.balance);
                
                this.chart.data.labels = labels;
                this.chart.data.datasets[0].data = data;
                this.chart.update();
            }

            async setupHeatmap() {
                // Show loading state
                const statsElement = document.getElementById('heatmap-stats');
                if (statsElement) statsElement.textContent = 'Loading todo data...';
                
                await this.generateHeatmapData();
                this.renderHeatmap();
                this.updateHeatmapStats();
            }

            async generateHeatmapData() {
                try {
                    // Generate data for the last 365 days (like GitHub)
                    const today = new Date();
                    const startDate = new Date(today);
                    startDate.setDate(today.getDate() - 364); // 365 days including today
                    
                    // Start from Sunday of the week containing startDate
                    const startSunday = new Date(startDate);
                    startSunday.setDate(startDate.getDate() - startDate.getDay());
                    
                    // Check if supabase is available and user is authenticated
                    if (!window.supabase?.isAuthenticated()) {
                        console.warn('No supabase or user not authenticated for heatmap');
                        this.heatmapData = [];
                        return;
                    }
                    
                    // Get all completed todos in one query
                    const user = window.supabase.getCurrentUser();
                    if (!user) {
                        console.warn('No user logged in for heatmap');
                        this.heatmapData = [];
                        return;
                    }
                    
                    const startDateStr = startSunday.toISOString().split('T')[0];
                    const endDateStr = new Date(today.getTime() + 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                    
                    const completedTodos = await window.supabase.query(
                        `todos?user_id=eq.${user.id}&completed=eq.true&updated_at=gte.${startDateStr}&updated_at=lt.${endDateStr}&select=updated_at`
                    );
                    
                    // Group todos by date (convert UTC to local date)
                    const todosByDate = {};
                    if (completedTodos) {
                        completedTodos.forEach(todo => {
                            // Convert UTC timestamp to local date string
                            const utcDate = new Date(todo.updated_at);
                            const localDate = new Date(utcDate.getTime() - utcDate.getTimezoneOffset() * 60000);
                            const date = localDate.toISOString().split('T')[0];
                            todosByDate[date] = (todosByDate[date] || 0) + 1;
                        });
                    }
                    
                    this.heatmapData = [];
                    
                    for (let i = 0; i < 371; i++) { // 53 weeks * 7 days = 371
                        const date = new Date(startSunday);
                        date.setDate(startSunday.getDate() + i);
                        
                        // Use local date string to match with converted todo dates
                        const localDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
                        const dateStr = localDate.toISOString().split('T')[0];
                        const todoCount = todosByDate[dateStr] || 0;
                        
                        this.heatmapData.push({
                            date: dateStr,
                            count: todoCount,
                            level: this.getIntensityLevel(todoCount)
                        });
                    }
                    
                    console.log(`ðŸ“Š Generated heatmap data for ${this.heatmapData.length} days with ${completedTodos?.length || 0} completed todos`);
                } catch (error) {
                    console.error('Error generating heatmap data:', error);
                    this.heatmapData = [];
                }
            }


            getIntensityLevel(count) {
                if (count === 0) return 0;
                if (count <= 2) return 1;
                if (count <= 5) return 2;
                if (count <= 10) return 3;
                return 4;
            }

            renderHeatmap() {
                const gridContainer = document.getElementById('heatmap-grid');
                const monthsContainer = document.getElementById('heatmap-months');
                
                if (!gridContainer || !monthsContainer) return;
                
                // Clear existing content
                gridContainer.innerHTML = '';
                monthsContainer.innerHTML = '';
                
                // Render month labels
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                let currentMonth = -1;
                
                for (let week = 0; week < 53; week++) {
                    const weekStart = week * 7;
                    if (weekStart < this.heatmapData.length) {
                        const date = new Date(this.heatmapData[weekStart].date);
                        const month = date.getMonth();
                        
                        if (month !== currentMonth && week % 4 === 0) {
                            const monthDiv = document.createElement('div');
                            monthDiv.className = 'heatmap-month';
                            monthDiv.textContent = months[month];
                            monthDiv.style.gridColumn = `${week + 1} / span 4`;
                            monthsContainer.appendChild(monthDiv);
                            currentMonth = month;
                        }
                    }
                }
                
                // Render squares in correct grid position (column-first order for GitHub-style layout)
                for (let week = 0; week < 53; week++) {
                    for (let day = 0; day < 7; day++) {
                        const index = week * 7 + day;
                        if (index < this.heatmapData.length) {
                            const dayData = this.heatmapData[index];
                            const square = document.createElement('div');
                            square.className = `heatmap-square level-${dayData.level}`;
                            square.title = `${dayData.date}: ${dayData.count} todos completed`;
                            
                            // Set explicit grid position: column = week + 1, row = day + 1
                            square.style.gridColumn = week + 1;
                            square.style.gridRow = day + 1;
                            
                            square.addEventListener('click', () => {
                                alert(`${dayData.date}: ${dayData.count} todos completed`);
                            });
                            
                            gridContainer.appendChild(square);
                        }
                    }
                }
            }

            updateHeatmapStats() {
                const statsElement = document.getElementById('heatmap-stats');
                if (!statsElement) return;
                
                // Remove the stats text - user finds it not nice
                statsElement.textContent = '';
            }
        }

        // Initialize Analytics Manager
        window.AnalyticsManager = new AnalyticsManager();
        
        // Initialize when analytics tab is opened
        document.addEventListener('DOMContentLoaded', () => {
            const analyticsTab = document.querySelector('[data-tab="tab-analytics"]');
            if (analyticsTab) {
                analyticsTab.addEventListener('click', () => {
                    setTimeout(() => {
                        if (window.AnalyticsManager) {
                            window.AnalyticsManager.init();
                        }
                    }, 100);
                });
            }
            
            // Load saved balance tracking time from cloud
            if (window.AnalyticsManager) {
                window.AnalyticsManager.getTrackingTime().then(savedTime => {
                    const timeInput = document.getElementById('balance-tracking-time');
                    if (timeInput) timeInput.value = savedTime;
                });
            }
            
            // Save analytics settings
            const saveAnalyticsBtn = document.getElementById('save-analytics-settings');
            if (saveAnalyticsBtn) {
                saveAnalyticsBtn.addEventListener('click', async () => {
                    const timeInput = document.getElementById('balance-tracking-time');
                    if (timeInput && window.supabase?.isAuthenticated()) {
                        const user = window.supabase.getCurrentUser();
                        if (user) {
                            try {
                                // Save to cloud
                                const setting = {
                                    user_id: user.id,
                                    setting_key: 'balanceTrackingTime',
                                    setting_value: timeInput.value,
                                    updated_at: new Date().toISOString()
                                };
                                
                                await window.supabase.upsert('user_settings', setting, ['user_id', 'setting_key']);
                                alert(`Analytics Einstellungen gespeichert! SOL Balance wird tÃ¤glich um ${timeInput.value} Uhr aufgezeichnet.`);
                            } catch (error) {
                                console.error('Error saving analytics settings:', error);
                                alert('Fehler beim Speichern der Einstellungen.');
                            }
                        }
                    }
                });
            }
        });

        // === MOTIVATIONAL QUOTES SYSTEM ===
        class MotivationalQuotes {
            constructor() {
                this.quotes = [
                    { text: "The way to get started is to quit talking and begin doing.", author: "Walt Disney" },
                    { text: "Success is not final, failure is not fatal: it is the courage to continue that counts.", author: "Winston Churchill" },
                    { text: "Don't be afraid to give up the good to go for the great.", author: "John D. Rockefeller" },
                    { text: "The only impossible journey is the one you never begin.", author: "Tony Robbins" },
                    { text: "In the middle of difficulty lies opportunity.", author: "Albert Einstein" },
                    { text: "It does not matter how slowly you go as long as you do not stop.", author: "Confucius" },
                    { text: "Everything you've ever wanted is on the other side of fear.", author: "George Addair" },
                    { text: "Believe you can and you're halfway there.", author: "Theodore Roosevelt" },
                    { text: "The only person you are destined to become is the person you decide to be.", author: "Ralph Waldo Emerson" },
                    { text: "I have not failed. I've just found 10,000 ways that won't work.", author: "Thomas Edison" },
                    { text: "A successful man is one who can lay a firm foundation with the bricks others have thrown at him.", author: "David Brinkley" },
                    { text: "The stock market is filled with individuals who know the price of everything, but the value of nothing.", author: "Philip Fisher" },
                    { text: "Risk comes from not knowing what you're doing.", author: "Warren Buffett" },
                    { text: "The four most dangerous words in investing are: 'this time it's different.'", author: "Sir John Templeton" },
                    { text: "Time in the market beats timing the market.", author: "Ken Fisher" },
                    { text: "An investment in knowledge pays the best interest.", author: "Benjamin Franklin" },
                    { text: "The best investment you can make is in yourself.", author: "Warren Buffett" },
                    { text: "Don't put all your eggs in one basket.", author: "Andrew Carnegie" },
                    { text: "It's not how much money you make, but how much money you keep.", author: "Robert Kiyosaki" },
                    { text: "The real measure of your wealth is how much you'd be worth if you lost all your money.", author: "Anonymous" }
                ];
                this.currentQuoteIndex = this.getTodaysQuoteIndex();
            }

            getTodaysQuoteIndex() {
                // Use today's date to generate a consistent quote for the day
                const today = new Date();
                const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);
                return dayOfYear % this.quotes.length;
            }

            getCurrentQuote() {
                return this.quotes[this.currentQuoteIndex];
            }

            getRandomQuote() {
                this.currentQuoteIndex = Math.floor(Math.random() * this.quotes.length);
                return this.getCurrentQuote();
            }

            displayQuote(quote = null) {
                const quoteToDisplay = quote || this.getCurrentQuote();
                const quoteTextEl = document.getElementById('daily-quote');
                const quoteAuthorEl = document.getElementById('quote-author');

                if (quoteTextEl && quoteAuthorEl) {
                    quoteTextEl.textContent = quoteToDisplay.text;
                    quoteAuthorEl.textContent = quoteToDisplay.author;
                }
            }

            init() {
                // Display today's quote
                this.displayQuote();

                // Add refresh button functionality
                const refreshBtn = document.getElementById('refresh-quote-btn');
                if (refreshBtn) {
                    refreshBtn.addEventListener('click', () => {
                        const newQuote = this.getRandomQuote();
                        this.displayQuote(newQuote);
                        
                        // Simple feedback without excessive animation
                    });
                }
            }
        }

        // Initialize Motivational Quotes
        document.addEventListener('DOMContentLoaded', () => {
            window.motivationalQuotes = new MotivationalQuotes();
            window.motivationalQuotes.init();
        });
    </script>
    
    <!-- ========================================= -->
    <!-- CLOUD-FIRST POLICY ENFORCEMENT -->
    <!-- ========================================= -->
    <script src="CLOUD_POLICY.js"></script>
    <script>
        // Aktiviere Cloud-Policy fÃ¼r alle Manager
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ðŸ›¡ï¸ Activating Cloud-First Policy enforcement...');
            
            // Validiere alle existierenden Manager
            setTimeout(() => {
                const managers = [
                    { name: 'TodoManager', obj: window.TodoManager },
                    { name: 'GoalManager', obj: window.GoalManager },
                    { name: 'JournalManager', obj: window.JournalManager },
                    { name: 'TerminManager', obj: window.TerminManager },
                    { name: 'ResourceManager', obj: window.ResourceManager },
                    { name: 'Wiki', obj: window.Wiki },
                    { name: 'SimpleRoutineManager', obj: window.simpleRoutineManager }
                ];
                
                console.log('ðŸ” Validating all managers for Cloud-First compliance...');
                
                managers.forEach(({ name, obj }) => {
                    if (obj) {
                        console.log(`âœ… ${name}: Available and cloud-compliant`);
                    } else {
                        console.warn(`âš ï¸ ${name}: Not found`);
                    }
                });
                
                console.log('ðŸ“‹ All future implementations must follow CLOUD_POLICY.js guidelines');
                
            }, 2000);
        });
        
        // === GLOBAL GOAL EDIT MODAL EVENT LISTENERS SETUP ===
        // This needs to be outside of DOMContentLoaded to ensure it runs
        console.log('ðŸŽ¯ GLOBAL: Setting up goal edit modal event listeners...');
        
        // Make event listener initialization globally available
        window.initGoalEditModalEventListeners = function() {
            console.log('ðŸŽ¯ GLOBAL: Initializing goal edit modal event listeners...');
            
            const cancelEditGoalBtn = document.getElementById('cancel-edit-goal-value-btn');
            if (cancelEditGoalBtn) {
                console.log('âœ… GLOBAL: Found cancel-edit-goal-value-btn, adding event listener');
                // Remove existing listeners first
                const newCancelBtn = cancelEditGoalBtn.cloneNode(true);
                cancelEditGoalBtn.parentNode.replaceChild(newCancelBtn, cancelEditGoalBtn);
                
                newCancelBtn.addEventListener('click', () => {
                    console.log('ðŸŽ¯ GLOBAL: Cancel button clicked');
                    if (window.GoalManager && window.GoalManager.hideEditGoalValueModal) {
                        window.GoalManager.hideEditGoalValueModal();
                    } else {
                        console.error('âŒ GoalManager not available');
                    }
                });
            } else {
                console.error('âŒ GLOBAL: cancel-edit-goal-value-btn not found');
            }

            const editGoalForm = document.getElementById('edit-goal-value-form');
            if (editGoalForm) {
                console.log('âœ… GLOBAL: Found edit-goal-value-form, adding event listener');
                // Remove existing listeners first
                const newForm = editGoalForm.cloneNode(true);
                editGoalForm.parentNode.replaceChild(newForm, editGoalForm);
                
                newForm.addEventListener('submit', async (e) => {
                    console.log('ðŸŽ¯ GLOBAL: Form submit event triggered');
                    e.preventDefault();
                    
                    const goalId = e.target.dataset.goalId;
                    console.log('ðŸŽ¯ GLOBAL: Form submit goalId:', goalId);
                    if (goalId && window.GoalManager && window.GoalManager.editGoalValue) {
                        await window.GoalManager.editGoalValue(goalId);
                    } else {
                        console.error('âŒ GLOBAL: No goalId found or GoalManager not available');
                    }
                });
            } else {
                console.error('âŒ GLOBAL: edit-goal-value-form not found');
            }
        };
        
        // Try to initialize immediately
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('ðŸŽ¯ GLOBAL: DOM ready, initializing...');
                window.initGoalEditModalEventListeners();
            });
        } else {
            console.log('ðŸŽ¯ GLOBAL: DOM already ready, initializing now...');
            window.initGoalEditModalEventListeners();
        }
        
        // Event listeners are initialized when DOM is ready and when modal opens
        // No need for redundant retries


    </script>
</body>
</html>